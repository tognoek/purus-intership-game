// ../node_modules/playcanvas/build/playcanvas/src/core/constants.js
var TRACEID_RENDER_FRAME = "RenderFrame";
var TRACEID_RENDER_FRAME_TIME = "RenderFrameTime";
var TRACEID_RENDER_PASS = "RenderPass";
var TRACEID_RENDER_PASS_DETAIL = "RenderPassDetail";
var TRACEID_RENDER_ACTION = "RenderAction";
var TRACEID_RENDER_TARGET_ALLOC = "RenderTargetAlloc";
var TRACEID_TEXTURE_ALLOC = "TextureAlloc";
var TRACEID_SHADER_ALLOC = "ShaderAlloc";
var TRACEID_SHADER_COMPILE = "ShaderCompile";
var TRACEID_VRAM_TEXTURE = "VRAM.Texture";
var TRACEID_VRAM_VB = "VRAM.Vb";
var TRACEID_VRAM_IB = "VRAM.Ib";
var TRACEID_VRAM_SB = "VRAM.Sb";
var TRACEID_BINDGROUP_ALLOC = "BindGroupAlloc";
var TRACEID_BINDGROUPFORMAT_ALLOC = "BindGroupFormatAlloc";
var TRACEID_RENDERPIPELINE_ALLOC = "RenderPipelineAlloc";
var TRACEID_COMPUTEPIPELINE_ALLOC = "ComputePipelineAlloc";
var TRACEID_PIPELINELAYOUT_ALLOC = "PipelineLayoutAlloc";
var TRACE_ID_ELEMENT = "Element";
var TRACEID_TEXTURES = "Textures";
var TRACEID_RENDER_QUEUE = "RenderQueue";
var TRACEID_GPU_TIMINGS = "GpuTimings";

// ../node_modules/playcanvas/build/playcanvas/src/core/core.js
var version = "2.0.0";
var revision = "96da2ef";
function extend(target2, ex) {
  for (const prop in ex) {
    const copy = ex[prop];
    if (Array.isArray(copy)) {
      target2[prop] = extend([], copy);
    } else if (copy && typeof copy === "object") {
      target2[prop] = extend({}, copy);
    } else {
      target2[prop] = copy;
    }
  }
  return target2;
}

// ../node_modules/playcanvas/build/playcanvas/src/core/guid.js
var guid = {
  create() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
      const r = Math.random() * 16 | 0;
      const v = c2 === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/path.js
var path = {
  delimiter: "/",
  join(...sections) {
    let result = sections[0];
    for (let i = 0; i < sections.length - 1; i++) {
      const one = sections[i];
      const two = sections[i + 1];
      if (two[0] === path.delimiter) {
        result = two;
        continue;
      }
      if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
        result += path.delimiter + two;
      } else {
        result += two;
      }
    }
    return result;
  },
  normalize(pathname) {
    const lead = pathname.startsWith(path.delimiter);
    const trail = pathname.endsWith(path.delimiter);
    const parts = pathname.split("/");
    let result = "";
    let cleaned = [];
    for (let i = 0; i < parts.length; i++) {
      if (parts[i] === "") continue;
      if (parts[i] === ".") continue;
      if (parts[i] === ".." && cleaned.length > 0) {
        cleaned = cleaned.slice(0, cleaned.length - 2);
        continue;
      }
      if (i > 0) cleaned.push(path.delimiter);
      cleaned.push(parts[i]);
    }
    result = cleaned.join("");
    if (!lead && result[0] === path.delimiter) {
      result = result.slice(1);
    }
    if (trail && result[result.length - 1] !== path.delimiter) {
      result += path.delimiter;
    }
    return result;
  },
  split(pathname) {
    const lastDelimiterIndex = pathname.lastIndexOf(path.delimiter);
    if (lastDelimiterIndex !== -1) {
      return [pathname.substring(0, lastDelimiterIndex), pathname.substring(lastDelimiterIndex + 1)];
    }
    return ["", pathname];
  },
  getBasename(pathname) {
    return path.split(pathname)[1];
  },
  getDirectory(pathname) {
    return path.split(pathname)[0];
  },
  getExtension(pathname) {
    const ext = pathname.split("?")[0].split(".").pop();
    if (ext !== pathname) {
      return `.${ext}`;
    }
    return "";
  },
  isRelativePath(pathname) {
    return pathname.charAt(0) !== "/" && pathname.match(/:\/\//) === null;
  },
  extractPath(pathname) {
    let result = "";
    const parts = pathname.split("/");
    let i = 0;
    if (parts.length > 1) {
      if (path.isRelativePath(pathname)) {
        if (parts[0] === ".") {
          for (i = 0; i < parts.length - 1; ++i) {
            result += i === 0 ? parts[i] : `/${parts[i]}`;
          }
        } else if (parts[0] === "..") {
          for (i = 0; i < parts.length - 1; ++i) {
            result += i === 0 ? parts[i] : `/${parts[i]}`;
          }
        } else {
          result = ".";
          for (i = 0; i < parts.length - 1; ++i) {
            result += `/${parts[i]}`;
          }
        }
      } else {
        for (i = 0; i < parts.length - 1; ++i) {
          result += i === 0 ? parts[i] : `/${parts[i]}`;
        }
      }
    }
    return result;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/platform.js
var _ref;
var _ref2;
var _ref3;
var detectPassiveEvents = () => {
  let result = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get: function() {
        result = true;
        return false;
      }
    });
    window.addEventListener("testpassive", null, opts);
    window.removeEventListener("testpassive", null, opts);
  } catch (e) {
  }
  return result;
};
var ua = typeof navigator !== "undefined" ? navigator.userAgent : "";
var environment = typeof window !== "undefined" ? "browser" : typeof global !== "undefined" ? "node" : "worker";
var platformName = /android/i.test(ua) ? "android" : /ip(?:[ao]d|hone)/i.test(ua) ? "ios" : /windows/i.test(ua) ? "windows" : /mac os/i.test(ua) ? "osx" : /linux/i.test(ua) ? "linux" : /cros/i.test(ua) ? "cros" : null;
var browserName = environment !== "browser" ? null : /Chrome\/|Chromium\/|Edg.*\//.test(ua) ? "chrome" : /Safari\//.test(ua) ? "safari" : /Firefox\//.test(ua) ? "firefox" : "other";
var xbox = /xbox/i.test(ua);
var touch = environment === "browser" && ("ontouchstart" in window || "maxTouchPoints" in navigator && navigator.maxTouchPoints > 0);
var gamepads = environment === "browser" && (!!navigator.getGamepads || !!navigator.webkitGetGamepads);
var workers = typeof Worker !== "undefined";
var passiveEvents = detectPassiveEvents();
var platform = {
  name: platformName,
  environment,
  global: (_ref = (_ref2 = (_ref3 = typeof globalThis !== "undefined" && globalThis) != null ? _ref3 : environment === "browser" && window) != null ? _ref2 : environment === "node" && global) != null ? _ref : environment === "worker" && self,
  browser: environment === "browser",
  worker: environment === "worker",
  desktop: ["windows", "osx", "linux", "cros"].includes(platformName),
  mobile: ["android", "ios"].includes(platformName),
  ios: platformName === "ios",
  android: platformName === "android",
  xbox,
  gamepads,
  touch,
  workers,
  passiveEvents,
  browserName
};

// ../node_modules/playcanvas/build/playcanvas/src/core/string.js
var ASCII_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
var ASCII_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
var HIGH_SURROGATE_BEGIN = 55296;
var HIGH_SURROGATE_END = 56319;
var LOW_SURROGATE_BEGIN = 56320;
var LOW_SURROGATE_END = 57343;
var ZERO_WIDTH_JOINER = 8205;
var REGIONAL_INDICATOR_BEGIN = 127462;
var REGIONAL_INDICATOR_END = 127487;
var FITZPATRICK_MODIFIER_BEGIN = 127995;
var FITZPATRICK_MODIFIER_END = 127999;
var DIACRITICAL_MARKS_BEGIN = 8400;
var DIACRITICAL_MARKS_END = 8447;
var VARIATION_MODIFIER_BEGIN = 65024;
var VARIATION_MODIFIER_END = 65039;
function getCodePointData(string2, i = 0) {
  const size = string2.length;
  if (i < 0 || i >= size) {
    return null;
  }
  const first = string2.charCodeAt(i);
  if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
    const second = string2.charCodeAt(i + 1);
    if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
      return {
        code: (first - HIGH_SURROGATE_BEGIN) * 1024 + second - LOW_SURROGATE_BEGIN + 65536,
        long: true
      };
    }
  }
  return {
    code: first,
    long: false
  };
}
function isCodeBetween(string2, begin, end) {
  if (!string2) {
    return false;
  }
  const codeData = getCodePointData(string2);
  if (codeData) {
    const code = codeData.code;
    return code >= begin && code <= end;
  }
  return false;
}
function numCharsToTakeForNextSymbol(string2, index) {
  if (index === string2.length - 1) {
    return 1;
  }
  if (isCodeBetween(string2[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
    const first = string2.substring(index, index + 2);
    const second = string2.substring(index + 2, index + 4);
    if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
      return 4;
    }
    if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
      return 3;
    }
    return 2;
  }
  if (isCodeBetween(string2[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
    return 2;
  }
  return 1;
}
var string = {
  ASCII_LOWERCASE,
  ASCII_UPPERCASE,
  ASCII_LETTERS,
  format(s2, ...args) {
    for (let i = 0; i < args.length; i++) {
      s2 = s2.replace(`{${i}}`, args[i]);
    }
    return s2;
  },
  getCodePoint(string2, i) {
    const codePointData = getCodePointData(string2, i);
    return codePointData && codePointData.code;
  },
  getCodePoints(string2) {
    if (typeof string2 !== "string") {
      throw new TypeError("Not a string");
    }
    let i = 0;
    const arr = [];
    let codePoint;
    while (!!(codePoint = getCodePointData(string2, i))) {
      arr.push(codePoint.code);
      i += codePoint.long ? 2 : 1;
    }
    return arr;
  },
  getSymbols(string2) {
    if (typeof string2 !== "string") {
      throw new TypeError("Not a string");
    }
    let index = 0;
    const length = string2.length;
    const output = [];
    let take = 0;
    let ch;
    while (index < length) {
      take += numCharsToTakeForNextSymbol(string2, index + take);
      ch = string2[index + take];
      if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
        ch = string2[index + take++];
      }
      if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
        ch = string2[index + take++];
      }
      if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
        ch = string2[index + take++];
        continue;
      }
      const char = string2.substring(index, index + take);
      output.push(char);
      index += take;
      take = 0;
    }
    return output;
  },
  fromCodePoint() {
    const chars = [];
    let current;
    let codePoint;
    let units;
    for (let i = 0; i < arguments.length; ++i) {
      current = Number(arguments[i]);
      codePoint = current - 65536;
      units = current > 65535 ? [(codePoint >> 10) + 55296, codePoint % 1024 + 56320] : [current];
      chars.push(String.fromCharCode.apply(null, units));
    }
    return chars.join("");
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/event-handle.js
var EventHandle = class {
  constructor(handler, name, callback, scope, once = false) {
    this.handler = void 0;
    this.name = void 0;
    this.callback = void 0;
    this.scope = void 0;
    this._once = void 0;
    this._removed = false;
    this.handler = handler;
    this.name = name;
    this.callback = callback;
    this.scope = scope;
    this._once = once;
  }
  off() {
    if (this._removed) return;
    this.handler.off(this.name, this.callback, this.scope);
  }
  on(name, callback, scope = this) {
    return this.handler._addCallback(name, callback, scope, false);
  }
  once(name, callback, scope = this) {
    return this.handler._addCallback(name, callback, scope, true);
  }
  set removed(value) {
    if (!value) return;
    this._removed = true;
  }
  get removed() {
    return this._removed;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/event-handler.js
var EventHandler = class {
  constructor() {
    this._callbacks = /* @__PURE__ */ new Map();
    this._callbackActive = /* @__PURE__ */ new Map();
  }
  initEventHandler() {
    this._callbacks = /* @__PURE__ */ new Map();
    this._callbackActive = /* @__PURE__ */ new Map();
  }
  _addCallback(name, callback, scope, once) {
    if (!this._callbacks.has(name)) {
      this._callbacks.set(name, []);
    }
    if (this._callbackActive.has(name)) {
      const callbackActive = this._callbackActive.get(name);
      if (callbackActive && callbackActive === this._callbacks.get(name)) {
        this._callbackActive.set(name, callbackActive.slice());
      }
    }
    const evt = new EventHandle(this, name, callback, scope, once);
    this._callbacks.get(name).push(evt);
    return evt;
  }
  on(name, callback, scope = this) {
    return this._addCallback(name, callback, scope, false);
  }
  once(name, callback, scope = this) {
    return this._addCallback(name, callback, scope, true);
  }
  off(name, callback, scope) {
    if (name) {
      if (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) {
        this._callbackActive.set(name, this._callbackActive.get(name).slice());
      }
    } else {
      for (const [key, callbacks] of this._callbackActive) {
        if (!this._callbacks.has(key)) {
          continue;
        }
        if (this._callbacks.get(key) !== callbacks) {
          continue;
        }
        this._callbackActive.set(key, callbacks.slice());
      }
    }
    if (!name) {
      for (const callbacks of this._callbacks.values()) {
        for (let i = 0; i < callbacks.length; i++) {
          callbacks[i].removed = true;
        }
      }
      this._callbacks.clear();
    } else if (!callback) {
      const callbacks = this._callbacks.get(name);
      if (callbacks) {
        for (let i = 0; i < callbacks.length; i++) {
          callbacks[i].removed = true;
        }
        this._callbacks.delete(name);
      }
    } else {
      const callbacks = this._callbacks.get(name);
      if (!callbacks) {
        return this;
      }
      for (let i = 0; i < callbacks.length; i++) {
        if (callbacks[i].callback !== callback) {
          continue;
        }
        if (scope && callbacks[i].scope !== scope) {
          continue;
        }
        callbacks[i].removed = true;
        callbacks.splice(i, 1);
        i--;
      }
      if (callbacks.length === 0) {
        this._callbacks.delete(name);
      }
    }
    return this;
  }
  fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
    if (!name) {
      return this;
    }
    const callbacksInitial = this._callbacks.get(name);
    if (!callbacksInitial) {
      return this;
    }
    let callbacks;
    if (!this._callbackActive.has(name)) {
      this._callbackActive.set(name, callbacksInitial);
    } else if (this._callbackActive.get(name) !== callbacksInitial) {
      callbacks = callbacksInitial.slice();
    }
    for (let i = 0; (callbacks || this._callbackActive.get(name)) && i < (callbacks || this._callbackActive.get(name)).length; i++) {
      const evt = (callbacks || this._callbackActive.get(name))[i];
      if (!evt.callback) continue;
      evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      if (evt._once) {
        const existingCallback = this._callbacks.get(name);
        const ind = existingCallback ? existingCallback.indexOf(evt) : -1;
        if (ind !== -1) {
          if (this._callbackActive.get(name) === existingCallback) {
            this._callbackActive.set(name, this._callbackActive.get(name).slice());
          }
          const _callbacks = this._callbacks.get(name);
          if (!_callbacks) continue;
          _callbacks[ind].removed = true;
          _callbacks.splice(ind, 1);
          if (_callbacks.length === 0) {
            this._callbacks.delete(name);
          }
        }
      }
    }
    if (!callbacks) {
      this._callbackActive.delete(name);
    }
    return this;
  }
  hasEvent(name) {
    var _this$_callbacks$get;
    return !!((_this$_callbacks$get = this._callbacks.get(name)) != null && _this$_callbacks$get.length);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/indexed-list.js
var IndexedList = class {
  constructor() {
    this._list = [];
    this._index = {};
  }
  push(key, item) {
    if (this._index[key]) {
      throw Error(`Key already in index ${key}`);
    }
    const location = this._list.push(item) - 1;
    this._index[key] = location;
  }
  has(key) {
    return this._index[key] !== void 0;
  }
  get(key) {
    const location = this._index[key];
    if (location !== void 0) {
      return this._list[location];
    }
    return null;
  }
  remove(key) {
    const location = this._index[key];
    if (location !== void 0) {
      this._list.splice(location, 1);
      delete this._index[key];
      for (key in this._index) {
        const idx = this._index[key];
        if (idx > location) {
          this._index[key] = idx - 1;
        }
      }
      return true;
    }
    return false;
  }
  list() {
    return this._list;
  }
  clear() {
    this._list.length = 0;
    for (const prop in this._index) {
      delete this._index[prop];
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/wasm-module.js
var cachedResult = (func) => {
  const uninitToken = {};
  let result = uninitToken;
  return () => {
    if (result === uninitToken) {
      result = func();
    }
    return result;
  };
};
var Impl = class _Impl {
  static loadScript(url, callback) {
    const s2 = document.createElement("script");
    s2.setAttribute("src", url);
    s2.onload = () => {
      callback(null);
    };
    s2.onerror = () => {
      callback(`Failed to load script='${url}'`);
    };
    document.body.appendChild(s2);
  }
  static loadWasm(moduleName, config, callback) {
    const loadUrl = _Impl.wasmSupported() && config.glueUrl && config.wasmUrl ? config.glueUrl : config.fallbackUrl;
    if (loadUrl) {
      _Impl.loadScript(loadUrl, (err3) => {
        if (err3) {
          callback(err3, null);
        } else {
          const module = window[moduleName];
          window[moduleName] = void 0;
          module({
            locateFile: () => config.wasmUrl,
            onAbort: () => {
              callback("wasm module aborted.");
            }
          }).then((instance) => {
            callback(null, instance);
          });
        }
      });
    } else {
      callback("No supported wasm modules found.", null);
    }
  }
  static getModule(name) {
    if (!_Impl.modules.hasOwnProperty(name)) {
      _Impl.modules[name] = {
        config: null,
        initializing: false,
        instance: null,
        callbacks: []
      };
    }
    return _Impl.modules[name];
  }
  static initialize(moduleName, module) {
    if (module.initializing) {
      return;
    }
    const config = module.config;
    if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
      module.initializing = true;
      _Impl.loadWasm(moduleName, config, (err3, instance) => {
        if (err3) {
          if (config.errorHandler) {
            config.errorHandler(err3);
          } else {
            console.error(`failed to initialize module=${moduleName} error=${err3}`);
          }
        } else {
          module.instance = instance;
          module.callbacks.forEach((callback) => {
            callback(instance);
          });
        }
      });
    }
  }
};
Impl.modules = {};
Impl.wasmSupported = cachedResult(() => {
  try {
    if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
      const module = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
      if (module instanceof WebAssembly.Module) {
        return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
      }
    }
  } catch (e) {
  }
  return false;
});
var WasmModule = class {
  static setConfig(moduleName, config) {
    const module = Impl.getModule(moduleName);
    module.config = config;
    if (module.callbacks.length > 0) {
      Impl.initialize(moduleName, module);
    }
  }
  static getConfig(moduleName) {
    var _Impl$modules;
    return (_Impl$modules = Impl.modules) == null || (_Impl$modules = _Impl$modules[moduleName]) == null ? void 0 : _Impl$modules.config;
  }
  static getInstance(moduleName, callback) {
    const module = Impl.getModule(moduleName);
    if (module.instance) {
      callback(module.instance);
    } else {
      module.callbacks.push(callback);
      if (module.config) {
        Impl.initialize(moduleName, module);
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/read-stream.js
var ReadStream = class {
  constructor(arraybuffer) {
    this.arraybuffer = void 0;
    this.dataView = void 0;
    this.offset = 0;
    this.arraybuffer = arraybuffer;
    this.dataView = new DataView(arraybuffer);
  }
  get remainingBytes() {
    return this.dataView.byteLength - this.offset;
  }
  reset(offset = 0) {
    this.offset = offset;
  }
  skip(bytes) {
    this.offset += bytes;
  }
  align(bytes) {
    this.offset = this.offset + bytes - 1 & ~(bytes - 1);
  }
  _inc(amount) {
    this.offset += amount;
    return this.offset - amount;
  }
  readChar() {
    return String.fromCharCode(this.dataView.getUint8(this.offset++));
  }
  readChars(numChars) {
    let result = "";
    for (let i = 0; i < numChars; ++i) {
      result += this.readChar();
    }
    return result;
  }
  readU8() {
    return this.dataView.getUint8(this.offset++);
  }
  readU16() {
    return this.dataView.getUint16(this._inc(2), true);
  }
  readU32() {
    return this.dataView.getUint32(this._inc(4), true);
  }
  readU64() {
    return this.readU32() + 2 ** 32 * this.readU32();
  }
  readU32be() {
    return this.dataView.getUint32(this._inc(4), false);
  }
  readArray(result) {
    for (let i = 0; i < result.length; ++i) {
      result[i] = this.readU8();
    }
  }
  readLine() {
    const view = this.dataView;
    let result = "";
    while (true) {
      if (this.offset >= view.byteLength) {
        break;
      }
      const c2 = String.fromCharCode(this.readU8());
      if (c2 === "\n") {
        break;
      }
      result += c2;
    }
    return result;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/sorted-loop-array.js
var SortedLoopArray = class {
  constructor(args) {
    this.items = [];
    this.length = 0;
    this.loopIndex = -1;
    this._sortBy = void 0;
    this._sortHandler = void 0;
    this._sortBy = args.sortBy;
    this._sortHandler = this._doSort.bind(this);
  }
  _binarySearch(item) {
    let left = 0;
    let right = this.items.length - 1;
    const search = item[this._sortBy];
    let middle;
    let current;
    while (left <= right) {
      middle = Math.floor((left + right) / 2);
      current = this.items[middle][this._sortBy];
      if (current <= search) {
        left = middle + 1;
      } else if (current > search) {
        right = middle - 1;
      }
    }
    return left;
  }
  _doSort(a, b) {
    const sortBy = this._sortBy;
    return a[sortBy] - b[sortBy];
  }
  insert(item) {
    const index = this._binarySearch(item);
    this.items.splice(index, 0, item);
    this.length++;
    if (this.loopIndex >= index) {
      this.loopIndex++;
    }
  }
  append(item) {
    this.items.push(item);
    this.length++;
  }
  remove(item) {
    const idx = this.items.indexOf(item);
    if (idx < 0) return;
    this.items.splice(idx, 1);
    this.length--;
    if (this.loopIndex >= idx) {
      this.loopIndex--;
    }
  }
  sort() {
    const current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
    this.items.sort(this._sortHandler);
    if (current !== null) {
      this.loopIndex = this.items.indexOf(current);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/tags.js
var Tags = class extends EventHandler {
  constructor(parent) {
    super();
    this._index = {};
    this._list = [];
    this._parent = parent;
  }
  add(...args) {
    let changed = false;
    const tags = this._processArguments(args, true);
    if (!tags.length) {
      return changed;
    }
    for (let i = 0; i < tags.length; i++) {
      if (this._index[tags[i]]) {
        continue;
      }
      changed = true;
      this._index[tags[i]] = true;
      this._list.push(tags[i]);
      this.fire("add", tags[i], this._parent);
    }
    if (changed) {
      this.fire("change", this._parent);
    }
    return changed;
  }
  remove(...args) {
    let changed = false;
    if (!this._list.length) {
      return changed;
    }
    const tags = this._processArguments(args, true);
    if (!tags.length) {
      return changed;
    }
    for (let i = 0; i < tags.length; i++) {
      if (!this._index[tags[i]]) {
        continue;
      }
      changed = true;
      delete this._index[tags[i]];
      this._list.splice(this._list.indexOf(tags[i]), 1);
      this.fire("remove", tags[i], this._parent);
    }
    if (changed) {
      this.fire("change", this._parent);
    }
    return changed;
  }
  clear() {
    if (!this._list.length) {
      return;
    }
    const tags = this._list.slice(0);
    this._list = [];
    this._index = {};
    for (let i = 0; i < tags.length; i++) {
      this.fire("remove", tags[i], this._parent);
    }
    this.fire("change", this._parent);
  }
  has(...query) {
    if (!this._list.length) {
      return false;
    }
    return this._has(this._processArguments(query));
  }
  _has(tags) {
    if (!this._list.length || !tags.length) {
      return false;
    }
    for (let i = 0; i < tags.length; i++) {
      if (tags[i].length === 1) {
        if (this._index[tags[i][0]]) {
          return true;
        }
      } else {
        let multiple = true;
        for (let t = 0; t < tags[i].length; t++) {
          if (this._index[tags[i][t]]) {
            continue;
          }
          multiple = false;
          break;
        }
        if (multiple) {
          return true;
        }
      }
    }
    return false;
  }
  list() {
    return this._list.slice(0);
  }
  _processArguments(args, flat) {
    const tags = [];
    let tmp = [];
    if (!args || !args.length) {
      return tags;
    }
    for (let i = 0; i < args.length; i++) {
      if (args[i] instanceof Array) {
        if (!flat) {
          tmp = [];
        }
        for (let t = 0; t < args[i].length; t++) {
          if (typeof args[i][t] !== "string") {
            continue;
          }
          if (flat) {
            tags.push(args[i][t]);
          } else {
            tmp.push(args[i][t]);
          }
        }
        if (!flat && tmp.length) {
          tags.push(tmp);
        }
      } else if (typeof args[i] === "string") {
        if (flat) {
          tags.push(args[i]);
        } else {
          tags.push([args[i]]);
        }
      }
    }
    return tags;
  }
  get size() {
    return this._list.length;
  }
};
Tags.EVENT_ADD = "add";
Tags.EVENT_REMOVE = "remove";
Tags.EVENT_CHANGE = "change";

// ../node_modules/playcanvas/build/playcanvas/src/core/time.js
var now = typeof window !== "undefined" && window.performance && window.performance.now ? performance.now.bind(performance) : Date.now;

// ../node_modules/playcanvas/build/playcanvas/src/core/uri.js
function createURI(options2) {
  let s2 = "";
  if ((options2.authority || options2.scheme) && (options2.host || options2.hostpath)) {
    throw new Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
  }
  if (options2.host && options2.hostpath) {
    throw new Error("Can't have 'host' and 'hostpath' option");
  }
  if (options2.path && options2.hostpath) {
    throw new Error("Can't have 'path' and 'hostpath' option");
  }
  if (options2.scheme) {
    s2 += `${options2.scheme}:`;
  }
  if (options2.authority) {
    s2 += `//${options2.authority}`;
  }
  if (options2.host) {
    s2 += options2.host;
  }
  if (options2.path) {
    s2 += options2.path;
  }
  if (options2.hostpath) {
    s2 += options2.hostpath;
  }
  if (options2.query) {
    s2 += `?${options2.query}`;
  }
  if (options2.fragment) {
    s2 += `#${options2.fragment}`;
  }
  return s2;
}
var re = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
var URI = class {
  constructor(uri) {
    this.scheme = void 0;
    this.authority = void 0;
    this.path = void 0;
    this.query = void 0;
    this.fragment = void 0;
    const result = uri.match(re);
    this.scheme = result[2];
    this.authority = result[4];
    this.path = result[5];
    this.query = result[7];
    this.fragment = result[9];
  }
  toString() {
    let s2 = "";
    if (this.scheme) {
      s2 += `${this.scheme}:`;
    }
    if (this.authority) {
      s2 += `//${this.authority}`;
    }
    s2 += this.path;
    if (this.query) {
      s2 += `?${this.query}`;
    }
    if (this.fragment) {
      s2 += `#${this.fragment}`;
    }
    return s2;
  }
  getQuery() {
    const result = {};
    if (this.query) {
      const queryParams = decodeURIComponent(this.query).split("&");
      for (const queryParam of queryParams) {
        const pair = queryParam.split("=");
        result[pair[0]] = pair[1];
      }
    }
    return result;
  }
  setQuery(params) {
    let q3 = "";
    for (const key in params) {
      if (params.hasOwnProperty(key)) {
        if (q3 !== "") {
          q3 += "&";
        }
        q3 += `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`;
      }
    }
    this.query = q3;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/tracing.js
var Tracing = class _Tracing {
  static set(channel, enabled = true) {
  }
  static get(channel) {
    return _Tracing._traceChannels.has(channel);
  }
};
Tracing._traceChannels = /* @__PURE__ */ new Set();
Tracing.stack = false;

// ../node_modules/playcanvas/build/playcanvas/src/core/math/constants.js
var CURVE_LINEAR = 0;
var CURVE_SMOOTHSTEP = 1;
var CURVE_SPLINE = 4;
var CURVE_STEP = 5;

// ../node_modules/playcanvas/build/playcanvas/src/core/math/math.js
var math = {
  DEG_TO_RAD: Math.PI / 180,
  RAD_TO_DEG: 180 / Math.PI,
  clamp(value, min, max) {
    if (value >= max) return max;
    if (value <= min) return min;
    return value;
  },
  intToBytes24(i) {
    const r = i >> 16 & 255;
    const g = i >> 8 & 255;
    const b = i & 255;
    return [r, g, b];
  },
  intToBytes32(i) {
    const r = i >> 24 & 255;
    const g = i >> 16 & 255;
    const b = i >> 8 & 255;
    const a = i & 255;
    return [r, g, b, a];
  },
  bytesToInt24(r, g, b) {
    if (r.length) {
      b = r[2];
      g = r[1];
      r = r[0];
    }
    return r << 16 | g << 8 | b;
  },
  bytesToInt32(r, g, b, a) {
    if (r.length) {
      a = r[3];
      b = r[2];
      g = r[1];
      r = r[0];
    }
    return (r << 24 | g << 16 | b << 8 | a) >>> 0;
  },
  lerp(a, b, alpha) {
    return a + (b - a) * math.clamp(alpha, 0, 1);
  },
  lerpAngle(a, b, alpha) {
    if (b - a > 180) {
      b -= 360;
    }
    if (b - a < -180) {
      b += 360;
    }
    return math.lerp(a, b, math.clamp(alpha, 0, 1));
  },
  powerOfTwo(x2) {
    return x2 !== 0 && !(x2 & x2 - 1);
  },
  nextPowerOfTwo(val) {
    val--;
    val |= val >> 1;
    val |= val >> 2;
    val |= val >> 4;
    val |= val >> 8;
    val |= val >> 16;
    val++;
    return val;
  },
  nearestPowerOfTwo(val) {
    return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));
  },
  random(min, max) {
    const diff = max - min;
    return Math.random() * diff + min;
  },
  smoothstep(min, max, x2) {
    if (x2 <= min) return 0;
    if (x2 >= max) return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * (3 - 2 * x2);
  },
  smootherstep(min, max, x2) {
    if (x2 <= min) return 0;
    if (x2 >= max) return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
  },
  roundUp(numToRound, multiple) {
    if (multiple === 0) {
      return numToRound;
    }
    return Math.ceil(numToRound / multiple) * multiple;
  },
  between(num, a, b, inclusive) {
    const min = Math.min(a, b);
    const max = Math.max(a, b);
    return inclusive ? num >= min && num <= max : num > min && num < max;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/math/color.js
var _Color;
var Color = class {
  constructor(r = 0, g = 0, b = 0, a = 1) {
    this.r = void 0;
    this.g = void 0;
    this.b = void 0;
    this.a = void 0;
    const length = r.length;
    if (length === 3 || length === 4) {
      var _r$;
      this.r = r[0];
      this.g = r[1];
      this.b = r[2];
      this.a = (_r$ = r[3]) != null ? _r$ : 1;
    } else {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }
  }
  clone() {
    const cstr = this.constructor;
    return new cstr(this.r, this.g, this.b, this.a);
  }
  copy(rhs) {
    this.r = rhs.r;
    this.g = rhs.g;
    this.b = rhs.b;
    this.a = rhs.a;
    return this;
  }
  equals(rhs) {
    return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
  }
  set(r, g, b, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  }
  lerp(lhs, rhs, alpha) {
    this.r = lhs.r + alpha * (rhs.r - lhs.r);
    this.g = lhs.g + alpha * (rhs.g - lhs.g);
    this.b = lhs.b + alpha * (rhs.b - lhs.b);
    this.a = lhs.a + alpha * (rhs.a - lhs.a);
    return this;
  }
  linear(src = this) {
    this.r = Math.pow(src.r, 2.2);
    this.g = Math.pow(src.g, 2.2);
    this.b = Math.pow(src.b, 2.2);
    this.a = src.a;
    return this;
  }
  gamma(src = this) {
    this.r = Math.pow(src.r, 1 / 2.2);
    this.g = Math.pow(src.g, 1 / 2.2);
    this.b = Math.pow(src.b, 1 / 2.2);
    this.a = src.a;
    return this;
  }
  mulScalar(scalar) {
    this.r *= scalar;
    this.g *= scalar;
    this.b *= scalar;
    return this;
  }
  fromString(hex) {
    const i = parseInt(hex.replace("#", "0x"), 16);
    let bytes;
    if (hex.length > 7) {
      bytes = math.intToBytes32(i);
    } else {
      bytes = math.intToBytes24(i);
      bytes[3] = 255;
    }
    this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
    return this;
  }
  toString(alpha) {
    let s2 = `#${((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1)}`;
    if (alpha === true) {
      const a = Math.round(this.a * 255).toString(16);
      if (this.a < 16 / 255) {
        s2 += `0${a}`;
      } else {
        s2 += a;
      }
    }
    return s2;
  }
};
_Color = Color;
Color.BLACK = Object.freeze(new _Color(0, 0, 0, 1));
Color.BLUE = Object.freeze(new _Color(0, 0, 1, 1));
Color.CYAN = Object.freeze(new _Color(0, 1, 1, 1));
Color.GRAY = Object.freeze(new _Color(0.5, 0.5, 0.5, 1));
Color.GREEN = Object.freeze(new _Color(0, 1, 0, 1));
Color.MAGENTA = Object.freeze(new _Color(1, 0, 1, 1));
Color.RED = Object.freeze(new _Color(1, 0, 0, 1));
Color.WHITE = Object.freeze(new _Color(1, 1, 1, 1));
Color.YELLOW = Object.freeze(new _Color(1, 1, 0, 1));

// ../node_modules/playcanvas/build/playcanvas/src/core/math/curve-evaluator.js
var CurveEvaluator = class {
  constructor(curve, time = 0) {
    this._curve = void 0;
    this._left = -Infinity;
    this._right = Infinity;
    this._recip = 0;
    this._p0 = 0;
    this._p1 = 0;
    this._m0 = 0;
    this._m1 = 0;
    this._curve = curve;
    this._reset(time);
  }
  evaluate(time, forceReset = false) {
    if (forceReset || time < this._left || time >= this._right) {
      this._reset(time);
    }
    let result;
    const type = this._curve.type;
    if (type === CURVE_STEP) {
      result = this._p0;
    } else {
      const t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
      if (type === CURVE_LINEAR) {
        result = math.lerp(this._p0, this._p1, t);
      } else if (type === CURVE_SMOOTHSTEP) {
        result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
      } else {
        result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
      }
    }
    return result;
  }
  _reset(time) {
    const keys = this._curve.keys;
    const len = keys.length;
    if (!len) {
      this._left = -Infinity;
      this._right = Infinity;
      this._recip = 0;
      this._p0 = this._p1 = this._m0 = this._m1 = 0;
    } else {
      if (time < keys[0][0]) {
        this._left = -Infinity;
        this._right = keys[0][0];
        this._recip = 0;
        this._p0 = this._p1 = keys[0][1];
        this._m0 = this._m1 = 0;
      } else if (time >= keys[len - 1][0]) {
        this._left = keys[len - 1][0];
        this._right = Infinity;
        this._recip = 0;
        this._p0 = this._p1 = keys[len - 1][1];
        this._m0 = this._m1 = 0;
      } else {
        let index = 0;
        while (time >= keys[index + 1][0]) {
          index++;
        }
        this._left = keys[index][0];
        this._right = keys[index + 1][0];
        const diff = 1 / (this._right - this._left);
        this._recip = isFinite(diff) ? diff : 0;
        this._p0 = keys[index][1];
        this._p1 = keys[index + 1][1];
        if (this._curve.type === CURVE_SPLINE) {
          this._calcTangents(keys, index);
        }
      }
    }
  }
  _calcTangents(keys, index) {
    let a;
    const b = keys[index];
    const c2 = keys[index + 1];
    let d;
    if (index === 0) {
      a = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];
    } else {
      a = keys[index - 1];
    }
    if (index === keys.length - 2) {
      d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];
    } else {
      d = keys[index + 2];
    }
    if (this._curve.type === CURVE_SPLINE) {
      const s1_ = 2 * (c2[0] - b[0]) / (c2[0] - a[0]);
      const s2_ = 2 * (c2[0] - b[0]) / (d[0] - b[0]);
      this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c2[1] - a[1]);
      this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
    } else {
      const s1 = (c2[0] - b[0]) / (b[0] - a[0]);
      const s2 = (c2[0] - b[0]) / (d[0] - c2[0]);
      const a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
      const d_ = c2[1] + (d[1] - c2[1]) * (isFinite(s2) ? s2 : 0);
      const tension = this._curve.tension;
      this._m0 = tension * (c2[1] - a_);
      this._m1 = tension * (d_ - b[1]);
    }
  }
  _evaluateHermite(p0, p12, m0, m1, t) {
    const t2 = t * t;
    const twot = t + t;
    const omt = 1 - t;
    const omt2 = omt * omt;
    return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p12 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/math/curve.js
var Curve = class {
  constructor(data2) {
    this.keys = [];
    this.type = CURVE_SMOOTHSTEP;
    this.tension = 0.5;
    this._eval = new CurveEvaluator(this);
    if (data2) {
      for (let i = 0; i < data2.length - 1; i += 2) {
        this.keys.push([data2[i], data2[i + 1]]);
      }
    }
    this.sort();
  }
  get length() {
    return this.keys.length;
  }
  add(time, value) {
    const keys = this.keys;
    const len = keys.length;
    let i = 0;
    for (; i < len; i++) {
      if (keys[i][0] > time) {
        break;
      }
    }
    const key = [time, value];
    this.keys.splice(i, 0, key);
    return key;
  }
  get(index) {
    return this.keys[index];
  }
  sort() {
    this.keys.sort((a, b) => a[0] - b[0]);
  }
  value(time) {
    return this._eval.evaluate(time, true);
  }
  closest(time) {
    const keys = this.keys;
    const length = keys.length;
    let min = 2;
    let result = null;
    for (let i = 0; i < length; i++) {
      const diff = Math.abs(time - keys[i][0]);
      if (min >= diff) {
        min = diff;
        result = keys[i];
      } else {
        break;
      }
    }
    return result;
  }
  clone() {
    const result = new this.constructor();
    result.keys = this.keys.map((key) => [...key]);
    result.type = this.type;
    result.tension = this.tension;
    return result;
  }
  quantize(precision) {
    precision = Math.max(precision, 2);
    const values = new Float32Array(precision);
    const step = 1 / (precision - 1);
    values[0] = this._eval.evaluate(0, true);
    for (let i = 1; i < precision; i++) {
      values[i] = this._eval.evaluate(step * i);
    }
    return values;
  }
  quantizeClamped(precision, min, max) {
    const result = this.quantize(precision);
    for (let i = 0; i < result.length; ++i) {
      result[i] = Math.min(max, Math.max(min, result[i]));
    }
    return result;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/math/curve-set.js
var CurveSet = class {
  constructor() {
    this.curves = [];
    this._type = CURVE_SMOOTHSTEP;
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.curves.push(new Curve(arguments[i]));
      }
    } else {
      if (arguments.length === 0) {
        this.curves.push(new Curve());
      } else {
        const arg = arguments[0];
        if (typeof arg === "number") {
          for (let i = 0; i < arg; i++) {
            this.curves.push(new Curve());
          }
        } else {
          for (let i = 0; i < arg.length; i++) {
            this.curves.push(new Curve(arg[i]));
          }
        }
      }
    }
  }
  get length() {
    return this.curves.length;
  }
  set type(value) {
    this._type = value;
    for (let i = 0; i < this.curves.length; i++) {
      this.curves[i].type = value;
    }
  }
  get type() {
    return this._type;
  }
  get(index) {
    return this.curves[index];
  }
  value(time, result = []) {
    const length = this.curves.length;
    result.length = length;
    for (let i = 0; i < length; i++) {
      result[i] = this.curves[i].value(time);
    }
    return result;
  }
  clone() {
    const result = new this.constructor();
    result.curves = [];
    for (let i = 0; i < this.curves.length; i++) {
      result.curves.push(this.curves[i].clone());
    }
    result._type = this._type;
    return result;
  }
  quantize(precision) {
    precision = Math.max(precision, 2);
    const numCurves = this.curves.length;
    const values = new Float32Array(precision * numCurves);
    const step = 1 / (precision - 1);
    for (let c2 = 0; c2 < numCurves; c2++) {
      const ev = new CurveEvaluator(this.curves[c2]);
      for (let i = 0; i < precision; i++) {
        values[i * numCurves + c2] = ev.evaluate(step * i);
      }
    }
    return values;
  }
  quantizeClamped(precision, min, max) {
    const result = this.quantize(precision);
    for (let i = 0; i < result.length; ++i) {
      result[i] = Math.min(max, Math.max(min, result[i]));
    }
    return result;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/math/float-packing.js
var oneDiv255 = 1 / 255;
var floatView = new Float32Array(1);
var int32View = new Int32Array(floatView.buffer);
var FloatPacking = class _FloatPacking {
  static float2Half(value) {
    floatView[0] = value;
    const x2 = int32View[0];
    let bits = x2 >> 16 & 32768;
    let m = x2 >> 12 & 2047;
    const e = x2 >> 23 & 255;
    if (e < 103) {
      return bits;
    }
    if (e > 142) {
      bits |= 31744;
      bits |= (e === 255 ? 0 : 1) && x2 & 8388607;
      return bits;
    }
    if (e < 113) {
      m |= 2048;
      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }
    bits |= e - 112 << 10 | m >> 1;
    bits += m & 1;
    return bits;
  }
  static float2Bytes(value, array2, offset, numBytes) {
    const enc1 = 255 * value % 1;
    array2[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);
    if (numBytes > 1) {
      const enc2 = 65025 * value % 1;
      array2[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);
      if (numBytes > 2) {
        const enc3 = 16581375 * value % 1;
        array2[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);
        if (numBytes > 3) {
          array2[offset + 3] = Math.round(enc3 * 255);
        }
      }
    }
  }
  static float2BytesRange(value, array2, offset, min, max, numBytes) {
    value = math.clamp((value - min) / (max - min), 0, 1);
    _FloatPacking.float2Bytes(value, array2, offset, numBytes);
  }
  static float2MantissaExponent(value, array2, offset, numBytes) {
    const exponent = Math.floor(Math.log2(Math.abs(value))) + 1;
    value /= Math.pow(2, exponent);
    _FloatPacking.float2BytesRange(value, array2, offset, -1, 1, numBytes - 1);
    array2[offset + numBytes - 1] = Math.round(exponent + 127);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/math/vec3.js
var _Vec;
var Vec3 = class {
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    if (x2.length === 3) {
      this.x = x2[0];
      this.y = x2[1];
      this.z = x2[2];
    } else {
      this.x = x2;
      this.y = y2;
      this.z = z2;
    }
  }
  add(rhs) {
    this.x += rhs.x;
    this.y += rhs.y;
    this.z += rhs.z;
    return this;
  }
  add2(lhs, rhs) {
    this.x = lhs.x + rhs.x;
    this.y = lhs.y + rhs.y;
    this.z = lhs.z + rhs.z;
    return this;
  }
  addScalar(scalar) {
    this.x += scalar;
    this.y += scalar;
    this.z += scalar;
    return this;
  }
  addScaled(rhs, scalar) {
    this.x += rhs.x * scalar;
    this.y += rhs.y * scalar;
    this.z += rhs.z * scalar;
    return this;
  }
  clone() {
    const cstr = this.constructor;
    return new cstr(this.x, this.y, this.z);
  }
  copy(rhs) {
    this.x = rhs.x;
    this.y = rhs.y;
    this.z = rhs.z;
    return this;
  }
  cross(lhs, rhs) {
    const lx = lhs.x;
    const ly = lhs.y;
    const lz = lhs.z;
    const rx = rhs.x;
    const ry = rhs.y;
    const rz = rhs.z;
    this.x = ly * rz - ry * lz;
    this.y = lz * rx - rz * lx;
    this.z = lx * ry - rx * ly;
    return this;
  }
  distance(rhs) {
    const x2 = this.x - rhs.x;
    const y2 = this.y - rhs.y;
    const z2 = this.z - rhs.z;
    return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  }
  div(rhs) {
    this.x /= rhs.x;
    this.y /= rhs.y;
    this.z /= rhs.z;
    return this;
  }
  div2(lhs, rhs) {
    this.x = lhs.x / rhs.x;
    this.y = lhs.y / rhs.y;
    this.z = lhs.z / rhs.z;
    return this;
  }
  divScalar(scalar) {
    this.x /= scalar;
    this.y /= scalar;
    this.z /= scalar;
    return this;
  }
  dot(rhs) {
    return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
  }
  equals(rhs) {
    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
  }
  equalsApprox(rhs, epsilon3 = 1e-6) {
    return Math.abs(this.x - rhs.x) < epsilon3 && Math.abs(this.y - rhs.y) < epsilon3 && Math.abs(this.z - rhs.z) < epsilon3;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  lerp(lhs, rhs, alpha) {
    this.x = lhs.x + alpha * (rhs.x - lhs.x);
    this.y = lhs.y + alpha * (rhs.y - lhs.y);
    this.z = lhs.z + alpha * (rhs.z - lhs.z);
    return this;
  }
  mul(rhs) {
    this.x *= rhs.x;
    this.y *= rhs.y;
    this.z *= rhs.z;
    return this;
  }
  mul2(lhs, rhs) {
    this.x = lhs.x * rhs.x;
    this.y = lhs.y * rhs.y;
    this.z = lhs.z * rhs.z;
    return this;
  }
  mulScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  normalize(src = this) {
    const lengthSq = src.x * src.x + src.y * src.y + src.z * src.z;
    if (lengthSq > 0) {
      const invLength = 1 / Math.sqrt(lengthSq);
      this.x = src.x * invLength;
      this.y = src.y * invLength;
      this.z = src.z * invLength;
    }
    return this;
  }
  floor(src = this) {
    this.x = Math.floor(src.x);
    this.y = Math.floor(src.y);
    this.z = Math.floor(src.z);
    return this;
  }
  ceil(src = this) {
    this.x = Math.ceil(src.x);
    this.y = Math.ceil(src.y);
    this.z = Math.ceil(src.z);
    return this;
  }
  round(src = this) {
    this.x = Math.round(src.x);
    this.y = Math.round(src.y);
    this.z = Math.round(src.z);
    return this;
  }
  min(rhs) {
    if (rhs.x < this.x) this.x = rhs.x;
    if (rhs.y < this.y) this.y = rhs.y;
    if (rhs.z < this.z) this.z = rhs.z;
    return this;
  }
  max(rhs) {
    if (rhs.x > this.x) this.x = rhs.x;
    if (rhs.y > this.y) this.y = rhs.y;
    if (rhs.z > this.z) this.z = rhs.z;
    return this;
  }
  project(rhs) {
    const a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
    const b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
    const s2 = a_dot_b / b_dot_b;
    this.x = rhs.x * s2;
    this.y = rhs.y * s2;
    this.z = rhs.z * s2;
    return this;
  }
  set(x2, y2, z2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    return this;
  }
  sub(rhs) {
    this.x -= rhs.x;
    this.y -= rhs.y;
    this.z -= rhs.z;
    return this;
  }
  sub2(lhs, rhs) {
    this.x = lhs.x - rhs.x;
    this.y = lhs.y - rhs.y;
    this.z = lhs.z - rhs.z;
    return this;
  }
  subScalar(scalar) {
    this.x -= scalar;
    this.y -= scalar;
    this.z -= scalar;
    return this;
  }
  toString() {
    return `[${this.x}, ${this.y}, ${this.z}]`;
  }
};
_Vec = Vec3;
Vec3.ZERO = Object.freeze(new _Vec(0, 0, 0));
Vec3.ONE = Object.freeze(new _Vec(1, 1, 1));
Vec3.UP = Object.freeze(new _Vec(0, 1, 0));
Vec3.DOWN = Object.freeze(new _Vec(0, -1, 0));
Vec3.RIGHT = Object.freeze(new _Vec(1, 0, 0));
Vec3.LEFT = Object.freeze(new _Vec(-1, 0, 0));
Vec3.FORWARD = Object.freeze(new _Vec(0, 0, -1));
Vec3.BACK = Object.freeze(new _Vec(0, 0, 1));

// ../node_modules/playcanvas/build/playcanvas/src/core/math/mat3.js
var _Mat;
var Mat3 = class {
  constructor() {
    this.data = new Float32Array(9);
    this.data[0] = this.data[4] = this.data[8] = 1;
  }
  clone() {
    const cstr = this.constructor;
    return new cstr().copy(this);
  }
  copy(rhs) {
    const src = rhs.data;
    const dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    return this;
  }
  set(src) {
    const dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    return this;
  }
  getX(x2 = new Vec3()) {
    return x2.set(this.data[0], this.data[1], this.data[2]);
  }
  getY(y2 = new Vec3()) {
    return y2.set(this.data[3], this.data[4], this.data[5]);
  }
  getZ(z2 = new Vec3()) {
    return z2.set(this.data[6], this.data[7], this.data[8]);
  }
  equals(rhs) {
    const l = this.data;
    const r = rhs.data;
    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
  }
  isIdentity() {
    const m = this.data;
    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
  }
  setIdentity() {
    const m = this.data;
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 1;
    m[5] = 0;
    m[6] = 0;
    m[7] = 0;
    m[8] = 1;
    return this;
  }
  toString() {
    return `[${this.data.join(", ")}]`;
  }
  transpose(src = this) {
    const s2 = src.data;
    const t = this.data;
    if (s2 === t) {
      let tmp;
      tmp = s2[1];
      t[1] = s2[3];
      t[3] = tmp;
      tmp = s2[2];
      t[2] = s2[6];
      t[6] = tmp;
      tmp = s2[5];
      t[5] = s2[7];
      t[7] = tmp;
    } else {
      t[0] = s2[0];
      t[1] = s2[3];
      t[2] = s2[6];
      t[3] = s2[1];
      t[4] = s2[4];
      t[5] = s2[7];
      t[6] = s2[2];
      t[7] = s2[5];
      t[8] = s2[8];
    }
    return this;
  }
  setFromMat4(m) {
    const src = m.data;
    const dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[4];
    dst[4] = src[5];
    dst[5] = src[6];
    dst[6] = src[8];
    dst[7] = src[9];
    dst[8] = src[10];
    return this;
  }
  setFromQuat(r) {
    const qx = r.x;
    const qy = r.y;
    const qz = r.z;
    const qw = r.w;
    const x2 = qx + qx;
    const y2 = qy + qy;
    const z2 = qz + qz;
    const xx = qx * x2;
    const xy = qx * y2;
    const xz = qx * z2;
    const yy = qy * y2;
    const yz = qy * z2;
    const zz = qz * z2;
    const wx = qw * x2;
    const wy = qw * y2;
    const wz = qw * z2;
    const m = this.data;
    m[0] = 1 - (yy + zz);
    m[1] = xy + wz;
    m[2] = xz - wy;
    m[3] = xy - wz;
    m[4] = 1 - (xx + zz);
    m[5] = yz + wx;
    m[6] = xz + wy;
    m[7] = yz - wx;
    m[8] = 1 - (xx + yy);
    return this;
  }
  invertMat4(src) {
    const s2 = src.data;
    const a0 = s2[0];
    const a1 = s2[1];
    const a2 = s2[2];
    const a4 = s2[4];
    const a5 = s2[5];
    const a6 = s2[6];
    const a8 = s2[8];
    const a9 = s2[9];
    const a10 = s2[10];
    const b11 = a10 * a5 - a6 * a9;
    const b21 = -a10 * a1 + a2 * a9;
    const b31 = a6 * a1 - a2 * a5;
    const b12 = -a10 * a4 + a6 * a8;
    const b22 = a10 * a0 - a2 * a8;
    const b32 = -a6 * a0 + a2 * a4;
    const b13 = a9 * a4 - a5 * a8;
    const b23 = -a9 * a0 + a1 * a8;
    const b33 = a5 * a0 - a1 * a4;
    const det = a0 * b11 + a1 * b12 + a2 * b13;
    if (det === 0) {
      this.setIdentity();
    } else {
      const invDet = 1 / det;
      const t = this.data;
      t[0] = b11 * invDet;
      t[1] = b21 * invDet;
      t[2] = b31 * invDet;
      t[3] = b12 * invDet;
      t[4] = b22 * invDet;
      t[5] = b32 * invDet;
      t[6] = b13 * invDet;
      t[7] = b23 * invDet;
      t[8] = b33 * invDet;
    }
    return this;
  }
  transformVector(vec2, res = new Vec3()) {
    const m = this.data;
    const {
      x: x2,
      y: y2,
      z: z2
    } = vec2;
    res.x = x2 * m[0] + y2 * m[3] + z2 * m[6];
    res.y = x2 * m[1] + y2 * m[4] + z2 * m[7];
    res.z = x2 * m[2] + y2 * m[5] + z2 * m[8];
    return res;
  }
};
_Mat = Mat3;
Mat3.IDENTITY = Object.freeze(new _Mat());
Mat3.ZERO = Object.freeze(new _Mat().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));

// ../node_modules/playcanvas/build/playcanvas/src/core/math/vec2.js
var _Vec2;
var Vec2 = class {
  constructor(x2 = 0, y2 = 0) {
    this.x = void 0;
    this.y = void 0;
    if (x2.length === 2) {
      this.x = x2[0];
      this.y = x2[1];
    } else {
      this.x = x2;
      this.y = y2;
    }
  }
  add(rhs) {
    this.x += rhs.x;
    this.y += rhs.y;
    return this;
  }
  add2(lhs, rhs) {
    this.x = lhs.x + rhs.x;
    this.y = lhs.y + rhs.y;
    return this;
  }
  addScalar(scalar) {
    this.x += scalar;
    this.y += scalar;
    return this;
  }
  addScaled(rhs, scalar) {
    this.x += rhs.x * scalar;
    this.y += rhs.y * scalar;
    return this;
  }
  clone() {
    const cstr = this.constructor;
    return new cstr(this.x, this.y);
  }
  copy(rhs) {
    this.x = rhs.x;
    this.y = rhs.y;
    return this;
  }
  cross(rhs) {
    return this.x * rhs.y - this.y * rhs.x;
  }
  distance(rhs) {
    const x2 = this.x - rhs.x;
    const y2 = this.y - rhs.y;
    return Math.sqrt(x2 * x2 + y2 * y2);
  }
  div(rhs) {
    this.x /= rhs.x;
    this.y /= rhs.y;
    return this;
  }
  div2(lhs, rhs) {
    this.x = lhs.x / rhs.x;
    this.y = lhs.y / rhs.y;
    return this;
  }
  divScalar(scalar) {
    this.x /= scalar;
    this.y /= scalar;
    return this;
  }
  dot(rhs) {
    return this.x * rhs.x + this.y * rhs.y;
  }
  equals(rhs) {
    return this.x === rhs.x && this.y === rhs.y;
  }
  equalsApprox(rhs, epsilon3 = 1e-6) {
    return Math.abs(this.x - rhs.x) < epsilon3 && Math.abs(this.y - rhs.y) < epsilon3;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  lerp(lhs, rhs, alpha) {
    this.x = lhs.x + alpha * (rhs.x - lhs.x);
    this.y = lhs.y + alpha * (rhs.y - lhs.y);
    return this;
  }
  mul(rhs) {
    this.x *= rhs.x;
    this.y *= rhs.y;
    return this;
  }
  mul2(lhs, rhs) {
    this.x = lhs.x * rhs.x;
    this.y = lhs.y * rhs.y;
    return this;
  }
  mulScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  normalize(src = this) {
    const lengthSq = src.x * src.x + src.y * src.y;
    if (lengthSq > 0) {
      const invLength = 1 / Math.sqrt(lengthSq);
      this.x = src.x * invLength;
      this.y = src.y * invLength;
    }
    return this;
  }
  rotate(degrees) {
    const angle = Math.atan2(this.x, this.y) + degrees * math.DEG_TO_RAD;
    const len = Math.sqrt(this.x * this.x + this.y * this.y);
    this.x = Math.sin(angle) * len;
    this.y = Math.cos(angle) * len;
    return this;
  }
  angle() {
    return Math.atan2(this.x, this.y) * math.RAD_TO_DEG;
  }
  angleTo(rhs) {
    return Math.atan2(this.x * rhs.y + this.y * rhs.x, this.x * rhs.x + this.y * rhs.y) * math.RAD_TO_DEG;
  }
  floor(src = this) {
    this.x = Math.floor(src.x);
    this.y = Math.floor(src.y);
    return this;
  }
  ceil(src = this) {
    this.x = Math.ceil(src.x);
    this.y = Math.ceil(src.y);
    return this;
  }
  round(src = this) {
    this.x = Math.round(src.x);
    this.y = Math.round(src.y);
    return this;
  }
  min(rhs) {
    if (rhs.x < this.x) this.x = rhs.x;
    if (rhs.y < this.y) this.y = rhs.y;
    return this;
  }
  max(rhs) {
    if (rhs.x > this.x) this.x = rhs.x;
    if (rhs.y > this.y) this.y = rhs.y;
    return this;
  }
  set(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  sub(rhs) {
    this.x -= rhs.x;
    this.y -= rhs.y;
    return this;
  }
  sub2(lhs, rhs) {
    this.x = lhs.x - rhs.x;
    this.y = lhs.y - rhs.y;
    return this;
  }
  subScalar(scalar) {
    this.x -= scalar;
    this.y -= scalar;
    return this;
  }
  toString() {
    return `[${this.x}, ${this.y}]`;
  }
  static angleRad(lhs, rhs) {
    return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);
  }
};
_Vec2 = Vec2;
Vec2.ZERO = Object.freeze(new _Vec2(0, 0));
Vec2.ONE = Object.freeze(new _Vec2(1, 1));
Vec2.UP = Object.freeze(new _Vec2(0, 1));
Vec2.DOWN = Object.freeze(new _Vec2(0, -1));
Vec2.RIGHT = Object.freeze(new _Vec2(1, 0));
Vec2.LEFT = Object.freeze(new _Vec2(-1, 0));

// ../node_modules/playcanvas/build/playcanvas/src/core/math/vec4.js
var _Vec3;
var Vec4 = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, w = 0) {
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    if (x2.length === 4) {
      this.x = x2[0];
      this.y = x2[1];
      this.z = x2[2];
      this.w = x2[3];
    } else {
      this.x = x2;
      this.y = y2;
      this.z = z2;
      this.w = w;
    }
  }
  add(rhs) {
    this.x += rhs.x;
    this.y += rhs.y;
    this.z += rhs.z;
    this.w += rhs.w;
    return this;
  }
  add2(lhs, rhs) {
    this.x = lhs.x + rhs.x;
    this.y = lhs.y + rhs.y;
    this.z = lhs.z + rhs.z;
    this.w = lhs.w + rhs.w;
    return this;
  }
  addScalar(scalar) {
    this.x += scalar;
    this.y += scalar;
    this.z += scalar;
    this.w += scalar;
    return this;
  }
  addScaled(rhs, scalar) {
    this.x += rhs.x * scalar;
    this.y += rhs.y * scalar;
    this.z += rhs.z * scalar;
    this.w += rhs.w * scalar;
    return this;
  }
  clone() {
    const cstr = this.constructor;
    return new cstr(this.x, this.y, this.z, this.w);
  }
  copy(rhs) {
    this.x = rhs.x;
    this.y = rhs.y;
    this.z = rhs.z;
    this.w = rhs.w;
    return this;
  }
  div(rhs) {
    this.x /= rhs.x;
    this.y /= rhs.y;
    this.z /= rhs.z;
    this.w /= rhs.w;
    return this;
  }
  div2(lhs, rhs) {
    this.x = lhs.x / rhs.x;
    this.y = lhs.y / rhs.y;
    this.z = lhs.z / rhs.z;
    this.w = lhs.w / rhs.w;
    return this;
  }
  divScalar(scalar) {
    this.x /= scalar;
    this.y /= scalar;
    this.z /= scalar;
    this.w /= scalar;
    return this;
  }
  dot(rhs) {
    return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
  }
  equals(rhs) {
    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
  }
  equalsApprox(rhs, epsilon3 = 1e-6) {
    return Math.abs(this.x - rhs.x) < epsilon3 && Math.abs(this.y - rhs.y) < epsilon3 && Math.abs(this.z - rhs.z) < epsilon3 && Math.abs(this.w - rhs.w) < epsilon3;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  lerp(lhs, rhs, alpha) {
    this.x = lhs.x + alpha * (rhs.x - lhs.x);
    this.y = lhs.y + alpha * (rhs.y - lhs.y);
    this.z = lhs.z + alpha * (rhs.z - lhs.z);
    this.w = lhs.w + alpha * (rhs.w - lhs.w);
    return this;
  }
  mul(rhs) {
    this.x *= rhs.x;
    this.y *= rhs.y;
    this.z *= rhs.z;
    this.w *= rhs.w;
    return this;
  }
  mul2(lhs, rhs) {
    this.x = lhs.x * rhs.x;
    this.y = lhs.y * rhs.y;
    this.z = lhs.z * rhs.z;
    this.w = lhs.w * rhs.w;
    return this;
  }
  mulScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  normalize(src = this) {
    const lengthSq = src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w;
    if (lengthSq > 0) {
      const invLength = 1 / Math.sqrt(lengthSq);
      this.x = src.x * invLength;
      this.y = src.y * invLength;
      this.z = src.z * invLength;
      this.w = src.w * invLength;
    }
    return this;
  }
  floor(src = this) {
    this.x = Math.floor(src.x);
    this.y = Math.floor(src.y);
    this.z = Math.floor(src.z);
    this.w = Math.floor(src.w);
    return this;
  }
  ceil(src = this) {
    this.x = Math.ceil(src.x);
    this.y = Math.ceil(src.y);
    this.z = Math.ceil(src.z);
    this.w = Math.ceil(src.w);
    return this;
  }
  round(src = this) {
    this.x = Math.round(src.x);
    this.y = Math.round(src.y);
    this.z = Math.round(src.z);
    this.w = Math.round(src.w);
    return this;
  }
  min(rhs) {
    if (rhs.x < this.x) this.x = rhs.x;
    if (rhs.y < this.y) this.y = rhs.y;
    if (rhs.z < this.z) this.z = rhs.z;
    if (rhs.w < this.w) this.w = rhs.w;
    return this;
  }
  max(rhs) {
    if (rhs.x > this.x) this.x = rhs.x;
    if (rhs.y > this.y) this.y = rhs.y;
    if (rhs.z > this.z) this.z = rhs.z;
    if (rhs.w > this.w) this.w = rhs.w;
    return this;
  }
  set(x2, y2, z2, w) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w;
    return this;
  }
  sub(rhs) {
    this.x -= rhs.x;
    this.y -= rhs.y;
    this.z -= rhs.z;
    this.w -= rhs.w;
    return this;
  }
  sub2(lhs, rhs) {
    this.x = lhs.x - rhs.x;
    this.y = lhs.y - rhs.y;
    this.z = lhs.z - rhs.z;
    this.w = lhs.w - rhs.w;
    return this;
  }
  subScalar(scalar) {
    this.x -= scalar;
    this.y -= scalar;
    this.z -= scalar;
    this.w -= scalar;
    return this;
  }
  toString() {
    return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
  }
};
_Vec3 = Vec4;
Vec4.ZERO = Object.freeze(new _Vec3(0, 0, 0, 0));
Vec4.ONE = Object.freeze(new _Vec3(1, 1, 1, 1));

// ../node_modules/playcanvas/build/playcanvas/src/core/math/mat4.js
var _Mat2;
var _halfSize = new Vec2();
var x = new Vec3();
var y = new Vec3();
var z = new Vec3();
var scale = new Vec3();
var Mat4 = class _Mat4 {
  constructor() {
    this.data = new Float32Array(16);
    this.data[0] = this.data[5] = this.data[10] = this.data[15] = 1;
  }
  static _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {
    if (fovIsHorizontal) {
      halfSize.x = znear * Math.tan(fov * Math.PI / 360);
      halfSize.y = halfSize.x / aspect;
    } else {
      halfSize.y = znear * Math.tan(fov * Math.PI / 360);
      halfSize.x = halfSize.y * aspect;
    }
  }
  add2(lhs, rhs) {
    const a = lhs.data, b = rhs.data, r = this.data;
    r[0] = a[0] + b[0];
    r[1] = a[1] + b[1];
    r[2] = a[2] + b[2];
    r[3] = a[3] + b[3];
    r[4] = a[4] + b[4];
    r[5] = a[5] + b[5];
    r[6] = a[6] + b[6];
    r[7] = a[7] + b[7];
    r[8] = a[8] + b[8];
    r[9] = a[9] + b[9];
    r[10] = a[10] + b[10];
    r[11] = a[11] + b[11];
    r[12] = a[12] + b[12];
    r[13] = a[13] + b[13];
    r[14] = a[14] + b[14];
    r[15] = a[15] + b[15];
    return this;
  }
  add(rhs) {
    return this.add2(this, rhs);
  }
  clone() {
    const cstr = this.constructor;
    return new cstr().copy(this);
  }
  copy(rhs) {
    const src = rhs.data, dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    dst[9] = src[9];
    dst[10] = src[10];
    dst[11] = src[11];
    dst[12] = src[12];
    dst[13] = src[13];
    dst[14] = src[14];
    dst[15] = src[15];
    return this;
  }
  equals(rhs) {
    const l = this.data, r = rhs.data;
    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
  }
  isIdentity() {
    const m = this.data;
    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
  }
  mul2(lhs, rhs) {
    const a = lhs.data;
    const b = rhs.data;
    const r = this.data;
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    let b0, b1, b2, b3;
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
    r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
    r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
    r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
    return this;
  }
  mulAffine2(lhs, rhs) {
    const a = lhs.data;
    const b = rhs.data;
    const r = this.data;
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    let b0, b1, b2;
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    r[0] = a00 * b0 + a10 * b1 + a20 * b2;
    r[1] = a01 * b0 + a11 * b1 + a21 * b2;
    r[2] = a02 * b0 + a12 * b1 + a22 * b2;
    r[3] = 0;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    r[4] = a00 * b0 + a10 * b1 + a20 * b2;
    r[5] = a01 * b0 + a11 * b1 + a21 * b2;
    r[6] = a02 * b0 + a12 * b1 + a22 * b2;
    r[7] = 0;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    r[8] = a00 * b0 + a10 * b1 + a20 * b2;
    r[9] = a01 * b0 + a11 * b1 + a21 * b2;
    r[10] = a02 * b0 + a12 * b1 + a22 * b2;
    r[11] = 0;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
    r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
    r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
    r[15] = 1;
    return this;
  }
  mul(rhs) {
    return this.mul2(this, rhs);
  }
  transformPoint(vec2, res = new Vec3()) {
    const m = this.data;
    const {
      x: x2,
      y: y2,
      z: z2
    } = vec2;
    res.x = x2 * m[0] + y2 * m[4] + z2 * m[8] + m[12];
    res.y = x2 * m[1] + y2 * m[5] + z2 * m[9] + m[13];
    res.z = x2 * m[2] + y2 * m[6] + z2 * m[10] + m[14];
    return res;
  }
  transformVector(vec2, res = new Vec3()) {
    const m = this.data;
    const {
      x: x2,
      y: y2,
      z: z2
    } = vec2;
    res.x = x2 * m[0] + y2 * m[4] + z2 * m[8];
    res.y = x2 * m[1] + y2 * m[5] + z2 * m[9];
    res.z = x2 * m[2] + y2 * m[6] + z2 * m[10];
    return res;
  }
  transformVec4(vec2, res = new Vec4()) {
    const m = this.data;
    const {
      x: x2,
      y: y2,
      z: z2,
      w
    } = vec2;
    res.x = x2 * m[0] + y2 * m[4] + z2 * m[8] + w * m[12];
    res.y = x2 * m[1] + y2 * m[5] + z2 * m[9] + w * m[13];
    res.z = x2 * m[2] + y2 * m[6] + z2 * m[10] + w * m[14];
    res.w = x2 * m[3] + y2 * m[7] + z2 * m[11] + w * m[15];
    return res;
  }
  setLookAt(position3, target2, up2) {
    z.sub2(position3, target2).normalize();
    y.copy(up2).normalize();
    x.cross(y, z).normalize();
    y.cross(z, x);
    const r = this.data;
    r[0] = x.x;
    r[1] = x.y;
    r[2] = x.z;
    r[3] = 0;
    r[4] = y.x;
    r[5] = y.y;
    r[6] = y.z;
    r[7] = 0;
    r[8] = z.x;
    r[9] = z.y;
    r[10] = z.z;
    r[11] = 0;
    r[12] = position3.x;
    r[13] = position3.y;
    r[14] = position3.z;
    r[15] = 1;
    return this;
  }
  setFrustum(left, right, bottom, top, znear, zfar) {
    const temp1 = 2 * znear;
    const temp2 = right - left;
    const temp3 = top - bottom;
    const temp4 = zfar - znear;
    const r = this.data;
    r[0] = temp1 / temp2;
    r[1] = 0;
    r[2] = 0;
    r[3] = 0;
    r[4] = 0;
    r[5] = temp1 / temp3;
    r[6] = 0;
    r[7] = 0;
    r[8] = (right + left) / temp2;
    r[9] = (top + bottom) / temp3;
    r[10] = (-zfar - znear) / temp4;
    r[11] = -1;
    r[12] = 0;
    r[13] = 0;
    r[14] = -temp1 * zfar / temp4;
    r[15] = 0;
    return this;
  }
  setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {
    _Mat4._getPerspectiveHalfSize(_halfSize, fov, aspect, znear, fovIsHorizontal);
    return this.setFrustum(-_halfSize.x, _halfSize.x, -_halfSize.y, _halfSize.y, znear, zfar);
  }
  setOrtho(left, right, bottom, top, near, far) {
    const r = this.data;
    r[0] = 2 / (right - left);
    r[1] = 0;
    r[2] = 0;
    r[3] = 0;
    r[4] = 0;
    r[5] = 2 / (top - bottom);
    r[6] = 0;
    r[7] = 0;
    r[8] = 0;
    r[9] = 0;
    r[10] = -2 / (far - near);
    r[11] = 0;
    r[12] = -(right + left) / (right - left);
    r[13] = -(top + bottom) / (top - bottom);
    r[14] = -(far + near) / (far - near);
    r[15] = 1;
    return this;
  }
  setFromAxisAngle(axis, angle) {
    angle *= math.DEG_TO_RAD;
    const {
      x: x2,
      y: y2,
      z: z2
    } = axis;
    const c2 = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t = 1 - c2;
    const tx = t * x2;
    const ty = t * y2;
    const m = this.data;
    m[0] = tx * x2 + c2;
    m[1] = tx * y2 + s2 * z2;
    m[2] = tx * z2 - s2 * y2;
    m[3] = 0;
    m[4] = tx * y2 - s2 * z2;
    m[5] = ty * y2 + c2;
    m[6] = ty * z2 + s2 * x2;
    m[7] = 0;
    m[8] = tx * z2 + s2 * y2;
    m[9] = ty * z2 - x2 * s2;
    m[10] = t * z2 * z2 + c2;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }
  setTranslate(x2, y2, z2) {
    const m = this.data;
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = 1;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = 1;
    m[11] = 0;
    m[12] = x2;
    m[13] = y2;
    m[14] = z2;
    m[15] = 1;
    return this;
  }
  setScale(x2, y2, z2) {
    const m = this.data;
    m[0] = x2;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = y2;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = z2;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }
  setViewport(x2, y2, width, height) {
    const m = this.data;
    m[0] = width * 0.5;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = height * 0.5;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = 0.5;
    m[11] = 0;
    m[12] = x2 + width * 0.5;
    m[13] = y2 + height * 0.5;
    m[14] = 0.5;
    m[15] = 1;
    return this;
  }
  setReflection(normal, distance) {
    const a = normal.x;
    const b = normal.y;
    const c2 = normal.z;
    const data2 = this.data;
    data2[0] = 1 - 2 * a * a;
    data2[1] = -2 * a * b;
    data2[2] = -2 * a * c2;
    data2[3] = 0;
    data2[4] = -2 * a * b;
    data2[5] = 1 - 2 * b * b;
    data2[6] = -2 * b * c2;
    data2[7] = 0;
    data2[8] = -2 * a * c2;
    data2[9] = -2 * b * c2;
    data2[10] = 1 - 2 * c2 * c2;
    data2[11] = 0;
    data2[12] = -2 * a * distance;
    data2[13] = -2 * b * distance;
    data2[14] = -2 * c2 * distance;
    data2[15] = 1;
    return this;
  }
  invert(src = this) {
    const s2 = src.data;
    const a00 = s2[0];
    const a01 = s2[1];
    const a02 = s2[2];
    const a03 = s2[3];
    const a10 = s2[4];
    const a11 = s2[5];
    const a12 = s2[6];
    const a13 = s2[7];
    const a20 = s2[8];
    const a21 = s2[9];
    const a22 = s2[10];
    const a23 = s2[11];
    const a30 = s2[12];
    const a31 = s2[13];
    const a32 = s2[14];
    const a33 = s2[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (det === 0) {
      this.setIdentity();
    } else {
      const invDet = 1 / det;
      const t = this.data;
      t[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
      t[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
      t[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
      t[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
      t[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
      t[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
      t[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
      t[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
      t[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
      t[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
      t[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
      t[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
      t[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
      t[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
      t[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
      t[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
    }
    return this;
  }
  set(src) {
    const dst = this.data;
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
    dst[6] = src[6];
    dst[7] = src[7];
    dst[8] = src[8];
    dst[9] = src[9];
    dst[10] = src[10];
    dst[11] = src[11];
    dst[12] = src[12];
    dst[13] = src[13];
    dst[14] = src[14];
    dst[15] = src[15];
    return this;
  }
  setIdentity() {
    const m = this.data;
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = 1;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = 1;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }
  setTRS(t, r, s2) {
    const qx = r.x;
    const qy = r.y;
    const qz = r.z;
    const qw = r.w;
    const sx = s2.x;
    const sy = s2.y;
    const sz = s2.z;
    const x2 = qx + qx;
    const y2 = qy + qy;
    const z2 = qz + qz;
    const xx = qx * x2;
    const xy = qx * y2;
    const xz = qx * z2;
    const yy = qy * y2;
    const yz = qy * z2;
    const zz = qz * z2;
    const wx = qw * x2;
    const wy = qw * y2;
    const wz = qw * z2;
    const m = this.data;
    m[0] = (1 - (yy + zz)) * sx;
    m[1] = (xy + wz) * sx;
    m[2] = (xz - wy) * sx;
    m[3] = 0;
    m[4] = (xy - wz) * sy;
    m[5] = (1 - (xx + zz)) * sy;
    m[6] = (yz + wx) * sy;
    m[7] = 0;
    m[8] = (xz + wy) * sz;
    m[9] = (yz - wx) * sz;
    m[10] = (1 - (xx + yy)) * sz;
    m[11] = 0;
    m[12] = t.x;
    m[13] = t.y;
    m[14] = t.z;
    m[15] = 1;
    return this;
  }
  transpose(src = this) {
    const s2 = src.data;
    const t = this.data;
    if (s2 === t) {
      let tmp;
      tmp = s2[1];
      t[1] = s2[4];
      t[4] = tmp;
      tmp = s2[2];
      t[2] = s2[8];
      t[8] = tmp;
      tmp = s2[3];
      t[3] = s2[12];
      t[12] = tmp;
      tmp = s2[6];
      t[6] = s2[9];
      t[9] = tmp;
      tmp = s2[7];
      t[7] = s2[13];
      t[13] = tmp;
      tmp = s2[11];
      t[11] = s2[14];
      t[14] = tmp;
    } else {
      t[0] = s2[0];
      t[1] = s2[4];
      t[2] = s2[8];
      t[3] = s2[12];
      t[4] = s2[1];
      t[5] = s2[5];
      t[6] = s2[9];
      t[7] = s2[13];
      t[8] = s2[2];
      t[9] = s2[6];
      t[10] = s2[10];
      t[11] = s2[14];
      t[12] = s2[3];
      t[13] = s2[7];
      t[14] = s2[11];
      t[15] = s2[15];
    }
    return this;
  }
  getTranslation(t = new Vec3()) {
    return t.set(this.data[12], this.data[13], this.data[14]);
  }
  getX(x2 = new Vec3()) {
    return x2.set(this.data[0], this.data[1], this.data[2]);
  }
  getY(y2 = new Vec3()) {
    return y2.set(this.data[4], this.data[5], this.data[6]);
  }
  getZ(z2 = new Vec3()) {
    return z2.set(this.data[8], this.data[9], this.data[10]);
  }
  getScale(scale2 = new Vec3()) {
    this.getX(x);
    this.getY(y);
    this.getZ(z);
    scale2.set(x.length(), y.length(), z.length());
    return scale2;
  }
  get scaleSign() {
    this.getX(x);
    this.getY(y);
    this.getZ(z);
    x.cross(x, y);
    return x.dot(z) < 0 ? -1 : 1;
  }
  setFromEulerAngles(ex, ey, ez) {
    ex *= math.DEG_TO_RAD;
    ey *= math.DEG_TO_RAD;
    ez *= math.DEG_TO_RAD;
    const s1 = Math.sin(-ex);
    const c1 = Math.cos(-ex);
    const s2 = Math.sin(-ey);
    const c2 = Math.cos(-ey);
    const s3 = Math.sin(-ez);
    const c3 = Math.cos(-ez);
    const m = this.data;
    m[0] = c2 * c3;
    m[1] = -c2 * s3;
    m[2] = s2;
    m[3] = 0;
    m[4] = c1 * s3 + c3 * s1 * s2;
    m[5] = c1 * c3 - s1 * s2 * s3;
    m[6] = -c2 * s1;
    m[7] = 0;
    m[8] = s1 * s3 - c1 * c3 * s2;
    m[9] = c3 * s1 + c1 * s2 * s3;
    m[10] = c1 * c2;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return this;
  }
  getEulerAngles(eulers = new Vec3()) {
    this.getScale(scale);
    const sx = scale.x;
    const sy = scale.y;
    const sz = scale.z;
    if (sx === 0 || sy === 0 || sz === 0) {
      return eulers.set(0, 0, 0);
    }
    const m = this.data;
    const y2 = Math.asin(-m[2] / sx);
    const halfPi = Math.PI * 0.5;
    let x2, z2;
    if (y2 < halfPi) {
      if (y2 > -halfPi) {
        x2 = Math.atan2(m[6] / sy, m[10] / sz);
        z2 = Math.atan2(m[1] / sx, m[0] / sx);
      } else {
        z2 = 0;
        x2 = -Math.atan2(m[4] / sy, m[5] / sy);
      }
    } else {
      z2 = 0;
      x2 = Math.atan2(m[4] / sy, m[5] / sy);
    }
    return eulers.set(x2, y2, z2).mulScalar(math.RAD_TO_DEG);
  }
  toString() {
    return `[${this.data.join(", ")}]`;
  }
};
_Mat2 = Mat4;
Mat4.IDENTITY = Object.freeze(new _Mat2());
Mat4.ZERO = Object.freeze(new _Mat2().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));

// ../node_modules/playcanvas/build/playcanvas/src/core/math/quat.js
var _Quat;
var Quat = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, w = 1) {
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    if (x2.length === 4) {
      this.x = x2[0];
      this.y = x2[1];
      this.z = x2[2];
      this.w = x2[3];
    } else {
      this.x = x2;
      this.y = y2;
      this.z = z2;
      this.w = w;
    }
  }
  clone() {
    const cstr = this.constructor;
    return new cstr(this.x, this.y, this.z, this.w);
  }
  conjugate(src = this) {
    this.x = src.x * -1;
    this.y = src.y * -1;
    this.z = src.z * -1;
    this.w = src.w;
    return this;
  }
  copy(rhs) {
    this.x = rhs.x;
    this.y = rhs.y;
    this.z = rhs.z;
    this.w = rhs.w;
    return this;
  }
  equals(rhs) {
    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
  }
  equalsApprox(rhs, epsilon3 = 1e-6) {
    return Math.abs(this.x - rhs.x) < epsilon3 && Math.abs(this.y - rhs.y) < epsilon3 && Math.abs(this.z - rhs.z) < epsilon3 && Math.abs(this.w - rhs.w) < epsilon3;
  }
  getAxisAngle(axis) {
    let rad = Math.acos(this.w) * 2;
    const s2 = Math.sin(rad / 2);
    if (s2 !== 0) {
      axis.x = this.x / s2;
      axis.y = this.y / s2;
      axis.z = this.z / s2;
      if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
        axis.x *= -1;
        axis.y *= -1;
        axis.z *= -1;
        rad *= -1;
      }
    } else {
      axis.x = 1;
      axis.y = 0;
      axis.z = 0;
    }
    return rad * math.RAD_TO_DEG;
  }
  getEulerAngles(eulers = new Vec3()) {
    let x2, y2, z2;
    const qx = this.x;
    const qy = this.y;
    const qz = this.z;
    const qw = this.w;
    const a2 = 2 * (qw * qy - qx * qz);
    if (a2 <= -0.99999) {
      x2 = 2 * Math.atan2(qx, qw);
      y2 = -Math.PI / 2;
      z2 = 0;
    } else if (a2 >= 0.99999) {
      x2 = 2 * Math.atan2(qx, qw);
      y2 = Math.PI / 2;
      z2 = 0;
    } else {
      x2 = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
      y2 = Math.asin(a2);
      z2 = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
    }
    return eulers.set(x2, y2, z2).mulScalar(math.RAD_TO_DEG);
  }
  invert(src = this) {
    return this.conjugate(src).normalize();
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  mul(rhs) {
    const q1x = this.x;
    const q1y = this.y;
    const q1z = this.z;
    const q1w = this.w;
    const q2x = rhs.x;
    const q2y = rhs.y;
    const q2z = rhs.z;
    const q2w = rhs.w;
    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
    return this;
  }
  mulScalar(scalar, src = this) {
    this.x = src.x * scalar;
    this.y = src.y * scalar;
    this.z = src.z * scalar;
    this.w = src.w * scalar;
    return this;
  }
  mul2(lhs, rhs) {
    const q1x = lhs.x;
    const q1y = lhs.y;
    const q1z = lhs.z;
    const q1w = lhs.w;
    const q2x = rhs.x;
    const q2y = rhs.y;
    const q2z = rhs.z;
    const q2w = rhs.w;
    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
    return this;
  }
  normalize(src = this) {
    let len = src.length();
    if (len === 0) {
      this.x = this.y = this.z = 0;
      this.w = 1;
    } else {
      len = 1 / len;
      this.x = src.x * len;
      this.y = src.y * len;
      this.z = src.z * len;
      this.w = src.w * len;
    }
    return this;
  }
  set(x2, y2, z2, w) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w;
    return this;
  }
  setFromAxisAngle(axis, angle) {
    angle *= 0.5 * math.DEG_TO_RAD;
    const sa = Math.sin(angle);
    const ca = Math.cos(angle);
    this.x = sa * axis.x;
    this.y = sa * axis.y;
    this.z = sa * axis.z;
    this.w = ca;
    return this;
  }
  setFromEulerAngles(ex, ey, ez) {
    if (ex instanceof Vec3) {
      const vec2 = ex;
      ex = vec2.x;
      ey = vec2.y;
      ez = vec2.z;
    }
    const halfToRad = 0.5 * math.DEG_TO_RAD;
    ex *= halfToRad;
    ey *= halfToRad;
    ez *= halfToRad;
    const sx = Math.sin(ex);
    const cx = Math.cos(ex);
    const sy = Math.sin(ey);
    const cy = Math.cos(ey);
    const sz = Math.sin(ez);
    const cz = Math.cos(ez);
    this.x = sx * cy * cz - cx * sy * sz;
    this.y = cx * sy * cz + sx * cy * sz;
    this.z = cx * cy * sz - sx * sy * cz;
    this.w = cx * cy * cz + sx * sy * sz;
    return this;
  }
  setFromMat4(m) {
    const d = m.data;
    let m00 = d[0];
    let m01 = d[1];
    let m02 = d[2];
    let m10 = d[4];
    let m11 = d[5];
    let m12 = d[6];
    let m20 = d[8];
    let m21 = d[9];
    let m22 = d[10];
    let l;
    l = m00 * m00 + m01 * m01 + m02 * m02;
    if (l === 0) return this.set(0, 0, 0, 1);
    l = 1 / Math.sqrt(l);
    m00 *= l;
    m01 *= l;
    m02 *= l;
    l = m10 * m10 + m11 * m11 + m12 * m12;
    if (l === 0) return this.set(0, 0, 0, 1);
    l = 1 / Math.sqrt(l);
    m10 *= l;
    m11 *= l;
    m12 *= l;
    l = m20 * m20 + m21 * m21 + m22 * m22;
    if (l === 0) return this.set(0, 0, 0, 1);
    l = 1 / Math.sqrt(l);
    m20 *= l;
    m21 *= l;
    m22 *= l;
    if (m22 < 0) {
      if (m00 > m11) {
        this.set(1 + m00 - m11 - m22, m01 + m10, m20 + m02, m12 - m21);
      } else {
        this.set(m01 + m10, 1 - m00 + m11 - m22, m12 + m21, m20 - m02);
      }
    } else {
      if (m00 < -m11) {
        this.set(m20 + m02, m12 + m21, 1 - m00 - m11 + m22, m01 - m10);
      } else {
        this.set(m12 - m21, m20 - m02, m01 - m10, 1 + m00 + m11 + m22);
      }
    }
    return this.mulScalar(1 / this.length());
  }
  setFromDirections(from, to) {
    const dotProduct = 1 + from.dot(to);
    if (dotProduct < Number.EPSILON) {
      if (Math.abs(from.x) > Math.abs(from.y)) {
        this.x = -from.z;
        this.y = 0;
        this.z = from.x;
        this.w = 0;
      } else {
        this.x = 0;
        this.y = -from.z;
        this.z = from.y;
        this.w = 0;
      }
    } else {
      this.x = from.y * to.z - from.z * to.y;
      this.y = from.z * to.x - from.x * to.z;
      this.z = from.x * to.y - from.y * to.x;
      this.w = dotProduct;
    }
    return this.normalize();
  }
  slerp(lhs, rhs, alpha) {
    const lx = lhs.x;
    const ly = lhs.y;
    const lz = lhs.z;
    const lw = lhs.w;
    let rx = rhs.x;
    let ry = rhs.y;
    let rz = rhs.z;
    let rw = rhs.w;
    let cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;
    if (cosHalfTheta < 0) {
      rw = -rw;
      rx = -rx;
      ry = -ry;
      rz = -rz;
      cosHalfTheta = -cosHalfTheta;
    }
    if (Math.abs(cosHalfTheta) >= 1) {
      this.w = lw;
      this.x = lx;
      this.y = ly;
      this.z = lz;
      return this;
    }
    const halfTheta = Math.acos(cosHalfTheta);
    const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 1e-3) {
      this.w = lw * 0.5 + rw * 0.5;
      this.x = lx * 0.5 + rx * 0.5;
      this.y = ly * 0.5 + ry * 0.5;
      this.z = lz * 0.5 + rz * 0.5;
      return this;
    }
    const ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
    const ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
    this.w = lw * ratioA + rw * ratioB;
    this.x = lx * ratioA + rx * ratioB;
    this.y = ly * ratioA + ry * ratioB;
    this.z = lz * ratioA + rz * ratioB;
    return this;
  }
  transformVector(vec2, res = new Vec3()) {
    const x2 = vec2.x, y2 = vec2.y, z2 = vec2.z;
    const qx = this.x, qy = this.y, qz = this.z, qw = this.w;
    const ix = qw * x2 + qy * z2 - qz * y2;
    const iy = qw * y2 + qz * x2 - qx * z2;
    const iz = qw * z2 + qx * y2 - qy * x2;
    const iw = -qx * x2 - qy * y2 - qz * z2;
    res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return res;
  }
  toString() {
    return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
  }
};
_Quat = Quat;
Quat.IDENTITY = Object.freeze(new _Quat(0, 0, 0, 1));
Quat.ZERO = Object.freeze(new _Quat(0, 0, 0, 0));

// ../node_modules/playcanvas/build/playcanvas/src/core/shape/bounding-box.js
var tmpVecA = new Vec3();
var tmpVecB = new Vec3();
var tmpVecC = new Vec3();
var tmpVecD = new Vec3();
var tmpVecE = new Vec3();
var BoundingBox = class _BoundingBox {
  constructor(center2, halfExtents) {
    this.center = new Vec3();
    this.halfExtents = new Vec3(0.5, 0.5, 0.5);
    this._min = new Vec3();
    this._max = new Vec3();
    if (center2) {
      this.center.copy(center2);
    }
    if (halfExtents) {
      this.halfExtents.copy(halfExtents);
    }
  }
  add(other) {
    const tc = this.center;
    const tcx = tc.x;
    const tcy = tc.y;
    const tcz = tc.z;
    const th = this.halfExtents;
    const thx = th.x;
    const thy = th.y;
    const thz = th.z;
    let tminx = tcx - thx;
    let tmaxx = tcx + thx;
    let tminy = tcy - thy;
    let tmaxy = tcy + thy;
    let tminz = tcz - thz;
    let tmaxz = tcz + thz;
    const oc = other.center;
    const ocx = oc.x;
    const ocy = oc.y;
    const ocz = oc.z;
    const oh = other.halfExtents;
    const ohx = oh.x;
    const ohy = oh.y;
    const ohz = oh.z;
    const ominx = ocx - ohx;
    const omaxx = ocx + ohx;
    const ominy = ocy - ohy;
    const omaxy = ocy + ohy;
    const ominz = ocz - ohz;
    const omaxz = ocz + ohz;
    if (ominx < tminx) tminx = ominx;
    if (omaxx > tmaxx) tmaxx = omaxx;
    if (ominy < tminy) tminy = ominy;
    if (omaxy > tmaxy) tmaxy = omaxy;
    if (ominz < tminz) tminz = ominz;
    if (omaxz > tmaxz) tmaxz = omaxz;
    tc.x = (tminx + tmaxx) * 0.5;
    tc.y = (tminy + tmaxy) * 0.5;
    tc.z = (tminz + tmaxz) * 0.5;
    th.x = (tmaxx - tminx) * 0.5;
    th.y = (tmaxy - tminy) * 0.5;
    th.z = (tmaxz - tminz) * 0.5;
  }
  copy(src) {
    this.center.copy(src.center);
    this.halfExtents.copy(src.halfExtents);
  }
  clone() {
    return new _BoundingBox(this.center, this.halfExtents);
  }
  intersects(other) {
    const aMax = this.getMax();
    const aMin = this.getMin();
    const bMax2 = other.getMax();
    const bMin2 = other.getMin();
    return aMin.x <= bMax2.x && aMax.x >= bMin2.x && aMin.y <= bMax2.y && aMax.y >= bMin2.y && aMin.z <= bMax2.z && aMax.z >= bMin2.z;
  }
  _intersectsRay(ray, point) {
    const tMin = tmpVecA.copy(this.getMin()).sub(ray.origin);
    const tMax = tmpVecB.copy(this.getMax()).sub(ray.origin);
    const dir = ray.direction;
    if (dir.x === 0) {
      tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
      tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
    } else {
      tMin.x /= dir.x;
      tMax.x /= dir.x;
    }
    if (dir.y === 0) {
      tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
      tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
    } else {
      tMin.y /= dir.y;
      tMax.y /= dir.y;
    }
    if (dir.z === 0) {
      tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
      tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
    } else {
      tMin.z /= dir.z;
      tMax.z /= dir.z;
    }
    const realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
    const realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
    const minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
    const maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
    const intersects = minMax >= maxMin && maxMin >= 0;
    if (intersects) {
      point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);
    }
    return intersects;
  }
  _fastIntersectsRay(ray) {
    const diff = tmpVecA;
    const cross = tmpVecB;
    const prod = tmpVecC;
    const absDiff = tmpVecD;
    const absDir = tmpVecE;
    const rayDir = ray.direction;
    diff.sub2(ray.origin, this.center);
    absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
    prod.mul2(diff, rayDir);
    if (absDiff.x > this.halfExtents.x && prod.x >= 0) {
      return false;
    }
    if (absDiff.y > this.halfExtents.y && prod.y >= 0) {
      return false;
    }
    if (absDiff.z > this.halfExtents.z && prod.z >= 0) {
      return false;
    }
    absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
    cross.cross(rayDir, diff);
    cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
    if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) {
      return false;
    }
    if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) {
      return false;
    }
    if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) {
      return false;
    }
    return true;
  }
  intersectsRay(ray, point) {
    if (point) {
      return this._intersectsRay(ray, point);
    }
    return this._fastIntersectsRay(ray);
  }
  setMinMax(min, max) {
    this.center.add2(max, min).mulScalar(0.5);
    this.halfExtents.sub2(max, min).mulScalar(0.5);
  }
  getMin() {
    return this._min.copy(this.center).sub(this.halfExtents);
  }
  getMax() {
    return this._max.copy(this.center).add(this.halfExtents);
  }
  containsPoint(point) {
    const min = this.getMin();
    const max = this.getMax();
    if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
      return false;
    }
    return true;
  }
  setFromTransformedAabb(aabb3, m, ignoreScale = false) {
    const ac = aabb3.center;
    const ar = aabb3.halfExtents;
    const d = m.data;
    let mx0 = d[0];
    let mx1 = d[4];
    let mx2 = d[8];
    let my0 = d[1];
    let my1 = d[5];
    let my2 = d[9];
    let mz0 = d[2];
    let mz1 = d[6];
    let mz2 = d[10];
    if (ignoreScale) {
      let lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;
      if (lengthSq > 0) {
        const invLength = 1 / Math.sqrt(lengthSq);
        mx0 *= invLength;
        mx1 *= invLength;
        mx2 *= invLength;
      }
      lengthSq = my0 * my0 + my1 * my1 + my2 * my2;
      if (lengthSq > 0) {
        const invLength = 1 / Math.sqrt(lengthSq);
        my0 *= invLength;
        my1 *= invLength;
        my2 *= invLength;
      }
      lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;
      if (lengthSq > 0) {
        const invLength = 1 / Math.sqrt(lengthSq);
        mz0 *= invLength;
        mz1 *= invLength;
        mz2 *= invLength;
      }
    }
    this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
    this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);
  }
  static computeMinMax(vertices, min, max, numVerts = vertices.length / 3) {
    if (numVerts > 0) {
      let minx = vertices[0];
      let miny = vertices[1];
      let minz = vertices[2];
      let maxx = minx;
      let maxy = miny;
      let maxz = minz;
      const n = numVerts * 3;
      for (let i = 3; i < n; i += 3) {
        const x2 = vertices[i];
        const y2 = vertices[i + 1];
        const z2 = vertices[i + 2];
        if (x2 < minx) minx = x2;
        if (y2 < miny) miny = y2;
        if (z2 < minz) minz = z2;
        if (x2 > maxx) maxx = x2;
        if (y2 > maxy) maxy = y2;
        if (z2 > maxz) maxz = z2;
      }
      min.set(minx, miny, minz);
      max.set(maxx, maxy, maxz);
    }
  }
  compute(vertices, numVerts) {
    _BoundingBox.computeMinMax(vertices, tmpVecA, tmpVecB, numVerts);
    this.setMinMax(tmpVecA, tmpVecB);
  }
  intersectsBoundingSphere(sphere) {
    const sq = this._distanceToBoundingSphereSq(sphere);
    if (sq <= sphere.radius * sphere.radius) {
      return true;
    }
    return false;
  }
  _distanceToBoundingSphereSq(sphere) {
    const boxMin = this.getMin();
    const boxMax = this.getMax();
    let sq = 0;
    const axis = ["x", "y", "z"];
    for (let i = 0; i < 3; ++i) {
      let out = 0;
      const pn = sphere.center[axis[i]];
      const bMin2 = boxMin[axis[i]];
      const bMax2 = boxMax[axis[i]];
      let val = 0;
      if (pn < bMin2) {
        val = bMin2 - pn;
        out += val * val;
      }
      if (pn > bMax2) {
        val = pn - bMax2;
        out += val * val;
      }
      sq += out;
    }
    return sq;
  }
  _expand(expandMin, expandMax) {
    tmpVecA.add2(this.getMin(), expandMin);
    tmpVecB.add2(this.getMax(), expandMax);
    this.setMinMax(tmpVecA, tmpVecB);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/shape/bounding-sphere.js
var tmpVecA2 = new Vec3();
var tmpVecB2 = new Vec3();
var BoundingSphere = class {
  constructor(center2 = new Vec3(), radius = 0.5) {
    this.center = void 0;
    this.radius = void 0;
    this.center = center2;
    this.radius = radius;
  }
  containsPoint(point) {
    const lenSq = tmpVecA2.sub2(point, this.center).lengthSq();
    const r = this.radius;
    return lenSq < r * r;
  }
  intersectsRay(ray, point) {
    const m = tmpVecA2.copy(ray.origin).sub(this.center);
    const b = m.dot(tmpVecB2.copy(ray.direction).normalize());
    const c2 = m.dot(m) - this.radius * this.radius;
    if (c2 > 0 && b > 0) {
      return false;
    }
    const discr = b * b - c2;
    if (discr < 0) {
      return false;
    }
    const t = Math.abs(-b - Math.sqrt(discr));
    if (point) {
      point.copy(ray.direction).mulScalar(t).add(ray.origin);
    }
    return true;
  }
  intersectsBoundingSphere(sphere) {
    tmpVecA2.sub2(sphere.center, this.center);
    const totalRadius = sphere.radius + this.radius;
    if (tmpVecA2.lengthSq() <= totalRadius * totalRadius) {
      return true;
    }
    return false;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/shape/plane.js
var Plane = class {
  constructor(normal = Vec3.UP, distance = 0) {
    this.normal = new Vec3();
    this.distance = void 0;
    this.normal.copy(normal);
    this.distance = distance;
  }
  clone() {
    const cstr = this.constructor;
    return new cstr().copy(this);
  }
  copy(src) {
    this.normal.copy(src.normal);
    this.distance = src.distance;
    return this;
  }
  intersectsLine(start, end, point) {
    const d = this.distance;
    const d0 = this.normal.dot(start) + d;
    const d1 = this.normal.dot(end) + d;
    const t = d0 / (d0 - d1);
    const intersects = t >= 0 && t <= 1;
    if (intersects && point) {
      point.lerp(start, end, t);
    }
    return intersects;
  }
  intersectsRay(ray, point) {
    const denominator = this.normal.dot(ray.direction);
    if (denominator === 0) {
      return false;
    }
    const t = -(this.normal.dot(ray.origin) + this.distance) / denominator;
    if (t >= 0 && point) {
      point.copy(ray.direction).mulScalar(t).add(ray.origin);
    }
    return t >= 0;
  }
  normalize() {
    const invLength = 1 / this.normal.length();
    this.normal.mulScalar(invLength);
    this.distance *= invLength;
    return this;
  }
  set(nx, ny, nz, d) {
    this.normal.set(nx, ny, nz);
    this.distance = d;
    return this;
  }
  setFromPointNormal(point, normal) {
    this.normal.copy(normal);
    this.distance = -this.normal.dot(point);
    return this;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/shape/frustum.js
var Frustum = class {
  constructor() {
    this.planes = [];
    for (let i = 0; i < 6; i++) {
      this.planes[i] = new Plane();
    }
  }
  clone() {
    const cstr = this.constructor;
    return new cstr().copy(this);
  }
  copy(src) {
    for (let i = 0; i < 6; i++) {
      this.planes[i].copy(src.planes[i]);
    }
    return this;
  }
  setFromMat4(matrix2) {
    const [m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33] = matrix2.data;
    const planes = this.planes;
    planes[0].set(m03 - m00, m13 - m10, m23 - m20, m33 - m30).normalize();
    planes[1].set(m03 + m00, m13 + m10, m23 + m20, m33 + m30).normalize();
    planes[2].set(m03 + m01, m13 + m11, m23 + m21, m33 + m31).normalize();
    planes[3].set(m03 - m01, m13 - m11, m23 - m21, m33 - m31).normalize();
    planes[4].set(m03 - m02, m13 - m12, m23 - m22, m33 - m32).normalize();
    planes[5].set(m03 + m02, m13 + m12, m23 + m22, m33 + m32).normalize();
  }
  containsPoint(point) {
    for (let p = 0; p < 6; p++) {
      const {
        normal,
        distance
      } = this.planes[p];
      if (normal.dot(point) + distance <= 0) {
        return false;
      }
    }
    return true;
  }
  containsSphere(sphere) {
    const {
      center: center2,
      radius
    } = sphere;
    let c2 = 0;
    for (let p = 0; p < 6; p++) {
      const {
        normal,
        distance
      } = this.planes[p];
      const d = normal.dot(center2) + distance;
      if (d <= -radius) {
        return 0;
      }
      if (d > radius) {
        c2++;
      }
    }
    return c2 === 6 ? 2 : 1;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/shape/ray.js
var Ray = class {
  constructor(origin, direction) {
    this.origin = new Vec3();
    this.direction = Vec3.FORWARD.clone();
    if (origin) {
      this.origin.copy(origin);
    }
    if (direction) {
      this.direction.copy(direction);
    }
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(src) {
    return this.set(src.origin, src.direction);
  }
  clone() {
    return new this.constructor(this.origin, this.direction);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/shape/oriented-box.js
var tmpRay = new Ray();
var tmpVec3 = new Vec3();
var tmpSphere = new BoundingSphere();
var tmpMat4 = new Mat4();
var OrientedBox = class {
  constructor(worldTransform = new Mat4(), halfExtents) {
    this.halfExtents = new Vec3(0.5, 0.5, 0.5);
    this._modelTransform = void 0;
    this._worldTransform = void 0;
    this._aabb = void 0;
    if (halfExtents) {
      this.halfExtents.copy(halfExtents);
    }
    this._modelTransform = worldTransform.clone().invert();
    this._worldTransform = worldTransform.clone();
    this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
  }
  set worldTransform(value) {
    this._worldTransform.copy(value);
    this._modelTransform.copy(value).invert();
  }
  get worldTransform() {
    return this._worldTransform;
  }
  intersectsRay(ray, point) {
    this._modelTransform.transformPoint(ray.origin, tmpRay.origin);
    this._modelTransform.transformVector(ray.direction, tmpRay.direction);
    if (point) {
      const result = this._aabb._intersectsRay(tmpRay, point);
      tmpMat4.copy(this._modelTransform).invert().transformPoint(point, point);
      return result;
    }
    return this._aabb._fastIntersectsRay(tmpRay);
  }
  containsPoint(point) {
    this._modelTransform.transformPoint(point, tmpVec3);
    return this._aabb.containsPoint(tmpVec3);
  }
  intersectsBoundingSphere(sphere) {
    this._modelTransform.transformPoint(sphere.center, tmpSphere.center);
    tmpSphere.radius = sphere.radius;
    if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
      return true;
    }
    return false;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/shape/tri.js
var e1 = new Vec3();
var e2 = new Vec3();
var h = new Vec3();
var s = new Vec3();
var q = new Vec3();
var EPSILON = 1e-6;
var Tri = class {
  constructor(v0 = Vec3.ZERO, v1 = Vec3.ZERO, v22 = Vec3.ZERO) {
    this.v0 = new Vec3();
    this.v1 = new Vec3();
    this.v2 = new Vec3();
    this.set(v0, v1, v22);
  }
  set(v0, v1, v22) {
    this.v0.copy(v0);
    this.v1.copy(v1);
    this.v2.copy(v22);
    return this;
  }
  intersectsRay(ray, point) {
    e1.sub2(this.v1, this.v0);
    e2.sub2(this.v2, this.v0);
    h.cross(ray.direction, e2);
    const a = e1.dot(h);
    if (a > -EPSILON && a < EPSILON) {
      return false;
    }
    const f = 1 / a;
    s.sub2(ray.origin, this.v0);
    const u = f * s.dot(h);
    if (u < 0 || u > 1) {
      return false;
    }
    q.cross(s, e1);
    const v = f * ray.direction.dot(q);
    if (v < 0 || u + v > 1) {
      return false;
    }
    const t = f * e2.dot(q);
    if (t > EPSILON) {
      if (point instanceof Vec3) {
        point.copy(ray.direction).mulScalar(t).add(ray.origin);
      }
      return true;
    }
    return false;
  }
  toString() {
    return `[${this.v0.toString()}, ${this.v1.toString()}, ${this.v2.toString()}]`;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/audio/constants.js
var DISTANCE_LINEAR = "linear";
var DISTANCE_INVERSE = "inverse";
var DISTANCE_EXPONENTIAL = "exponential";

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/constants.js
var ADDRESS_REPEAT = 0;
var ADDRESS_CLAMP_TO_EDGE = 1;
var ADDRESS_MIRRORED_REPEAT = 2;
var BLENDMODE_ZERO = 0;
var BLENDMODE_ONE = 1;
var BLENDMODE_SRC_COLOR = 2;
var BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
var BLENDMODE_DST_COLOR = 4;
var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
var BLENDMODE_SRC_ALPHA = 6;
var BLENDMODE_SRC_ALPHA_SATURATE = 7;
var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
var BLENDMODE_DST_ALPHA = 9;
var BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
var BLENDMODE_CONSTANT = 11;
var BLENDMODE_ONE_MINUS_CONSTANT = 12;
var BLENDEQUATION_ADD = 0;
var BLENDEQUATION_SUBTRACT = 1;
var BLENDEQUATION_REVERSE_SUBTRACT = 2;
var BLENDEQUATION_MIN = 3;
var BLENDEQUATION_MAX = 4;
var BUFFERUSAGE_READ = 1;
var BUFFERUSAGE_WRITE = 2;
var BUFFERUSAGE_COPY_SRC = 4;
var BUFFERUSAGE_COPY_DST = 8;
var BUFFERUSAGE_INDEX = 16;
var BUFFERUSAGE_VERTEX = 32;
var BUFFERUSAGE_UNIFORM = 64;
var BUFFERUSAGE_STORAGE = 128;
var BUFFERUSAGE_INDIRECT = 256;
var BUFFER_STATIC = 0;
var BUFFER_DYNAMIC = 1;
var BUFFER_STREAM = 2;
var BUFFER_GPUDYNAMIC = 3;
var CLEARFLAG_COLOR = 1;
var CLEARFLAG_DEPTH = 2;
var CLEARFLAG_STENCIL = 4;
var CUBEFACE_POSX = 0;
var CUBEFACE_NEGX = 1;
var CUBEFACE_POSY = 2;
var CUBEFACE_NEGY = 3;
var CUBEFACE_POSZ = 4;
var CUBEFACE_NEGZ = 5;
var CULLFACE_NONE = 0;
var CULLFACE_BACK = 1;
var CULLFACE_FRONT = 2;
var CULLFACE_FRONTANDBACK = 3;
var FILTER_NEAREST = 0;
var FILTER_LINEAR = 1;
var FILTER_NEAREST_MIPMAP_NEAREST = 2;
var FILTER_NEAREST_MIPMAP_LINEAR = 3;
var FILTER_LINEAR_MIPMAP_NEAREST = 4;
var FILTER_LINEAR_MIPMAP_LINEAR = 5;
var FUNC_NEVER = 0;
var FUNC_LESS = 1;
var FUNC_EQUAL = 2;
var FUNC_LESSEQUAL = 3;
var FUNC_GREATER = 4;
var FUNC_NOTEQUAL = 5;
var FUNC_GREATEREQUAL = 6;
var FUNC_ALWAYS = 7;
var INDEXFORMAT_UINT8 = 0;
var INDEXFORMAT_UINT16 = 1;
var INDEXFORMAT_UINT32 = 2;
var PIXELFORMAT_A8 = 0;
var PIXELFORMAT_L8 = 1;
var PIXELFORMAT_LA8 = 2;
var PIXELFORMAT_RGB565 = 3;
var PIXELFORMAT_RGBA5551 = 4;
var PIXELFORMAT_RGBA4 = 5;
var PIXELFORMAT_RGB8 = 6;
var PIXELFORMAT_RGBA8 = 7;
var PIXELFORMAT_DXT1 = 8;
var PIXELFORMAT_DXT3 = 9;
var PIXELFORMAT_DXT5 = 10;
var PIXELFORMAT_RGB16F = 11;
var PIXELFORMAT_RGBA16F = 12;
var PIXELFORMAT_RGB32F = 13;
var PIXELFORMAT_RGBA32F = 14;
var PIXELFORMAT_R32F = 15;
var PIXELFORMAT_DEPTH = 16;
var PIXELFORMAT_DEPTHSTENCIL = 17;
var PIXELFORMAT_111110F = 18;
var PIXELFORMAT_SRGB8 = 19;
var PIXELFORMAT_SRGBA8 = 20;
var PIXELFORMAT_ETC1 = 21;
var PIXELFORMAT_ETC2_RGB = 22;
var PIXELFORMAT_ETC2_RGBA = 23;
var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
var PIXELFORMAT_ASTC_4x4 = 28;
var PIXELFORMAT_ATC_RGB = 29;
var PIXELFORMAT_ATC_RGBA = 30;
var PIXELFORMAT_BGRA8 = 31;
var PIXELFORMAT_R8I = 32;
var PIXELFORMAT_R8U = 33;
var PIXELFORMAT_R16I = 34;
var PIXELFORMAT_R16U = 35;
var PIXELFORMAT_R32I = 36;
var PIXELFORMAT_R32U = 37;
var PIXELFORMAT_RG8I = 38;
var PIXELFORMAT_RG8U = 39;
var PIXELFORMAT_RG16I = 40;
var PIXELFORMAT_RG16U = 41;
var PIXELFORMAT_RG32I = 42;
var PIXELFORMAT_RG32U = 43;
var PIXELFORMAT_RGBA8I = 44;
var PIXELFORMAT_RGBA8U = 45;
var PIXELFORMAT_RGBA16I = 46;
var PIXELFORMAT_RGBA16U = 47;
var PIXELFORMAT_RGBA32I = 48;
var PIXELFORMAT_RGBA32U = 49;
var PIXELFORMAT_R16F = 50;
var PIXELFORMAT_RG16F = 51;
var PIXELFORMAT_R8 = 52;
var PIXELFORMAT_RG8 = 53;
var PIXELFORMAT_DXT1_SRGB = 54;
var PIXELFORMAT_DXT3_SRGB = 55;
var PIXELFORMAT_DXT5_SRGB = 56;
var PIXELFORMAT_PVRTC_2BPP_SRGB_1 = 57;
var PIXELFORMAT_PVRTC_2BPP_SRGBA_1 = 58;
var PIXELFORMAT_PVRTC_4BPP_SRGB_1 = 59;
var PIXELFORMAT_PVRTC_4BPP_SRGBA_1 = 60;
var PIXELFORMAT_ETC2_SRGB = 61;
var PIXELFORMAT_ETC2_SRGBA = 62;
var PIXELFORMAT_ASTC_4x4_SRGB = 63;
var PIXELFORMAT_SBGRA8 = 64;
var pixelFormatInfo = /* @__PURE__ */ new Map([[PIXELFORMAT_A8, {
  name: "A8",
  size: 1,
  ldr: true
}], [PIXELFORMAT_R8, {
  name: "R8",
  size: 1,
  ldr: true
}], [PIXELFORMAT_L8, {
  name: "L8",
  size: 1,
  ldr: true
}], [PIXELFORMAT_LA8, {
  name: "LA8",
  size: 2,
  ldr: true
}], [PIXELFORMAT_RG8, {
  name: "RG8",
  size: 2,
  ldr: true
}], [PIXELFORMAT_RGB565, {
  name: "RGB565",
  size: 2,
  ldr: true
}], [PIXELFORMAT_RGBA5551, {
  name: "RGBA5551",
  size: 2,
  ldr: true
}], [PIXELFORMAT_RGBA4, {
  name: "RGBA4",
  size: 2,
  ldr: true
}], [PIXELFORMAT_RGB8, {
  name: "RGB8",
  size: 4,
  ldr: true
}], [PIXELFORMAT_RGBA8, {
  name: "RGBA8",
  size: 4,
  ldr: true,
  srgbFormat: PIXELFORMAT_SRGBA8
}], [PIXELFORMAT_R16F, {
  name: "R16F",
  size: 2
}], [PIXELFORMAT_RG16F, {
  name: "RG16F",
  size: 4
}], [PIXELFORMAT_RGB16F, {
  name: "RGB16F",
  size: 8
}], [PIXELFORMAT_RGBA16F, {
  name: "RGBA16F",
  size: 8
}], [PIXELFORMAT_RGB32F, {
  name: "RGB32F",
  size: 16
}], [PIXELFORMAT_RGBA32F, {
  name: "RGBA32F",
  size: 16
}], [PIXELFORMAT_R32F, {
  name: "R32F",
  size: 4
}], [PIXELFORMAT_DEPTH, {
  name: "DEPTH",
  size: 4
}], [PIXELFORMAT_DEPTHSTENCIL, {
  name: "DEPTHSTENCIL",
  size: 4
}], [PIXELFORMAT_111110F, {
  name: "111110F",
  size: 4
}], [PIXELFORMAT_SRGB8, {
  name: "SRGB8",
  size: 4,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_SRGBA8, {
  name: "SRGBA8",
  size: 4,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_BGRA8, {
  name: "BGRA8",
  size: 4,
  ldr: true
}], [PIXELFORMAT_SBGRA8, {
  name: "SBGRA8",
  size: 4,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_DXT1, {
  name: "DXT1",
  blockSize: 8,
  ldr: true,
  srgbFormat: PIXELFORMAT_DXT1_SRGB
}], [PIXELFORMAT_DXT3, {
  name: "DXT3",
  blockSize: 16,
  ldr: true,
  srgbFormat: PIXELFORMAT_DXT3_SRGB
}], [PIXELFORMAT_DXT5, {
  name: "DXT5",
  blockSize: 16,
  ldr: true,
  srgbFormat: PIXELFORMAT_DXT5_SRGB
}], [PIXELFORMAT_ETC1, {
  name: "ETC1",
  blockSize: 8,
  ldr: true
}], [PIXELFORMAT_ETC2_RGB, {
  name: "ETC2_RGB",
  blockSize: 8,
  ldr: true,
  srgbFormat: PIXELFORMAT_ETC2_SRGB
}], [PIXELFORMAT_ETC2_RGBA, {
  name: "ETC2_RGBA",
  blockSize: 16,
  ldr: true,
  srgbFormat: PIXELFORMAT_ETC2_SRGBA
}], [PIXELFORMAT_PVRTC_2BPP_RGB_1, {
  name: "PVRTC_2BPP_RGB_1",
  ldr: true,
  blockSize: 8,
  srgbFormat: PIXELFORMAT_PVRTC_2BPP_SRGB_1
}], [PIXELFORMAT_PVRTC_2BPP_RGBA_1, {
  name: "PVRTC_2BPP_RGBA_1",
  ldr: true,
  blockSize: 8,
  srgbFormat: PIXELFORMAT_PVRTC_2BPP_SRGBA_1
}], [PIXELFORMAT_PVRTC_4BPP_RGB_1, {
  name: "PVRTC_4BPP_RGB_1",
  ldr: true,
  blockSize: 8,
  srgbFormat: PIXELFORMAT_PVRTC_4BPP_SRGB_1
}], [PIXELFORMAT_PVRTC_4BPP_RGBA_1, {
  name: "PVRTC_4BPP_RGBA_1",
  ldr: true,
  blockSize: 8,
  srgbFormat: PIXELFORMAT_PVRTC_4BPP_SRGBA_1
}], [PIXELFORMAT_ASTC_4x4, {
  name: "ASTC_4x4",
  blockSize: 16,
  ldr: true,
  srgbFormat: PIXELFORMAT_ASTC_4x4_SRGB
}], [PIXELFORMAT_ATC_RGB, {
  name: "ATC_RGB",
  blockSize: 8,
  ldr: true
}], [PIXELFORMAT_ATC_RGBA, {
  name: "ATC_RGBA",
  blockSize: 16,
  ldr: true
}], [PIXELFORMAT_DXT1_SRGB, {
  name: "DXT1_SRGB",
  blockSize: 8,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_DXT3_SRGB, {
  name: "DXT3_SRGB",
  blockSize: 16,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_DXT5_SRGB, {
  name: "DXT5_SRGB",
  blockSize: 16,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_PVRTC_2BPP_SRGB_1, {
  name: "PVRTC_2BPP_SRGB_1",
  blockSize: 8,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_PVRTC_2BPP_SRGBA_1, {
  name: "PVRTC_2BPP_SRGBA_1",
  blockSize: 8,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_PVRTC_4BPP_SRGB_1, {
  name: "PVRTC_4BPP_SRGB_1",
  blockSize: 8,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_PVRTC_4BPP_SRGBA_1, {
  name: "PVRTC_4BPP_SRGBA_1",
  blockSize: 8,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_ETC2_SRGB, {
  name: "ETC2_SRGB",
  blockSize: 8,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_ETC2_SRGBA, {
  name: "ETC2_SRGBA",
  blockSize: 16,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_ASTC_4x4_SRGB, {
  name: "ASTC_4x4_SRGB",
  blockSize: 16,
  ldr: true,
  srgb: true
}], [PIXELFORMAT_R8I, {
  name: "R8I",
  size: 1,
  isInt: true
}], [PIXELFORMAT_R8U, {
  name: "R8U",
  size: 1,
  isInt: true
}], [PIXELFORMAT_R16I, {
  name: "R16I",
  size: 2,
  isInt: true
}], [PIXELFORMAT_R16U, {
  name: "R16U",
  size: 2,
  isInt: true
}], [PIXELFORMAT_R32I, {
  name: "R32I",
  size: 4,
  isInt: true
}], [PIXELFORMAT_R32U, {
  name: "R32U",
  size: 4,
  isInt: true
}], [PIXELFORMAT_RG8I, {
  name: "RG8I",
  size: 2,
  isInt: true
}], [PIXELFORMAT_RG8U, {
  name: "RG8U",
  size: 2,
  isInt: true
}], [PIXELFORMAT_RG16I, {
  name: "RG16I",
  size: 4,
  isInt: true
}], [PIXELFORMAT_RG16U, {
  name: "RG16U",
  size: 4,
  isInt: true
}], [PIXELFORMAT_RG32I, {
  name: "RG32I",
  size: 8,
  isInt: true
}], [PIXELFORMAT_RG32U, {
  name: "RG32U",
  size: 8,
  isInt: true
}], [PIXELFORMAT_RGBA8I, {
  name: "RGBA8I",
  size: 4,
  isInt: true
}], [PIXELFORMAT_RGBA8U, {
  name: "RGBA8U",
  size: 4,
  isInt: true
}], [PIXELFORMAT_RGBA16I, {
  name: "RGBA16I",
  size: 8,
  isInt: true
}], [PIXELFORMAT_RGBA16U, {
  name: "RGBA16U",
  size: 8,
  isInt: true
}], [PIXELFORMAT_RGBA32I, {
  name: "RGBA32I",
  size: 16,
  isInt: true
}], [PIXELFORMAT_RGBA32U, {
  name: "RGBA32U",
  size: 16,
  isInt: true
}]]);
var isCompressedPixelFormat = (format) => {
  var _pixelFormatInfo$get;
  return ((_pixelFormatInfo$get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get.blockSize) !== void 0;
};
var isSrgbPixelFormat = (format) => {
  var _pixelFormatInfo$get2;
  return ((_pixelFormatInfo$get2 = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get2.srgb) === true;
};
var isIntegerPixelFormat = (format) => {
  var _pixelFormatInfo$get3;
  return ((_pixelFormatInfo$get3 = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get3.isInt) === true;
};
var pixelFormatLinearToGamma = (format) => {
  var _pixelFormatInfo$get4;
  return ((_pixelFormatInfo$get4 = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get4.srgbFormat) || format;
};
var requiresManualGamma = (format) => {
  const info = pixelFormatInfo.get(format);
  return !!(info != null && info.ldr && !(info != null && info.srgb));
};
var getPixelFormatArrayType = (format) => {
  switch (format) {
    case PIXELFORMAT_R32F:
    case PIXELFORMAT_RGB32F:
    case PIXELFORMAT_RGBA32F:
      return Float32Array;
    case PIXELFORMAT_R32I:
    case PIXELFORMAT_RG32I:
    case PIXELFORMAT_RGBA32I:
      return Int32Array;
    case PIXELFORMAT_R32U:
    case PIXELFORMAT_RG32U:
    case PIXELFORMAT_RGBA32U:
      return Uint32Array;
    case PIXELFORMAT_R16I:
    case PIXELFORMAT_RG16I:
    case PIXELFORMAT_RGBA16I:
      return Int16Array;
    case PIXELFORMAT_RG8:
    case PIXELFORMAT_R16U:
    case PIXELFORMAT_RG16U:
    case PIXELFORMAT_RGBA16U:
    case PIXELFORMAT_RGB565:
    case PIXELFORMAT_RGBA5551:
    case PIXELFORMAT_RGBA4:
    case PIXELFORMAT_R16F:
    case PIXELFORMAT_RG16F:
    case PIXELFORMAT_RGB16F:
    case PIXELFORMAT_RGBA16F:
      return Uint16Array;
    case PIXELFORMAT_R8I:
    case PIXELFORMAT_RG8I:
    case PIXELFORMAT_RGBA8I:
      return Int8Array;
    default:
      return Uint8Array;
  }
};
var PRIMITIVE_POINTS = 0;
var PRIMITIVE_LINES = 1;
var PRIMITIVE_LINELOOP = 2;
var PRIMITIVE_LINESTRIP = 3;
var PRIMITIVE_TRIANGLES = 4;
var PRIMITIVE_TRISTRIP = 5;
var PRIMITIVE_TRIFAN = 6;
var SEMANTIC_POSITION = "POSITION";
var SEMANTIC_NORMAL = "NORMAL";
var SEMANTIC_TANGENT = "TANGENT";
var SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
var SEMANTIC_BLENDINDICES = "BLENDINDICES";
var SEMANTIC_COLOR = "COLOR";
var SEMANTIC_TEXCOORD = "TEXCOORD";
var SEMANTIC_TEXCOORD0 = "TEXCOORD0";
var SEMANTIC_TEXCOORD1 = "TEXCOORD1";
var SEMANTIC_TEXCOORD2 = "TEXCOORD2";
var SEMANTIC_TEXCOORD3 = "TEXCOORD3";
var SEMANTIC_TEXCOORD4 = "TEXCOORD4";
var SEMANTIC_TEXCOORD5 = "TEXCOORD5";
var SEMANTIC_TEXCOORD6 = "TEXCOORD6";
var SEMANTIC_TEXCOORD7 = "TEXCOORD7";
var SEMANTIC_ATTR0 = "ATTR0";
var SEMANTIC_ATTR1 = "ATTR1";
var SEMANTIC_ATTR2 = "ATTR2";
var SEMANTIC_ATTR3 = "ATTR3";
var SEMANTIC_ATTR4 = "ATTR4";
var SEMANTIC_ATTR5 = "ATTR5";
var SEMANTIC_ATTR6 = "ATTR6";
var SEMANTIC_ATTR7 = "ATTR7";
var SEMANTIC_ATTR8 = "ATTR8";
var SEMANTIC_ATTR9 = "ATTR9";
var SEMANTIC_ATTR10 = "ATTR10";
var SEMANTIC_ATTR11 = "ATTR11";
var SEMANTIC_ATTR12 = "ATTR12";
var SEMANTIC_ATTR13 = "ATTR13";
var SEMANTIC_ATTR14 = "ATTR14";
var SEMANTIC_ATTR15 = "ATTR15";
var SHADERTAG_MATERIAL = 1;
var STENCILOP_KEEP = 0;
var STENCILOP_ZERO = 1;
var STENCILOP_REPLACE = 2;
var STENCILOP_INCREMENT = 3;
var STENCILOP_INCREMENTWRAP = 4;
var STENCILOP_DECREMENT = 5;
var STENCILOP_DECREMENTWRAP = 6;
var STENCILOP_INVERT = 7;
var TEXTURELOCK_NONE = 0;
var TEXTURELOCK_READ = 1;
var TEXTURELOCK_WRITE = 2;
var TEXTURETYPE_DEFAULT = "default";
var TEXTURETYPE_RGBM = "rgbm";
var TEXTURETYPE_RGBE = "rgbe";
var TEXTURETYPE_RGBP = "rgbp";
var TEXTURETYPE_SWIZZLEGGGR = "swizzleGGGR";
var TEXHINT_NONE = 0;
var TEXHINT_SHADOWMAP = 1;
var TEXHINT_ASSET = 2;
var TEXHINT_LIGHTMAP = 3;
var TEXTUREDIMENSION_1D = "1d";
var TEXTUREDIMENSION_2D = "2d";
var TEXTUREDIMENSION_2D_ARRAY = "2d-array";
var TEXTUREDIMENSION_CUBE = "cube";
var TEXTUREDIMENSION_CUBE_ARRAY = "cube-array";
var TEXTUREDIMENSION_3D = "3d";
var SAMPLETYPE_FLOAT = 0;
var SAMPLETYPE_UNFILTERABLE_FLOAT = 1;
var SAMPLETYPE_DEPTH = 2;
var SAMPLETYPE_INT = 3;
var SAMPLETYPE_UINT = 4;
var TEXTUREPROJECTION_NONE = "none";
var TEXTUREPROJECTION_CUBE = "cube";
var TEXTUREPROJECTION_EQUIRECT = "equirect";
var TEXTUREPROJECTION_OCTAHEDRAL = "octahedral";
var SHADERLANGUAGE_GLSL = "glsl";
var SHADERLANGUAGE_WGSL = "wgsl";
var TYPE_INT8 = 0;
var TYPE_UINT8 = 1;
var TYPE_INT16 = 2;
var TYPE_UINT16 = 3;
var TYPE_INT32 = 4;
var TYPE_UINT32 = 5;
var TYPE_FLOAT32 = 6;
var TYPE_FLOAT16 = 7;
var UNIFORMTYPE_BOOL = 0;
var UNIFORMTYPE_INT = 1;
var UNIFORMTYPE_FLOAT = 2;
var UNIFORMTYPE_VEC2 = 3;
var UNIFORMTYPE_VEC3 = 4;
var UNIFORMTYPE_VEC4 = 5;
var UNIFORMTYPE_IVEC2 = 6;
var UNIFORMTYPE_IVEC3 = 7;
var UNIFORMTYPE_IVEC4 = 8;
var UNIFORMTYPE_BVEC2 = 9;
var UNIFORMTYPE_BVEC3 = 10;
var UNIFORMTYPE_BVEC4 = 11;
var UNIFORMTYPE_MAT2 = 12;
var UNIFORMTYPE_MAT3 = 13;
var UNIFORMTYPE_MAT4 = 14;
var UNIFORMTYPE_TEXTURE2D = 15;
var UNIFORMTYPE_TEXTURECUBE = 16;
var UNIFORMTYPE_FLOATARRAY = 17;
var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
var UNIFORMTYPE_TEXTURE3D = 20;
var UNIFORMTYPE_VEC2ARRAY = 21;
var UNIFORMTYPE_VEC3ARRAY = 22;
var UNIFORMTYPE_VEC4ARRAY = 23;
var UNIFORMTYPE_MAT4ARRAY = 24;
var UNIFORMTYPE_TEXTURE2D_ARRAY = 25;
var UNIFORMTYPE_UINT = 26;
var UNIFORMTYPE_UVEC2 = 27;
var UNIFORMTYPE_UVEC3 = 28;
var UNIFORMTYPE_UVEC4 = 29;
var UNIFORMTYPE_INTARRAY = 30;
var UNIFORMTYPE_UINTARRAY = 31;
var UNIFORMTYPE_BOOLARRAY = 32;
var UNIFORMTYPE_IVEC2ARRAY = 33;
var UNIFORMTYPE_UVEC2ARRAY = 34;
var UNIFORMTYPE_BVEC2ARRAY = 35;
var UNIFORMTYPE_IVEC3ARRAY = 36;
var UNIFORMTYPE_UVEC3ARRAY = 37;
var UNIFORMTYPE_BVEC3ARRAY = 38;
var UNIFORMTYPE_IVEC4ARRAY = 39;
var UNIFORMTYPE_UVEC4ARRAY = 40;
var UNIFORMTYPE_BVEC4ARRAY = 41;
var UNIFORMTYPE_ITEXTURE2D = 42;
var UNIFORMTYPE_UTEXTURE2D = 43;
var UNIFORMTYPE_ITEXTURECUBE = 44;
var UNIFORMTYPE_UTEXTURECUBE = 45;
var UNIFORMTYPE_ITEXTURE3D = 46;
var UNIFORMTYPE_UTEXTURE3D = 47;
var UNIFORMTYPE_ITEXTURE2D_ARRAY = 48;
var UNIFORMTYPE_UTEXTURE2D_ARRAY = 49;
var uniformTypeToName = ["bool", "int", "float", "vec2", "vec3", "vec4", "ivec2", "ivec3", "ivec4", "bvec2", "bvec3", "bvec4", "mat2", "mat3", "mat4", "sampler2D", "samplerCube", "", "sampler2DShadow", "samplerCubeShadow", "sampler3D", "", "", "", "", "sampler2DArray", "uint", "uvec2", "uvec3", "uvec4", "", "", "", "", "", "", "", "", "", "", "", "", "isampler2D", "usampler2D", "isamplerCube", "usamplerCube", "isampler3D", "usampler3D", "isampler2DArray", "usampler2DArray"];
var uniformTypeToStorage = new Uint8Array([TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_INT32, TYPE_UINT32, TYPE_UINT32, TYPE_UINT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32]);
var DEVICETYPE_WEBGL2 = "webgl2";
var DEVICETYPE_WEBGPU = "webgpu";
var DEVICETYPE_NULL = "null";
var SHADERSTAGE_VERTEX = 1;
var SHADERSTAGE_FRAGMENT = 2;
var SHADERSTAGE_COMPUTE = 4;
var DISPLAYFORMAT_LDR = "ldr";
var DISPLAYFORMAT_LDR_SRGB = "ldr_srgb";
var DISPLAYFORMAT_HDR = "hdr";
var TEXPROPERTY_MIN_FILTER = 1;
var TEXPROPERTY_MAG_FILTER = 2;
var TEXPROPERTY_ADDRESS_U = 4;
var TEXPROPERTY_ADDRESS_V = 8;
var TEXPROPERTY_ADDRESS_W = 16;
var TEXPROPERTY_COMPARE_ON_READ = 32;
var TEXPROPERTY_COMPARE_FUNC = 64;
var TEXPROPERTY_ANISOTROPY = 128;
var TEXPROPERTY_ALL = 255;
var BINDGROUP_VIEW = 0;
var BINDGROUP_MESH = 1;
var BINDGROUP_MESH_UB = 2;
var bindGroupNames = ["view", "mesh", "mesh_ub"];
var UNIFORM_BUFFER_DEFAULT_SLOT_NAME = "default";
var typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Uint16Array];
var typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4, 2];
var vertexTypesNames = ["INT8", "UINT8", "INT16", "UINT16", "INT32", "UINT32", "FLOAT32", "FLOAT16"];
var typedArrayToType = {
  "Int8Array": TYPE_INT8,
  "Uint8Array": TYPE_UINT8,
  "Int16Array": TYPE_INT16,
  "Uint16Array": TYPE_UINT16,
  "Int32Array": TYPE_INT32,
  "Uint32Array": TYPE_UINT32,
  "Float32Array": TYPE_FLOAT32
};
var typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];
var typedArrayIndexFormatsByteSize = [1, 2, 4];
var semanticToLocation = {};
semanticToLocation[SEMANTIC_POSITION] = 0;
semanticToLocation[SEMANTIC_NORMAL] = 1;
semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
semanticToLocation[SEMANTIC_COLOR] = 4;
semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
semanticToLocation[SEMANTIC_TANGENT] = 13;
semanticToLocation[SEMANTIC_ATTR0] = 0;
semanticToLocation[SEMANTIC_ATTR1] = 1;
semanticToLocation[SEMANTIC_ATTR2] = 2;
semanticToLocation[SEMANTIC_ATTR3] = 3;
semanticToLocation[SEMANTIC_ATTR4] = 4;
semanticToLocation[SEMANTIC_ATTR5] = 5;
semanticToLocation[SEMANTIC_ATTR6] = 6;
semanticToLocation[SEMANTIC_ATTR7] = 7;
semanticToLocation[SEMANTIC_ATTR8] = 8;
semanticToLocation[SEMANTIC_ATTR9] = 9;
semanticToLocation[SEMANTIC_ATTR10] = 10;
semanticToLocation[SEMANTIC_ATTR11] = 11;
semanticToLocation[SEMANTIC_ATTR12] = 12;
semanticToLocation[SEMANTIC_ATTR13] = 13;
semanticToLocation[SEMANTIC_ATTR14] = 14;
semanticToLocation[SEMANTIC_ATTR15] = 15;
var CHUNKAPI_1_51 = "1.51";
var CHUNKAPI_1_55 = "1.55";
var CHUNKAPI_1_56 = "1.56";
var CHUNKAPI_1_57 = "1.57";
var CHUNKAPI_1_58 = "1.58";
var CHUNKAPI_1_60 = "1.60";
var CHUNKAPI_1_62 = "1.62";
var CHUNKAPI_1_65 = "1.65";
var CHUNKAPI_1_70 = "1.70";

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/bind-group-format.js
var id = 0;
var textureDimensionInfo = {
  [TEXTUREDIMENSION_2D]: "texture2D",
  [TEXTUREDIMENSION_CUBE]: "textureCube",
  [TEXTUREDIMENSION_3D]: "texture3D",
  [TEXTUREDIMENSION_2D_ARRAY]: "texture2DArray"
};
var BindBaseFormat = class {
  constructor(name, visibility) {
    this.slot = -1;
    this.scopeId = null;
    this.name = name;
    this.visibility = visibility;
  }
};
var BindUniformBufferFormat = class extends BindBaseFormat {
};
var BindStorageBufferFormat = class extends BindBaseFormat {
  constructor(name, visibility, readOnly = false) {
    super(name, visibility);
    this.readOnly = readOnly;
  }
};
var BindTextureFormat = class extends BindBaseFormat {
  constructor(name, visibility, textureDimension = TEXTUREDIMENSION_2D, sampleType = SAMPLETYPE_FLOAT, hasSampler = true) {
    super(name, visibility);
    this.textureDimension = textureDimension;
    this.sampleType = sampleType;
    this.hasSampler = hasSampler;
  }
};
var BindStorageTextureFormat = class extends BindBaseFormat {
  constructor(name, format = PIXELFORMAT_RGBA8, textureDimension = TEXTUREDIMENSION_2D, write = true, read = false) {
    super(name, SHADERSTAGE_COMPUTE);
    this.format = format;
    this.textureDimension = textureDimension;
    this.write = write;
    this.read = read;
  }
};
var BindGroupFormat = class {
  constructor(graphicsDevice, formats) {
    this.uniformBufferFormats = [];
    this.textureFormats = [];
    this.storageTextureFormats = [];
    this.storageBufferFormats = [];
    this.id = id++;
    let slot = 0;
    formats.forEach((format) => {
      format.slot = slot++;
      if (format instanceof BindTextureFormat && format.hasSampler) {
        slot++;
      }
      if (format instanceof BindUniformBufferFormat) {
        this.uniformBufferFormats.push(format);
      } else if (format instanceof BindTextureFormat) {
        this.textureFormats.push(format);
      } else if (format instanceof BindStorageTextureFormat) {
        this.storageTextureFormats.push(format);
      } else if (format instanceof BindStorageBufferFormat) {
        this.storageBufferFormats.push(format);
      } else ;
    });
    this.device = graphicsDevice;
    const scope = graphicsDevice.scope;
    this.bufferFormatsMap = /* @__PURE__ */ new Map();
    this.uniformBufferFormats.forEach((bf, i) => this.bufferFormatsMap.set(bf.name, i));
    this.textureFormatsMap = /* @__PURE__ */ new Map();
    this.textureFormats.forEach((tf, i) => {
      this.textureFormatsMap.set(tf.name, i);
      tf.scopeId = scope.resolve(tf.name);
    });
    this.storageTextureFormatsMap = /* @__PURE__ */ new Map();
    this.storageTextureFormats.forEach((tf, i) => {
      this.storageTextureFormatsMap.set(tf.name, i);
      tf.scopeId = scope.resolve(tf.name);
    });
    this.storageBufferFormatsMap = /* @__PURE__ */ new Map();
    this.storageBufferFormats.forEach((bf, i) => {
      this.storageBufferFormatsMap.set(bf.name, i);
      bf.scopeId = scope.resolve(bf.name);
    });
    this.impl = graphicsDevice.createBindGroupFormatImpl(this);
  }
  destroy() {
    this.impl.destroy();
  }
  getTexture(name) {
    const index = this.textureFormatsMap.get(name);
    if (index !== void 0) {
      return this.textureFormats[index];
    }
    return null;
  }
  getStorageTexture(name) {
    const index = this.storageTextureFormatsMap.get(name);
    if (index !== void 0) {
      return this.storageTextureFormats[index];
    }
    return null;
  }
  getShaderDeclarationTextures(bindGroup) {
    let code = "";
    this.textureFormats.forEach((format) => {
      let textureType = textureDimensionInfo[format.textureDimension];
      let namePostfix = "";
      let extraCode = "";
      if (textureType === "texture2DArray") {
        namePostfix = "_texture";
        extraCode = `#define ${format.name} sampler2DArray(${format.name}${namePostfix}, ${format.name}_sampler)
`;
      }
      if (format.sampleType === SAMPLETYPE_INT) {
        textureType = `i${textureType}`;
      } else if (format.sampleType === SAMPLETYPE_UINT) {
        textureType = `u${textureType}`;
      }
      code += `layout(set = ${bindGroup}, binding = ${format.slot}) uniform ${textureType} ${format.name}${namePostfix};
`;
      if (format.hasSampler) {
        code += `layout(set = ${bindGroup}, binding = ${format.slot + 1}) uniform sampler ${format.name}_sampler;
`;
      }
      code += extraCode;
    });
    return code;
  }
  loseContext() {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/bind-group.js
var id2 = 0;
var DynamicBindGroup = class {
  constructor() {
    this.bindGroup = void 0;
    this.offsets = [];
  }
};
var BindGroup = class {
  constructor(graphicsDevice, format, defaultUniformBuffer) {
    this.renderVersionUpdated = -1;
    this.uniformBuffers = void 0;
    this.uniformBufferOffsets = [];
    this.id = id2++;
    this.device = graphicsDevice;
    this.format = format;
    this.dirty = true;
    this.impl = graphicsDevice.createBindGroupImpl(this);
    this.textures = [];
    this.storageTextures = [];
    this.storageBuffers = [];
    this.uniformBuffers = [];
    this.defaultUniformBuffer = defaultUniformBuffer;
    if (defaultUniformBuffer) {
      this.setUniformBuffer(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, defaultUniformBuffer);
    }
  }
  destroy() {
    this.impl.destroy();
    this.impl = null;
    this.format = null;
    this.defaultUniformBuffer = null;
  }
  setUniformBuffer(name, uniformBuffer) {
    const index = this.format.bufferFormatsMap.get(name);
    if (this.uniformBuffers[index] !== uniformBuffer) {
      this.uniformBuffers[index] = uniformBuffer;
      this.dirty = true;
    }
  }
  setStorageBuffer(name, storageBuffer) {
    const index = this.format.storageBufferFormatsMap.get(name);
    if (this.storageBuffers[index] !== storageBuffer) {
      this.storageBuffers[index] = storageBuffer;
      this.dirty = true;
    }
  }
  setTexture(name, texture) {
    const index = this.format.textureFormatsMap.get(name);
    if (this.textures[index] !== texture) {
      this.textures[index] = texture;
      this.dirty = true;
    } else if (this.renderVersionUpdated < texture.renderVersionDirty) {
      this.dirty = true;
    }
  }
  setStorageTexture(name, texture) {
    const index = this.format.storageTextureFormatsMap.get(name);
    if (this.storageTextures[index] !== texture) {
      this.storageTextures[index] = texture;
      this.dirty = true;
    } else if (this.renderVersionUpdated < texture.renderVersionDirty) {
      this.dirty = true;
    }
  }
  updateUniformBuffers() {
    for (let i = 0; i < this.uniformBuffers.length; i++) {
      this.uniformBuffers[i].update();
    }
  }
  update() {
    const {
      textureFormats,
      storageTextureFormats,
      storageBufferFormats
    } = this.format;
    for (let i = 0; i < textureFormats.length; i++) {
      const textureFormat = textureFormats[i];
      const value = textureFormat.scopeId.value;
      this.setTexture(textureFormat.name, value);
    }
    for (let i = 0; i < storageTextureFormats.length; i++) {
      const storageTextureFormat = storageTextureFormats[i];
      const value = storageTextureFormat.scopeId.value;
      this.setStorageTexture(storageTextureFormat.name, value);
    }
    for (let i = 0; i < storageBufferFormats.length; i++) {
      const storageBufferFormat = storageBufferFormats[i];
      const value = storageBufferFormat.scopeId.value;
      this.setStorageBuffer(storageBufferFormat.name, value);
    }
    this.uniformBufferOffsets.length = this.uniformBuffers.length;
    for (let i = 0; i < this.uniformBuffers.length; i++) {
      const uniformBuffer = this.uniformBuffers[i];
      this.uniformBufferOffsets[i] = uniformBuffer.offset;
      if (this.renderVersionUpdated < uniformBuffer.renderVersionDirty) {
        this.dirty = true;
      }
    }
    if (this.dirty) {
      this.dirty = false;
      this.renderVersionUpdated = this.device.renderVersion;
      this.impl.update(this);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/_virtual/_rollupPluginBabelHelpers.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}

// ../node_modules/playcanvas/build/playcanvas/src/core/math/bit-packing.js
var BitPacking = {
  set(storage, value, shift, mask = 1) {
    const data2 = storage & ~(mask << shift);
    return data2 | value << shift;
  },
  get(storage, shift, mask = 1) {
    return storage >> shift & mask;
  },
  all(storage, shift, mask = 1) {
    const shifted = mask << shift;
    return (storage & shifted) === shifted;
  },
  any(storage, shift, mask = 1) {
    return (storage & mask << shift) !== 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/blend-state.js
var _BlendState;
var opMask = 7;
var factorMask = 15;
var colorOpShift = 0;
var colorSrcFactorShift = 3;
var colorDstFactorShift = 7;
var alphaOpShift = 11;
var alphaSrcFactorShift = 14;
var alphaDstFactorShift = 18;
var redWriteShift = 22;
var greenWriteShift = 23;
var blueWriteShift = 24;
var alphaWriteShift = 25;
var blendShift = 26;
var allWriteMasks = 15;
var allWriteShift = redWriteShift;
var BlendState = class {
  constructor(blend = false, colorOp = BLENDEQUATION_ADD, colorSrcFactor = BLENDMODE_ONE, colorDstFactor = BLENDMODE_ZERO, alphaOp, alphaSrcFactor, alphaDstFactor, redWrite = true, greenWrite = true, blueWrite = true, alphaWrite = true) {
    this.target0 = 0;
    this.setColorBlend(colorOp, colorSrcFactor, colorDstFactor);
    this.setAlphaBlend(alphaOp != null ? alphaOp : colorOp, alphaSrcFactor != null ? alphaSrcFactor : colorSrcFactor, alphaDstFactor != null ? alphaDstFactor : colorDstFactor);
    this.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);
    this.blend = blend;
  }
  set blend(value) {
    this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blendShift);
  }
  get blend() {
    return BitPacking.all(this.target0, blendShift);
  }
  setColorBlend(op, srcFactor, dstFactor) {
    this.target0 = BitPacking.set(this.target0, op, colorOpShift, opMask);
    this.target0 = BitPacking.set(this.target0, srcFactor, colorSrcFactorShift, factorMask);
    this.target0 = BitPacking.set(this.target0, dstFactor, colorDstFactorShift, factorMask);
  }
  setAlphaBlend(op, srcFactor, dstFactor) {
    this.target0 = BitPacking.set(this.target0, op, alphaOpShift, opMask);
    this.target0 = BitPacking.set(this.target0, srcFactor, alphaSrcFactorShift, factorMask);
    this.target0 = BitPacking.set(this.target0, dstFactor, alphaDstFactorShift, factorMask);
  }
  setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite) {
    this.redWrite = redWrite;
    this.greenWrite = greenWrite;
    this.blueWrite = blueWrite;
    this.alphaWrite = alphaWrite;
  }
  get colorOp() {
    return BitPacking.get(this.target0, colorOpShift, opMask);
  }
  get colorSrcFactor() {
    return BitPacking.get(this.target0, colorSrcFactorShift, factorMask);
  }
  get colorDstFactor() {
    return BitPacking.get(this.target0, colorDstFactorShift, factorMask);
  }
  get alphaOp() {
    return BitPacking.get(this.target0, alphaOpShift, opMask);
  }
  get alphaSrcFactor() {
    return BitPacking.get(this.target0, alphaSrcFactorShift, factorMask);
  }
  get alphaDstFactor() {
    return BitPacking.get(this.target0, alphaDstFactorShift, factorMask);
  }
  set redWrite(value) {
    this.target0 = BitPacking.set(this.target0, value ? 1 : 0, redWriteShift);
  }
  get redWrite() {
    return BitPacking.all(this.target0, redWriteShift);
  }
  set greenWrite(value) {
    this.target0 = BitPacking.set(this.target0, value ? 1 : 0, greenWriteShift);
  }
  get greenWrite() {
    return BitPacking.all(this.target0, greenWriteShift);
  }
  set blueWrite(value) {
    this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blueWriteShift);
  }
  get blueWrite() {
    return BitPacking.all(this.target0, blueWriteShift);
  }
  set alphaWrite(value) {
    this.target0 = BitPacking.set(this.target0, value ? 1 : 0, alphaWriteShift);
  }
  get alphaWrite() {
    return BitPacking.all(this.target0, alphaWriteShift);
  }
  get allWrite() {
    return BitPacking.get(this.target0, allWriteShift, allWriteMasks);
  }
  copy(rhs) {
    this.target0 = rhs.target0;
    return this;
  }
  clone() {
    const clone = new this.constructor();
    return clone.copy(this);
  }
  get key() {
    return this.target0;
  }
  equals(rhs) {
    return this.target0 === rhs.target0;
  }
};
_BlendState = BlendState;
BlendState.NOBLEND = Object.freeze(new _BlendState());
BlendState.NOWRITE = Object.freeze(new _BlendState(void 0, void 0, void 0, void 0, void 0, void 0, void 0, false, false, false, false));
BlendState.ALPHABLEND = Object.freeze(new _BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA));
BlendState.ADDBLEND = Object.freeze(new _BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE));

// ../node_modules/playcanvas/build/playcanvas/src/core/string-ids.js
var StringIds = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
    this.id = 0;
  }
  get(name) {
    let value = this.map.get(name);
    if (value === void 0) {
      value = this.id++;
      this.map.set(name, value);
    }
    return value;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/depth-state.js
var _DepthState;
var stringIds = new StringIds();
var funcMask = 7;
var funcShift = 0;
var writeShift = 3;
var DepthState = class {
  constructor(func = FUNC_LESSEQUAL, write = true) {
    this.data = 0;
    this._depthBias = 0;
    this._depthBiasSlope = 0;
    this.key = 0;
    this.func = func;
    this.write = write;
  }
  set test(value) {
    this.func = value ? FUNC_LESSEQUAL : FUNC_ALWAYS;
    this.updateKey();
  }
  get test() {
    return this.func !== FUNC_ALWAYS;
  }
  set write(value) {
    this.data = BitPacking.set(this.data, value ? 1 : 0, writeShift);
    this.updateKey();
  }
  get write() {
    return BitPacking.all(this.data, writeShift);
  }
  set func(value) {
    this.data = BitPacking.set(this.data, value, funcShift, funcMask);
    this.updateKey();
  }
  get func() {
    return BitPacking.get(this.data, funcShift, funcMask);
  }
  set depthBias(value) {
    this._depthBias = value;
    this.updateKey();
  }
  get depthBias() {
    return this._depthBias;
  }
  set depthBiasSlope(value) {
    this._depthBiasSlope = value;
    this.updateKey();
  }
  get depthBiasSlope() {
    return this._depthBiasSlope;
  }
  copy(rhs) {
    this.data = rhs.data;
    this._depthBias = rhs._depthBias;
    this._depthBiasSlope = rhs._depthBiasSlope;
    this.key = rhs.key;
    return this;
  }
  clone() {
    const clone = new this.constructor();
    return clone.copy(this);
  }
  updateKey() {
    const {
      data: data2,
      _depthBias,
      _depthBiasSlope
    } = this;
    const key = `${data2}-${_depthBias}-${_depthBiasSlope}`;
    this.key = stringIds.get(key);
  }
  equals(rhs) {
    return this.key === rhs.key;
  }
};
_DepthState = DepthState;
DepthState.DEFAULT = Object.freeze(new _DepthState());
DepthState.NODEPTH = Object.freeze(new _DepthState(FUNC_ALWAYS, false));
DepthState.WRITEDEPTH = Object.freeze(new _DepthState(FUNC_ALWAYS, true));

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/version.js
var Version = class {
  constructor() {
    this.globalId = 0;
    this.revision = 0;
  }
  equals(other) {
    return this.globalId === other.globalId && this.revision === other.revision;
  }
  copy(other) {
    this.globalId = other.globalId;
    this.revision = other.revision;
  }
  reset() {
    this.globalId = 0;
    this.revision = 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/versioned-object.js
var idCounter = 0;
var VersionedObject = class {
  constructor() {
    idCounter++;
    this.version = new Version();
    this.version.globalId = idCounter;
  }
  increment() {
    this.version.revision++;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/scope-id.js
var ScopeId = class {
  constructor(name) {
    this.name = name;
    this.value = null;
    this.versionObject = new VersionedObject();
  }
  toJSON(key) {
    return void 0;
  }
  setValue(value) {
    this.value = value;
    this.versionObject.increment();
  }
  getValue() {
    return this.value;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/scope-space.js
var ScopeSpace = class {
  constructor(name) {
    this.name = name;
    this.variables = /* @__PURE__ */ new Map();
  }
  resolve(name) {
    if (!this.variables.has(name)) {
      this.variables.set(name, new ScopeId(name));
    }
    return this.variables.get(name);
  }
  removeValue(value) {
    for (const uniformName in this.variables) {
      const uniform = this.variables[uniformName];
      if (uniform.value === value) {
        uniform.value = null;
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/vertex-buffer.js
var id3 = 0;
var VertexBuffer = class {
  constructor(graphicsDevice, format, numVertices, options2) {
    var _options$usage;
    this.usage = BUFFER_STATIC;
    this.usage = (_options$usage = options2 == null ? void 0 : options2.usage) != null ? _options$usage : BUFFER_STATIC;
    this.device = graphicsDevice;
    this.format = format;
    this.numVertices = numVertices;
    this.id = id3++;
    this.impl = graphicsDevice.createVertexBufferImpl(this, format, options2);
    this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
    this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
    const initialData = options2 == null ? void 0 : options2.data;
    if (initialData) {
      this.setData(initialData);
    } else {
      this.storage = new ArrayBuffer(this.numBytes);
    }
    this.device.buffers.push(this);
  }
  destroy() {
    const device = this.device;
    const idx = device.buffers.indexOf(this);
    if (idx !== -1) {
      device.buffers.splice(idx, 1);
    }
    if (this.impl.initialized) {
      this.impl.destroy(device);
      this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
    }
  }
  adjustVramSizeTracking(vram, size) {
    vram.vb += size;
  }
  loseContext() {
    this.impl.loseContext();
  }
  getFormat() {
    return this.format;
  }
  getUsage() {
    return this.usage;
  }
  getNumVertices() {
    return this.numVertices;
  }
  lock() {
    return this.storage;
  }
  unlock() {
    this.impl.unlock(this);
  }
  setData(data2) {
    if (data2.byteLength !== this.numBytes) {
      return false;
    }
    this.storage = data2;
    this.unlock();
    return true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/hash.js
function hashCode(str) {
  let hash = 0;
  for (let i = 0, len = str.length; i < len; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash |= 0;
  }
  return hash;
}
function hash32Fnv1a(array2) {
  const prime = 16777619;
  let hash = 2166136261;
  for (let i = 0; i < array2.length; i++) {
    hash ^= array2[i];
    hash *= prime;
  }
  return hash >>> 0;
}

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/device-cache.js
var DeviceCache = class {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  get(device, onCreate) {
    if (!this._cache.has(device)) {
      this._cache.set(device, onCreate());
      device.on("destroy", () => {
        this.remove(device);
      });
      device.on("devicelost", () => {
        var _this$_cache$get;
        (_this$_cache$get = this._cache.get(device)) == null || _this$_cache$get.loseContext == null || _this$_cache$get.loseContext(device);
      });
    }
    return this._cache.get(device);
  }
  remove(device) {
    var _this$_cache$get2;
    (_this$_cache$get2 = this._cache.get(device)) == null || _this$_cache$get2.destroy == null || _this$_cache$get2.destroy(device);
    this._cache.delete(device);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/vertex-format.js
var stringIds2 = new StringIds();
var webgpuValidElementSizes = [2, 4, 8, 12, 16];
var deviceCache = new DeviceCache();
var VertexFormat = class _VertexFormat {
  constructor(graphicsDevice, description, vertexCount) {
    this.device = graphicsDevice;
    this._elements = [];
    this.hasUv0 = false;
    this.hasUv1 = false;
    this.hasColor = false;
    this.hasTangents = false;
    this.verticesByteSize = 0;
    this.vertexCount = vertexCount;
    this.interleaved = vertexCount === void 0;
    this.instancing = false;
    this.size = description.reduce((total, desc) => {
      return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
    }, 0);
    let offset = 0, elementSize;
    for (let i = 0, len = description.length; i < len; i++) {
      var _elementDesc$asInt, _elementDesc$normaliz;
      const elementDesc = description[i];
      elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
      if (vertexCount) {
        offset = math.roundUp(offset, elementSize);
      }
      const asInt = (_elementDesc$asInt = elementDesc.asInt) != null ? _elementDesc$asInt : false;
      const normalize = asInt ? false : (_elementDesc$normaliz = elementDesc.normalize) != null ? _elementDesc$normaliz : false;
      const element = {
        name: elementDesc.semantic,
        offset: vertexCount ? offset : elementDesc.hasOwnProperty("offset") ? elementDesc.offset : offset,
        stride: vertexCount ? elementSize : elementDesc.hasOwnProperty("stride") ? elementDesc.stride : this.size,
        dataType: elementDesc.type,
        numComponents: elementDesc.components,
        normalize,
        size: elementSize,
        asInt
      };
      this._elements.push(element);
      if (vertexCount) {
        offset += elementSize * vertexCount;
      } else {
        offset += Math.ceil(elementSize / 4) * 4;
      }
      if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
        this.hasUv0 = true;
      } else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
        this.hasUv1 = true;
      } else if (elementDesc.semantic === SEMANTIC_COLOR) {
        this.hasColor = true;
      } else if (elementDesc.semantic === SEMANTIC_TANGENT) {
        this.hasTangents = true;
      }
    }
    if (vertexCount) {
      this.verticesByteSize = offset;
    }
    this._evaluateHash();
  }
  get elements() {
    return this._elements;
  }
  static getDefaultInstancingFormat(graphicsDevice) {
    return deviceCache.get(graphicsDevice, () => {
      return new _VertexFormat(graphicsDevice, [{
        semantic: SEMANTIC_ATTR12,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR13,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR14,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR15,
        components: 4,
        type: TYPE_FLOAT32
      }]);
    });
  }
  static isElementValid(graphicsDevice, elementDesc) {
    const elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
    if (graphicsDevice.isWebGPU && !webgpuValidElementSizes.includes(elementSize)) {
      return false;
    }
    return true;
  }
  update() {
    this._evaluateHash();
  }
  _evaluateHash() {
    const stringElementsBatch = [];
    const stringElementsRender = [];
    const len = this._elements.length;
    for (let i = 0; i < len; i++) {
      const {
        name,
        dataType,
        numComponents,
        normalize,
        offset,
        stride,
        size,
        asInt
      } = this._elements[i];
      const stringElementBatch = name + dataType + numComponents + normalize + asInt;
      stringElementsBatch.push(stringElementBatch);
      const stringElementRender = stringElementBatch + offset + stride + size;
      stringElementsRender.push(stringElementRender);
    }
    stringElementsBatch.sort();
    const batchingString = stringElementsBatch.join();
    this.batchingHash = hashCode(batchingString);
    this.shaderProcessingHashString = batchingString;
    this.renderingHashString = stringElementsRender.join("_");
    this.renderingHash = stringIds2.get(this.renderingHashString);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/stencil-parameters.js
var _StencilParameters;
var stringIds3 = new StringIds();
var StencilParameters = class {
  set func(value) {
    this._func = value;
    this._dirty = true;
  }
  get func() {
    return this._func;
  }
  set ref(value) {
    this._ref = value;
    this._dirty = true;
  }
  get ref() {
    return this._ref;
  }
  set fail(value) {
    this._fail = value;
    this._dirty = true;
  }
  get fail() {
    return this._fail;
  }
  set zfail(value) {
    this._zfail = value;
    this._dirty = true;
  }
  get zfail() {
    return this._zfail;
  }
  set zpass(value) {
    this._zpass = value;
    this._dirty = true;
  }
  get zpass() {
    return this._zpass;
  }
  set readMask(value) {
    this._readMask = value;
    this._dirty = true;
  }
  get readMask() {
    return this._readMask;
  }
  set writeMask(value) {
    this._writeMask = value;
    this._dirty = true;
  }
  get writeMask() {
    return this._writeMask;
  }
  constructor(options2 = {}) {
    var _options$func, _options$ref, _options$readMask, _options$writeMask, _options$fail, _options$zfail, _options$zpass;
    this._func = void 0;
    this._ref = void 0;
    this._fail = void 0;
    this._zfail = void 0;
    this._zpass = void 0;
    this._readMask = void 0;
    this._writeMask = void 0;
    this._dirty = true;
    this._key = void 0;
    this._func = (_options$func = options2.func) != null ? _options$func : FUNC_ALWAYS;
    this._ref = (_options$ref = options2.ref) != null ? _options$ref : 0;
    this._readMask = (_options$readMask = options2.readMask) != null ? _options$readMask : 255;
    this._writeMask = (_options$writeMask = options2.writeMask) != null ? _options$writeMask : 255;
    this._fail = (_options$fail = options2.fail) != null ? _options$fail : STENCILOP_KEEP;
    this._zfail = (_options$zfail = options2.zfail) != null ? _options$zfail : STENCILOP_KEEP;
    this._zpass = (_options$zpass = options2.zpass) != null ? _options$zpass : STENCILOP_KEEP;
    this._evalKey();
  }
  _evalKey() {
    const {
      _func,
      _ref: _ref4,
      _fail,
      _zfail,
      _zpass,
      _readMask,
      _writeMask
    } = this;
    const key = `${_func},${_ref4},${_fail},${_zfail},${_zpass},${_readMask},${_writeMask}`;
    this._key = stringIds3.get(key);
    this._dirty = false;
  }
  get key() {
    if (this._dirty) {
      this._evalKey();
    }
    return this._key;
  }
  copy(rhs) {
    this._func = rhs._func;
    this._ref = rhs._ref;
    this._readMask = rhs._readMask;
    this._writeMask = rhs._writeMask;
    this._fail = rhs._fail;
    this._zfail = rhs._zfail;
    this._zpass = rhs._zpass;
    this._dirty = rhs._dirty;
    this._key = rhs._key;
    return this;
  }
  clone() {
    const clone = new this.constructor();
    return clone.copy(this);
  }
};
_StencilParameters = StencilParameters;
StencilParameters.DEFAULT = Object.freeze(new _StencilParameters());

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/graphics-device.js
var GraphicsDevice = class _GraphicsDevice extends EventHandler {
  constructor(canvas, options2) {
    var _this$initOptions, _this$initOptions$alp, _this$initOptions2, _this$initOptions2$de, _this$initOptions3, _this$initOptions3$st, _this$initOptions4, _this$initOptions4$an, _this$initOptions5, _this$initOptions5$po, _this$initOptions6, _this$initOptions6$di;
    super();
    this.canvas = void 0;
    this.backBuffer = null;
    this.backBufferSize = new Vec2();
    this.backBufferFormat = void 0;
    this.backBufferAntialias = false;
    this.isWebGPU = false;
    this.isWebGL2 = false;
    this.scope = void 0;
    this.maxAnisotropy = void 0;
    this.maxCubeMapSize = void 0;
    this.maxTextureSize = void 0;
    this.maxVolumeSize = void 0;
    this.maxColorAttachments = 1;
    this.precision = void 0;
    this.samples = void 0;
    this.supportsStencil = void 0;
    this.supportsCompute = false;
    this.supportsStorageTextureRead = false;
    this.renderTarget = null;
    this.shaders = [];
    this.textures = [];
    this.targets = /* @__PURE__ */ new Set();
    this.renderVersion = 0;
    this.renderPassIndex = void 0;
    this.insideRenderPass = false;
    this.supportsUniformBuffers = false;
    this.textureFloatRenderable = void 0;
    this.textureHalfFloatRenderable = void 0;
    this.textureRG11B10Renderable = false;
    this.textureFloatFilterable = false;
    this.quadVertexBuffer = void 0;
    this.blendState = new BlendState();
    this.depthState = new DepthState();
    this.stencilEnabled = false;
    this.stencilFront = new StencilParameters();
    this.stencilBack = new StencilParameters();
    this.dynamicBuffers = void 0;
    this.gpuProfiler = void 0;
    this.defaultClearOptions = {
      color: [0, 0, 0, 1],
      depth: 1,
      stencil: 0,
      flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
    };
    this.clientRect = {
      width: 0,
      height: 0
    };
    this.canvas = canvas;
    this.initOptions = _extends({}, options2);
    (_this$initOptions$alp = (_this$initOptions = this.initOptions).alpha) != null ? _this$initOptions$alp : _this$initOptions.alpha = true;
    (_this$initOptions2$de = (_this$initOptions2 = this.initOptions).depth) != null ? _this$initOptions2$de : _this$initOptions2.depth = true;
    (_this$initOptions3$st = (_this$initOptions3 = this.initOptions).stencil) != null ? _this$initOptions3$st : _this$initOptions3.stencil = true;
    (_this$initOptions4$an = (_this$initOptions4 = this.initOptions).antialias) != null ? _this$initOptions4$an : _this$initOptions4.antialias = true;
    (_this$initOptions5$po = (_this$initOptions5 = this.initOptions).powerPreference) != null ? _this$initOptions5$po : _this$initOptions5.powerPreference = "high-performance";
    (_this$initOptions6$di = (_this$initOptions6 = this.initOptions).displayFormat) != null ? _this$initOptions6$di : _this$initOptions6.displayFormat = DISPLAYFORMAT_LDR;
    this._maxPixelRatio = platform.browser ? Math.min(1, window.devicePixelRatio) : 1;
    this.buffers = [];
    this._vram = {
      tex: 0,
      vb: 0,
      ib: 0,
      ub: 0,
      sb: 0
    };
    this._shaderStats = {
      vsCompiled: 0,
      fsCompiled: 0,
      linked: 0,
      materialShaders: 0,
      compileTime: 0
    };
    this.initializeContextCaches();
    this._drawCallsPerFrame = 0;
    this._shaderSwitchesPerFrame = 0;
    this._primsPerFrame = [];
    for (let i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {
      this._primsPerFrame[i] = 0;
    }
    this._renderTargetCreationTime = 0;
    this.scope = new ScopeSpace("Device");
    this.textureBias = this.scope.resolve("textureBias");
    this.textureBias.setValue(0);
  }
  postInit() {
    const vertexFormat = new VertexFormat(this, [{
      semantic: SEMANTIC_POSITION,
      components: 2,
      type: TYPE_FLOAT32
    }]);
    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    this.quadVertexBuffer = new VertexBuffer(this, vertexFormat, 4, {
      data: positions
    });
  }
  destroy() {
    var _this$quadVertexBuffe, _this$dynamicBuffers, _this$gpuProfiler;
    this.fire("destroy");
    (_this$quadVertexBuffe = this.quadVertexBuffer) == null || _this$quadVertexBuffe.destroy();
    this.quadVertexBuffer = null;
    (_this$dynamicBuffers = this.dynamicBuffers) == null || _this$dynamicBuffers.destroy();
    this.dynamicBuffers = null;
    (_this$gpuProfiler = this.gpuProfiler) == null || _this$gpuProfiler.destroy();
    this.gpuProfiler = null;
  }
  onDestroyShader(shader) {
    this.fire("destroy:shader", shader);
    const idx = this.shaders.indexOf(shader);
    if (idx !== -1) {
      this.shaders.splice(idx, 1);
    }
  }
  postDestroy() {
    this.scope = null;
    this.canvas = null;
  }
  loseContext() {
    var _this$gpuProfiler2;
    this.contextLost = true;
    this.backBufferSize.set(-1, -1);
    for (const texture of this.textures) {
      texture.loseContext();
    }
    for (const buffer of this.buffers) {
      buffer.loseContext();
    }
    for (const target2 of this.targets) {
      target2.loseContext();
    }
    (_this$gpuProfiler2 = this.gpuProfiler) == null || _this$gpuProfiler2.loseContext();
  }
  restoreContext() {
    var _this$gpuProfiler3;
    this.contextLost = false;
    this.initializeRenderState();
    this.initializeContextCaches();
    for (const buffer of this.buffers) {
      buffer.unlock();
    }
    (_this$gpuProfiler3 = this.gpuProfiler) == null || _this$gpuProfiler3.restoreContext == null || _this$gpuProfiler3.restoreContext();
  }
  toJSON(key) {
    return void 0;
  }
  initializeContextCaches() {
    this.indexBuffer = null;
    this.vertexBuffers = [];
    this.shader = null;
    this.shaderValid = void 0;
    this.shaderAsyncCompile = false;
    this.renderTarget = null;
  }
  initializeRenderState() {
    this.blendState = new BlendState();
    this.depthState = new DepthState();
    this.cullMode = CULLFACE_BACK;
    this.vx = this.vy = this.vw = this.vh = 0;
    this.sx = this.sy = this.sw = this.sh = 0;
    this.blendColor = new Color(0, 0, 0, 0);
  }
  setStencilState(stencilFront, stencilBack) {
  }
  setBlendState(blendState) {
  }
  setBlendColor(r, g, b, a) {
  }
  setDepthState(depthState) {
  }
  setCullMode(cullMode) {
  }
  setRenderTarget(renderTarget) {
    this.renderTarget = renderTarget;
  }
  setIndexBuffer(indexBuffer) {
    this.indexBuffer = indexBuffer;
  }
  setVertexBuffer(vertexBuffer) {
    if (vertexBuffer) {
      this.vertexBuffers.push(vertexBuffer);
    }
  }
  clearVertexBuffer() {
    this.vertexBuffers.length = 0;
  }
  getRenderTarget() {
    return this.renderTarget;
  }
  initRenderTarget(target2) {
    if (target2.initialized) return;
    target2.init();
    this.targets.add(target2);
  }
  _isBrowserInterface(texture) {
    return this._isImageBrowserInterface(texture) || this._isImageCanvasInterface(texture) || this._isImageVideoInterface(texture);
  }
  _isImageBrowserInterface(texture) {
    return typeof ImageBitmap !== "undefined" && texture instanceof ImageBitmap || typeof HTMLImageElement !== "undefined" && texture instanceof HTMLImageElement;
  }
  _isImageCanvasInterface(texture) {
    return typeof HTMLCanvasElement !== "undefined" && texture instanceof HTMLCanvasElement;
  }
  _isImageVideoInterface(texture) {
    return typeof HTMLVideoElement !== "undefined" && texture instanceof HTMLVideoElement;
  }
  resizeCanvas(width, height) {
    const pixelRatio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);
    const w = Math.floor(width * pixelRatio);
    const h2 = Math.floor(height * pixelRatio);
    if (w !== this.canvas.width || h2 !== this.canvas.height) {
      this.setResolution(w, h2);
    }
  }
  setResolution(width, height) {
    this.canvas.width = width;
    this.canvas.height = height;
    this.fire(_GraphicsDevice.EVENT_RESIZE, width, height);
  }
  updateClientRect() {
    if (platform.worker) {
      this.clientRect.width = this.canvas.width;
      this.clientRect.height = this.canvas.height;
    } else {
      const rect = this.canvas.getBoundingClientRect();
      this.clientRect.width = rect.width;
      this.clientRect.height = rect.height;
    }
  }
  get width() {
    return this.canvas.width;
  }
  get height() {
    return this.canvas.height;
  }
  set fullscreen(fullscreen) {
  }
  get fullscreen() {
    return false;
  }
  set maxPixelRatio(ratio) {
    this._maxPixelRatio = ratio;
  }
  get maxPixelRatio() {
    return this._maxPixelRatio;
  }
  get deviceType() {
    return this._deviceType;
  }
  startRenderPass(renderPass) {
  }
  endRenderPass(renderPass) {
  }
  startComputePass() {
  }
  endComputePass() {
  }
  frameStart() {
    this.renderPassIndex = 0;
    this.renderVersion++;
  }
  frameEnd() {
  }
  computeDispatch(computes) {
  }
  getRenderableHdrFormat(formats = [PIXELFORMAT_111110F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F], filterable = true) {
    for (let i = 0; i < formats.length; i++) {
      const format = formats[i];
      switch (format) {
        case PIXELFORMAT_111110F: {
          if (this.textureRG11B10Renderable) {
            return format;
          }
          break;
        }
        case PIXELFORMAT_RGBA16F:
          if (this.textureHalfFloatRenderable) {
            return format;
          }
          break;
        case PIXELFORMAT_RGBA32F:
          if (this.textureFloatRenderable && (!filterable || this.textureFloatFilterable)) {
            return format;
          }
          break;
      }
    }
    return void 0;
  }
};
GraphicsDevice.EVENT_RESIZE = "resizecanvas";

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/render-target.js
var id4 = 0;
var RenderTarget = class {
  constructor(options2 = {}) {
    var _options$face, _this$_colorBuffer, _this$_depthBuffer, _options$samples, _options$autoResolve, _options$flipY;
    this.name = void 0;
    this._device = void 0;
    this._colorBuffer = void 0;
    this._colorBuffers = void 0;
    this._depthBuffer = void 0;
    this._depth = void 0;
    this._stencil = void 0;
    this._samples = void 0;
    this.autoResolve = void 0;
    this._face = void 0;
    this.flipY = void 0;
    this.id = id4++;
    this._colorBuffer = options2.colorBuffer;
    if (options2.colorBuffer) {
      this._colorBuffers = [options2.colorBuffer];
    }
    this._depthBuffer = options2.depthBuffer;
    this._face = (_options$face = options2.face) != null ? _options$face : 0;
    if (this._depthBuffer) {
      const format = this._depthBuffer._format;
      if (format === PIXELFORMAT_DEPTH) {
        this._depth = true;
        this._stencil = false;
      } else if (format === PIXELFORMAT_DEPTHSTENCIL) {
        this._depth = true;
        this._stencil = true;
      } else {
        this._depth = false;
        this._stencil = false;
      }
    } else {
      var _options$depth, _options$stencil;
      this._depth = (_options$depth = options2.depth) != null ? _options$depth : true;
      this._stencil = (_options$stencil = options2.stencil) != null ? _options$stencil : false;
    }
    if (options2.colorBuffers) {
      if (!this._colorBuffers) {
        this._colorBuffers = [...options2.colorBuffers];
        this._colorBuffer = options2.colorBuffers[0];
      }
    }
    const device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device) || options2.graphicsDevice;
    this._device = device;
    const {
      maxSamples
    } = this._device;
    this._samples = Math.min((_options$samples = options2.samples) != null ? _options$samples : 1, maxSamples);
    if (device.isWebGPU) {
      this._samples = this._samples > 1 ? maxSamples : 1;
    }
    this.autoResolve = (_options$autoResolve = options2.autoResolve) != null ? _options$autoResolve : true;
    this.name = options2.name;
    if (!this.name) {
      var _this$_colorBuffer2;
      this.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;
    }
    if (!this.name) {
      var _this$_depthBuffer2;
      this.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;
    }
    if (!this.name) {
      this.name = "Untitled";
    }
    this.flipY = (_options$flipY = options2.flipY) != null ? _options$flipY : false;
    this.validateMrt();
    this.impl = device.createRenderTargetImpl(this);
  }
  destroy() {
    const device = this._device;
    if (device) {
      device.targets.delete(this);
      if (device.renderTarget === this) {
        device.setRenderTarget(null);
      }
      this.destroyFrameBuffers();
    }
  }
  destroyFrameBuffers() {
    const device = this._device;
    if (device) {
      this.impl.destroy(device);
    }
  }
  destroyTextureBuffers() {
    var _this$_depthBuffer3, _this$_colorBuffers;
    (_this$_depthBuffer3 = this._depthBuffer) == null || _this$_depthBuffer3.destroy();
    this._depthBuffer = null;
    (_this$_colorBuffers = this._colorBuffers) == null || _this$_colorBuffers.forEach((colorBuffer) => {
      colorBuffer.destroy();
    });
    this._colorBuffers = null;
    this._colorBuffer = null;
  }
  resize(width, height) {
    if (this.width !== width || this.height !== height) {
      var _this$_depthBuffer4, _this$_colorBuffers2;
      const device = this._device;
      this.destroyFrameBuffers();
      if (device.renderTarget === this) {
        device.setRenderTarget(null);
      }
      (_this$_depthBuffer4 = this._depthBuffer) == null || _this$_depthBuffer4.resize(width, height);
      (_this$_colorBuffers2 = this._colorBuffers) == null || _this$_colorBuffers2.forEach((colorBuffer) => {
        colorBuffer.resize(width, height);
      });
      this.validateMrt();
      this.impl = device.createRenderTargetImpl(this);
    }
  }
  validateMrt() {
  }
  init() {
    this.impl.init(this._device, this);
  }
  get initialized() {
    return this.impl.initialized;
  }
  get device() {
    return this._device;
  }
  loseContext() {
    this.impl.loseContext();
  }
  resolve(color = true, depth = !!this._depthBuffer) {
    if (this._device && this._samples > 1) {
      this.impl.resolve(this._device, this, color, depth);
    }
  }
  copy(source, color, depth) {
    if (!this._device) {
      if (source._device) {
        this._device = source._device;
      } else {
        return false;
      }
    }
    const success = this._device.copyRenderTarget(source, this, color, depth);
    return success;
  }
  get samples() {
    return this._samples;
  }
  get depth() {
    return this._depth;
  }
  get stencil() {
    return this._stencil;
  }
  get colorBuffer() {
    return this._colorBuffer;
  }
  getColorBuffer(index) {
    var _this$_colorBuffers3;
    return (_this$_colorBuffers3 = this._colorBuffers) == null ? void 0 : _this$_colorBuffers3[index];
  }
  get depthBuffer() {
    return this._depthBuffer;
  }
  get face() {
    return this._face;
  }
  get width() {
    var _this$_colorBuffer3, _this$_depthBuffer5;
    return ((_this$_colorBuffer3 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer3.width) || ((_this$_depthBuffer5 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer5.width) || this._device.width;
  }
  get height() {
    var _this$_colorBuffer4, _this$_depthBuffer6;
    return ((_this$_colorBuffer4 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer4.height) || ((_this$_depthBuffer6 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer6.height) || this._device.height;
  }
  isColorBufferSrgb(index = 0) {
    if (this.device.backBuffer === this) {
      return isSrgbPixelFormat(this.device.backBufferFormat);
    }
    const colorBuffer = this.getColorBuffer(index);
    return colorBuffer ? isSrgbPixelFormat(colorBuffer.format) : false;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-bind-group.js
var WebgpuBindGroup = class {
  constructor() {
    this.bindGroup = void 0;
  }
  update(bindGroup) {
    this.destroy();
    const device = bindGroup.device;
    const desc = this.createDescriptor(device, bindGroup);
    this.bindGroup = device.wgpu.createBindGroup(desc);
  }
  destroy() {
    this.bindGroup = null;
  }
  createDescriptor(device, bindGroup) {
    const entries = [];
    const format = bindGroup.format;
    const uniformBufferFormats = bindGroup.format.uniformBufferFormats;
    bindGroup.uniformBuffers.forEach((ub, i) => {
      const slot = uniformBufferFormats[i].slot;
      const buffer = ub.persistent ? ub.impl.buffer : ub.allocation.gpuBuffer.buffer;
      entries.push({
        binding: slot,
        resource: {
          buffer,
          offset: 0,
          size: ub.format.byteSize
        }
      });
    });
    const textureFormats = bindGroup.format.textureFormats;
    bindGroup.textures.forEach((tex, textureIndex) => {
      const wgpuTexture = tex.impl;
      const textureFormat = format.textureFormats[textureIndex];
      const slot = textureFormats[textureIndex].slot;
      const view = wgpuTexture.getView(device);
      entries.push({
        binding: slot,
        resource: view
      });
      if (textureFormat.hasSampler) {
        const sampler = wgpuTexture.getSampler(device, textureFormat.sampleType);
        entries.push({
          binding: slot + 1,
          resource: sampler
        });
      }
    });
    const storageTextureFormats = bindGroup.format.storageTextureFormats;
    bindGroup.storageTextures.forEach((tex, textureIndex) => {
      const wgpuTexture = tex.impl;
      const slot = storageTextureFormats[textureIndex].slot;
      const view = wgpuTexture.getView(device);
      entries.push({
        binding: slot,
        resource: view
      });
    });
    const storageBufferFormats = bindGroup.format.storageBufferFormats;
    bindGroup.storageBuffers.forEach((buffer, bufferIndex) => {
      const wgpuBuffer = buffer.impl.buffer;
      const slot = storageBufferFormats[bufferIndex].slot;
      entries.push({
        binding: slot,
        resource: {
          buffer: wgpuBuffer
        }
      });
    });
    const desc = {
      layout: bindGroup.format.impl.bindGroupLayout,
      entries
    };
    return desc;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-utils.js
var WebgpuUtils = class {
  static shaderStage(stage) {
    let ret = 0;
    if (stage & SHADERSTAGE_VERTEX) ret |= GPUShaderStage.VERTEX;
    if (stage & SHADERSTAGE_FRAGMENT) ret |= GPUShaderStage.FRAGMENT;
    if (stage & SHADERSTAGE_COMPUTE) ret |= GPUShaderStage.COMPUTE;
    return ret;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/constants.js
var gpuTextureFormats = [];
gpuTextureFormats[PIXELFORMAT_A8] = "";
gpuTextureFormats[PIXELFORMAT_L8] = "";
gpuTextureFormats[PIXELFORMAT_LA8] = "";
gpuTextureFormats[PIXELFORMAT_R8] = "r8unorm";
gpuTextureFormats[PIXELFORMAT_RG8] = "rg8unorm";
gpuTextureFormats[PIXELFORMAT_RGB565] = "";
gpuTextureFormats[PIXELFORMAT_RGBA5551] = "";
gpuTextureFormats[PIXELFORMAT_RGBA4] = "";
gpuTextureFormats[PIXELFORMAT_RGB8] = "rgba8unorm";
gpuTextureFormats[PIXELFORMAT_RGBA8] = "rgba8unorm";
gpuTextureFormats[PIXELFORMAT_DXT1] = "bc1-rgba-unorm";
gpuTextureFormats[PIXELFORMAT_DXT3] = "bc2-rgba-unorm";
gpuTextureFormats[PIXELFORMAT_DXT5] = "bc3-rgba-unorm";
gpuTextureFormats[PIXELFORMAT_RGB16F] = "";
gpuTextureFormats[PIXELFORMAT_RGBA16F] = "rgba16float";
gpuTextureFormats[PIXELFORMAT_R16F] = "r16float";
gpuTextureFormats[PIXELFORMAT_RG16F] = "rg16float";
gpuTextureFormats[PIXELFORMAT_RGB32F] = "";
gpuTextureFormats[PIXELFORMAT_RGBA32F] = "rgba32float";
gpuTextureFormats[PIXELFORMAT_R32F] = "r32float";
gpuTextureFormats[PIXELFORMAT_DEPTH] = "depth32float";
gpuTextureFormats[PIXELFORMAT_DEPTHSTENCIL] = "depth24plus-stencil8";
gpuTextureFormats[PIXELFORMAT_111110F] = "rg11b10ufloat";
gpuTextureFormats[PIXELFORMAT_SRGB8] = "";
gpuTextureFormats[PIXELFORMAT_SRGBA8] = "rgba8unorm-srgb";
gpuTextureFormats[PIXELFORMAT_ETC1] = "";
gpuTextureFormats[PIXELFORMAT_ETC2_RGB] = "etc2-rgb8unorm";
gpuTextureFormats[PIXELFORMAT_ETC2_RGBA] = "etc2-rgba8unorm";
gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGB_1] = "";
gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = "";
gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGB_1] = "";
gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = "";
gpuTextureFormats[PIXELFORMAT_ASTC_4x4] = "astc-4x4-unorm";
gpuTextureFormats[PIXELFORMAT_ATC_RGB] = "";
gpuTextureFormats[PIXELFORMAT_ATC_RGBA] = "";
gpuTextureFormats[PIXELFORMAT_BGRA8] = "bgra8unorm";
gpuTextureFormats[PIXELFORMAT_SBGRA8] = "bgra8unorm-srgb";
gpuTextureFormats[PIXELFORMAT_R8I] = "r8sint";
gpuTextureFormats[PIXELFORMAT_R8U] = "r8uint";
gpuTextureFormats[PIXELFORMAT_R16I] = "r16sint";
gpuTextureFormats[PIXELFORMAT_R16U] = "r16uint";
gpuTextureFormats[PIXELFORMAT_R32I] = "r32sint";
gpuTextureFormats[PIXELFORMAT_R32U] = "r32uint";
gpuTextureFormats[PIXELFORMAT_RG8I] = "rg8sint";
gpuTextureFormats[PIXELFORMAT_RG8U] = "rg8uint";
gpuTextureFormats[PIXELFORMAT_RG16I] = "rg16sint";
gpuTextureFormats[PIXELFORMAT_RG16U] = "rg16uint";
gpuTextureFormats[PIXELFORMAT_RG32I] = "rg32sint";
gpuTextureFormats[PIXELFORMAT_RG32U] = "rg32uint";
gpuTextureFormats[PIXELFORMAT_RGBA8I] = "rgba8sint";
gpuTextureFormats[PIXELFORMAT_RGBA8U] = "rgba8uint";
gpuTextureFormats[PIXELFORMAT_RGBA16I] = "rgba16sint";
gpuTextureFormats[PIXELFORMAT_RGBA16U] = "rgba16uint";
gpuTextureFormats[PIXELFORMAT_RGBA32I] = "rgba32sint";
gpuTextureFormats[PIXELFORMAT_RGBA32U] = "rgba32uint";
gpuTextureFormats[PIXELFORMAT_DXT1_SRGB] = "bc1-rgba-unorm-srgb";
gpuTextureFormats[PIXELFORMAT_DXT3_SRGB] = "bc2-rgba-unorm-srgb";
gpuTextureFormats[PIXELFORMAT_DXT5_SRGB] = "bc3-rgba-unorm-srgb";
gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_SRGB_1] = "";
gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_SRGBA_1] = "";
gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_SRGB_1] = "";
gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_SRGBA_1] = "";
gpuTextureFormats[PIXELFORMAT_ETC2_SRGB] = "etc2-rgb8unorm-srgb";
gpuTextureFormats[PIXELFORMAT_ETC2_SRGBA] = "etc2-rgba8unorm-srgb";

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-bind-group-format.js
var samplerTypes = [];
samplerTypes[SAMPLETYPE_FLOAT] = "filtering";
samplerTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = "non-filtering";
samplerTypes[SAMPLETYPE_DEPTH] = "comparison";
samplerTypes[SAMPLETYPE_INT] = "comparison";
samplerTypes[SAMPLETYPE_UINT] = "comparison";
var sampleTypes = [];
sampleTypes[SAMPLETYPE_FLOAT] = "float";
sampleTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = "unfilterable-float";
sampleTypes[SAMPLETYPE_DEPTH] = "depth";
sampleTypes[SAMPLETYPE_INT] = "sint";
sampleTypes[SAMPLETYPE_UINT] = "uint";
var stringIds4 = new StringIds();
var WebgpuBindGroupFormat = class {
  constructor(bindGroupFormat) {
    const device = bindGroupFormat.device;
    const {
      key,
      desc
    } = this.createDescriptor(bindGroupFormat);
    this.key = stringIds4.get(key);
    this.bindGroupLayout = device.wgpu.createBindGroupLayout(desc);
  }
  destroy() {
    this.bindGroupLayout = null;
  }
  loseContext() {
  }
  createDescriptor(bindGroupFormat) {
    const entries = [];
    let key = "";
    bindGroupFormat.uniformBufferFormats.forEach((bufferFormat) => {
      const visibility = WebgpuUtils.shaderStage(bufferFormat.visibility);
      key += `#${bufferFormat.slot}U:${visibility}`;
      entries.push({
        binding: bufferFormat.slot,
        visibility,
        buffer: {
          type: "uniform",
          hasDynamicOffset: true
        }
      });
    });
    bindGroupFormat.textureFormats.forEach((textureFormat) => {
      const visibility = WebgpuUtils.shaderStage(textureFormat.visibility);
      const sampleType = textureFormat.sampleType;
      const viewDimension = textureFormat.textureDimension;
      const multisampled = false;
      const gpuSampleType = sampleTypes[sampleType];
      key += `#${textureFormat.slot}T:${visibility}-${gpuSampleType}-${viewDimension}-${multisampled}`;
      entries.push({
        binding: textureFormat.slot,
        visibility,
        texture: {
          sampleType: gpuSampleType,
          viewDimension,
          multisampled
        }
      });
      if (textureFormat.hasSampler) {
        const gpuSamplerType = samplerTypes[sampleType];
        key += `#${textureFormat.slot + 1}S:${visibility}-${gpuSamplerType}`;
        entries.push({
          binding: textureFormat.slot + 1,
          visibility,
          sampler: {
            type: gpuSamplerType
          }
        });
      }
    });
    bindGroupFormat.storageTextureFormats.forEach((textureFormat) => {
      const {
        format,
        textureDimension
      } = textureFormat;
      const {
        read,
        write
      } = textureFormat;
      key += `#${textureFormat.slot}ST:${format}-${textureDimension}-${read ? "r1" : "r0"}-${write ? "w1" : "w0"}`;
      entries.push({
        binding: textureFormat.slot,
        visibility: GPUShaderStage.COMPUTE,
        storageTexture: {
          access: read ? write ? "read-write" : "read-only" : "write-only",
          format: gpuTextureFormats[format],
          viewDimension: textureDimension
        }
      });
    });
    bindGroupFormat.storageBufferFormats.forEach((bufferFormat) => {
      const readOnly = bufferFormat.readOnly;
      const visibility = WebgpuUtils.shaderStage(bufferFormat.visibility);
      key += `#${bufferFormat.slot}SB:${visibility}-${readOnly ? "ro" : "rw"}`;
      entries.push({
        binding: bufferFormat.slot,
        visibility,
        buffer: {
          type: readOnly ? "read-only-storage" : "storage"
        }
      });
    });
    const desc = {
      entries
    };
    return {
      key,
      desc
    };
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-buffer.js
var WebgpuBuffer = class {
  constructor(usageFlags = 0) {
    this.buffer = null;
    this.usageFlags = 0;
    this.usageFlags = usageFlags;
  }
  destroy(device) {
    if (this.buffer) {
      this.buffer.destroy();
      this.buffer = null;
    }
  }
  get initialized() {
    return !!this.buffer;
  }
  loseContext() {
  }
  allocate(device, size) {
    this.buffer = device.wgpu.createBuffer({
      size,
      usage: this.usageFlags
    });
  }
  unlock(device, storage) {
    var _storage$byteOffset, _storage$buffer;
    const wgpu = device.wgpu;
    if (!this.buffer) {
      const size = storage.byteLength + 3 & ~3;
      this.usageFlags |= GPUBufferUsage.COPY_DST;
      this.allocate(device, size);
    }
    const srcOffset = (_storage$byteOffset = storage.byteOffset) != null ? _storage$byteOffset : 0;
    const srcData = new Uint8Array((_storage$buffer = storage.buffer) != null ? _storage$buffer : storage, srcOffset, storage.byteLength);
    const data2 = new Uint8Array(this.buffer.size);
    data2.set(srcData);
    wgpu.queue.writeBuffer(this.buffer, 0, data2, 0, data2.length);
  }
  read(device, offset, size, data2) {
    return device.readStorageBuffer(this, offset, size, data2);
  }
  write(device, bufferOffset, data2, dataOffset, size) {
    device.writeStorageBuffer(this, bufferOffset, data2, dataOffset, size);
  }
  clear(device, offset, size) {
    device.clearStorageBuffer(this, offset, size);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-index-buffer.js
var WebgpuIndexBuffer = class extends WebgpuBuffer {
  constructor(indexBuffer, options2) {
    super(BUFFERUSAGE_INDEX | (options2 != null && options2.storage ? BUFFERUSAGE_STORAGE : 0));
    this.format = null;
    this.format = indexBuffer.format === INDEXFORMAT_UINT16 ? "uint16" : "uint32";
  }
  unlock(indexBuffer) {
    const device = indexBuffer.device;
    super.unlock(device, indexBuffer.storage);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/array-utils.js
var array = {
  equals(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (let i = 0; i < arr1.length; i++) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }
    return true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-vertex-buffer-layout.js
var gpuVertexFormats = [];
gpuVertexFormats[TYPE_INT8] = "sint8";
gpuVertexFormats[TYPE_UINT8] = "uint8";
gpuVertexFormats[TYPE_INT16] = "sint16";
gpuVertexFormats[TYPE_UINT16] = "uint16";
gpuVertexFormats[TYPE_INT32] = "sint32";
gpuVertexFormats[TYPE_UINT32] = "uint32";
gpuVertexFormats[TYPE_FLOAT32] = "float32";
gpuVertexFormats[TYPE_FLOAT16] = "float16";
var gpuVertexFormatsNormalized = [];
gpuVertexFormatsNormalized[TYPE_INT8] = "snorm8";
gpuVertexFormatsNormalized[TYPE_UINT8] = "unorm8";
gpuVertexFormatsNormalized[TYPE_INT16] = "snorm16";
gpuVertexFormatsNormalized[TYPE_UINT16] = "unorm16";
gpuVertexFormatsNormalized[TYPE_INT32] = "sint32";
gpuVertexFormatsNormalized[TYPE_UINT32] = "uint32";
gpuVertexFormatsNormalized[TYPE_FLOAT32] = "float32";
gpuVertexFormatsNormalized[TYPE_FLOAT16] = "float16";
var WebgpuVertexBufferLayout = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  get(vertexFormat0, vertexFormat1 = null) {
    const key = this.getKey(vertexFormat0, vertexFormat1);
    let layout = this.cache.get(key);
    if (!layout) {
      layout = this.create(vertexFormat0, vertexFormat1);
      this.cache.set(key, layout);
    }
    return layout;
  }
  getKey(vertexFormat0, vertexFormat1 = null) {
    return `${vertexFormat0 == null ? void 0 : vertexFormat0.renderingHashString}-${vertexFormat1 == null ? void 0 : vertexFormat1.renderingHashString}`;
  }
  create(vertexFormat0, vertexFormat1) {
    const layout = [];
    const addFormat = (format) => {
      const interleaved = format.interleaved;
      const stepMode = format.instancing ? "instance" : "vertex";
      let attributes = [];
      const elementCount = format.elements.length;
      for (let i = 0; i < elementCount; i++) {
        const element = format.elements[i];
        const location = semanticToLocation[element.name];
        const formatTable = element.normalize ? gpuVertexFormatsNormalized : gpuVertexFormats;
        attributes.push({
          shaderLocation: location,
          offset: interleaved ? element.offset : 0,
          format: `${formatTable[element.dataType]}${element.numComponents > 1 ? `x${element.numComponents}` : ""}`
        });
        if (!interleaved || i === elementCount - 1) {
          layout.push({
            attributes,
            arrayStride: element.stride,
            stepMode
          });
          attributes = [];
        }
      }
    };
    if (vertexFormat0) {
      addFormat(vertexFormat0);
    }
    if (vertexFormat1) {
      addFormat(vertexFormat1);
    }
    return layout;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-pipeline.js
var WebgpuPipeline = class {
  constructor(device) {
    this.device = device;
  }
  getPipelineLayout(bindGroupFormats) {
    const bindGroupLayouts = [];
    bindGroupFormats.forEach((format) => {
      bindGroupLayouts.push(format.bindGroupLayout);
    });
    const desc = {
      bindGroupLayouts
    };
    const pipelineLayout = this.device.wgpu.createPipelineLayout(desc);
    return pipelineLayout;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-render-pipeline.js
var _primitiveTopology = ["point-list", "line-list", void 0, "line-strip", "triangle-list", "triangle-strip", void 0];
var _blendOperation = ["add", "subtract", "reverse-subtract", "min", "max"];
var _blendFactor = ["zero", "one", "src", "one-minus-src", "dst", "one-minus-dst", "src-alpha", "src-alpha-saturated", "one-minus-src-alpha", "dst-alpha", "one-minus-dst-alpha", "constant", "one-minus-constant"];
var _compareFunction = ["never", "less", "equal", "less-equal", "greater", "not-equal", "greater-equal", "always"];
var _cullModes = ["none", "back", "front"];
var _stencilOps = ["keep", "zero", "replace", "increment-clamp", "increment-wrap", "decrement-clamp", "decrement-wrap", "invert"];
var CacheEntry = class {
  constructor() {
    this.pipeline = void 0;
    this.hashes = void 0;
  }
};
var WebgpuRenderPipeline = class extends WebgpuPipeline {
  constructor(device) {
    super(device);
    this.lookupHashes = new Uint32Array(13);
    this.vertexBufferLayout = new WebgpuVertexBufferLayout();
    this.cache = /* @__PURE__ */ new Map();
  }
  get(primitive2, vertexFormat0, vertexFormat1, shader, renderTarget, bindGroupFormats, blendState, depthState, cullMode, stencilEnabled, stencilFront, stencilBack) {
    var _vertexFormat0$render, _vertexFormat1$render, _bindGroupFormats$0$k, _bindGroupFormats$, _bindGroupFormats$1$k, _bindGroupFormats$2, _bindGroupFormats$2$k, _bindGroupFormats$3;
    const lookupHashes2 = this.lookupHashes;
    lookupHashes2[0] = primitive2.type;
    lookupHashes2[1] = shader.id;
    lookupHashes2[2] = cullMode;
    lookupHashes2[3] = depthState.key;
    lookupHashes2[4] = blendState.key;
    lookupHashes2[5] = (_vertexFormat0$render = vertexFormat0 == null ? void 0 : vertexFormat0.renderingHash) != null ? _vertexFormat0$render : 0;
    lookupHashes2[6] = (_vertexFormat1$render = vertexFormat1 == null ? void 0 : vertexFormat1.renderingHash) != null ? _vertexFormat1$render : 0;
    lookupHashes2[7] = renderTarget.impl.key;
    lookupHashes2[8] = (_bindGroupFormats$0$k = (_bindGroupFormats$ = bindGroupFormats[0]) == null ? void 0 : _bindGroupFormats$.key) != null ? _bindGroupFormats$0$k : 0;
    lookupHashes2[9] = (_bindGroupFormats$1$k = (_bindGroupFormats$2 = bindGroupFormats[1]) == null ? void 0 : _bindGroupFormats$2.key) != null ? _bindGroupFormats$1$k : 0;
    lookupHashes2[10] = (_bindGroupFormats$2$k = (_bindGroupFormats$3 = bindGroupFormats[2]) == null ? void 0 : _bindGroupFormats$3.key) != null ? _bindGroupFormats$2$k : 0;
    lookupHashes2[11] = stencilEnabled ? stencilFront.key : 0;
    lookupHashes2[12] = stencilEnabled ? stencilBack.key : 0;
    const hash = hash32Fnv1a(lookupHashes2);
    let cacheEntries = this.cache.get(hash);
    if (cacheEntries) {
      for (let i = 0; i < cacheEntries.length; i++) {
        const entry = cacheEntries[i];
        if (array.equals(entry.hashes, lookupHashes2)) {
          return entry.pipeline;
        }
      }
    }
    const primitiveTopology = _primitiveTopology[primitive2.type];
    const pipelineLayout = this.getPipelineLayout(bindGroupFormats);
    const vertexBufferLayout = this.vertexBufferLayout.get(vertexFormat0, vertexFormat1);
    const cacheEntry = new CacheEntry();
    cacheEntry.hashes = new Uint32Array(lookupHashes2);
    cacheEntry.pipeline = this.create(primitiveTopology, shader, renderTarget, pipelineLayout, blendState, depthState, vertexBufferLayout, cullMode, stencilEnabled, stencilFront, stencilBack);
    if (cacheEntries) {
      cacheEntries.push(cacheEntry);
    } else {
      cacheEntries = [cacheEntry];
    }
    this.cache.set(hash, cacheEntries);
    return cacheEntry.pipeline;
  }
  getBlend(blendState) {
    let blend;
    if (blendState.blend) {
      blend = {
        color: {
          operation: _blendOperation[blendState.colorOp],
          srcFactor: _blendFactor[blendState.colorSrcFactor],
          dstFactor: _blendFactor[blendState.colorDstFactor]
        },
        alpha: {
          operation: _blendOperation[blendState.alphaOp],
          srcFactor: _blendFactor[blendState.alphaSrcFactor],
          dstFactor: _blendFactor[blendState.alphaDstFactor]
        }
      };
    }
    return blend;
  }
  getDepthStencil(depthState, renderTarget, stencilEnabled, stencilFront, stencilBack) {
    let depthStencil;
    const {
      depth,
      stencil
    } = renderTarget;
    if (depth || stencil) {
      depthStencil = {
        format: renderTarget.impl.depthFormat
      };
      if (depth) {
        depthStencil.depthWriteEnabled = depthState.write;
        depthStencil.depthCompare = _compareFunction[depthState.func];
        depthStencil.depthBias = depthState.depthBias;
        depthStencil.depthBiasSlopeScale = depthState.depthBiasSlope;
      } else {
        depthStencil.depthWriteEnabled = false;
        depthStencil.depthCompare = "always";
      }
      if (stencil && stencilEnabled) {
        depthStencil.stencilReadMas = stencilFront.readMask;
        depthStencil.stencilWriteMask = stencilFront.writeMask;
        depthStencil.stencilFront = {
          compare: _compareFunction[stencilFront.func],
          failOp: _stencilOps[stencilFront.fail],
          passOp: _stencilOps[stencilFront.zpass],
          depthFailOp: _stencilOps[stencilFront.zfail]
        };
        depthStencil.stencilBack = {
          compare: _compareFunction[stencilBack.func],
          failOp: _stencilOps[stencilBack.fail],
          passOp: _stencilOps[stencilBack.zpass],
          depthFailOp: _stencilOps[stencilBack.zfail]
        };
      }
    }
    return depthStencil;
  }
  create(primitiveTopology, shader, renderTarget, pipelineLayout, blendState, depthState, vertexBufferLayout, cullMode, stencilEnabled, stencilFront, stencilBack) {
    const wgpu = this.device.wgpu;
    const webgpuShader = shader.impl;
    const desc = {
      vertex: {
        module: webgpuShader.getVertexShaderModule(),
        entryPoint: webgpuShader.vertexEntryPoint,
        buffers: vertexBufferLayout
      },
      primitive: {
        topology: primitiveTopology,
        frontFace: "ccw",
        cullMode: _cullModes[cullMode]
      },
      depthStencil: this.getDepthStencil(depthState, renderTarget, stencilEnabled, stencilFront, stencilBack),
      multisample: {
        count: renderTarget.samples
      },
      layout: pipelineLayout
    };
    desc.fragment = {
      module: webgpuShader.getFragmentShaderModule(),
      entryPoint: webgpuShader.fragmentEntryPoint,
      targets: []
    };
    const colorAttachments = renderTarget.impl.colorAttachments;
    if (colorAttachments.length > 0) {
      let writeMask = 0;
      if (blendState.redWrite) writeMask |= GPUColorWrite.RED;
      if (blendState.greenWrite) writeMask |= GPUColorWrite.GREEN;
      if (blendState.blueWrite) writeMask |= GPUColorWrite.BLUE;
      if (blendState.alphaWrite) writeMask |= GPUColorWrite.ALPHA;
      const blend = this.getBlend(blendState);
      colorAttachments.forEach((attachment) => {
        desc.fragment.targets.push({
          format: attachment.format,
          writeMask,
          blend
        });
      });
    }
    const pipeline = wgpu.createRenderPipeline(desc);
    return pipeline;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-compute-pipeline.js
var WebgpuComputePipeline = class extends WebgpuPipeline {
  get(shader, bindGroupFormat) {
    const pipelineLayout = this.getPipelineLayout([bindGroupFormat.impl]);
    const pipeline = this.create(shader, pipelineLayout);
    return pipeline;
  }
  create(shader, pipelineLayout) {
    const wgpu = this.device.wgpu;
    const webgpuShader = shader.impl;
    const desc = {
      compute: {
        module: webgpuShader.getComputeShaderModule(),
        entryPoint: webgpuShader.computeEntryPoint
      },
      layout: pipelineLayout
    };
    const pipeline = wgpu.createComputePipeline(desc);
    return pipeline;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-render-target.js
var stringIds5 = new StringIds();
var ColorAttachment = class {
  constructor() {
    this.format = void 0;
    this.multisampledBuffer = void 0;
  }
  destroy() {
    var _this$multisampledBuf;
    (_this$multisampledBuf = this.multisampledBuffer) == null || _this$multisampledBuf.destroy();
    this.multisampledBuffer = null;
  }
};
var WebgpuRenderTarget = class {
  constructor(renderTarget) {
    this.initialized = false;
    this.key = void 0;
    this.colorAttachments = [];
    this.depthFormat = void 0;
    this.hasStencil = void 0;
    this.depthTexture = null;
    this.depthTextureInternal = false;
    this.assignedColorTexture = null;
    this.renderPassDescriptor = {};
    this.isBackbuffer = false;
    this.renderTarget = renderTarget;
    if (renderTarget._colorBuffers) {
      renderTarget._colorBuffers.forEach((colorBuffer, index) => {
        this.setColorAttachment(index, void 0, colorBuffer.impl.format);
      });
    }
    this.updateKey();
  }
  destroy(device) {
    this.initialized = false;
    if (this.depthTextureInternal) {
      var _this$depthTexture;
      (_this$depthTexture = this.depthTexture) == null || _this$depthTexture.destroy();
      this.depthTexture = null;
    }
    this.assignedColorTexture = null;
    this.colorAttachments.forEach((colorAttachment) => {
      colorAttachment.destroy();
    });
    this.colorAttachments.length = 0;
  }
  updateKey() {
    const rt = this.renderTarget;
    let key = `${rt.samples}:${rt.depth ? this.depthFormat : "nodepth"}`;
    this.colorAttachments.forEach((colorAttachment) => {
      key += `:${colorAttachment.format}`;
    });
    this.key = stringIds5.get(key);
  }
  setDepthFormat(depthFormat) {
    this.depthFormat = depthFormat;
    this.hasStencil = depthFormat === "depth24plus-stencil8";
  }
  assignColorTexture(device, gpuTexture) {
    this.assignedColorTexture = gpuTexture;
    const view = gpuTexture.createView({
      format: device.backBufferViewFormat
    });
    const colorAttachment = this.renderPassDescriptor.colorAttachments[0];
    const samples = this.renderTarget.samples;
    if (samples > 1) {
      colorAttachment.resolveTarget = view;
    } else {
      colorAttachment.view = view;
    }
    this.setColorAttachment(0, void 0, device.backBufferViewFormat);
    this.updateKey();
  }
  setColorAttachment(index, multisampledBuffer, format) {
    if (!this.colorAttachments[index]) {
      this.colorAttachments[index] = new ColorAttachment();
    }
    if (multisampledBuffer) {
      this.colorAttachments[index].multisampledBuffer = multisampledBuffer;
    }
    if (format) {
      this.colorAttachments[index].format = format;
    }
  }
  init(device, renderTarget) {
    var _renderTarget$_colorB, _renderTarget$_colorB2;
    const wgpu = device.wgpu;
    this.initDepthStencil(wgpu, renderTarget);
    this.renderPassDescriptor.colorAttachments = [];
    const count = (_renderTarget$_colorB = (_renderTarget$_colorB2 = renderTarget._colorBuffers) == null ? void 0 : _renderTarget$_colorB2.length) != null ? _renderTarget$_colorB : 1;
    for (let i = 0; i < count; ++i) {
      var _this$colorAttachment;
      const colorAttachment = this.initColor(device, wgpu, renderTarget, i);
      const isDefaultFramebuffer = i === 0 && ((_this$colorAttachment = this.colorAttachments[0]) == null ? void 0 : _this$colorAttachment.format);
      if (colorAttachment.view || isDefaultFramebuffer) {
        this.renderPassDescriptor.colorAttachments.push(colorAttachment);
      }
    }
    this.initialized = true;
  }
  initDepthStencil(wgpu, renderTarget) {
    const {
      samples,
      width,
      height,
      depth,
      depthBuffer
    } = renderTarget;
    if (depth || depthBuffer) {
      if (!depthBuffer) {
        this.setDepthFormat("depth24plus-stencil8");
        const depthTextureDesc = {
          size: [width, height, 1],
          dimension: "2d",
          sampleCount: samples,
          format: this.depthFormat,
          usage: GPUTextureUsage.RENDER_ATTACHMENT
        };
        if (samples > 1) {
          depthTextureDesc.usage |= GPUTextureUsage.TEXTURE_BINDING;
        } else {
          depthTextureDesc.usage |= GPUTextureUsage.COPY_SRC;
        }
        this.depthTexture = wgpu.createTexture(depthTextureDesc);
        this.depthTextureInternal = true;
      } else {
        this.depthTexture = depthBuffer.impl.gpuTexture;
        this.setDepthFormat(depthBuffer.impl.format);
      }
      this.renderPassDescriptor.depthStencilAttachment = {
        view: this.depthTexture.createView()
      };
    }
  }
  initColor(device, wgpu, renderTarget, index) {
    const colorAttachment = {};
    const {
      samples,
      width,
      height
    } = renderTarget;
    const colorBuffer = renderTarget.getColorBuffer(index);
    let colorView = null;
    if (colorBuffer) {
      const mipLevelCount = 1;
      if (colorBuffer.cubemap) {
        colorView = colorBuffer.impl.createView({
          dimension: "2d",
          baseArrayLayer: renderTarget.face,
          arrayLayerCount: 1,
          mipLevelCount
        });
      } else {
        colorView = colorBuffer.impl.createView({
          mipLevelCount
        });
      }
    }
    if (samples > 1) {
      const format = this.isBackbuffer ? device.backBufferViewFormat : colorBuffer.impl.format;
      const multisampledTextureDesc = {
        size: [width, height, 1],
        dimension: "2d",
        sampleCount: samples,
        format,
        usage: GPUTextureUsage.RENDER_ATTACHMENT
      };
      const multisampledColorBuffer = wgpu.createTexture(multisampledTextureDesc);
      this.setColorAttachment(index, multisampledColorBuffer, multisampledTextureDesc.format);
      colorAttachment.view = multisampledColorBuffer.createView();
      colorAttachment.resolveTarget = colorView;
    } else {
      colorAttachment.view = colorView;
    }
    return colorAttachment;
  }
  setupForRenderPass(renderPass, renderTarget) {
    var _this$renderPassDescr, _this$renderPassDescr2;
    const count = (_this$renderPassDescr = (_this$renderPassDescr2 = this.renderPassDescriptor.colorAttachments) == null ? void 0 : _this$renderPassDescr2.length) != null ? _this$renderPassDescr : 0;
    for (let i = 0; i < count; ++i) {
      const colorAttachment = this.renderPassDescriptor.colorAttachments[i];
      const colorOps = renderPass.colorArrayOps[i];
      const srgb = renderTarget.isColorBufferSrgb(i);
      colorAttachment.clearValue = srgb ? colorOps.clearValueLinear : colorOps.clearValue;
      colorAttachment.loadOp = colorOps.clear ? "clear" : "load";
      colorAttachment.storeOp = colorOps.store ? "store" : "discard";
    }
    const depthAttachment = this.renderPassDescriptor.depthStencilAttachment;
    if (depthAttachment) {
      depthAttachment.depthClearValue = renderPass.depthStencilOps.clearDepthValue;
      depthAttachment.depthLoadOp = renderPass.depthStencilOps.clearDepth ? "clear" : "load";
      depthAttachment.depthStoreOp = renderPass.depthStencilOps.storeDepth ? "store" : "discard";
      depthAttachment.depthReadOnly = false;
      if (this.hasStencil) {
        depthAttachment.stencilClearValue = renderPass.depthStencilOps.clearStencilValue;
        depthAttachment.stencilLoadOp = renderPass.depthStencilOps.clearStencil ? "clear" : "load";
        depthAttachment.stencilStoreOp = renderPass.depthStencilOps.storeStencil ? "store" : "discard";
        depthAttachment.stencilReadOnly = false;
      }
    }
  }
  loseContext() {
    this.initialized = false;
  }
  resolve(device, target2, color, depth) {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/uniform-buffer-format.js
var uniformTypeToNumComponents = [];
uniformTypeToNumComponents[UNIFORMTYPE_FLOAT] = 1;
uniformTypeToNumComponents[UNIFORMTYPE_VEC2] = 2;
uniformTypeToNumComponents[UNIFORMTYPE_VEC3] = 3;
uniformTypeToNumComponents[UNIFORMTYPE_VEC4] = 4;
uniformTypeToNumComponents[UNIFORMTYPE_INT] = 1;
uniformTypeToNumComponents[UNIFORMTYPE_IVEC2] = 2;
uniformTypeToNumComponents[UNIFORMTYPE_IVEC3] = 3;
uniformTypeToNumComponents[UNIFORMTYPE_IVEC4] = 4;
uniformTypeToNumComponents[UNIFORMTYPE_BOOL] = 1;
uniformTypeToNumComponents[UNIFORMTYPE_BVEC2] = 2;
uniformTypeToNumComponents[UNIFORMTYPE_BVEC3] = 3;
uniformTypeToNumComponents[UNIFORMTYPE_BVEC4] = 4;
uniformTypeToNumComponents[UNIFORMTYPE_MAT2] = 8;
uniformTypeToNumComponents[UNIFORMTYPE_MAT3] = 12;
uniformTypeToNumComponents[UNIFORMTYPE_MAT4] = 16;
uniformTypeToNumComponents[UNIFORMTYPE_UINT] = 1;
uniformTypeToNumComponents[UNIFORMTYPE_UVEC2] = 2;
uniformTypeToNumComponents[UNIFORMTYPE_UVEC3] = 3;
uniformTypeToNumComponents[UNIFORMTYPE_UVEC4] = 4;
var UniformFormat = class {
  get isArrayType() {
    return this.count > 0;
  }
  constructor(name, type, count = 0) {
    this.name = void 0;
    this.type = void 0;
    this.byteSize = void 0;
    this.offset = void 0;
    this.scopeId = void 0;
    this.count = void 0;
    this.numComponents = void 0;
    this.shortName = name;
    this.name = count ? `${name}[0]` : name;
    this.type = type;
    this.numComponents = uniformTypeToNumComponents[type];
    this.updateType = type;
    if (count > 0) {
      switch (type) {
        case UNIFORMTYPE_FLOAT:
          this.updateType = UNIFORMTYPE_FLOATARRAY;
          break;
        case UNIFORMTYPE_INT:
          this.updateType = UNIFORMTYPE_INTARRAY;
          break;
        case UNIFORMTYPE_UINT:
          this.updateType = UNIFORMTYPE_UINTARRAY;
          break;
        case UNIFORMTYPE_BOOL:
          this.updateType = UNIFORMTYPE_BOOLARRAY;
          break;
        case UNIFORMTYPE_VEC2:
          this.updateType = UNIFORMTYPE_VEC2ARRAY;
          break;
        case UNIFORMTYPE_IVEC2:
          this.updateType = UNIFORMTYPE_IVEC2ARRAY;
          break;
        case UNIFORMTYPE_UVEC2:
          this.updateType = UNIFORMTYPE_UVEC2ARRAY;
          break;
        case UNIFORMTYPE_BVEC2:
          this.updateType = UNIFORMTYPE_BVEC2ARRAY;
          break;
        case UNIFORMTYPE_VEC3:
          this.updateType = UNIFORMTYPE_VEC3ARRAY;
          break;
        case UNIFORMTYPE_IVEC3:
          this.updateType = UNIFORMTYPE_IVEC3ARRAY;
          break;
        case UNIFORMTYPE_UVEC3:
          this.updateType = UNIFORMTYPE_UVEC3ARRAY;
          break;
        case UNIFORMTYPE_BVEC3:
          this.updateType = UNIFORMTYPE_BVEC3ARRAY;
          break;
        case UNIFORMTYPE_VEC4:
          this.updateType = UNIFORMTYPE_VEC4ARRAY;
          break;
        case UNIFORMTYPE_IVEC4:
          this.updateType = UNIFORMTYPE_IVEC4ARRAY;
          break;
        case UNIFORMTYPE_UVEC4:
          this.updateType = UNIFORMTYPE_UVEC4ARRAY;
          break;
        case UNIFORMTYPE_BVEC4:
          this.updateType = UNIFORMTYPE_BVEC4ARRAY;
          break;
        case UNIFORMTYPE_MAT4:
          this.updateType = UNIFORMTYPE_MAT4ARRAY;
          break;
      }
    }
    this.count = count;
    let componentSize = this.numComponents;
    if (count) {
      componentSize = math.roundUp(componentSize, 4);
    }
    this.byteSize = componentSize * 4;
    if (count) {
      this.byteSize *= count;
    }
  }
  calculateOffset(offset) {
    let alignment = this.byteSize <= 8 ? this.byteSize : 16;
    if (this.count) {
      alignment = 16;
    }
    offset = math.roundUp(offset, alignment);
    this.offset = offset / 4;
  }
};
var UniformBufferFormat = class {
  constructor(graphicsDevice, uniforms) {
    this.byteSize = 0;
    this.map = /* @__PURE__ */ new Map();
    this.scope = graphicsDevice.scope;
    this.uniforms = uniforms;
    let offset = 0;
    for (let i = 0; i < uniforms.length; i++) {
      const uniform = uniforms[i];
      uniform.calculateOffset(offset);
      offset = uniform.offset * 4 + uniform.byteSize;
      uniform.scopeId = this.scope.resolve(uniform.name);
      this.map.set(uniform.name, uniform);
    }
    this.byteSize = math.roundUp(offset, 16);
  }
  get(name) {
    return this.map.get(name);
  }
  getShaderDeclaration(bindGroup, bindIndex) {
    const name = bindGroupNames[bindGroup];
    let code = `layout(set = ${bindGroup}, binding = ${bindIndex}, std140) uniform ub_${name} {
`;
    this.uniforms.forEach((uniform) => {
      const typeString = uniformTypeToName[uniform.type];
      code += `    ${typeString} ${uniform.shortName}${uniform.count ? `[${uniform.count}]` : ""};
`;
    });
    return `${code}};
`;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-processor.js
var KEYWORD = /[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g;
var KEYWORD_LINE = /(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)(;+)/g;
var MARKER = "@@@";
var ARRAY_IDENTIFIER = /([\w-]+)\[(.*?)\]/;
var precisionQualifiers = /* @__PURE__ */ new Set(["highp", "mediump", "lowp"]);
var shadowSamplers = /* @__PURE__ */ new Set(["sampler2DShadow", "samplerCubeShadow", "sampler2DArrayShadow"]);
var textureDimensions = {
  sampler2D: TEXTUREDIMENSION_2D,
  sampler3D: TEXTUREDIMENSION_3D,
  samplerCube: TEXTUREDIMENSION_CUBE,
  samplerCubeShadow: TEXTUREDIMENSION_CUBE,
  sampler2DShadow: TEXTUREDIMENSION_2D,
  sampler2DArray: TEXTUREDIMENSION_2D_ARRAY,
  sampler2DArrayShadow: TEXTUREDIMENSION_2D_ARRAY,
  isampler2D: TEXTUREDIMENSION_2D,
  usampler2D: TEXTUREDIMENSION_2D,
  isampler3D: TEXTUREDIMENSION_3D,
  usampler3D: TEXTUREDIMENSION_3D,
  isamplerCube: TEXTUREDIMENSION_CUBE,
  usamplerCube: TEXTUREDIMENSION_CUBE,
  isampler2DArray: TEXTUREDIMENSION_2D_ARRAY,
  usampler2DArray: TEXTUREDIMENSION_2D_ARRAY
};
var UniformLine = class {
  constructor(line, shader) {
    this.line = line;
    const words = line.trim().split(/\s+/);
    if (precisionQualifiers.has(words[0])) {
      this.precision = words.shift();
    }
    this.type = words.shift();
    if (line.includes(",")) ;
    if (line.includes("[")) {
      const rest = words.join(" ");
      const match = ARRAY_IDENTIFIER.exec(rest);
      this.name = match[1];
      this.arraySize = Number(match[2]);
      if (isNaN(this.arraySize)) {
        shader.failed = true;
      }
    } else {
      this.name = words.shift();
      this.arraySize = 0;
    }
    this.isSampler = this.type.indexOf("sampler") !== -1;
    this.isSignedInt = this.type.indexOf("isampler") !== -1;
    this.isUnsignedInt = this.type.indexOf("usampler") !== -1;
  }
};
var ShaderProcessor = class _ShaderProcessor {
  static run(device, shaderDefinition, shader) {
    const varyingMap = /* @__PURE__ */ new Map();
    const vertexExtracted = _ShaderProcessor.extract(shaderDefinition.vshader);
    const fragmentExtracted = _ShaderProcessor.extract(shaderDefinition.fshader);
    const attributesBlock = _ShaderProcessor.processAttributes(vertexExtracted.attributes, shaderDefinition.attributes, shaderDefinition.processingOptions);
    const vertexVaryingsBlock = _ShaderProcessor.processVaryings(vertexExtracted.varyings, varyingMap, true);
    const fragmentVaryingsBlock = _ShaderProcessor.processVaryings(fragmentExtracted.varyings, varyingMap, false);
    const outBlock = _ShaderProcessor.processOuts(fragmentExtracted.outs);
    const concatUniforms = vertexExtracted.uniforms.concat(fragmentExtracted.uniforms);
    const uniforms = Array.from(new Set(concatUniforms));
    const parsedUniforms = uniforms.map((line) => new UniformLine(line, shader));
    const uniformsData = _ShaderProcessor.processUniforms(device, parsedUniforms, shaderDefinition.processingOptions, shader);
    const vBlock = `${attributesBlock}
${vertexVaryingsBlock}
${uniformsData.code}`;
    const vshader = vertexExtracted.src.replace(MARKER, vBlock);
    const fBlock = `${fragmentVaryingsBlock}
${outBlock}
${uniformsData.code}`;
    const fshader = fragmentExtracted.src.replace(MARKER, fBlock);
    return {
      vshader,
      fshader,
      meshUniformBufferFormat: uniformsData.meshUniformBufferFormat,
      meshBindGroupFormat: uniformsData.meshBindGroupFormat
    };
  }
  static extract(src) {
    const attributes = [];
    const varyings = [];
    const outs = [];
    const uniforms = [];
    let replacement = `${MARKER}
`;
    let match;
    while ((match = KEYWORD.exec(src)) !== null) {
      const keyword = match[1];
      switch (keyword) {
        case "attribute":
        case "varying":
        case "uniform":
        case "out": {
          KEYWORD_LINE.lastIndex = match.index;
          const lineMatch = KEYWORD_LINE.exec(src);
          if (keyword === "attribute") {
            attributes.push(lineMatch[2]);
          } else if (keyword === "varying") {
            varyings.push(lineMatch[2]);
          } else if (keyword === "out") {
            outs.push(lineMatch[2]);
          } else if (keyword === "uniform") {
            uniforms.push(lineMatch[2]);
          }
          src = _ShaderProcessor.cutOut(src, match.index, KEYWORD_LINE.lastIndex, replacement);
          KEYWORD.lastIndex = match.index + replacement.length;
          replacement = "";
          break;
        }
      }
    }
    return {
      src,
      attributes,
      varyings,
      outs,
      uniforms
    };
  }
  static processUniforms(device, uniforms, processingOptions, shader) {
    const uniformLinesSamplers = [];
    const uniformLinesNonSamplers = [];
    uniforms.forEach((uniform) => {
      if (uniform.isSampler) {
        uniformLinesSamplers.push(uniform);
      } else {
        uniformLinesNonSamplers.push(uniform);
      }
    });
    const meshUniforms = [];
    uniformLinesNonSamplers.forEach((uniform) => {
      if (!processingOptions.hasUniform(uniform.name)) {
        const uniformType = uniformTypeToName.indexOf(uniform.type);
        const uniformFormat = new UniformFormat(uniform.name, uniformType, uniform.arraySize);
        meshUniforms.push(uniformFormat);
      }
    });
    const meshUniformBufferFormat = meshUniforms.length ? new UniformBufferFormat(device, meshUniforms) : null;
    const textureFormats = [];
    uniformLinesSamplers.forEach((uniform) => {
      if (!processingOptions.hasTexture(uniform.name)) {
        let sampleType = SAMPLETYPE_FLOAT;
        if (uniform.isSignedInt) {
          sampleType = SAMPLETYPE_INT;
        } else if (uniform.isUnsignedInt) {
          sampleType = SAMPLETYPE_UINT;
        } else {
          if (uniform.precision === "highp") {
            sampleType = SAMPLETYPE_UNFILTERABLE_FLOAT;
          }
          if (shadowSamplers.has(uniform.type)) {
            sampleType = SAMPLETYPE_DEPTH;
          }
        }
        const dimension = textureDimensions[uniform.type];
        textureFormats.push(new BindTextureFormat(uniform.name, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT, dimension, sampleType));
      }
    });
    const meshBindGroupFormat = new BindGroupFormat(device, textureFormats);
    let code = "";
    processingOptions.uniformFormats.forEach((format, bindGroupIndex) => {
      if (format) {
        code += format.getShaderDeclaration(bindGroupIndex, 0);
      }
    });
    if (meshUniformBufferFormat) {
      code += meshUniformBufferFormat.getShaderDeclaration(BINDGROUP_MESH_UB, 0);
    }
    processingOptions.bindGroupFormats.forEach((format, bindGroupIndex) => {
      if (format) {
        code += format.getShaderDeclarationTextures(bindGroupIndex);
      }
    });
    code += meshBindGroupFormat.getShaderDeclarationTextures(BINDGROUP_MESH);
    return {
      code,
      meshUniformBufferFormat,
      meshBindGroupFormat
    };
  }
  static processVaryings(varyingLines, varyingMap, isVertex) {
    let block = "";
    const op = isVertex ? "out" : "in";
    varyingLines.forEach((line, index) => {
      const words = _ShaderProcessor.splitToWords(line);
      const type = words.slice(0, -1).join(" ");
      const name = words[words.length - 1];
      if (isVertex) {
        varyingMap.set(name, index);
      } else {
        index = varyingMap.get(name);
      }
      block += `layout(location = ${index}) ${op} ${type} ${name};
`;
    });
    return block;
  }
  static processOuts(outsLines) {
    let block = "";
    outsLines.forEach((line, index) => {
      block += `layout(location = ${index}) out ${line};
`;
    });
    return block;
  }
  static getTypeCount(type) {
    const lastChar = type.substring(type.length - 1);
    const num = parseInt(lastChar, 10);
    return isNaN(num) ? 1 : num;
  }
  static processAttributes(attributeLines, shaderDefinitionAttributes, processingOptions) {
    let block = "";
    attributeLines.forEach((line) => {
      const words = _ShaderProcessor.splitToWords(line);
      let type = words[0];
      let name = words[1];
      if (shaderDefinitionAttributes.hasOwnProperty(name)) {
        const semantic = shaderDefinitionAttributes[name];
        const location = semanticToLocation[semantic];
        let copyCode;
        const element = processingOptions.getVertexElement(semantic);
        if (element) {
          const dataType = element.dataType;
          if (dataType !== TYPE_FLOAT32 && dataType !== TYPE_FLOAT16 && !element.normalize && !element.asInt) {
            const attribNumElements = _ShaderProcessor.getTypeCount(type);
            const newName = `_private_${name}`;
            copyCode = `vec${attribNumElements} ${name} = vec${attribNumElements}(${newName});
`;
            name = newName;
            const isSignedType = dataType === TYPE_INT8 || dataType === TYPE_INT16 || dataType === TYPE_INT32;
            if (attribNumElements === 1) {
              type = isSignedType ? "int" : "uint";
            } else {
              type = isSignedType ? `ivec${attribNumElements}` : `uvec${attribNumElements}`;
            }
          }
        }
        block += `layout(location = ${location}) in ${type} ${name};
`;
        if (copyCode) {
          block += copyCode;
        }
      }
    });
    return block;
  }
  static splitToWords(line) {
    line = line.replace(/\s+/g, " ").trim();
    return line.split(" ");
  }
  static cutOut(src, start, end, replacement) {
    return src.substring(0, start) + replacement + src.substring(end);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-shader.js
var WebgpuShader = class {
  constructor(shader) {
    this._vertexCode = null;
    this._fragmentCode = null;
    this._computeCode = null;
    this.vertexEntryPoint = "main";
    this.fragmentEntryPoint = "main";
    this.computeEntryPoint = "main";
    this.shader = shader;
    const definition = shader.definition;
    if (definition.shaderLanguage === SHADERLANGUAGE_WGSL) {
      var _definition$vshader, _definition$fshader, _definition$cshader;
      this._vertexCode = (_definition$vshader = definition.vshader) != null ? _definition$vshader : null;
      this._fragmentCode = (_definition$fshader = definition.fshader) != null ? _definition$fshader : null;
      this._computeCode = (_definition$cshader = definition.cshader) != null ? _definition$cshader : null;
      shader.meshUniformBufferFormat = definition.meshUniformBufferFormat;
      shader.meshBindGroupFormat = definition.meshBindGroupFormat;
      this.computeUniformBufferFormats = definition.computeUniformBufferFormats;
      this.computeBindGroupFormat = definition.computeBindGroupFormat;
      this.vertexEntryPoint = "vertexMain";
      this.fragmentEntryPoint = "fragmentMain";
      shader.ready = true;
    } else {
      if (definition.processingOptions) {
        this.process();
      }
    }
  }
  destroy(shader) {
    this._vertexCode = null;
    this._fragmentCode = null;
  }
  createShaderModule(code, shaderType) {
    const device = this.shader.device;
    const wgpu = device.wgpu;
    const shaderModule = wgpu.createShaderModule({
      code
    });
    return shaderModule;
  }
  getVertexShaderModule() {
    return this.createShaderModule(this._vertexCode, "Vertex");
  }
  getFragmentShaderModule() {
    return this.createShaderModule(this._fragmentCode, "Fragment");
  }
  getComputeShaderModule() {
    return this.createShaderModule(this._computeCode, "Compute");
  }
  process() {
    const shader = this.shader;
    const processed = ShaderProcessor.run(shader.device, shader.definition, shader);
    this._vertexCode = this.transpile(processed.vshader, "vertex", shader.definition.vshader);
    this._fragmentCode = this.transpile(processed.fshader, "fragment", shader.definition.fshader);
    if (!(this._vertexCode && this._fragmentCode)) {
      shader.failed = true;
    } else {
      shader.ready = true;
    }
    shader.meshUniformBufferFormat = processed.meshUniformBufferFormat;
    shader.meshBindGroupFormat = processed.meshBindGroupFormat;
  }
  transpile(src, shaderType, originalSrc) {
    try {
      const spirv = this.shader.device.glslang.compileGLSL(src, shaderType);
      const wgsl = this.shader.device.twgsl.convertSpirV2WGSL(spirv);
      return wgsl;
    } catch (err3) {
      console.error(`Failed to transpile webgl ${shaderType} shader [${this.shader.label}] to WebGPU while rendering ${void 0}, error:
 [${err3.stack}]`, {
        processed: src,
        original: originalSrc,
        shader: this.shader,
        error: err3,
        stack: err3.stack
      });
    }
  }
  get vertexCode() {
    return this._vertexCode;
  }
  get fragmentCode() {
    return this._fragmentCode;
  }
  loseContext() {
  }
  restoreContext(device, shader) {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/texture-utils.js
var TextureUtils = class _TextureUtils {
  static calcLevelDimension(dimension, mipLevel) {
    return Math.max(dimension >> mipLevel, 1);
  }
  static calcMipLevelsCount(width, height, depth = 1) {
    return 1 + Math.floor(Math.log2(Math.max(width, height, depth)));
  }
  static calcLevelGpuSize(width, height, depth, format) {
    var _pixelFormatInfo$get$, _pixelFormatInfo$get, _formatInfo$blockSize;
    const formatInfo = pixelFormatInfo.get(format);
    const pixelSize = (_pixelFormatInfo$get$ = (_pixelFormatInfo$get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get.size) != null ? _pixelFormatInfo$get$ : 0;
    if (pixelSize > 0) {
      return width * height * depth * pixelSize;
    }
    const blockSize = (_formatInfo$blockSize = formatInfo.blockSize) != null ? _formatInfo$blockSize : 0;
    let blockWidth = Math.floor((width + 3) / 4);
    const blockHeight = Math.floor((height + 3) / 4);
    const blockDepth = Math.floor((depth + 3) / 4);
    if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
      blockWidth = Math.max(Math.floor(blockWidth / 2), 1);
    }
    return blockWidth * blockHeight * blockDepth * blockSize;
  }
  static calcGpuSize(width, height, depth, format, mipmaps, cubemap) {
    let result = 0;
    while (1) {
      result += _TextureUtils.calcLevelGpuSize(width, height, depth, format);
      if (!mipmaps || width === 1 && height === 1 && depth === 1) {
        break;
      }
      width = Math.max(width >> 1, 1);
      height = Math.max(height >> 1, 1);
      depth = Math.max(depth >> 1, 1);
    }
    return result * (cubemap ? 6 : 1);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-texture.js
var gpuAddressModes = [];
gpuAddressModes[ADDRESS_REPEAT] = "repeat";
gpuAddressModes[ADDRESS_CLAMP_TO_EDGE] = "clamp-to-edge";
gpuAddressModes[ADDRESS_MIRRORED_REPEAT] = "mirror-repeat";
var gpuFilterModes = [];
gpuFilterModes[FILTER_NEAREST] = {
  level: "nearest",
  mip: "nearest"
};
gpuFilterModes[FILTER_LINEAR] = {
  level: "linear",
  mip: "nearest"
};
gpuFilterModes[FILTER_NEAREST_MIPMAP_NEAREST] = {
  level: "nearest",
  mip: "nearest"
};
gpuFilterModes[FILTER_NEAREST_MIPMAP_LINEAR] = {
  level: "nearest",
  mip: "linear"
};
gpuFilterModes[FILTER_LINEAR_MIPMAP_NEAREST] = {
  level: "linear",
  mip: "nearest"
};
gpuFilterModes[FILTER_LINEAR_MIPMAP_LINEAR] = {
  level: "linear",
  mip: "linear"
};
var dummyUse = (thingOne) => {
};
var WebgpuTexture = class {
  constructor(texture) {
    this.gpuTexture = void 0;
    this.view = void 0;
    this.samplers = [];
    this.desc = void 0;
    this.format = void 0;
    this.texture = texture;
    this.format = gpuTextureFormats[texture.format];
    this.create(texture.device);
  }
  create(device) {
    const texture = this.texture;
    const wgpu = device.wgpu;
    const mipLevelCount = texture.requiredMipLevels;
    this.desc = {
      size: {
        width: texture.width,
        height: texture.height,
        depthOrArrayLayers: texture.cubemap ? 6 : texture.array ? texture.arrayLength : 1
      },
      format: this.format,
      mipLevelCount,
      sampleCount: 1,
      dimension: texture.volume ? "3d" : "2d",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | (isCompressedPixelFormat(texture.format) ? 0 : GPUTextureUsage.RENDER_ATTACHMENT) | (texture.storage ? GPUTextureUsage.STORAGE_BINDING : 0)
    };
    this.gpuTexture = wgpu.createTexture(this.desc);
    let viewDescr;
    if (this.texture.format === PIXELFORMAT_DEPTHSTENCIL) {
      viewDescr = {
        format: "depth24plus",
        aspect: "depth-only"
      };
    }
    this.view = this.createView(viewDescr);
  }
  destroy(device) {
  }
  propertyChanged(flag) {
    this.samplers.length = 0;
  }
  getView(device) {
    this.uploadImmediate(device, this.texture);
    return this.view;
  }
  createView(viewDescr) {
    var _options$format, _options$dimension, _options$aspect, _options$baseMipLevel, _options$mipLevelCoun, _options$baseArrayLay, _options$arrayLayerCo;
    const options2 = viewDescr != null ? viewDescr : {};
    const textureDescr = this.desc;
    const texture = this.texture;
    const defaultViewDimension = () => {
      if (texture.cubemap) return "cube";
      if (texture.volume) return "3d";
      if (texture.array) return "2d-array";
      return "2d";
    };
    const desc = {
      format: (_options$format = options2.format) != null ? _options$format : textureDescr.format,
      dimension: (_options$dimension = options2.dimension) != null ? _options$dimension : defaultViewDimension(),
      aspect: (_options$aspect = options2.aspect) != null ? _options$aspect : "all",
      baseMipLevel: (_options$baseMipLevel = options2.baseMipLevel) != null ? _options$baseMipLevel : 0,
      mipLevelCount: (_options$mipLevelCoun = options2.mipLevelCount) != null ? _options$mipLevelCoun : textureDescr.mipLevelCount,
      baseArrayLayer: (_options$baseArrayLay = options2.baseArrayLayer) != null ? _options$baseArrayLay : 0,
      arrayLayerCount: (_options$arrayLayerCo = options2.arrayLayerCount) != null ? _options$arrayLayerCo : textureDescr.depthOrArrayLayers
    };
    const view = this.gpuTexture.createView(desc);
    return view;
  }
  getSampler(device, sampleType) {
    let sampler = this.samplers[sampleType];
    if (!sampler) {
      const texture = this.texture;
      const desc = {
        addressModeU: gpuAddressModes[texture.addressU],
        addressModeV: gpuAddressModes[texture.addressV],
        addressModeW: gpuAddressModes[texture.addressW]
      };
      if (!sampleType && texture.compareOnRead) {
        sampleType = SAMPLETYPE_DEPTH;
      }
      if (sampleType === SAMPLETYPE_DEPTH || sampleType === SAMPLETYPE_INT || sampleType === SAMPLETYPE_UINT) {
        desc.compare = "less";
        desc.magFilter = "linear";
        desc.minFilter = "linear";
      } else if (sampleType === SAMPLETYPE_UNFILTERABLE_FLOAT) {
        desc.magFilter = "nearest";
        desc.minFilter = "nearest";
        desc.mipmapFilter = "nearest";
      } else {
        const forceNearest = !device.textureFloatFilterable && (texture.format === PIXELFORMAT_RGBA32F || texture.format === PIXELFORMAT_RGBA16F);
        if (forceNearest || this.texture.format === PIXELFORMAT_DEPTHSTENCIL || isIntegerPixelFormat(this.texture.format)) {
          desc.magFilter = "nearest";
          desc.minFilter = "nearest";
          desc.mipmapFilter = "nearest";
        } else {
          desc.magFilter = gpuFilterModes[texture.magFilter].level;
          desc.minFilter = gpuFilterModes[texture.minFilter].level;
          desc.mipmapFilter = gpuFilterModes[texture.minFilter].mip;
        }
      }
      const allLinear = desc.minFilter === "linear" && desc.magFilter === "linear" && desc.mipmapFilter === "linear";
      desc.maxAnisotropy = allLinear ? math.clamp(Math.round(texture._anisotropy), 1, device.maxTextureAnisotropy) : 1;
      sampler = device.wgpu.createSampler(desc);
      this.samplers[sampleType] = sampler;
    }
    return sampler;
  }
  loseContext() {
  }
  uploadImmediate(device, texture) {
    if (texture._needsUpload || texture._needsMipmapsUpload) {
      this.uploadData(device);
      texture._needsUpload = false;
      texture._needsMipmapsUpload = false;
    }
  }
  uploadData(device) {
    const texture = this.texture;
    if (texture._levels) {
      let anyUploads = false;
      let anyLevelMissing = false;
      const requiredMipLevels = texture.requiredMipLevels;
      for (let mipLevel = 0; mipLevel < requiredMipLevels; mipLevel++) {
        const mipObject = texture._levels[mipLevel];
        if (mipObject) {
          if (texture.cubemap) {
            for (let face = 0; face < 6; face++) {
              const faceSource = mipObject[face];
              if (faceSource) {
                if (this.isExternalImage(faceSource)) {
                  this.uploadExternalImage(device, faceSource, mipLevel, face);
                  anyUploads = true;
                } else if (ArrayBuffer.isView(faceSource)) {
                  this.uploadTypedArrayData(device, faceSource, mipLevel, face);
                  anyUploads = true;
                } else ;
              } else {
                anyLevelMissing = true;
              }
            }
          } else if (texture._volume) ;
          else if (texture.array) {
            if (texture.arrayLength === mipObject.length) {
              for (let index = 0; index < texture._arrayLength; index++) {
                const arraySource = mipObject[index];
                if (this.isExternalImage(arraySource)) {
                  this.uploadExternalImage(device, arraySource, mipLevel, index);
                  anyUploads = true;
                } else if (ArrayBuffer.isView(arraySource)) {
                  this.uploadTypedArrayData(device, arraySource, mipLevel, index);
                  anyUploads = true;
                } else ;
              }
            } else {
              anyLevelMissing = true;
            }
          } else {
            if (this.isExternalImage(mipObject)) {
              this.uploadExternalImage(device, mipObject, mipLevel, 0);
              anyUploads = true;
            } else if (ArrayBuffer.isView(mipObject)) {
              this.uploadTypedArrayData(device, mipObject, mipLevel, 0);
              anyUploads = true;
            } else ;
          }
        } else {
          anyLevelMissing = true;
        }
      }
      if (anyUploads && anyLevelMissing && texture.mipmaps && !isCompressedPixelFormat(texture.format)) {
        device.mipmapRenderer.generate(this);
      }
      if (texture._gpuSize) {
        texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
      }
      texture._gpuSize = texture.gpuSize;
      texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
    }
  }
  isExternalImage(image) {
    return image instanceof ImageBitmap || image instanceof HTMLVideoElement || image instanceof HTMLCanvasElement || image instanceof OffscreenCanvas;
  }
  uploadExternalImage(device, image, mipLevel, index) {
    const src = {
      source: image,
      origin: [0, 0],
      flipY: false
    };
    const dst = {
      texture: this.gpuTexture,
      mipLevel,
      origin: [0, 0, index],
      aspect: "all"
    };
    const copySize = {
      width: this.desc.size.width,
      height: this.desc.size.height,
      depthOrArrayLayers: 1
    };
    device.submit();
    dummyUse(image instanceof HTMLCanvasElement && image.getContext("2d"));
    device.wgpu.queue.copyExternalImageToTexture(src, dst, copySize);
  }
  uploadTypedArrayData(device, data2, mipLevel, index) {
    const texture = this.texture;
    const wgpu = device.wgpu;
    const dest = {
      texture: this.gpuTexture,
      origin: [0, 0, index],
      mipLevel
    };
    const width = TextureUtils.calcLevelDimension(texture.width, mipLevel);
    const height = TextureUtils.calcLevelDimension(texture.height, mipLevel);
    TextureUtils.calcLevelGpuSize(width, height, 1, texture.format);
    const formatInfo = pixelFormatInfo.get(texture.format);
    let dataLayout;
    let size;
    if (formatInfo.size) {
      dataLayout = {
        offset: 0,
        bytesPerRow: formatInfo.size * width,
        rowsPerImage: height
      };
      size = {
        width,
        height
      };
    } else if (formatInfo.blockSize) {
      const blockDim = (size2) => {
        return Math.floor((size2 + 3) / 4);
      };
      dataLayout = {
        offset: 0,
        bytesPerRow: formatInfo.blockSize * blockDim(width),
        rowsPerImage: blockDim(height)
      };
      size = {
        width: Math.max(4, width),
        height: Math.max(4, height)
      };
    } else ;
    device.submit();
    wgpu.queue.writeTexture(dest, data2, dataLayout, size);
  }
  read(x2, y2, width, height, options2) {
    var _options$mipLevel, _options$face, _options$data, _options$immediate, _device$commandEncode;
    const mipLevel = (_options$mipLevel = options2.mipLevel) != null ? _options$mipLevel : 0;
    const face = (_options$face = options2.face) != null ? _options$face : 0;
    let data2 = (_options$data = options2.data) != null ? _options$data : null;
    const immediate = (_options$immediate = options2.immediate) != null ? _options$immediate : false;
    const texture = this.texture;
    const formatInfo = pixelFormatInfo.get(texture.format);
    const bytesPerRow = width * formatInfo.size;
    const paddedBytesPerRow = math.roundUp(bytesPerRow, 256);
    const size = paddedBytesPerRow * height;
    const device = texture.device;
    const stagingBuffer = device.createBufferImpl(BUFFERUSAGE_READ | BUFFERUSAGE_COPY_DST);
    stagingBuffer.allocate(device, size);
    const commandEncoder = (_device$commandEncode = device.commandEncoder) != null ? _device$commandEncode : device.wgpu.createCommandEncoder();
    const src = {
      texture: this.gpuTexture,
      mipLevel,
      origin: [x2, y2, face]
    };
    const dst = {
      buffer: stagingBuffer.buffer,
      offset: 0,
      bytesPerRow: paddedBytesPerRow
    };
    const copySize = {
      width,
      height,
      depthOrArrayLayers: 1
    };
    commandEncoder.copyTextureToBuffer(src, dst, copySize);
    if (!device.commandEncoder) {
      const cb = commandEncoder.finish();
      device.addCommandBuffer(cb);
    }
    return device.readBuffer(stagingBuffer, size, null, immediate).then((temp) => {
      var _data;
      (_data = data2) != null ? _data : data2 = new Uint8Array(height * bytesPerRow);
      for (let i = 0; i < height; i++) {
        const srcOffset = i * paddedBytesPerRow;
        const dstOffset = i * bytesPerRow;
        const sub = temp.subarray(srcOffset, srcOffset + bytesPerRow);
        data2.set(sub, dstOffset);
      }
      return data2;
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-uniform-buffer.js
var WebgpuUniformBuffer = class extends WebgpuBuffer {
  constructor(uniformBuffer) {
    super(BUFFERUSAGE_UNIFORM);
  }
  unlock(uniformBuffer) {
    const device = uniformBuffer.device;
    super.unlock(device, uniformBuffer.storageInt32.buffer);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-vertex-buffer.js
var WebgpuVertexBuffer = class extends WebgpuBuffer {
  constructor(vertexBuffer, format, options2) {
    super(BUFFERUSAGE_VERTEX | (options2 != null && options2.storage ? BUFFERUSAGE_STORAGE : 0));
  }
  unlock(vertexBuffer) {
    const device = vertexBuffer.device;
    super.unlock(device, vertexBuffer.storage);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/preprocessor.js
var KEYWORD2 = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension|include)/g;
var DEFINE = /define[ \t]+([^\n]+)\r?(?:\n|$)/g;
var EXTENSION = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g;
var UNDEF = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g;
var IF = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g;
var ENDIF = /(endif|else|elif)([ \t][^\r\n]+)?\r?(?:\n|$)/g;
var IDENTIFIER = /([\w-]+)/;
var DEFINED = /(!|\s)?defined\(([\w-]+)\)/;
var INVALID = /[><=|&+-]/g;
var INCLUDE = /include[ \t]+"([\w-]+)"\r?(?:\n|$)/g;
var Preprocessor = class _Preprocessor {
  static run(source, includes = /* @__PURE__ */ new Map(), stripUnusedColorAttachments = false) {
    source = this.stripComments(source);
    source = source.split(/\r?\n/).map((line) => line.trimEnd()).join("\n");
    const defines = /* @__PURE__ */ new Map();
    if (stripUnusedColorAttachments) {
      const counts = /* @__PURE__ */ new Map();
      const regex = /(pcFragColor[1-8])\b/g;
      const matches = source.match(regex);
      matches == null || matches.forEach((match) => {
        var _counts$get;
        const index = parseInt(match.charAt(match.length - 1), 10);
        counts.set(index, ((_counts$get = counts.get(index)) != null ? _counts$get : 0) + 1);
      });
      counts.forEach((count, index) => {
        if (count === 1) {
          defines.set(`REMOVE_COLOR_ATTACHMENT_${index}`, "");
        }
      });
    }
    source = this._preprocess(source, defines, includes);
    const intDefines = /* @__PURE__ */ new Map();
    defines.forEach((value, key) => {
      if (Number.isInteger(parseFloat(value)) && !value.includes(".")) {
        intDefines.set(key, value);
      }
    });
    source = this.stripComments(source);
    source = this.RemoveEmptyLines(source);
    source = this.processArraySize(source, intDefines);
    return source;
  }
  static stripComments(source) {
    return source.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "$1");
  }
  static processArraySize(source, intDefines) {
    if (source !== null) {
      intDefines.forEach((value, key) => {
        source = source.replace(new RegExp(`\\[${key}\\]`, "g"), `[${value}]`);
      });
    }
    return source;
  }
  static RemoveEmptyLines(source) {
    if (source !== null) {
      source = source.split(/\r?\n/).map((line) => line.trim() === "" ? "" : line).join("\n");
      source = source.replace(/(\n\n){3,}/g, "\n\n");
    }
    return source;
  }
  static _preprocess(source, defines = /* @__PURE__ */ new Map(), includes) {
    const originalSource = source;
    const stack = [];
    let error = false;
    let match;
    while ((match = KEYWORD2.exec(source)) !== null) {
      const keyword = match[1];
      switch (keyword) {
        case "define": {
          DEFINE.lastIndex = match.index;
          const define = DEFINE.exec(source);
          error || (error = define === null);
          const expression = define[1];
          IDENTIFIER.lastIndex = define.index;
          const identifierValue = IDENTIFIER.exec(expression);
          const identifier = identifierValue[1];
          let value = expression.substring(identifier.length).trim();
          if (value === "") value = "true";
          const keep = _Preprocessor._keep(stack);
          if (keep) {
            defines.set(identifier, value);
          }
          KEYWORD2.lastIndex = define.index + define[0].length;
          break;
        }
        case "undef": {
          UNDEF.lastIndex = match.index;
          const undef = UNDEF.exec(source);
          const identifier = undef[1].trim();
          const keep = _Preprocessor._keep(stack);
          if (keep) {
            defines.delete(identifier);
          }
          KEYWORD2.lastIndex = undef.index + undef[0].length;
          break;
        }
        case "extension": {
          EXTENSION.lastIndex = match.index;
          const extension = EXTENSION.exec(source);
          error || (error = extension === null);
          if (extension) {
            const identifier = extension[1];
            const keep = _Preprocessor._keep(stack);
            if (keep) {
              defines.set(identifier, "true");
            }
          }
          KEYWORD2.lastIndex = extension.index + extension[0].length;
          break;
        }
        case "ifdef":
        case "ifndef":
        case "if": {
          IF.lastIndex = match.index;
          const iff = IF.exec(source);
          const expression = iff[2];
          const evaluated = _Preprocessor.evaluate(expression, defines);
          error || (error = evaluated.error);
          let result = evaluated.result;
          if (keyword === "ifndef") {
            result = !result;
          }
          stack.push({
            anyKeep: result,
            keep: result,
            start: match.index,
            end: IF.lastIndex
          });
          KEYWORD2.lastIndex = iff.index + iff[0].length;
          break;
        }
        case "endif":
        case "else":
        case "elif": {
          ENDIF.lastIndex = match.index;
          const endif = ENDIF.exec(source);
          const blockInfo = stack.pop();
          const blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : "";
          source = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);
          KEYWORD2.lastIndex = blockInfo.start + blockCode.length;
          const endifCommand = endif[1];
          if (endifCommand === "else" || endifCommand === "elif") {
            let result = false;
            if (!blockInfo.anyKeep) {
              if (endifCommand === "else") {
                result = !blockInfo.keep;
              } else {
                const evaluated = _Preprocessor.evaluate(endif[2], defines);
                result = evaluated.result;
                error || (error = evaluated.error);
              }
            }
            stack.push({
              anyKeep: blockInfo.anyKeep || result,
              keep: result,
              start: KEYWORD2.lastIndex,
              end: KEYWORD2.lastIndex
            });
          }
          break;
        }
        case "include": {
          INCLUDE.lastIndex = match.index;
          const include = INCLUDE.exec(source);
          error || (error = include === null);
          const identifier = include[1].trim();
          const keep = _Preprocessor._keep(stack);
          if (keep) {
            const includeSource = includes == null ? void 0 : includes.get(identifier);
            if (includeSource !== void 0) {
              source = source.substring(0, include.index - 1) + includeSource + source.substring(INCLUDE.lastIndex);
              KEYWORD2.lastIndex = include.index;
            } else {
              console.error(`Include "${identifier}" not resolved while preprocessing a shader`, {
                source: originalSource
              });
              error = true;
            }
          }
          break;
        }
      }
    }
    if (error) {
      console.warn("Failed to preprocess shader: ", {
        source: originalSource
      });
      return originalSource;
    }
    return source;
  }
  static _keep(stack) {
    for (let i = 0; i < stack.length; i++) {
      if (!stack[i].keep) {
        return false;
      }
    }
    return true;
  }
  static evaluate(expression, defines) {
    const correct = INVALID.exec(expression) === null;
    let invert = false;
    const defined = DEFINED.exec(expression);
    if (defined) {
      invert = defined[1] === "!";
      expression = defined[2];
    }
    expression = expression.trim();
    let exists = defines.has(expression);
    if (invert) {
      exists = !exists;
    }
    return {
      result: exists,
      error: !correct
    };
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/frag/gles3.js
var gles3PS = `
#ifndef outType_0
#define outType_0 vec4
#endif
layout(location = 0) out highp outType_0 pc_fragColor;
#ifndef REMOVE_COLOR_ATTACHMENT_1
#if COLOR_ATTACHMENT_1
layout(location = 1) out highp outType_1 pc_fragColor1;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_2
#if COLOR_ATTACHMENT_2
layout(location = 2) out highp outType_2 pc_fragColor2;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_3
#if COLOR_ATTACHMENT_3
layout(location = 3) out highp outType_3 pc_fragColor3;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_4
#if COLOR_ATTACHMENT_4
layout(location = 4) out highp outType_4 pc_fragColor4;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_5
#if COLOR_ATTACHMENT_5
layout(location = 5) out highp outType_5 pc_fragColor5;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_6
#if COLOR_ATTACHMENT_6
layout(location = 6) out highp outType_6 pc_fragColor6;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_7
#if COLOR_ATTACHMENT_7
layout(location = 7) out highp outType_7 pc_fragColor7;
#endif
#endif
#define gl_FragColor pc_fragColor
#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7
#define varying in
#define texture2D texture
#define texture2DBias texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad
#define utexture2D texture
#define itexture2D texture
#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2DShadow name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name
#define GL2
`;

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/vert/gles3.js
var gles3VS = `
#define attribute in
#define varying out
#define texture2D texture
#define utexture2D texture
#define itexture2D texture
#define GL2
#define VERTEXSHADER
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name
`;

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/frag/webgpu.js
var webgpuPS = `
#extension GL_EXT_samplerless_texture_functions : require
#ifndef outType_0
#define outType_0 vec4
#endif
#ifndef outType_1
#define outType_1 vec4
#endif
#ifndef outType_2
#define outType_2 vec4
#endif
#ifndef outType_3
#define outType_3 vec4
#endif
#ifndef outType_4
#define outType_4 vec4
#endif
#ifndef outType_5
#define outType_5 vec4
#endif
#ifndef outType_6
#define outType_6 vec4
#endif
#ifndef outType_7
#define outType_7 vec4
#endif
layout(location = 0) out highp outType_0 pc_fragColor;
layout(location = 1) out highp outType_1 pc_fragColor1;
layout(location = 2) out highp outType_2 pc_fragColor2;
layout(location = 3) out highp outType_3 pc_fragColor3;
layout(location = 4) out highp outType_4 pc_fragColor4;
layout(location = 5) out highp outType_5 pc_fragColor5;
layout(location = 6) out highp outType_6 pc_fragColor6;
layout(location = 7) out highp outType_7 pc_fragColor7;
#define gl_FragColor pc_fragColor
#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7
#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)
#define texture2DLodEXT(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)
#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)
#define textureCubeLodEXT(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)
#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)
#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)
#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)
#define SHADOWMAP_PASS(name) name, name ## _sampler
#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT
#define GL2
#define WEBGPU
`;

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/vert/webgpu.js
var webgpuVS = `
#extension GL_EXT_samplerless_texture_functions : require
#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)
#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT
#define GL2
#define WEBGPU
#define VERTEXSHADER
#define gl_VertexID gl_VertexIndex
`;

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/frag/shared.js
var sharedFS = `
vec2 getGrabScreenPos(vec4 clipPos) {
	vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;
	#ifdef WEBGPU
		uv.y = 1.0 - uv.y;
	#endif
	return uv;
}
vec2 getImageEffectUV(vec2 uv) {
	#ifdef WEBGPU
		uv.y = 1.0 - uv.y;
	#endif
	return uv;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-utils.js
var _attrib2Semantic = {
  vertex_position: SEMANTIC_POSITION,
  vertex_normal: SEMANTIC_NORMAL,
  vertex_tangent: SEMANTIC_TANGENT,
  vertex_texCoord0: SEMANTIC_TEXCOORD0,
  vertex_texCoord1: SEMANTIC_TEXCOORD1,
  vertex_texCoord2: SEMANTIC_TEXCOORD2,
  vertex_texCoord3: SEMANTIC_TEXCOORD3,
  vertex_texCoord4: SEMANTIC_TEXCOORD4,
  vertex_texCoord5: SEMANTIC_TEXCOORD5,
  vertex_texCoord6: SEMANTIC_TEXCOORD6,
  vertex_texCoord7: SEMANTIC_TEXCOORD7,
  vertex_color: SEMANTIC_COLOR,
  vertex_boneIndices: SEMANTIC_BLENDINDICES,
  vertex_boneWeights: SEMANTIC_BLENDWEIGHT
};
var ShaderUtils = class _ShaderUtils {
  static createDefinition(device, options2) {
    var _options$name;
    const getDefines = (gpu, gl2, isVertex, options3) => {
      const deviceIntro = device.isWebGPU ? gpu : gl2;
      let attachmentsDefine = "";
      if (!isVertex) {
        var _options$fragmentOutp;
        let fragmentOutputTypes = (_options$fragmentOutp = options3.fragmentOutputTypes) != null ? _options$fragmentOutp : "vec4";
        if (!Array.isArray(fragmentOutputTypes)) {
          fragmentOutputTypes = [fragmentOutputTypes];
        }
        for (let i = 0; i < device.maxColorAttachments; i++) {
          var _fragmentOutputTypes$;
          attachmentsDefine += `#define COLOR_ATTACHMENT_${i}
`;
          const outType = (_fragmentOutputTypes$ = fragmentOutputTypes[i]) != null ? _fragmentOutputTypes$ : "vec4";
          attachmentsDefine += `#define outType_${i} ${outType}
`;
        }
      }
      return attachmentsDefine + deviceIntro;
    };
    const name = (_options$name = options2.name) != null ? _options$name : "Untitled";
    let vertCode;
    let fragCode;
    if (options2.shaderLanguage === SHADERLANGUAGE_WGSL) {
      vertCode = options2.vertexCode;
      fragCode = options2.fragmentCode;
    } else {
      vertCode = `${_ShaderUtils.versionCode(device) + getDefines(webgpuVS, gles3VS, true, options2) + _ShaderUtils.getDefinesCode(options2.vertexDefines) + _ShaderUtils.precisionCode(device)}
${sharedFS}${_ShaderUtils.getShaderNameCode(name)}${options2.vertexCode}`;
      fragCode = `${(options2.fragmentPreamble || "") + _ShaderUtils.versionCode(device) + getDefines(webgpuPS, gles3PS, false, options2) + _ShaderUtils.getDefinesCode(options2.fragmentDefines) + _ShaderUtils.precisionCode(device)}
${sharedFS}${_ShaderUtils.getShaderNameCode(name)}${options2.fragmentCode || _ShaderUtils.dummyFragmentCode()}`;
    }
    return {
      name,
      shaderLanguage: options2.shaderLanguage,
      attributes: options2.attributes,
      vshader: vertCode,
      vincludes: options2.vertexIncludes,
      fincludes: options2.fragmentIncludes,
      fshader: fragCode,
      useTransformFeedback: options2.useTransformFeedback,
      meshUniformBufferFormat: options2.meshUniformBufferFormat,
      meshBindGroupFormat: options2.meshBindGroupFormat
    };
  }
  static getDefinesCode(defines) {
    let code = "";
    defines == null || defines.forEach((value, key) => {
      code += `#define ${key} ${value}
`;
    });
    return code;
  }
  static getShaderNameCode(name) {
    return `#define SHADER_NAME ${name}
`;
  }
  static dummyFragmentCode() {
    return "void main(void) {gl_FragColor = vec4(0.0);}";
  }
  static versionCode(device) {
    return device.isWebGPU ? "#version 450\n" : "#version 300 es\n";
  }
  static precisionCode(device, forcePrecision) {
    if (forcePrecision && forcePrecision !== "highp" && forcePrecision !== "mediump" && forcePrecision !== "lowp") {
      forcePrecision = null;
    }
    if (forcePrecision) {
      if (forcePrecision === "highp" && device.maxPrecision !== "highp") {
        forcePrecision = "mediump";
      }
      if (forcePrecision === "mediump" && device.maxPrecision === "lowp") {
        forcePrecision = "lowp";
      }
    }
    const precision = forcePrecision ? forcePrecision : device.precision;
    const code = `
						precision ${precision} float;
						precision ${precision} int;
						precision ${precision} usampler2D;
						precision ${precision} isampler2D;
						precision ${precision} sampler2DShadow;
						precision ${precision} sampler2DArray;
				`;
    return code;
  }
  static collectAttributes(vsCode2) {
    const attribs = {};
    let attrs = 0;
    let found = vsCode2.indexOf("attribute");
    while (found >= 0) {
      if (found > 0 && vsCode2[found - 1] === "/") break;
      let ignore = false;
      if (found > 0) {
        let startOfLine = vsCode2.lastIndexOf("\n", found);
        startOfLine = startOfLine !== -1 ? startOfLine + 1 : 0;
        const lineStartString = vsCode2.substring(startOfLine, found);
        if (lineStartString.includes("#")) {
          ignore = true;
        }
      }
      if (!ignore) {
        const endOfLine = vsCode2.indexOf(";", found);
        const startOfAttribName = vsCode2.lastIndexOf(" ", endOfLine);
        const attribName = vsCode2.substring(startOfAttribName + 1, endOfLine);
        if (attribs[attribName]) ;
        else {
          const semantic = _attrib2Semantic[attribName];
          if (semantic !== void 0) {
            attribs[attribName] = semantic;
          } else {
            attribs[attribName] = `ATTR${attrs}`;
            attrs++;
          }
        }
      }
      found = vsCode2.indexOf("attribute", found + 1);
    }
    return attribs;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader.js
var id5 = 0;
var Shader = class {
  constructor(graphicsDevice, definition) {
    this.meshUniformBufferFormat = void 0;
    this.meshBindGroupFormat = void 0;
    this.id = id5++;
    this.device = graphicsDevice;
    this.definition = definition;
    this.name = definition.name || "Untitled";
    this.init();
    if (definition.cshader) ;
    else {
      var _definition$attribute;
      definition.vshader = Preprocessor.run(definition.vshader, definition.vincludes);
      (_definition$attribute = definition.attributes) != null ? _definition$attribute : definition.attributes = ShaderUtils.collectAttributes(definition.vshader);
      const stripUnusedColorAttachments = graphicsDevice.isWebGL2 && (platform.name === "osx" || platform.name === "ios");
      definition.fshader = Preprocessor.run(definition.fshader, definition.fincludes, stripUnusedColorAttachments);
    }
    this.impl = graphicsDevice.createShaderImpl(this);
  }
  init() {
    this.ready = false;
    this.failed = false;
  }
  get label() {
    return `Shader Id ${this.id} ${this.name}`;
  }
  destroy() {
    this.device.onDestroyShader(this);
    this.impl.destroy(this);
  }
  loseContext() {
    this.init();
    this.impl.loseContext();
  }
  restoreContext() {
    this.impl.restoreContext(this.device, this);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/dynamic-buffers.js
var UsedBuffer = class {
  constructor() {
    this.gpuBuffer = void 0;
    this.stagingBuffer = void 0;
    this.offset = void 0;
    this.size = void 0;
  }
};
var DynamicBufferAllocation = class {
  constructor() {
    this.storage = void 0;
    this.gpuBuffer = void 0;
    this.offset = void 0;
  }
};
var DynamicBuffers = class {
  constructor(device, bufferSize, bufferAlignment) {
    this.bufferSize = void 0;
    this.gpuBuffers = [];
    this.stagingBuffers = [];
    this.usedBuffers = [];
    this.activeBuffer = null;
    this.device = device;
    this.bufferSize = bufferSize;
    this.bufferAlignment = bufferAlignment;
  }
  destroy() {
    this.gpuBuffers.forEach((gpuBuffer) => {
      gpuBuffer.destroy(this.device);
    });
    this.gpuBuffers = null;
    this.stagingBuffers.forEach((stagingBuffer) => {
      stagingBuffer.destroy(this.device);
    });
    this.stagingBuffers = null;
    this.usedBuffers = null;
    this.activeBuffer = null;
  }
  alloc(allocation, size) {
    if (this.activeBuffer) {
      const _alignedStart = math.roundUp(this.activeBuffer.size, this.bufferAlignment);
      const space = this.bufferSize - _alignedStart;
      if (space < size) {
        this.scheduleSubmit();
      }
    }
    if (!this.activeBuffer) {
      let gpuBuffer = this.gpuBuffers.pop();
      if (!gpuBuffer) {
        gpuBuffer = this.createBuffer(this.device, this.bufferSize, false);
      }
      let stagingBuffer = this.stagingBuffers.pop();
      if (!stagingBuffer) {
        stagingBuffer = this.createBuffer(this.device, this.bufferSize, true);
      }
      this.activeBuffer = new UsedBuffer();
      this.activeBuffer.stagingBuffer = stagingBuffer;
      this.activeBuffer.gpuBuffer = gpuBuffer;
      this.activeBuffer.offset = 0;
      this.activeBuffer.size = 0;
    }
    const activeBuffer = this.activeBuffer;
    const alignedStart = math.roundUp(activeBuffer.size, this.bufferAlignment);
    allocation.gpuBuffer = activeBuffer.gpuBuffer;
    allocation.offset = alignedStart;
    allocation.storage = activeBuffer.stagingBuffer.alloc(alignedStart, size);
    activeBuffer.size = alignedStart + size;
  }
  scheduleSubmit() {
    if (this.activeBuffer) {
      this.usedBuffers.push(this.activeBuffer);
      this.activeBuffer = null;
    }
  }
  submit() {
    this.scheduleSubmit();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/uniform-buffer.js
var _updateFunctions = [];
_updateFunctions[UNIFORMTYPE_FLOAT] = function(uniformBuffer, value, offset) {
  const dst = uniformBuffer.storageFloat32;
  dst[offset] = value;
};
_updateFunctions[UNIFORMTYPE_VEC2] = (uniformBuffer, value, offset) => {
  const dst = uniformBuffer.storageFloat32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
};
_updateFunctions[UNIFORMTYPE_VEC3] = (uniformBuffer, value, offset) => {
  const dst = uniformBuffer.storageFloat32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
  dst[offset + 2] = value[2];
};
_updateFunctions[UNIFORMTYPE_VEC4] = (uniformBuffer, value, offset) => {
  const dst = uniformBuffer.storageFloat32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
  dst[offset + 2] = value[2];
  dst[offset + 3] = value[3];
};
_updateFunctions[UNIFORMTYPE_INT] = function(uniformBuffer, value, offset) {
  const dst = uniformBuffer.storageInt32;
  dst[offset] = value;
};
_updateFunctions[UNIFORMTYPE_IVEC2] = function(uniformBuffer, value, offset) {
  const dst = uniformBuffer.storageInt32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
};
_updateFunctions[UNIFORMTYPE_IVEC3] = function(uniformBuffer, value, offset) {
  const dst = uniformBuffer.storageInt32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
  dst[offset + 2] = value[2];
};
_updateFunctions[UNIFORMTYPE_IVEC4] = function(uniformBuffer, value, offset) {
  const dst = uniformBuffer.storageInt32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
  dst[offset + 2] = value[2];
  dst[offset + 3] = value[3];
};
_updateFunctions[UNIFORMTYPE_MAT2] = (uniformBuffer, value, offset) => {
  const dst = uniformBuffer.storageFloat32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
  dst[offset + 4] = value[2];
  dst[offset + 5] = value[3];
  dst[offset + 8] = value[4];
  dst[offset + 9] = value[5];
};
_updateFunctions[UNIFORMTYPE_MAT3] = (uniformBuffer, value, offset) => {
  const dst = uniformBuffer.storageFloat32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
  dst[offset + 2] = value[2];
  dst[offset + 4] = value[3];
  dst[offset + 5] = value[4];
  dst[offset + 6] = value[5];
  dst[offset + 8] = value[6];
  dst[offset + 9] = value[7];
  dst[offset + 10] = value[8];
};
_updateFunctions[UNIFORMTYPE_FLOATARRAY] = function(uniformBuffer, value, offset, count) {
  const dst = uniformBuffer.storageFloat32;
  for (let i = 0; i < count; i++) {
    dst[offset + i * 4] = value[i];
  }
};
_updateFunctions[UNIFORMTYPE_VEC2ARRAY] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageFloat32;
  for (let i = 0; i < count; i++) {
    dst[offset + i * 4] = value[i * 2];
    dst[offset + i * 4 + 1] = value[i * 2 + 1];
  }
};
_updateFunctions[UNIFORMTYPE_VEC3ARRAY] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageFloat32;
  for (let i = 0; i < count; i++) {
    dst[offset + i * 4] = value[i * 3];
    dst[offset + i * 4 + 1] = value[i * 3 + 1];
    dst[offset + i * 4 + 2] = value[i * 3 + 2];
  }
};
_updateFunctions[UNIFORMTYPE_UINT] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageUint32;
  dst[offset] = value;
};
_updateFunctions[UNIFORMTYPE_UVEC2] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageUint32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
};
_updateFunctions[UNIFORMTYPE_UVEC3] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageUint32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
  dst[offset + 2] = value[2];
};
_updateFunctions[UNIFORMTYPE_UVEC4] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageUint32;
  dst[offset] = value[0];
  dst[offset + 1] = value[1];
  dst[offset + 2] = value[2];
  dst[offset + 3] = value[3];
};
_updateFunctions[UNIFORMTYPE_INTARRAY] = function(uniformBuffer, value, offset, count) {
  const dst = uniformBuffer.storageInt32;
  for (let i = 0; i < count; i++) {
    dst[offset + i * 4] = value[i];
  }
};
_updateFunctions[UNIFORMTYPE_BOOLARRAY] = _updateFunctions[UNIFORMTYPE_INTARRAY];
_updateFunctions[UNIFORMTYPE_UINTARRAY] = function(uniformBuffer, value, offset, count) {
  const dst = uniformBuffer.storageUint32;
  for (let i = 0; i < count; i++) {
    dst[offset + i * 4] = value[i];
  }
};
_updateFunctions[UNIFORMTYPE_IVEC2ARRAY] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageInt32;
  for (let i = 0; i < count; i++) {
    dst[offset + i * 4] = value[i * 2];
    dst[offset + i * 4 + 1] = value[i * 2 + 1];
  }
};
_updateFunctions[UNIFORMTYPE_BVEC2ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC2ARRAY];
_updateFunctions[UNIFORMTYPE_UVEC2ARRAY] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageUint32;
  for (let i = 0; i < count; i++) {
    dst[offset + i * 4] = value[i * 2];
    dst[offset + i * 4 + 1] = value[i * 2 + 1];
  }
};
_updateFunctions[UNIFORMTYPE_IVEC3ARRAY] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageInt32;
  for (let i = 0; i < count; i++) {
    dst[offset + i * 4] = value[i * 3];
    dst[offset + i * 4 + 1] = value[i * 3 + 1];
    dst[offset + i * 4 + 2] = value[i * 3 + 2];
  }
};
_updateFunctions[UNIFORMTYPE_BVEC3ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC3ARRAY];
_updateFunctions[UNIFORMTYPE_UVEC3ARRAY] = (uniformBuffer, value, offset, count) => {
  const dst = uniformBuffer.storageUint32;
  for (let i = 0; i < count; i++) {
    dst[offset + i * 4] = value[i * 3];
    dst[offset + i * 4 + 1] = value[i * 3 + 1];
    dst[offset + i * 4 + 2] = value[i * 3 + 2];
  }
};
var UniformBuffer = class {
  constructor(graphicsDevice, format, persistent = true) {
    this.device = void 0;
    this.persistent = void 0;
    this.allocation = void 0;
    this.storageFloat32 = void 0;
    this.storageInt32 = void 0;
    this.storageUint32 = void 0;
    this.renderVersionDirty = 0;
    this.device = graphicsDevice;
    this.format = format;
    this.persistent = persistent;
    if (persistent) {
      this.impl = graphicsDevice.createUniformBufferImpl(this);
      const storage = new ArrayBuffer(format.byteSize);
      this.assignStorage(new Int32Array(storage));
      graphicsDevice._vram.ub += this.format.byteSize;
    } else {
      this.allocation = new DynamicBufferAllocation();
    }
  }
  destroy() {
    if (this.persistent) {
      const device = this.device;
      this.impl.destroy(device);
      device._vram.ub -= this.format.byteSize;
    }
  }
  get offset() {
    return this.persistent ? 0 : this.allocation.offset;
  }
  assignStorage(storage) {
    this.storageInt32 = storage;
    this.storageUint32 = new Uint32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);
    this.storageFloat32 = new Float32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);
  }
  loseContext() {
    var _this$impl;
    (_this$impl = this.impl) == null || _this$impl.loseContext();
  }
  setUniform(uniformFormat, value) {
    const offset = uniformFormat.offset;
    if (value !== null && value !== void 0) {
      const updateFunction = _updateFunctions[uniformFormat.updateType];
      if (updateFunction) {
        updateFunction(this, value, offset, uniformFormat.count);
      } else {
        this.storageFloat32.set(value, offset);
      }
    }
  }
  set(name, value) {
    const uniformFormat = this.format.map.get(name);
    if (uniformFormat) {
      this.setUniform(uniformFormat, value);
    }
  }
  startUpdate(dynamicBindGroup) {
    if (!this.persistent) {
      const allocation = this.allocation;
      const oldGpuBuffer = allocation.gpuBuffer;
      this.device.dynamicBuffers.alloc(allocation, this.format.byteSize);
      this.assignStorage(allocation.storage);
      if (dynamicBindGroup) {
        dynamicBindGroup.bindGroup = allocation.gpuBuffer.getBindGroup(this);
        dynamicBindGroup.offsets[0] = allocation.offset;
      }
      if (oldGpuBuffer !== allocation.gpuBuffer) {
        this.renderVersionDirty = this.device.renderVersion;
      }
    }
  }
  endUpdate() {
    if (this.persistent) {
      this.impl.unlock(this);
    } else {
      this.storageFloat32 = null;
      this.storageInt32 = null;
    }
  }
  update(dynamicBindGroup) {
    this.startUpdate(dynamicBindGroup);
    const uniforms = this.format.uniforms;
    for (let i = 0; i < uniforms.length; i++) {
      const value = uniforms[i].scopeId.value;
      this.setUniform(uniforms[i], value);
    }
    this.endUpdate();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-clear-renderer.js
var primitive = {
  type: PRIMITIVE_TRISTRIP,
  base: 0,
  count: 4,
  indexed: false
};
var WebgpuClearRenderer = class {
  constructor(device) {
    const code = `

						struct ub_mesh {
								color : vec4f,
								depth: f32
						}

						@group(2) @binding(0) var<uniform> ubMesh : ub_mesh;

						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f
						}

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
								var output : VertexOutput;
								output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);
								return output;
						}

						@fragment
						fn fragmentMain() -> @location(0) vec4f {
								return ubMesh.color;
						}
				`;
    this.shader = new Shader(device, {
      name: "WebGPUClearRendererShader",
      shaderLanguage: SHADERLANGUAGE_WGSL,
      vshader: code,
      fshader: code
    });
    this.uniformBuffer = new UniformBuffer(device, new UniformBufferFormat(device, [new UniformFormat("color", UNIFORMTYPE_VEC4), new UniformFormat("depth", UNIFORMTYPE_FLOAT)]), false);
    this.dynamicBindGroup = new DynamicBindGroup();
    this.colorData = new Float32Array(4);
  }
  destroy() {
    this.shader.destroy();
    this.shader = null;
    this.uniformBuffer.destroy();
    this.uniformBuffer = null;
  }
  clear(device, renderTarget, options2, defaultOptions) {
    var _options$flags;
    options2 = options2 || defaultOptions;
    const flags = (_options$flags = options2.flags) != null ? _options$flags : defaultOptions.flags;
    if (flags !== 0) {
      const {
        uniformBuffer,
        dynamicBindGroup
      } = this;
      uniformBuffer.startUpdate(dynamicBindGroup);
      device.setBindGroup(BINDGROUP_MESH_UB, dynamicBindGroup.bindGroup, dynamicBindGroup.offsets);
      device.setBindGroup(BINDGROUP_MESH, device.emptyBindGroup);
      if (flags & CLEARFLAG_COLOR && (renderTarget.colorBuffer || renderTarget.impl.assignedColorTexture)) {
        var _options$color;
        const color = (_options$color = options2.color) != null ? _options$color : defaultOptions.color;
        this.colorData.set(color);
        device.setBlendState(BlendState.NOBLEND);
      } else {
        device.setBlendState(BlendState.NOWRITE);
      }
      uniformBuffer.set("color", this.colorData);
      if (flags & CLEARFLAG_DEPTH && renderTarget.depth) {
        var _options$depth;
        const depth = (_options$depth = options2.depth) != null ? _options$depth : defaultOptions.depth;
        uniformBuffer.set("depth", depth);
        device.setDepthState(DepthState.WRITEDEPTH);
      } else {
        uniformBuffer.set("depth", 1);
        device.setDepthState(DepthState.NODEPTH);
      }
      if (flags & CLEARFLAG_STENCIL && renderTarget.stencil) ;
      uniformBuffer.endUpdate();
      device.setCullMode(CULLFACE_NONE);
      device.setShader(this.shader);
      device.draw(primitive);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-mipmap-renderer.js
var WebgpuMipmapRenderer = class {
  constructor(device) {
    this.device = void 0;
    this.device = device;
    const code = `
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
								@location(0) texCoord : vec2f
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var imgSampler : sampler;
						@group(0) @binding(1) var img : texture_2d<f32>;

						@fragment
						fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
							return textureSample(img, imgSampler, texCoord);
						}
				`;
    this.shader = new Shader(device, {
      name: "WebGPUMipmapRendererShader",
      shaderLanguage: SHADERLANGUAGE_WGSL,
      vshader: code,
      fshader: code
    });
    this.minSampler = device.wgpu.createSampler({
      minFilter: "linear"
    });
  }
  destroy() {
    this.shader.destroy();
    this.shader = null;
  }
  generate(webgpuTexture) {
    var _device$commandEncode;
    const textureDescr = webgpuTexture.desc;
    if (textureDescr.mipLevelCount <= 1) {
      return;
    }
    if (webgpuTexture.texture.volume) {
      return;
    }
    const device = this.device;
    const wgpu = device.wgpu;
    const webgpuShader = this.shader.impl;
    const pipeline = wgpu.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: webgpuShader.getVertexShaderModule(),
        entryPoint: webgpuShader.vertexEntryPoint
      },
      fragment: {
        module: webgpuShader.getFragmentShaderModule(),
        entryPoint: webgpuShader.fragmentEntryPoint,
        targets: [{
          format: textureDescr.format
        }]
      },
      primitive: {
        topology: "triangle-strip"
      }
    });
    const texture = webgpuTexture.texture;
    const numFaces = texture.cubemap ? 6 : texture.array ? texture.arrayLength : 1;
    const srcViews = [];
    for (let face = 0; face < numFaces; face++) {
      srcViews.push(webgpuTexture.createView({
        dimension: "2d",
        baseMipLevel: 0,
        mipLevelCount: 1,
        baseArrayLayer: face
      }));
    }
    const commandEncoder = (_device$commandEncode = device.commandEncoder) != null ? _device$commandEncode : wgpu.createCommandEncoder();
    for (let i = 1; i < textureDescr.mipLevelCount; i++) {
      for (let face = 0; face < numFaces; face++) {
        const dstView = webgpuTexture.createView({
          dimension: "2d",
          baseMipLevel: i,
          mipLevelCount: 1,
          baseArrayLayer: face
        });
        const passEncoder = commandEncoder.beginRenderPass({
          colorAttachments: [{
            view: dstView,
            loadOp: "clear",
            storeOp: "store"
          }]
        });
        const bindGroup = wgpu.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [{
            binding: 0,
            resource: this.minSampler
          }, {
            binding: 1,
            resource: srcViews[face]
          }]
        });
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.draw(4);
        passEncoder.end();
        srcViews[face] = dstView;
      }
    }
    if (!device.commandEncoder) {
      const cb = commandEncoder.finish();
      device.addCommandBuffer(cb);
    }
    device.pipeline = null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/dynamic-buffer.js
var DynamicBuffer = class {
  constructor(device) {
    this.device = void 0;
    this.bindGroupCache = /* @__PURE__ */ new Map();
    this.device = device;
    this.bindGroupFormat = new BindGroupFormat(this.device, [new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)]);
  }
  getBindGroup(ub) {
    const ubSize = ub.format.byteSize;
    let bindGroup = this.bindGroupCache.get(ubSize);
    if (!bindGroup) {
      bindGroup = new BindGroup(this.device, this.bindGroupFormat, ub);
      bindGroup.update();
      this.bindGroupCache.set(ubSize, bindGroup);
    }
    return bindGroup;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-dynamic-buffer.js
var WebgpuDynamicBuffer = class extends DynamicBuffer {
  constructor(device, size, isStaging) {
    super(device);
    this.buffer = null;
    this.mappedRange = null;
    this.buffer = device.wgpu.createBuffer({
      size,
      usage: isStaging ? GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC : GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: isStaging
    });
    if (isStaging) {
      this.onAvailable();
    }
    device._vram.ub += size;
  }
  destroy(device) {
    device._vram.ub -= this.buffer.size;
    this.buffer.destroy();
    this.buffer = null;
  }
  onAvailable() {
    this.mappedRange = this.buffer.getMappedRange();
  }
  alloc(offset, size) {
    return new Int32Array(this.mappedRange, offset, size / 4);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-dynamic-buffers.js
var WebgpuDynamicBuffers = class extends DynamicBuffers {
  constructor(...args) {
    super(...args);
    this.pendingStagingBuffers = [];
  }
  createBuffer(device, size, isStaging) {
    return new WebgpuDynamicBuffer(device, size, isStaging);
  }
  submit() {
    super.submit();
    const count = this.usedBuffers.length;
    if (count) {
      const device = this.device;
      const gpuBuffers = this.gpuBuffers;
      const commandEncoder = device.wgpu.createCommandEncoder();
      for (let i = count - 1; i >= 0; i--) {
        const usedBuffer = this.usedBuffers[i];
        const {
          stagingBuffer,
          gpuBuffer,
          offset,
          size
        } = usedBuffer;
        const src = stagingBuffer.buffer;
        src.unmap();
        commandEncoder.copyBufferToBuffer(src, offset, gpuBuffer.buffer, offset, size);
        gpuBuffers.push(gpuBuffer);
      }
      const cb = commandEncoder.finish();
      device.addCommandBuffer(cb, true);
      for (let i = 0; i < count; i++) {
        const stagingBuffer = this.usedBuffers[i].stagingBuffer;
        this.pendingStagingBuffers.push(stagingBuffer);
      }
      this.usedBuffers.length = 0;
    }
  }
  onCommandBuffersSubmitted() {
    const count = this.pendingStagingBuffers.length;
    if (count) {
      for (let i = 0; i < count; i++) {
        const stagingBuffer = this.pendingStagingBuffers[i];
        stagingBuffer.buffer.mapAsync(GPUMapMode.WRITE).then(() => {
          if (this.stagingBuffers) {
            stagingBuffer.onAvailable();
            this.stagingBuffers.push(stagingBuffer);
          }
        });
      }
      this.pendingStagingBuffers.length = 0;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/gpu-profiler.js
var GpuProfiler = class {
  constructor() {
    this.frameAllocations = [];
    this.pastFrameAllocations = /* @__PURE__ */ new Map();
    this._enabled = false;
    this._enableRequest = false;
    this._frameTime = 0;
  }
  loseContext() {
    this.pastFrameAllocations.clear();
  }
  set enabled(value) {
    this._enableRequest = value;
  }
  get enabled() {
    return this._enableRequest;
  }
  processEnableRequest() {
    if (this._enableRequest !== this._enabled) {
      this._enabled = this._enableRequest;
      if (!this._enabled) {
        this._frameTime = 0;
      }
    }
  }
  request(renderVersion) {
    this.pastFrameAllocations.set(renderVersion, this.frameAllocations);
    this.frameAllocations = [];
  }
  report(renderVersion, timings) {
    if (timings) {
      const allocations = this.pastFrameAllocations.get(renderVersion);
      if (timings.length > 0) {
        this._frameTime = timings[0];
      }
      if (Tracing.get(TRACEID_GPU_TIMINGS)) {
        for (let i = 0; i < allocations.length; ++i) {
          allocations[i];
        }
      }
    }
    this.pastFrameAllocations.delete(renderVersion);
  }
  getSlot(name) {
    const slot = this.frameAllocations.length;
    this.frameAllocations.push(name);
    return slot;
  }
  get slotCount() {
    return this.frameAllocations.length;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-query-set.js
var WebgpuQuerySet = class {
  constructor(device, isTimestamp, capacity) {
    this.querySet = void 0;
    this.stagingBuffers = [];
    this.activeStagingBuffer = null;
    this.bytesPerSlot = void 0;
    this.device = device;
    this.capacity = capacity;
    this.bytesPerSlot = isTimestamp ? 8 : 4;
    const wgpu = device.wgpu;
    this.querySet = wgpu.createQuerySet({
      type: isTimestamp ? "timestamp" : "occlusion",
      count: capacity
    });
    this.queryBuffer = wgpu.createBuffer({
      size: this.bytesPerSlot * capacity,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
  }
  destroy() {
    var _this$querySet, _this$queryBuffer;
    (_this$querySet = this.querySet) == null || _this$querySet.destroy();
    this.querySet = null;
    (_this$queryBuffer = this.queryBuffer) == null || _this$queryBuffer.destroy();
    this.queryBuffer = null;
    this.activeStagingBuffer = null;
    this.stagingBuffers.forEach((stagingBuffer) => {
      stagingBuffer.destroy();
    });
    this.stagingBuffers = null;
  }
  getStagingBuffer() {
    let stagingBuffer = this.stagingBuffers.pop();
    if (!stagingBuffer) {
      stagingBuffer = this.device.wgpu.createBuffer({
        size: this.queryBuffer.size,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
    }
    return stagingBuffer;
  }
  resolve(count) {
    const device = this.device;
    const commandEncoder = device.wgpu.createCommandEncoder();
    commandEncoder.resolveQuerySet(this.querySet, 0, count, this.queryBuffer, 0);
    const activeStagingBuffer = this.getStagingBuffer();
    this.activeStagingBuffer = activeStagingBuffer;
    commandEncoder.copyBufferToBuffer(this.queryBuffer, 0, activeStagingBuffer, 0, this.bytesPerSlot * count);
    const cb = commandEncoder.finish();
    device.addCommandBuffer(cb);
  }
  request(count, renderVersion) {
    const stagingBuffer = this.activeStagingBuffer;
    this.activeStagingBuffer = null;
    return stagingBuffer.mapAsync(GPUMapMode.READ).then(() => {
      var _this$stagingBuffers;
      const srcTimings = new BigInt64Array(stagingBuffer.getMappedRange());
      const timings = [];
      for (let i = 0; i < count; i++) {
        timings.push(Number(srcTimings[i * 2 + 1] - srcTimings[i * 2]) * 1e-6);
      }
      stagingBuffer.unmap();
      (_this$stagingBuffers = this.stagingBuffers) == null || _this$stagingBuffers.push(stagingBuffer);
      return {
        renderVersion,
        timings
      };
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-gpu-profiler.js
var WebgpuGpuProfiler = class extends GpuProfiler {
  constructor(device) {
    super();
    this.device = void 0;
    this.frameGPUMarkerSlot = void 0;
    this.device = device;
    this.timestampQueriesSet = device.supportsTimestampQuery ? new WebgpuQuerySet(device, true, 512) : null;
  }
  destroy() {
    var _this$timestampQuerie;
    (_this$timestampQuerie = this.timestampQueriesSet) == null || _this$timestampQuerie.destroy();
    this.timestampQueriesSet = null;
  }
  frameStart() {
    this.processEnableRequest();
  }
  frameEnd() {
    if (this._enabled) {
      var _this$timestampQuerie2;
      (_this$timestampQuerie2 = this.timestampQueriesSet) == null || _this$timestampQuerie2.resolve(this.slotCount * 2);
    }
  }
  request() {
    if (this._enabled) {
      var _this$timestampQuerie3;
      const renderVersion = this.device.renderVersion;
      (_this$timestampQuerie3 = this.timestampQueriesSet) == null || _this$timestampQuerie3.request(this.slotCount, renderVersion).then((results) => {
        this.report(results.renderVersion, results.timings);
      });
      super.request(renderVersion);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-resolver.js
var WebgpuResolver = class {
  constructor(device) {
    this.device = void 0;
    this.pipelineCache = /* @__PURE__ */ new Map();
    this.device = device;
    const code = `
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var img : texture_depth_multisampled_2d;

						@fragment
						fn fragmentMain(@builtin(position) fragColor: vec4f) -> @location(0) vec4f {
								// load th depth value from sample index 0
								var depth = textureLoad(img, vec2i(fragColor.xy), 0u);
								return vec4<f32>(depth, 0.0, 0.0, 0.0);
						}
				`;
    this.shader = new Shader(device, {
      name: "WebGPUResolverDepthShader",
      shaderLanguage: SHADERLANGUAGE_WGSL,
      vshader: code,
      fshader: code
    });
  }
  destroy() {
    this.shader.destroy();
    this.shader = null;
    this.pipelineCache = null;
  }
  getPipeline(format) {
    let pipeline = this.pipelineCache.get(format);
    if (!pipeline) {
      pipeline = this.createPipeline(format);
      this.pipelineCache.set(format, pipeline);
    }
    return pipeline;
  }
  createPipeline(format) {
    const webgpuShader = this.shader.impl;
    const pipeline = this.device.wgpu.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: webgpuShader.getVertexShaderModule(),
        entryPoint: webgpuShader.vertexEntryPoint
      },
      fragment: {
        module: webgpuShader.getFragmentShaderModule(),
        entryPoint: webgpuShader.fragmentEntryPoint,
        targets: [{
          format
        }]
      },
      primitive: {
        topology: "triangle-strip"
      }
    });
    return pipeline;
  }
  resolveDepth(commandEncoder, sourceTexture, destinationTexture) {
    const device = this.device;
    const wgpu = device.wgpu;
    const pipeline = this.getPipeline(destinationTexture.format);
    const numFaces = sourceTexture.depthOrArrayLayers;
    for (let face = 0; face < numFaces; face++) {
      const srcView = sourceTexture.createView({
        dimension: "2d",
        aspect: "depth-only",
        baseMipLevel: 0,
        mipLevelCount: 1,
        baseArrayLayer: face
      });
      const dstView = destinationTexture.createView({
        dimension: "2d",
        baseMipLevel: 0,
        mipLevelCount: 1,
        baseArrayLayer: face
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: dstView,
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      const bindGroup = wgpu.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [{
          binding: 0,
          resource: srcView
        }]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4);
      passEncoder.end();
    }
    device.pipeline = null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-compute.js
var WebgpuCompute = class {
  constructor(compute) {
    this.uniformBuffers = [];
    this.bindGroup = null;
    this.compute = compute;
    const {
      device,
      shader
    } = compute;
    const {
      computeBindGroupFormat,
      computeUniformBufferFormats
    } = shader.impl;
    this.bindGroup = new BindGroup(device, computeBindGroupFormat);
    if (computeUniformBufferFormats) {
      for (const name in computeUniformBufferFormats) {
        if (computeUniformBufferFormats.hasOwnProperty(name)) {
          const ub = new UniformBuffer(device, computeUniformBufferFormats[name], true);
          this.uniformBuffers.push(ub);
          this.bindGroup.setUniformBuffer(name, ub);
        }
      }
    }
    this.pipeline = device.computePipeline.get(shader, computeBindGroupFormat);
  }
  destroy() {
    this.uniformBuffers.forEach((ub) => ub.destroy());
    this.uniformBuffers.length = 0;
    this.bindGroup.destroy();
    this.bindGroup = null;
  }
  updateBindGroup() {
    const {
      bindGroup
    } = this;
    bindGroup.updateUniformBuffers();
    bindGroup.update();
  }
  dispatch(x2, y2, z2) {
    const device = this.compute.device;
    device.setBindGroup(0, this.bindGroup);
    const passEncoder = device.passEncoder;
    passEncoder.setPipeline(this.pipeline);
    passEncoder.dispatchWorkgroups(x2, y2, z2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgpu/webgpu-graphics-device.js
var _uniqueLocations = /* @__PURE__ */ new Map();
var WebgpuGraphicsDevice = class extends GraphicsDevice {
  constructor(canvas, options2 = {}) {
    var _options$alpha, _options$antialias;
    super(canvas, options2);
    this.renderPipeline = new WebgpuRenderPipeline(this);
    this.computePipeline = new WebgpuComputePipeline(this);
    this.clearRenderer = void 0;
    this.mipmapRenderer = void 0;
    this.pipeline = void 0;
    this.bindGroupFormats = [];
    this.emptyBindGroup = void 0;
    this.commandEncoder = null;
    this.commandBuffers = [];
    this.limits = void 0;
    options2 = this.initOptions;
    options2.alpha = (_options$alpha = options2.alpha) != null ? _options$alpha : true;
    this.backBufferAntialias = (_options$antialias = options2.antialias) != null ? _options$antialias : false;
    this.isWebGPU = true;
    this._deviceType = DEVICETYPE_WEBGPU;
  }
  destroy() {
    this.clearRenderer.destroy();
    this.clearRenderer = null;
    this.mipmapRenderer.destroy();
    this.mipmapRenderer = null;
    this.resolver.destroy();
    this.resolver = null;
    super.destroy();
  }
  initDeviceCaps() {
    var _this$wgpu;
    const limits = (_this$wgpu = this.wgpu) == null ? void 0 : _this$wgpu.limits;
    this.limits = limits;
    this.precision = "highp";
    this.maxPrecision = "highp";
    this.maxSamples = 4;
    this.maxTextures = 16;
    this.maxTextureSize = limits.maxTextureDimension2D;
    this.maxCubeMapSize = limits.maxTextureDimension2D;
    this.maxVolumeSize = limits.maxTextureDimension3D;
    this.maxColorAttachments = limits.maxColorAttachments;
    this.maxPixelRatio = 1;
    this.maxAnisotropy = 16;
    this.fragmentUniformsCount = limits.maxUniformBufferBindingSize / 16;
    this.vertexUniformsCount = limits.maxUniformBufferBindingSize / 16;
    this.supportsUniformBuffers = true;
    this.supportsAreaLights = true;
    this.supportsGpuParticles = true;
    this.supportsCompute = true;
    this.textureFloatRenderable = true;
    this.textureHalfFloatRenderable = true;
    this.supportsImageBitmap = true;
    this.samples = this.backBufferAntialias ? 4 : 1;
    const wgslFeatures = navigator.gpu.wgslLanguageFeatures;
    this.supportsStorageTextureRead = wgslFeatures == null ? void 0 : wgslFeatures.has("readonly_and_readwrite_storage_textures");
  }
  async initWebGpu(glslangUrl, twgslUrl) {
    var _this$gpuAdapter, _this$wgpu$lost;
    if (!window.navigator.gpu) {
      throw new Error("Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.");
    }
    const buildUrl = (srcPath) => {
      return new URL(srcPath, window.location.href).toString();
    };
    const results = await Promise.all([import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      `${buildUrl(twgslUrl)}`
    ).then((module) => twgsl(twgslUrl.replace(".js", ".wasm"))), import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      `${buildUrl(glslangUrl)}`
    ).then((module) => module.default())]);
    this.twgsl = results[0];
    this.glslang = results[1];
    const adapterOptions = {
      powerPreference: this.initOptions.powerPreference !== "default" ? this.initOptions.powerPreference : void 0
    };
    this.gpuAdapter = await window.navigator.gpu.requestAdapter(adapterOptions);
    const requiredFeatures = [];
    const requireFeature = (feature) => {
      const supported = this.gpuAdapter.features.has(feature);
      if (supported) {
        requiredFeatures.push(feature);
      }
      return supported;
    };
    this.textureFloatFilterable = requireFeature("float32-filterable");
    this.extCompressedTextureS3TC = requireFeature("texture-compression-bc");
    this.extCompressedTextureETC = requireFeature("texture-compression-etc2");
    this.extCompressedTextureASTC = requireFeature("texture-compression-astc");
    this.supportsTimestampQuery = requireFeature("timestamp-query");
    this.supportsDepthClip = requireFeature("depth-clip-control");
    this.supportsDepth32Stencil = requireFeature("depth32float-stencil8");
    this.supportsIndirectFirstInstance = requireFeature("indirect-first-instance");
    this.supportsShaderF16 = requireFeature("shader-f16");
    this.supportsStorageRGBA8 = requireFeature("bgra8unorm-storage");
    this.textureRG11B10Renderable = requireFeature("rg11b10ufloat-renderable");
    const adapterLimits = (_this$gpuAdapter = this.gpuAdapter) == null ? void 0 : _this$gpuAdapter.limits;
    const requiredLimits = {};
    if (adapterLimits) {
      for (const limitName in adapterLimits) {
        if (limitName === "minSubgroupSize" || limitName === "maxSubgroupSize") {
          continue;
        }
        requiredLimits[limitName] = adapterLimits[limitName];
      }
    }
    const deviceDescr = {
      requiredFeatures,
      requiredLimits,
      defaultQueue: {
        label: "Default Queue"
      }
    };
    this.wgpu = await this.gpuAdapter.requestDevice(deviceDescr);
    (_this$wgpu$lost = this.wgpu.lost) == null || _this$wgpu$lost.then((info) => {
      if (info.reason !== "destroyed") ;
    });
    this.initDeviceCaps();
    this.gpuContext = this.canvas.getContext("webgpu");
    const preferredCanvasFormat = navigator.gpu.getPreferredCanvasFormat();
    const displayFormat = this.initOptions.displayFormat;
    this.backBufferFormat = preferredCanvasFormat === "rgba8unorm" ? displayFormat === DISPLAYFORMAT_LDR_SRGB ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8 : displayFormat === DISPLAYFORMAT_LDR_SRGB ? PIXELFORMAT_SBGRA8 : PIXELFORMAT_BGRA8;
    this.backBufferViewFormat = displayFormat === DISPLAYFORMAT_LDR_SRGB ? `${preferredCanvasFormat}-srgb` : preferredCanvasFormat;
    this.canvasConfig = {
      device: this.wgpu,
      colorSpace: "srgb",
      alphaMode: this.initOptions.alpha ? "premultiplied" : "opaque",
      format: preferredCanvasFormat,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,
      viewFormats: displayFormat === DISPLAYFORMAT_LDR_SRGB ? [this.backBufferViewFormat] : []
    };
    this.gpuContext.configure(this.canvasConfig);
    this.createBackbuffer();
    this.clearRenderer = new WebgpuClearRenderer(this);
    this.mipmapRenderer = new WebgpuMipmapRenderer(this);
    this.resolver = new WebgpuResolver(this);
    this.postInit();
    return this;
  }
  postInit() {
    super.postInit();
    this.initializeRenderState();
    this.setupPassEncoderDefaults();
    this.gpuProfiler = new WebgpuGpuProfiler(this);
    this.dynamicBuffers = new WebgpuDynamicBuffers(this, 100 * 1024, this.limits.minUniformBufferOffsetAlignment);
    this.emptyBindGroup = new BindGroup(this, new BindGroupFormat(this, []));
    this.emptyBindGroup.update();
  }
  createBackbuffer() {
    this.supportsStencil = this.initOptions.stencil;
    this.backBuffer = new RenderTarget({
      name: "WebgpuFramebuffer",
      graphicsDevice: this,
      depth: this.initOptions.depth,
      stencil: this.supportsStencil,
      samples: this.samples
    });
    this.backBuffer.impl.isBackbuffer = true;
  }
  frameStart() {
    super.frameStart();
    this.gpuProfiler.frameStart();
    this.submit();
    const outColorBuffer = this.gpuContext.getCurrentTexture();
    if (this.backBufferSize.x !== outColorBuffer.width || this.backBufferSize.y !== outColorBuffer.height) {
      this.backBufferSize.set(outColorBuffer.width, outColorBuffer.height);
      this.backBuffer.destroy();
      this.backBuffer = null;
      this.createBackbuffer();
    }
    const rt = this.backBuffer;
    const wrt = rt.impl;
    wrt.setColorAttachment(0, void 0, this.backBufferViewFormat);
    this.initRenderTarget(rt);
    wrt.assignColorTexture(this, outColorBuffer);
  }
  frameEnd() {
    super.frameEnd();
    this.gpuProfiler.frameEnd();
    this.submit();
    if (!this.contextLost) {
      this.gpuProfiler.request();
    }
  }
  createBufferImpl(usageFlags) {
    return new WebgpuBuffer(usageFlags);
  }
  createUniformBufferImpl(uniformBuffer) {
    return new WebgpuUniformBuffer(uniformBuffer);
  }
  createVertexBufferImpl(vertexBuffer, format, options2) {
    return new WebgpuVertexBuffer(vertexBuffer, format, options2);
  }
  createIndexBufferImpl(indexBuffer, options2) {
    return new WebgpuIndexBuffer(indexBuffer, options2);
  }
  createShaderImpl(shader) {
    return new WebgpuShader(shader);
  }
  createTextureImpl(texture) {
    return new WebgpuTexture(texture);
  }
  createRenderTargetImpl(renderTarget) {
    return new WebgpuRenderTarget(renderTarget);
  }
  createBindGroupFormatImpl(bindGroupFormat) {
    return new WebgpuBindGroupFormat(bindGroupFormat);
  }
  createBindGroupImpl(bindGroup) {
    return new WebgpuBindGroup();
  }
  createComputeImpl(compute) {
    return new WebgpuCompute(compute);
  }
  setBindGroup(index, bindGroup, offsets) {
    if (this.passEncoder) {
      this.passEncoder.setBindGroup(index, bindGroup.impl.bindGroup, offsets != null ? offsets : bindGroup.uniformBufferOffsets);
      this.bindGroupFormats[index] = bindGroup.format.impl;
    }
  }
  submitVertexBuffer(vertexBuffer, slot) {
    const format = vertexBuffer.format;
    const {
      interleaved,
      elements
    } = format;
    const elementCount = elements.length;
    const vbBuffer = vertexBuffer.impl.buffer;
    if (interleaved) {
      this.passEncoder.setVertexBuffer(slot, vbBuffer);
      return 1;
    }
    for (let i = 0; i < elementCount; i++) {
      this.passEncoder.setVertexBuffer(slot + i, vbBuffer, elements[i].offset);
    }
    return elementCount;
  }
  validateVBLocations(vb0, vb1) {
    const validateVB = (vb) => {
      const {
        elements
      } = vb.format;
      for (let i = 0; i < elements.length; i++) {
        const name = elements[i].name;
        const location = semanticToLocation[name];
        if (_uniqueLocations.has(location)) ;
        _uniqueLocations.set(location, name);
      }
    };
    validateVB(vb0);
    validateVB(vb1);
    _uniqueLocations.clear();
  }
  draw(primitive2, numInstances = 1, keepBuffers) {
    if (this.shader.ready && !this.shader.failed) {
      const passEncoder = this.passEncoder;
      const vb0 = this.vertexBuffers[0];
      const vb1 = this.vertexBuffers[1];
      this.vertexBuffers.length = 0;
      if (vb0) {
        const vbSlot = this.submitVertexBuffer(vb0, 0);
        if (vb1) {
          this.submitVertexBuffer(vb1, vbSlot);
        }
      }
      const pipeline = this.renderPipeline.get(primitive2, vb0 == null ? void 0 : vb0.format, vb1 == null ? void 0 : vb1.format, this.shader, this.renderTarget, this.bindGroupFormats, this.blendState, this.depthState, this.cullMode, this.stencilEnabled, this.stencilFront, this.stencilBack);
      if (this.pipeline !== pipeline) {
        this.pipeline = pipeline;
        passEncoder.setPipeline(pipeline);
      }
      const ib = this.indexBuffer;
      if (ib) {
        this.indexBuffer = null;
        passEncoder.setIndexBuffer(ib.impl.buffer, ib.impl.format);
        passEncoder.drawIndexed(primitive2.count, numInstances, primitive2.base, 0, 0);
      } else {
        passEncoder.draw(primitive2.count, numInstances, primitive2.base, 0);
      }
    }
  }
  setShader(shader, asyncCompile = false) {
    if (shader !== this.shader) {
      this.shader = shader;
    }
  }
  setBlendState(blendState) {
    this.blendState.copy(blendState);
  }
  setDepthState(depthState) {
    this.depthState.copy(depthState);
  }
  setStencilState(stencilFront, stencilBack) {
    if (stencilFront || stencilBack) {
      this.stencilEnabled = true;
      this.stencilFront.copy(stencilFront != null ? stencilFront : StencilParameters.DEFAULT);
      this.stencilBack.copy(stencilBack != null ? stencilBack : StencilParameters.DEFAULT);
      const ref = this.stencilFront.ref;
      if (this.stencilRef !== ref) {
        this.stencilRef = ref;
        this.passEncoder.setStencilReference(ref);
      }
    } else {
      this.stencilEnabled = false;
    }
  }
  setBlendColor(r, g, b, a) {
    const c2 = this.blendColor;
    if (r !== c2.r || g !== c2.g || b !== c2.b || a !== c2.a) {
      c2.set(r, g, b, a);
      this.passEncoder.setBlendConstant(c2);
    }
  }
  setCullMode(cullMode) {
    this.cullMode = cullMode;
  }
  setAlphaToCoverage(state) {
  }
  initializeContextCaches() {
    super.initializeContextCaches();
  }
  setupPassEncoderDefaults() {
    this.pipeline = null;
    this.stencilRef = 0;
    this.blendColor.set(0, 0, 0, 0);
  }
  _uploadDirtyTextures() {
    this.textures.forEach((texture) => {
      if (texture._needsUpload || texture._needsMipmaps) {
        texture.upload();
      }
    });
  }
  startRenderPass(renderPass) {
    this._uploadDirtyTextures();
    const rt = renderPass.renderTarget || this.backBuffer;
    this.renderTarget = rt;
    const wrt = rt.impl;
    this.commandEncoder = this.wgpu.createCommandEncoder();
    if (rt !== this.backBuffer) {
      this.initRenderTarget(rt);
    }
    wrt.setupForRenderPass(renderPass, rt);
    const renderPassDesc = wrt.renderPassDescriptor;
    if (this.gpuProfiler._enabled) {
      if (this.gpuProfiler.timestampQueriesSet) {
        const slot = this.gpuProfiler.getSlot(renderPass.name);
        renderPassDesc.timestampWrites = {
          querySet: this.gpuProfiler.timestampQueriesSet.querySet,
          beginningOfPassWriteIndex: slot * 2,
          endOfPassWriteIndex: slot * 2 + 1
        };
      }
    }
    this.passEncoder = this.commandEncoder.beginRenderPass(renderPassDesc);
    this.setupPassEncoderDefaults();
    const {
      width,
      height
    } = rt;
    this.setViewport(0, 0, width, height);
    this.setScissor(0, 0, width, height);
    this.insideRenderPass = true;
  }
  endRenderPass(renderPass) {
    this.passEncoder.end();
    this.passEncoder = null;
    this.insideRenderPass = false;
    this.bindGroupFormats.length = 0;
    for (let i = 0; i < renderPass.colorArrayOps.length; i++) {
      const colorOps = renderPass.colorArrayOps[i];
      if (colorOps.mipmaps) {
        this.mipmapRenderer.generate(renderPass.renderTarget._colorBuffers[i].impl);
      }
    }
    const cb = this.commandEncoder.finish();
    this.addCommandBuffer(cb);
    this.commandEncoder = null;
  }
  startComputePass() {
    this.commandEncoder = this.wgpu.createCommandEncoder();
    this.pipeline = null;
    this.passEncoder = this.commandEncoder.beginComputePass();
    this.insideRenderPass = true;
  }
  endComputePass() {
    this.passEncoder.end();
    this.passEncoder = null;
    this.insideRenderPass = false;
    this.bindGroupFormats.length = 0;
    const cb = this.commandEncoder.finish();
    this.addCommandBuffer(cb);
    this.commandEncoder = null;
  }
  computeDispatch(computes) {
    this.startComputePass();
    for (let i = 0; i < computes.length; i++) {
      const compute = computes[i];
      compute.applyParameters();
      compute.impl.updateBindGroup();
    }
    for (let i = 0; i < computes.length; i++) {
      const compute = computes[i];
      compute.impl.dispatch(compute.countX, compute.countY, compute.countZ);
    }
    this.endComputePass();
  }
  addCommandBuffer(commandBuffer, front = false) {
    if (front) {
      this.commandBuffers.unshift(commandBuffer);
    } else {
      this.commandBuffers.push(commandBuffer);
    }
  }
  submit() {
    if (this.commandBuffers.length > 0) {
      this.dynamicBuffers.submit();
      this.wgpu.queue.submit(this.commandBuffers);
      this.commandBuffers.length = 0;
      this.dynamicBuffers.onCommandBuffersSubmitted();
    }
  }
  clear(options2) {
    if (options2.flags) {
      this.clearRenderer.clear(this, this.renderTarget, options2, this.defaultClearOptions);
    }
  }
  setViewport(x2, y2, w, h2) {
    if (this.passEncoder) {
      if (!this.renderTarget.flipY) {
        y2 = this.renderTarget.height - y2 - h2;
      }
      this.vx = x2;
      this.vy = y2;
      this.vw = w;
      this.vh = h2;
      this.passEncoder.setViewport(x2, y2, w, h2, 0, 1);
    }
  }
  setScissor(x2, y2, w, h2) {
    if (this.passEncoder) {
      if (!this.renderTarget.flipY) {
        y2 = this.renderTarget.height - y2 - h2;
      }
      this.sx = x2;
      this.sy = y2;
      this.sw = w;
      this.sh = h2;
      this.passEncoder.setScissorRect(x2, y2, w, h2);
    }
  }
  clearStorageBuffer(storageBuffer, offset = 0, size = storageBuffer.byteSize) {
    var _this$commandEncoder;
    const commandEncoder = (_this$commandEncoder = this.commandEncoder) != null ? _this$commandEncoder : this.wgpu.createCommandEncoder();
    commandEncoder.clearBuffer(storageBuffer.buffer, offset, size);
    if (!this.commandEncoder) {
      const cb = commandEncoder.finish();
      this.addCommandBuffer(cb);
    }
  }
  readStorageBuffer(storageBuffer, offset = 0, size = storageBuffer.byteSize - offset, data2 = null, immediate = false) {
    var _this$commandEncoder2;
    const stagingBuffer = this.createBufferImpl(BUFFERUSAGE_READ | BUFFERUSAGE_COPY_DST);
    stagingBuffer.allocate(this, size);
    const destBuffer = stagingBuffer.buffer;
    const commandEncoder = (_this$commandEncoder2 = this.commandEncoder) != null ? _this$commandEncoder2 : this.wgpu.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(storageBuffer.buffer, offset, destBuffer, 0, size);
    if (!this.commandEncoder) {
      const cb = commandEncoder.finish();
      this.addCommandBuffer(cb);
    }
    return this.readBuffer(stagingBuffer, size, data2, immediate);
  }
  readBuffer(stagingBuffer, size, data2 = null, immediate = false) {
    const destBuffer = stagingBuffer.buffer;
    return new Promise((resolve, reject) => {
      const read = () => {
        destBuffer == null || destBuffer.mapAsync(GPUMapMode.READ).then(() => {
          var _data;
          (_data = data2) != null ? _data : data2 = new Uint8Array(size);
          const copySrc = destBuffer.getMappedRange(0, size);
          const srcType = data2.constructor;
          data2.set(new srcType(copySrc));
          destBuffer.unmap();
          stagingBuffer.destroy(this);
          resolve(data2);
        });
      };
      if (immediate) {
        this.submit();
        read();
      } else {
        setTimeout(() => {
          read();
        });
      }
    });
  }
  writeStorageBuffer(storageBuffer, bufferOffset = 0, data2, dataOffset = 0, size) {
    this.wgpu.queue.writeBuffer(storageBuffer.buffer, bufferOffset, data2, dataOffset, size);
  }
  copyRenderTarget(source, dest, color, depth) {
    var _this$commandEncoder3;
    const copySize = {
      width: source ? source.width : dest.width,
      height: source ? source.height : dest.height,
      depthOrArrayLayers: 1
    };
    const commandEncoder = (_this$commandEncoder3 = this.commandEncoder) != null ? _this$commandEncoder3 : this.wgpu.createCommandEncoder();
    if (color) {
      const copySrc = {
        texture: source ? source.colorBuffer.impl.gpuTexture : this.backBuffer.impl.assignedColorTexture,
        mipLevel: 0
      };
      const copyDst = {
        texture: dest ? dest.colorBuffer.impl.gpuTexture : this.backBuffer.impl.assignedColorTexture,
        mipLevel: 0
      };
      commandEncoder.copyTextureToTexture(copySrc, copyDst, copySize);
    }
    if (depth) {
      const sourceRT = source ? source : this.renderTarget;
      const sourceTexture = sourceRT.impl.depthTexture;
      if (source.samples > 1) {
        const destTexture = dest.colorBuffer.impl.gpuTexture;
        this.resolver.resolveDepth(commandEncoder, sourceTexture, destTexture);
      } else {
        const destTexture = dest ? dest.depthBuffer.impl.gpuTexture : this.renderTarget.impl.depthTexture;
        const copySrc = {
          texture: sourceTexture,
          mipLevel: 0
        };
        const copyDst = {
          texture: destTexture,
          mipLevel: 0
        };
        commandEncoder.copyTextureToTexture(copySrc, copyDst, copySize);
      }
    }
    if (!this.commandEncoder) {
      const cb = commandEncoder.finish();
      this.addCommandBuffer(cb);
    }
    return true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/texture.js
var id6 = 0;
var Texture = class {
  constructor(graphicsDevice, options2 = {}) {
    var _options$name, _options$width, _options$height, _options$format, _options$volume, _options$depth, _options$arrayLength, _options$storage, _options$cubemap, _options$flipY, _options$premultiplyA, _ref4, _options$mipmaps, _options$minFilter, _options$magFilter, _options$anisotropy, _options$addressU, _options$addressV, _options$addressW, _options$compareOnRea, _options$compareFunc;
    this.name = void 0;
    this._gpuSize = 0;
    this.id = id6++;
    this._invalid = false;
    this._lockedLevel = -1;
    this._lockedMode = TEXTURELOCK_NONE;
    this.renderVersionDirty = 0;
    this._storage = false;
    this.device = graphicsDevice;
    this.name = (_options$name = options2.name) != null ? _options$name : "";
    this._width = Math.floor((_options$width = options2.width) != null ? _options$width : 4);
    this._height = Math.floor((_options$height = options2.height) != null ? _options$height : 4);
    this._format = (_options$format = options2.format) != null ? _options$format : PIXELFORMAT_RGBA8;
    this._compressed = isCompressedPixelFormat(this._format);
    this._integerFormat = isIntegerPixelFormat(this._format);
    if (this._integerFormat) {
      options2.mipmaps = false;
      options2.minFilter = FILTER_NEAREST;
      options2.magFilter = FILTER_NEAREST;
    }
    this._volume = (_options$volume = options2.volume) != null ? _options$volume : false;
    this._depth = Math.floor((_options$depth = options2.depth) != null ? _options$depth : 1);
    this._arrayLength = Math.floor((_options$arrayLength = options2.arrayLength) != null ? _options$arrayLength : 0);
    this._storage = (_options$storage = options2.storage) != null ? _options$storage : false;
    this._cubemap = (_options$cubemap = options2.cubemap) != null ? _options$cubemap : false;
    this._flipY = (_options$flipY = options2.flipY) != null ? _options$flipY : false;
    this._premultiplyAlpha = (_options$premultiplyA = options2.premultiplyAlpha) != null ? _options$premultiplyA : false;
    this._mipmaps = (_ref4 = (_options$mipmaps = options2.mipmaps) != null ? _options$mipmaps : options2.autoMipmap) != null ? _ref4 : true;
    this._minFilter = (_options$minFilter = options2.minFilter) != null ? _options$minFilter : FILTER_LINEAR_MIPMAP_LINEAR;
    this._magFilter = (_options$magFilter = options2.magFilter) != null ? _options$magFilter : FILTER_LINEAR;
    this._anisotropy = (_options$anisotropy = options2.anisotropy) != null ? _options$anisotropy : 1;
    this._addressU = (_options$addressU = options2.addressU) != null ? _options$addressU : ADDRESS_REPEAT;
    this._addressV = (_options$addressV = options2.addressV) != null ? _options$addressV : ADDRESS_REPEAT;
    this._addressW = (_options$addressW = options2.addressW) != null ? _options$addressW : ADDRESS_REPEAT;
    this._compareOnRead = (_options$compareOnRea = options2.compareOnRead) != null ? _options$compareOnRea : false;
    this._compareFunc = (_options$compareFunc = options2.compareFunc) != null ? _options$compareFunc : FUNC_LESS;
    this.type = options2.hasOwnProperty("type") ? options2.type : TEXTURETYPE_DEFAULT;
    this.projection = TEXTUREPROJECTION_NONE;
    if (this._cubemap) {
      this.projection = TEXTUREPROJECTION_CUBE;
    } else if (options2.projection && options2.projection !== TEXTUREPROJECTION_CUBE) {
      this.projection = options2.projection;
    }
    this.impl = graphicsDevice.createTextureImpl(this);
    this.dirtyAll();
    this._levels = options2.levels;
    if (this._levels) {
      this.upload();
    } else {
      this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
    }
    graphicsDevice.textures.push(this);
  }
  destroy() {
    const device = this.device;
    if (device) {
      const idx = device.textures.indexOf(this);
      if (idx !== -1) {
        device.textures.splice(idx, 1);
      }
      device.scope.removeValue(this);
      this.impl.destroy(device);
      this.adjustVramSizeTracking(device._vram, -this._gpuSize);
      this._levels = null;
      this.device = null;
    }
  }
  resize(width, height, depth = 1) {
    const device = this.device;
    this.adjustVramSizeTracking(device._vram, -this._gpuSize);
    this.impl.destroy(device);
    this._width = Math.floor(width);
    this._height = Math.floor(height);
    this._depth = Math.floor(depth);
    this.impl = device.createTextureImpl(this);
    this.dirtyAll();
  }
  loseContext() {
    this.impl.loseContext();
    this.dirtyAll();
  }
  adjustVramSizeTracking(vram, size) {
    vram.tex += size;
  }
  propertyChanged(flag) {
    this.impl.propertyChanged(flag);
    this.renderVersionDirty = this.device.renderVersion;
  }
  get requiredMipLevels() {
    return this.mipmaps ? TextureUtils.calcMipLevelsCount(this.width, this.height) : 1;
  }
  get lockedMode() {
    return this._lockedMode;
  }
  set minFilter(v) {
    if (this._minFilter !== v) {
      if (isIntegerPixelFormat(this._format)) ;
      else {
        this._minFilter = v;
        this.propertyChanged(TEXPROPERTY_MIN_FILTER);
      }
    }
  }
  get minFilter() {
    return this._minFilter;
  }
  set magFilter(v) {
    if (this._magFilter !== v) {
      if (isIntegerPixelFormat(this._format)) ;
      else {
        this._magFilter = v;
        this.propertyChanged(TEXPROPERTY_MAG_FILTER);
      }
    }
  }
  get magFilter() {
    return this._magFilter;
  }
  set addressU(v) {
    if (this._addressU !== v) {
      this._addressU = v;
      this.propertyChanged(TEXPROPERTY_ADDRESS_U);
    }
  }
  get addressU() {
    return this._addressU;
  }
  set addressV(v) {
    if (this._addressV !== v) {
      this._addressV = v;
      this.propertyChanged(TEXPROPERTY_ADDRESS_V);
    }
  }
  get addressV() {
    return this._addressV;
  }
  set addressW(addressW) {
    if (!this._volume) {
      return;
    }
    if (addressW !== this._addressW) {
      this._addressW = addressW;
      this.propertyChanged(TEXPROPERTY_ADDRESS_W);
    }
  }
  get addressW() {
    return this._addressW;
  }
  set compareOnRead(v) {
    if (this._compareOnRead !== v) {
      this._compareOnRead = v;
      this.propertyChanged(TEXPROPERTY_COMPARE_ON_READ);
    }
  }
  get compareOnRead() {
    return this._compareOnRead;
  }
  set compareFunc(v) {
    if (this._compareFunc !== v) {
      this._compareFunc = v;
      this.propertyChanged(TEXPROPERTY_COMPARE_FUNC);
    }
  }
  get compareFunc() {
    return this._compareFunc;
  }
  set anisotropy(v) {
    if (this._anisotropy !== v) {
      this._anisotropy = v;
      this.propertyChanged(TEXPROPERTY_ANISOTROPY);
    }
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set mipmaps(v) {
    if (this._mipmaps !== v) {
      if (this.device.isWebGPU) ;
      else if (isIntegerPixelFormat(this._format)) ;
      else {
        this._mipmaps = v;
      }
      if (v) this._needsMipmapsUpload = true;
    }
  }
  get mipmaps() {
    return this._mipmaps;
  }
  get storage() {
    return this._storage;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get depth() {
    return this._depth;
  }
  get format() {
    return this._format;
  }
  get cubemap() {
    return this._cubemap;
  }
  get gpuSize() {
    const mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
    return TextureUtils.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
  }
  get array() {
    return this._arrayLength > 0;
  }
  get arrayLength() {
    return this._arrayLength;
  }
  get volume() {
    return this._volume;
  }
  set flipY(flipY) {
    if (this._flipY !== flipY) {
      this._flipY = flipY;
      this._needsUpload = true;
    }
  }
  get flipY() {
    return this._flipY;
  }
  set premultiplyAlpha(premultiplyAlpha) {
    if (this._premultiplyAlpha !== premultiplyAlpha) {
      this._premultiplyAlpha = premultiplyAlpha;
      this._needsUpload = true;
    }
  }
  get premultiplyAlpha() {
    return this._premultiplyAlpha;
  }
  get pot() {
    return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
  }
  get encoding() {
    switch (this.type) {
      case TEXTURETYPE_RGBM:
        return "rgbm";
      case TEXTURETYPE_RGBE:
        return "rgbe";
      case TEXTURETYPE_RGBP:
        return "rgbp";
    }
    return requiresManualGamma(this.format) ? "srgb" : "linear";
  }
  dirtyAll() {
    this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
    this._needsUpload = true;
    this._needsMipmapsUpload = this._mipmaps;
    this._mipmapsUploaded = false;
    this.propertyChanged(TEXPROPERTY_ALL);
  }
  lock(options2 = {}) {
    var _options$level, _options$face, _options$mode;
    (_options$level = options2.level) != null ? _options$level : options2.level = 0;
    (_options$face = options2.face) != null ? _options$face : options2.face = 0;
    (_options$mode = options2.mode) != null ? _options$mode : options2.mode = TEXTURELOCK_WRITE;
    this._lockedMode = options2.mode;
    this._lockedLevel = options2.level;
    const levels = this.cubemap ? this._levels[options2.face] : this._levels;
    if (levels[options2.level] === null) {
      const width = Math.max(1, this._width >> options2.level);
      const height = Math.max(1, this._height >> options2.level);
      const depth = Math.max(1, this._depth >> options2.level);
      const data2 = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, depth, this._format));
      levels[options2.level] = new (getPixelFormatArrayType(this._format))(data2);
    }
    return levels[options2.level];
  }
  setSource(source, mipLevel = 0) {
    let invalid = false;
    let width, height;
    if (this._cubemap) {
      if (source[0]) {
        width = source[0].width || 0;
        height = source[0].height || 0;
        for (let i = 0; i < 6; i++) {
          const face = source[i];
          if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {
            invalid = true;
            break;
          }
        }
      } else {
        invalid = true;
      }
      if (!invalid) {
        for (let i = 0; i < 6; i++) {
          if (this._levels[mipLevel][i] !== source[i]) {
            this._levelsUpdated[mipLevel][i] = true;
          }
        }
      }
    } else {
      if (!this.device._isBrowserInterface(source)) {
        invalid = true;
      }
      if (!invalid) {
        if (source !== this._levels[mipLevel]) {
          this._levelsUpdated[mipLevel] = true;
        }
        width = source.width;
        height = source.height;
      }
    }
    if (invalid) {
      this._width = 4;
      this._height = 4;
      if (this._cubemap) {
        for (let i = 0; i < 6; i++) {
          this._levels[mipLevel][i] = null;
          this._levelsUpdated[mipLevel][i] = true;
        }
      } else {
        this._levels[mipLevel] = null;
        this._levelsUpdated[mipLevel] = true;
      }
    } else {
      if (mipLevel === 0) {
        this._width = width;
        this._height = height;
      }
      this._levels[mipLevel] = source;
    }
    if (this._invalid !== invalid || !invalid) {
      this._invalid = invalid;
      this.upload();
    }
  }
  getSource(mipLevel = 0) {
    return this._levels[mipLevel];
  }
  unlock() {
    if (this._lockedMode === TEXTURELOCK_NONE) ;
    if (this._lockedMode === TEXTURELOCK_WRITE) {
      this.upload();
    }
    this._lockedLevel = -1;
    this._lockedMode = TEXTURELOCK_NONE;
  }
  upload() {
    var _this$impl$uploadImme, _this$impl;
    this._needsUpload = true;
    this._needsMipmapsUpload = this._mipmaps;
    (_this$impl$uploadImme = (_this$impl = this.impl).uploadImmediate) == null || _this$impl$uploadImme.call(_this$impl, this.device, this);
  }
  read(x2, y2, width, height, options2 = {}) {
    var _this$impl$read, _this$impl2;
    return (_this$impl$read = (_this$impl2 = this.impl).read) == null ? void 0 : _this$impl$read.call(_this$impl2, x2, y2, width, height, options2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-buffer.js
var WebglBuffer = class {
  constructor() {
    this.bufferId = null;
  }
  destroy(device) {
    if (this.bufferId) {
      device.gl.deleteBuffer(this.bufferId);
      this.bufferId = null;
    }
  }
  get initialized() {
    return !!this.bufferId;
  }
  loseContext() {
    this.bufferId = null;
  }
  unlock(device, usage, target2, storage) {
    const gl = device.gl;
    if (!this.bufferId) {
      let glUsage;
      switch (usage) {
        case BUFFER_STATIC:
          glUsage = gl.STATIC_DRAW;
          break;
        case BUFFER_DYNAMIC:
          glUsage = gl.DYNAMIC_DRAW;
          break;
        case BUFFER_STREAM:
          glUsage = gl.STREAM_DRAW;
          break;
        case BUFFER_GPUDYNAMIC:
          glUsage = gl.DYNAMIC_COPY;
          break;
      }
      this.bufferId = gl.createBuffer();
      gl.bindBuffer(target2, this.bufferId);
      gl.bufferData(target2, storage, glUsage);
    } else {
      gl.bindBuffer(target2, this.bufferId);
      gl.bufferSubData(target2, 0, storage);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-vertex-buffer.js
var WebglVertexBuffer = class extends WebglBuffer {
  constructor(...args) {
    super(...args);
    this.vao = null;
  }
  destroy(device) {
    super.destroy(device);
    device.unbindVertexArray();
  }
  loseContext() {
    super.loseContext();
    this.vao = null;
  }
  unlock(vertexBuffer) {
    const device = vertexBuffer.device;
    super.unlock(device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-index-buffer.js
var WebglIndexBuffer = class extends WebglBuffer {
  constructor(indexBuffer) {
    super();
    const gl = indexBuffer.device.gl;
    const format = indexBuffer.format;
    if (format === INDEXFORMAT_UINT8) {
      this.glFormat = gl.UNSIGNED_BYTE;
    } else if (format === INDEXFORMAT_UINT16) {
      this.glFormat = gl.UNSIGNED_SHORT;
    } else if (format === INDEXFORMAT_UINT32) {
      this.glFormat = gl.UNSIGNED_INT;
    }
  }
  unlock(indexBuffer) {
    const device = indexBuffer.device;
    super.unlock(device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-shader-input.js
var WebglShaderInput = class {
  constructor(graphicsDevice, name, type, locationId) {
    this.locationId = locationId;
    this.scopeId = graphicsDevice.scope.resolve(name);
    this.version = new Version();
    if (name.substring(name.length - 3) === "[0]") {
      switch (type) {
        case UNIFORMTYPE_FLOAT:
          type = UNIFORMTYPE_FLOATARRAY;
          break;
        case UNIFORMTYPE_INT:
          type = UNIFORMTYPE_INTARRAY;
          break;
        case UNIFORMTYPE_UINT:
          type = UNIFORMTYPE_UINTARRAY;
          break;
        case UNIFORMTYPE_BOOL:
          type = UNIFORMTYPE_BOOLARRAY;
          break;
        case UNIFORMTYPE_VEC2:
          type = UNIFORMTYPE_VEC2ARRAY;
          break;
        case UNIFORMTYPE_IVEC2:
          type = UNIFORMTYPE_IVEC2ARRAY;
          break;
        case UNIFORMTYPE_UVEC2:
          type = UNIFORMTYPE_UVEC2ARRAY;
          break;
        case UNIFORMTYPE_BVEC2:
          type = UNIFORMTYPE_BVEC2ARRAY;
          break;
        case UNIFORMTYPE_VEC3:
          type = UNIFORMTYPE_VEC3ARRAY;
          break;
        case UNIFORMTYPE_IVEC3:
          type = UNIFORMTYPE_IVEC3ARRAY;
          break;
        case UNIFORMTYPE_UVEC3:
          type = UNIFORMTYPE_UVEC3ARRAY;
          break;
        case UNIFORMTYPE_BVEC3:
          type = UNIFORMTYPE_BVEC3ARRAY;
          break;
        case UNIFORMTYPE_VEC4:
          type = UNIFORMTYPE_VEC4ARRAY;
          break;
        case UNIFORMTYPE_IVEC4:
          type = UNIFORMTYPE_IVEC4ARRAY;
          break;
        case UNIFORMTYPE_UVEC4:
          type = UNIFORMTYPE_UVEC4ARRAY;
          break;
        case UNIFORMTYPE_BVEC4:
          type = UNIFORMTYPE_BVEC4ARRAY;
          break;
      }
    }
    this.dataType = type;
    this.value = [null, null, null, null];
    this.array = [];
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-shader.js
var _vertexShaderBuiltins = /* @__PURE__ */ new Set(["gl_VertexID", "gl_InstanceID", "gl_DrawID", "gl_BaseVertex", "gl_BaseInstance"]);
var CompiledShaderCache = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  destroy(device) {
    this.map.forEach((shader) => {
      device.gl.deleteShader(shader);
    });
  }
  loseContext(device) {
    this.map.clear();
  }
};
var _vertexShaderCache = new DeviceCache();
var _fragmentShaderCache = new DeviceCache();
var WebglShader = class {
  constructor(shader) {
    this.compileDuration = 0;
    this.init();
    this.compile(shader.device, shader);
    this.link(shader.device, shader);
    shader.device.shaders.push(shader);
  }
  destroy(shader) {
    if (this.glProgram) {
      shader.device.gl.deleteProgram(this.glProgram);
      this.glProgram = null;
    }
  }
  init() {
    this.uniforms = [];
    this.samplers = [];
    this.attributes = [];
    this.glProgram = null;
    this.glVertexShader = null;
    this.glFragmentShader = null;
  }
  loseContext() {
    this.init();
  }
  restoreContext(device, shader) {
    this.compile(device, shader);
    this.link(device, shader);
  }
  compile(device, shader) {
    const definition = shader.definition;
    this.glVertexShader = this._compileShaderSource(device, definition.vshader, true);
    this.glFragmentShader = this._compileShaderSource(device, definition.fshader, false);
  }
  link(device, shader) {
    if (this.glProgram) {
      return;
    }
    const gl = device.gl;
    if (gl.isContextLost()) {
      return;
    }
    const glProgram = gl.createProgram();
    this.glProgram = glProgram;
    gl.attachShader(glProgram, this.glVertexShader);
    gl.attachShader(glProgram, this.glFragmentShader);
    const definition = shader.definition;
    const attrs = definition.attributes;
    if (definition.useTransformFeedback) {
      const outNames = [];
      for (const attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          outNames.push(`out_${attr}`);
        }
      }
      gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
    }
    for (const attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        const semantic = attrs[attr];
        const loc = semanticToLocation[semantic];
        gl.bindAttribLocation(glProgram, loc, attr);
      }
    }
    gl.linkProgram(glProgram);
  }
  _compileShaderSource(device, src, isVertexShader) {
    const gl = device.gl;
    const shaderDeviceCache = isVertexShader ? _vertexShaderCache : _fragmentShaderCache;
    const shaderCache = shaderDeviceCache.get(device, () => {
      return new CompiledShaderCache();
    });
    let glShader = shaderCache.map.get(src);
    if (!glShader) {
      glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
      if (!glShader && gl.isContextLost()) {
        return glShader;
      }
      gl.shaderSource(glShader, src);
      gl.compileShader(glShader);
      shaderCache.map.set(src, glShader);
    }
    return glShader;
  }
  finalize(device, shader) {
    const gl = device.gl;
    if (gl.isContextLost()) {
      return true;
    }
    const glProgram = this.glProgram;
    const definition = shader.definition;
    const linkStatus = gl.getProgramParameter(glProgram, gl.LINK_STATUS);
    if (!linkStatus) {
      if (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, "vertex")) {
        return false;
      }
      if (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, "fragment")) {
        return false;
      }
      const message = `Failed to link shader program. Error: ${gl.getProgramInfoLog(glProgram)}`;
      console.error(message);
      return false;
    }
    const numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttributes; i++) {
      const info = gl.getActiveAttrib(glProgram, i);
      const location = gl.getAttribLocation(glProgram, info.name);
      if (_vertexShaderBuiltins.has(info.name)) {
        continue;
      }
      if (definition.attributes[info.name] === void 0) {
        console.error(`Vertex shader attribute "${info.name}" is not mapped to a semantic in shader definition, shader [${shader.label}]`, shader);
        shader.failed = true;
      } else {
        const shaderInput = new WebglShaderInput(device, definition.attributes[info.name], device.pcUniformType[info.type], location);
        this.attributes.push(shaderInput);
      }
    }
    const samplerTypes2 = device._samplerTypes;
    const numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < numUniforms; i++) {
      const info = gl.getActiveUniform(glProgram, i);
      const location = gl.getUniformLocation(glProgram, info.name);
      const shaderInput = new WebglShaderInput(device, info.name, device.pcUniformType[info.type], location);
      if (samplerTypes2.has(info.type)) {
        this.samplers.push(shaderInput);
      } else {
        this.uniforms.push(shaderInput);
      }
    }
    shader.ready = true;
    return true;
  }
  _isCompiled(device, shader, glShader, source, shaderType) {
    const gl = device.gl;
    if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
      const infoLog = gl.getShaderInfoLog(glShader);
      const [code, error] = this._processError(source, infoLog);
      const message = `Failed to compile ${shaderType} shader:

${infoLog}
${code} while rendering ${void 0}`;
      console.error(message);
      return false;
    }
    return true;
  }
  isLinked(device) {
    const {
      extParallelShaderCompile
    } = device;
    if (extParallelShaderCompile) {
      return device.gl.getProgramParameter(this.glProgram, extParallelShaderCompile.COMPLETION_STATUS_KHR);
    }
    return true;
  }
  _processError(src, infoLog) {
    const error = {};
    let code = "";
    if (src) {
      const lines = src.split("\n");
      let from = 0;
      let to = lines.length;
      if (infoLog && infoLog.startsWith("ERROR:")) {
        const match = infoLog.match(/^ERROR:\s(\d+):(\d+):\s*(.+)/);
        if (match) {
          error.message = match[3];
          error.line = parseInt(match[2], 10);
          from = Math.max(0, error.line - 6);
          to = Math.min(lines.length, error.line + 5);
        }
      }
      for (let i = from; i < to; i++) {
        code += `${i + 1}:	${lines[i]}
`;
      }
      error.source = src;
    }
    return [code, error];
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-texture.js
function downsampleImage(image, size) {
  const srcW = image.width;
  const srcH = image.height;
  if (srcW > size || srcH > size) {
    const scale2 = size / Math.max(srcW, srcH);
    const dstW = Math.floor(srcW * scale2);
    const dstH = Math.floor(srcH * scale2);
    const canvas = document.createElement("canvas");
    canvas.width = dstW;
    canvas.height = dstH;
    const context = canvas.getContext("2d");
    context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
    return canvas;
  }
  return image;
}
var WebglTexture = class {
  constructor(texture) {
    this._glTexture = null;
    this._glTarget = void 0;
    this._glFormat = void 0;
    this._glInternalFormat = void 0;
    this._glPixelType = void 0;
    this._glCreated = void 0;
    this.dirtyParameterFlags = 0;
    this.texture = texture;
  }
  destroy(device) {
    if (this._glTexture) {
      for (let i = 0; i < device.textureUnits.length; i++) {
        const textureUnit = device.textureUnits[i];
        for (let j = 0; j < textureUnit.length; j++) {
          if (textureUnit[j] === this._glTexture) {
            textureUnit[j] = null;
          }
        }
      }
      device.gl.deleteTexture(this._glTexture);
      this._glTexture = null;
    }
  }
  loseContext() {
    this._glTexture = null;
  }
  propertyChanged(flag) {
    this.dirtyParameterFlags |= flag;
  }
  initialize(device, texture) {
    const gl = device.gl;
    this._glTexture = gl.createTexture();
    this._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : texture.array ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
    switch (texture._format) {
      case PIXELFORMAT_A8:
        this._glFormat = gl.ALPHA;
        this._glInternalFormat = gl.ALPHA;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_L8:
        this._glFormat = gl.LUMINANCE;
        this._glInternalFormat = gl.LUMINANCE;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_LA8:
        this._glFormat = gl.LUMINANCE_ALPHA;
        this._glInternalFormat = gl.LUMINANCE_ALPHA;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_R8:
        this._glFormat = gl.RED;
        this._glInternalFormat = gl.R8;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_RG8:
        this._glFormat = gl.RG;
        this._glInternalFormat = gl.RG8;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_RGB565:
        this._glFormat = gl.RGB;
        this._glInternalFormat = gl.RGB;
        this._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
        break;
      case PIXELFORMAT_RGBA5551:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = gl.RGBA;
        this._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
        break;
      case PIXELFORMAT_RGBA4:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = gl.RGBA;
        this._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
        break;
      case PIXELFORMAT_RGB8:
        this._glFormat = gl.RGB;
        this._glInternalFormat = gl.RGB8;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_RGBA8:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = gl.RGBA8;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_BGRA8:
      case PIXELFORMAT_SBGRA8:
        break;
      case PIXELFORMAT_DXT1:
        this._glFormat = gl.RGB;
        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
        break;
      case PIXELFORMAT_DXT3:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        break;
      case PIXELFORMAT_DXT5:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        break;
      case PIXELFORMAT_ETC1:
        this._glFormat = gl.RGB;
        this._glInternalFormat = device.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;
        break;
      case PIXELFORMAT_PVRTC_2BPP_RGB_1:
        this._glFormat = gl.RGB;
        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        break;
      case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        break;
      case PIXELFORMAT_PVRTC_4BPP_RGB_1:
        this._glFormat = gl.RGB;
        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        break;
      case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        break;
      case PIXELFORMAT_ETC2_RGB:
        this._glFormat = gl.RGB;
        this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
        break;
      case PIXELFORMAT_ETC2_RGBA:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
        break;
      case PIXELFORMAT_ASTC_4x4:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
        break;
      case PIXELFORMAT_ATC_RGB:
        this._glFormat = gl.RGB;
        this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;
        break;
      case PIXELFORMAT_ATC_RGBA:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
        break;
      case PIXELFORMAT_DXT1_SRGB:
        this._glFormat = gl.SRGB;
        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        break;
      case PIXELFORMAT_DXT3_SRGB:
        this._glFormat = gl.SRGB_ALPHA;
        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        break;
      case PIXELFORMAT_DXT5_SRGB:
        this._glFormat = gl.SRGB_ALPHA;
        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        break;
      case PIXELFORMAT_PVRTC_2BPP_SRGB_1:
        this._glFormat = gl.SRGB;
        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_SRGB_PVRTC_2BPPV1_EXT;
        break;
      case PIXELFORMAT_PVRTC_2BPP_SRGBA_1:
        this._glFormat = gl.SRGB_ALPHA;
        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT;
        break;
      case PIXELFORMAT_PVRTC_4BPP_SRGB_1:
        this._glFormat = gl.SRGB;
        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_SRGB_PVRTC_4BPPV1_EXT;
        break;
      case PIXELFORMAT_PVRTC_4BPP_SRGBA_1:
        this._glFormat = gl.SRGB_ALPHA;
        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT;
        break;
      case PIXELFORMAT_ETC2_SRGB:
        this._glFormat = gl.RGB;
        this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
        break;
      case PIXELFORMAT_ETC2_SRGBA:
        this._glFormat = gl.SRGB_ALPHA;
        this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
        break;
      case PIXELFORMAT_ASTC_4x4_SRGB:
        this._glFormat = gl.SRGB_ALPHA;
        this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
        break;
      case PIXELFORMAT_R16F:
        this._glFormat = gl.RED;
        this._glInternalFormat = gl.R16F;
        this._glPixelType = gl.HALF_FLOAT;
        break;
      case PIXELFORMAT_RG16F:
        this._glFormat = gl.RG;
        this._glInternalFormat = gl.RG16F;
        this._glPixelType = gl.HALF_FLOAT;
        break;
      case PIXELFORMAT_RGB16F:
        this._glFormat = gl.RGB;
        this._glInternalFormat = gl.RGB16F;
        this._glPixelType = gl.HALF_FLOAT;
        break;
      case PIXELFORMAT_RGBA16F:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = gl.RGBA16F;
        this._glPixelType = gl.HALF_FLOAT;
        break;
      case PIXELFORMAT_RGB32F:
        this._glFormat = gl.RGB;
        this._glInternalFormat = gl.RGB32F;
        this._glPixelType = gl.FLOAT;
        break;
      case PIXELFORMAT_RGBA32F:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = gl.RGBA32F;
        this._glPixelType = gl.FLOAT;
        break;
      case PIXELFORMAT_R32F:
        this._glFormat = gl.RED;
        this._glInternalFormat = gl.R32F;
        this._glPixelType = gl.FLOAT;
        break;
      case PIXELFORMAT_DEPTH:
        this._glFormat = gl.DEPTH_COMPONENT;
        this._glInternalFormat = gl.DEPTH_COMPONENT32F;
        this._glPixelType = gl.FLOAT;
        break;
      case PIXELFORMAT_DEPTHSTENCIL:
        this._glFormat = gl.DEPTH_STENCIL;
        this._glInternalFormat = gl.DEPTH24_STENCIL8;
        this._glPixelType = gl.UNSIGNED_INT_24_8;
        break;
      case PIXELFORMAT_111110F:
        this._glFormat = gl.RGB;
        this._glInternalFormat = gl.R11F_G11F_B10F;
        this._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;
        break;
      case PIXELFORMAT_SRGB8:
        this._glFormat = gl.RGB;
        this._glInternalFormat = gl.SRGB8;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_SRGBA8:
        this._glFormat = gl.RGBA;
        this._glInternalFormat = gl.SRGB8_ALPHA8;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_R8I:
        this._glFormat = gl.RED_INTEGER;
        this._glInternalFormat = gl.R8I;
        this._glPixelType = gl.BYTE;
        break;
      case PIXELFORMAT_R8U:
        this._glFormat = gl.RED_INTEGER;
        this._glInternalFormat = gl.R8UI;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_R16I:
        this._glFormat = gl.RED_INTEGER;
        this._glInternalFormat = gl.R16I;
        this._glPixelType = gl.SHORT;
        break;
      case PIXELFORMAT_R16U:
        this._glFormat = gl.RED_INTEGER;
        this._glInternalFormat = gl.R16UI;
        this._glPixelType = gl.UNSIGNED_SHORT;
        break;
      case PIXELFORMAT_R32I:
        this._glFormat = gl.RED_INTEGER;
        this._glInternalFormat = gl.R32I;
        this._glPixelType = gl.INT;
        break;
      case PIXELFORMAT_R32U:
        this._glFormat = gl.RED_INTEGER;
        this._glInternalFormat = gl.R32UI;
        this._glPixelType = gl.UNSIGNED_INT;
        break;
      case PIXELFORMAT_RG8I:
        this._glFormat = gl.RG_INTEGER;
        this._glInternalFormat = gl.RG8I;
        this._glPixelType = gl.BYTE;
        break;
      case PIXELFORMAT_RG8U:
        this._glFormat = gl.RG_INTEGER;
        this._glInternalFormat = gl.RG8UI;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_RG16I:
        this._glFormat = gl.RG_INTEGER;
        this._glInternalFormat = gl.RG16I;
        this._glPixelType = gl.SHORT;
        break;
      case PIXELFORMAT_RG16U:
        this._glFormat = gl.RG_INTEGER;
        this._glInternalFormat = gl.RG16UI;
        this._glPixelType = gl.UNSIGNED_SHORT;
        break;
      case PIXELFORMAT_RG32I:
        this._glFormat = gl.RG_INTEGER;
        this._glInternalFormat = gl.RG32I;
        this._glPixelType = gl.INT;
        break;
      case PIXELFORMAT_RG32U:
        this._glFormat = gl.RG_INTEGER;
        this._glInternalFormat = gl.RG32UI;
        this._glPixelType = gl.UNSIGNED_INT;
        break;
      case PIXELFORMAT_RGBA8I:
        this._glFormat = gl.RGBA_INTEGER;
        this._glInternalFormat = gl.RGBA8I;
        this._glPixelType = gl.BYTE;
        break;
      case PIXELFORMAT_RGBA8U:
        this._glFormat = gl.RGBA_INTEGER;
        this._glInternalFormat = gl.RGBA8UI;
        this._glPixelType = gl.UNSIGNED_BYTE;
        break;
      case PIXELFORMAT_RGBA16I:
        this._glFormat = gl.RGBA_INTEGER;
        this._glInternalFormat = gl.RGBA16I;
        this._glPixelType = gl.SHORT;
        break;
      case PIXELFORMAT_RGBA16U:
        this._glFormat = gl.RGBA_INTEGER;
        this._glInternalFormat = gl.RGBA16UI;
        this._glPixelType = gl.UNSIGNED_SHORT;
        break;
      case PIXELFORMAT_RGBA32I:
        this._glFormat = gl.RGBA_INTEGER;
        this._glInternalFormat = gl.RGBA32I;
        this._glPixelType = gl.INT;
        break;
      case PIXELFORMAT_RGBA32U:
        this._glFormat = gl.RGBA_INTEGER;
        this._glInternalFormat = gl.RGBA32UI;
        this._glPixelType = gl.UNSIGNED_INT;
        break;
    }
    this._glCreated = false;
  }
  upload(device, texture) {
    const gl = device.gl;
    if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) {
      return;
    }
    let mipLevel = 0;
    let mipObject;
    let resMult;
    const requiredMipLevels = texture.requiredMipLevels;
    if (texture.array) {
      gl.texStorage3D(gl.TEXTURE_2D_ARRAY, requiredMipLevels, this._glInternalFormat, texture._width, texture._height, texture._arrayLength);
    }
    while (texture._levels[mipLevel] || mipLevel === 0) {
      if (!texture._needsUpload && mipLevel === 0) {
        mipLevel++;
        continue;
      } else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
        break;
      }
      mipObject = texture._levels[mipLevel];
      resMult = 1 / Math.pow(2, mipLevel);
      if (mipLevel === 1 && !texture._compressed && !texture._integerFormat && texture._levels.length < requiredMipLevels) {
        gl.generateMipmap(this._glTarget);
        texture._mipmapsUploaded = true;
      }
      if (texture._cubemap) {
        let face;
        if (device._isBrowserInterface(mipObject[0])) {
          for (face = 0; face < 6; face++) {
            if (!texture._levelsUpdated[0][face]) {
              continue;
            }
            let src = mipObject[face];
            if (device._isImageBrowserInterface(src)) {
              if (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {
                src = downsampleImage(src, device.maxCubeMapSize);
                if (mipLevel === 0) {
                  texture._width = src.width;
                  texture._height = src.height;
                }
              }
            }
            device.setUnpackFlipY(false);
            device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            if (this._glCreated) {
              gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, this._glFormat, this._glPixelType, src);
            } else {
              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);
            }
          }
        } else {
          resMult = 1 / Math.pow(2, mipLevel);
          for (face = 0; face < 6; face++) {
            if (!texture._levelsUpdated[0][face]) {
              continue;
            }
            const texData = mipObject[face];
            if (texture._compressed) {
              if (this._glCreated && texData) {
                gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glInternalFormat, texData);
              } else {
                gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
              }
            } else {
              device.setUnpackFlipY(false);
              device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
              if (this._glCreated && texData) {
                gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, texData);
              } else {
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);
              }
            }
          }
        }
      } else if (texture._volume) {
        if (texture._compressed) {
          gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
        } else {
          device.setUnpackFlipY(false);
          device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
          gl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
        }
      } else if (texture.array && typeof mipObject === "object") {
        if (texture._arrayLength === mipObject.length) {
          if (texture._compressed) {
            for (let index = 0; index < texture._arrayLength; index++) {
              gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glFormat, mipObject[index]);
            }
          } else {
            for (let index = 0; index < texture._arrayLength; index++) {
              gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glFormat, this._glPixelType, mipObject[index]);
            }
          }
        }
      } else {
        if (device._isBrowserInterface(mipObject)) {
          if (device._isImageBrowserInterface(mipObject)) {
            if (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {
              mipObject = downsampleImage(mipObject, device.maxTextureSize);
              if (mipLevel === 0) {
                texture._width = mipObject.width;
                texture._height = mipObject.height;
              }
            }
          }
          const w = mipObject.width || mipObject.videoWidth;
          const h2 = mipObject.height || mipObject.videoHeight;
          device.setUnpackFlipY(texture._flipY);
          device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
          if (this._glCreated && texture._width === w && texture._height === h2 && !device._isImageVideoInterface(mipObject)) {
            gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, this._glFormat, this._glPixelType, mipObject);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);
            if (mipLevel === 0) {
              texture._width = w;
              texture._height = h2;
            }
          }
        } else {
          resMult = 1 / Math.pow(2, mipLevel);
          if (texture._compressed) {
            if (this._glCreated && mipObject) {
              gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), this._glInternalFormat, mipObject);
            } else {
              gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);
            }
          } else {
            device.setUnpackFlipY(false);
            device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            if (this._glCreated && mipObject) {
              gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, mipObject);
            } else {
              gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
            }
          }
        }
        if (mipLevel === 0) {
          texture._mipmapsUploaded = false;
        } else {
          texture._mipmapsUploaded = true;
        }
      }
      mipLevel++;
    }
    if (texture._needsUpload) {
      if (texture._cubemap) {
        for (let i = 0; i < 6; i++) {
          texture._levelsUpdated[0][i] = false;
        }
      } else {
        texture._levelsUpdated[0] = false;
      }
    }
    if (!texture._compressed && !texture._integerFormat && texture._mipmaps && texture._needsMipmapsUpload && texture._levels.length === 1) {
      gl.generateMipmap(this._glTarget);
      texture._mipmapsUploaded = true;
    }
    if (texture._gpuSize) {
      texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
    }
    texture._gpuSize = texture.gpuSize;
    texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
    this._glCreated = true;
  }
  read(x2, y2, width, height, options2) {
    const texture = this.texture;
    const device = texture.device;
    return device.readTextureAsync(texture, x2, y2, width, height, options2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-render-target.js
var FramebufferPair = class {
  constructor(msaaFB, resolveFB) {
    this.msaaFB = void 0;
    this.resolveFB = void 0;
    this.msaaFB = msaaFB;
    this.resolveFB = resolveFB;
  }
  destroy(gl) {
    if (this.msaaFB) {
      gl.deleteRenderbuffer(this.msaaFB);
      this.msaaFB = null;
    }
    if (this.resolveFB) {
      gl.deleteRenderbuffer(this.resolveFB);
      this.resolveFB = null;
    }
  }
};
var WebglRenderTarget = class {
  constructor() {
    this._glFrameBuffer = null;
    this._glDepthBuffer = null;
    this._glResolveFrameBuffer = null;
    this.colorMrtFramebuffers = null;
    this._glMsaaColorBuffers = [];
    this._glMsaaDepthBuffer = null;
    this.suppliedColorFramebuffer = void 0;
    this._isInitialized = false;
  }
  destroy(device) {
    var _this$colorMrtFramebu;
    const gl = device.gl;
    this._isInitialized = false;
    if (this._glFrameBuffer) {
      if (this._glFrameBuffer !== this.suppliedColorFramebuffer) {
        gl.deleteFramebuffer(this._glFrameBuffer);
      }
      this._glFrameBuffer = null;
    }
    if (this._glDepthBuffer) {
      gl.deleteRenderbuffer(this._glDepthBuffer);
      this._glDepthBuffer = null;
    }
    if (this._glResolveFrameBuffer) {
      if (this._glResolveFrameBuffer !== this.suppliedColorFramebuffer) {
        gl.deleteFramebuffer(this._glResolveFrameBuffer);
      }
      this._glResolveFrameBuffer = null;
    }
    this._glMsaaColorBuffers.forEach((buffer) => {
      gl.deleteRenderbuffer(buffer);
    });
    this._glMsaaColorBuffers.length = 0;
    (_this$colorMrtFramebu = this.colorMrtFramebuffers) == null || _this$colorMrtFramebu.forEach((framebuffer) => {
      framebuffer.destroy(gl);
    });
    this.colorMrtFramebuffers = null;
    if (this._glMsaaDepthBuffer) {
      gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
      this._glMsaaDepthBuffer = null;
    }
    this.suppliedColorFramebuffer = void 0;
  }
  get initialized() {
    return this._isInitialized;
  }
  init(device, target2) {
    const gl = device.gl;
    this._isInitialized = true;
    const buffers = [];
    if (this.suppliedColorFramebuffer !== void 0) {
      this._glFrameBuffer = this.suppliedColorFramebuffer;
    } else {
      var _target$_colorBuffers, _target$_colorBuffers2;
      this._glFrameBuffer = gl.createFramebuffer();
      device.setFramebuffer(this._glFrameBuffer);
      const colorBufferCount = (_target$_colorBuffers = (_target$_colorBuffers2 = target2._colorBuffers) == null ? void 0 : _target$_colorBuffers2.length) != null ? _target$_colorBuffers : 0;
      const attachmentBaseConstant = gl.COLOR_ATTACHMENT0;
      for (let i = 0; i < colorBufferCount; ++i) {
        const colorBuffer = target2.getColorBuffer(i);
        if (colorBuffer) {
          if (!colorBuffer.impl._glTexture) {
            colorBuffer._width = Math.min(colorBuffer.width, device.maxRenderBufferSize);
            colorBuffer._height = Math.min(colorBuffer.height, device.maxRenderBufferSize);
            device.setTexture(colorBuffer, 0);
          }
          gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant + i, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target2._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
          buffers.push(attachmentBaseConstant + i);
        }
      }
      gl.drawBuffers(buffers);
      const depthBuffer = target2._depthBuffer;
      if (depthBuffer) {
        if (!depthBuffer.impl._glTexture) {
          depthBuffer._width = Math.min(depthBuffer.width, device.maxRenderBufferSize);
          depthBuffer._height = Math.min(depthBuffer.height, device.maxRenderBufferSize);
          device.setTexture(depthBuffer, 0);
        }
        if (target2._stencil) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target2._face : gl.TEXTURE_2D, target2._depthBuffer.impl._glTexture, 0);
        } else {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target2._face : gl.TEXTURE_2D, target2._depthBuffer.impl._glTexture, 0);
        }
      } else if (target2._depth) {
        const willRenderMsaa = target2._samples > 1;
        if (!willRenderMsaa) {
          if (!this._glDepthBuffer) {
            this._glDepthBuffer = gl.createRenderbuffer();
          }
          gl.bindRenderbuffer(gl.RENDERBUFFER, this._glDepthBuffer);
          if (target2._stencil) {
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target2.width, target2.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);
          } else {
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT32F, target2.width, target2.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);
          }
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
      }
    }
    if (target2._samples > 1) {
      var _target$_colorBuffers3, _target$_colorBuffers4;
      this._glResolveFrameBuffer = this._glFrameBuffer;
      this._glFrameBuffer = gl.createFramebuffer();
      device.setFramebuffer(this._glFrameBuffer);
      const colorBufferCount = (_target$_colorBuffers3 = (_target$_colorBuffers4 = target2._colorBuffers) == null ? void 0 : _target$_colorBuffers4.length) != null ? _target$_colorBuffers3 : 0;
      if (this.suppliedColorFramebuffer !== void 0) {
        const buffer = gl.createRenderbuffer();
        this._glMsaaColorBuffers.push(buffer);
        const internalFormat = device.backBufferFormat === PIXELFORMAT_RGBA8 ? gl.RGBA8 : gl.RGB8;
        gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target2._samples, internalFormat, target2.width, target2.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
      } else {
        for (let i = 0; i < colorBufferCount; ++i) {
          const colorBuffer = target2.getColorBuffer(i);
          if (colorBuffer) {
            const buffer = gl.createRenderbuffer();
            this._glMsaaColorBuffers.push(buffer);
            gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target2._samples, colorBuffer.impl._glInternalFormat, target2.width, target2.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, buffer);
          }
        }
      }
      if (target2._depth) {
        if (!this._glMsaaDepthBuffer) {
          this._glMsaaDepthBuffer = gl.createRenderbuffer();
        }
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaDepthBuffer);
        if (target2._stencil) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target2._samples, gl.DEPTH24_STENCIL8, target2.width, target2.height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
        } else {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target2._samples, gl.DEPTH_COMPONENT32F, target2.width, target2.height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
        }
      }
      if (colorBufferCount > 1) {
        this._createMsaaMrtFramebuffers(device, target2, colorBufferCount);
        device.setFramebuffer(this._glFrameBuffer);
        gl.drawBuffers(buffers);
      }
    }
  }
  _createMsaaMrtFramebuffers(device, target2, colorBufferCount) {
    const gl = device.gl;
    this.colorMrtFramebuffers = [];
    for (let i = 0; i < colorBufferCount; ++i) {
      const colorBuffer = target2.getColorBuffer(i);
      const srcFramebuffer = gl.createFramebuffer();
      device.setFramebuffer(srcFramebuffer);
      const buffer = this._glMsaaColorBuffers[i];
      gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target2._samples, colorBuffer.impl._glInternalFormat, target2.width, target2.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
      const dstFramebuffer = gl.createFramebuffer();
      device.setFramebuffer(dstFramebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target2._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
      this.colorMrtFramebuffers[i] = new FramebufferPair(srcFramebuffer, dstFramebuffer);
    }
  }
  _checkFbo(device, target2, type = "") {
    const gl = device.gl;
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    switch (status) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        break;
      case gl.FRAMEBUFFER_UNSUPPORTED:
        break;
    }
  }
  loseContext() {
    this._glFrameBuffer = null;
    this._glDepthBuffer = null;
    this._glResolveFrameBuffer = null;
    this._glMsaaColorBuffers.length = 0;
    this._glMsaaDepthBuffer = null;
    this.colorMrtFramebuffers = null;
    this.suppliedColorFramebuffer = void 0;
    this._isInitialized = false;
  }
  internalResolve(device, src, dst, target2, mask) {
    device.setScissor(0, 0, target2.width, target2.height);
    const gl = device.gl;
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
    gl.blitFramebuffer(0, 0, target2.width, target2.height, 0, 0, target2.width, target2.height, mask, gl.NEAREST);
  }
  resolve(device, target2, color, depth) {
    const gl = device.gl;
    if (this.colorMrtFramebuffers) {
      if (color) {
        for (let i = 0; i < this.colorMrtFramebuffers.length; i++) {
          const fbPair = this.colorMrtFramebuffers[i];
          this.internalResolve(device, fbPair.msaaFB, fbPair.resolveFB, target2, gl.COLOR_BUFFER_BIT);
        }
      }
      if (depth) {
        this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target2, gl.DEPTH_BUFFER_BIT);
      }
    } else {
      this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target2, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0));
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-gpu-profiler.js
var FrameQueriesInfo = class {
  constructor() {
    this.renderVersion = void 0;
    this.queries = [];
  }
  destroy(gl) {
    this.queries.forEach((query) => gl.deleteQuery(query));
    this.queries = null;
  }
};
var WebglGpuProfiler = class extends GpuProfiler {
  constructor(device) {
    super();
    this.device = void 0;
    this.freeQueries = [];
    this.frameQueries = [];
    this.previousFrameQueries = [];
    this.timings = [];
    this.device = device;
    this.ext = device.extDisjointTimerQuery;
  }
  destroy() {
    this.freeQueries.forEach((query) => this.device.gl.deleteQuery(query));
    this.frameQueries.forEach((query) => this.device.gl.deleteQuery(query));
    this.previousFrameQueries.forEach((frameQueriesInfo) => frameQueriesInfo.destroy(this.device.gl));
    this.freeQueries = null;
    this.frameQueries = null;
    this.previousFrameQueries = null;
  }
  loseContext() {
    super.loseContext();
    this.freeQueries = [];
    this.frameQueries = [];
    this.previousFrameQueries = [];
  }
  restoreContext() {
    this.ext = this.device.extDisjointTimerQuery;
  }
  getQuery() {
    var _this$freeQueries$pop;
    return (_this$freeQueries$pop = this.freeQueries.pop()) != null ? _this$freeQueries$pop : this.device.gl.createQuery();
  }
  start(name) {
    if (this.ext) {
      const slot = this.getSlot(name);
      const query = this.getQuery();
      this.frameQueries[slot] = query;
      this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
      return slot;
    }
    return void 0;
  }
  end(slot) {
    if (slot !== void 0) {
      this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
    }
  }
  frameStart() {
    this.processEnableRequest();
    if (this._enabled) {
      this.frameGPUMarkerSlot = this.start("GpuFrame");
    }
  }
  frameEnd() {
    if (this._enabled) {
      this.end(this.frameGPUMarkerSlot);
    }
  }
  request() {
    if (this._enabled) {
      const ext = this.ext;
      const gl = this.device.gl;
      const renderVersion = this.device.renderVersion;
      const frameQueries = this.frameQueries;
      if (frameQueries.length > 0) {
        this.frameQueries = [];
        const frameQueriesInfo = new FrameQueriesInfo();
        frameQueriesInfo.queries = frameQueries;
        frameQueriesInfo.renderVersion = renderVersion;
        this.previousFrameQueries.push(frameQueriesInfo);
      }
      if (this.previousFrameQueries.length > 0) {
        const previousQueriesInfo = this.previousFrameQueries[0];
        const previousQueries = previousQueriesInfo.queries;
        const lastQuery = previousQueries[previousQueries.length - 1];
        const available = gl.getQueryParameter(lastQuery, gl.QUERY_RESULT_AVAILABLE);
        const disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
        if (available && !disjoint) {
          this.previousFrameQueries.shift();
          const timings = this.timings;
          timings.length = 0;
          for (let i = 0; i < previousQueries.length; i++) {
            const query = previousQueries[i];
            const duration = gl.getQueryParameter(query, gl.QUERY_RESULT);
            timings[i] = duration * 1e-6;
            this.freeQueries.push(query);
          }
          this.report(previousQueriesInfo.renderVersion, timings);
        }
        if (disjoint) {
          this.previousFrameQueries.forEach((frameQueriesInfo) => {
            this.report(frameQueriesInfo.renderVersion, null);
            frameQueriesInfo.destroy(gl);
          });
          this.previousFrameQueries.length = 0;
        }
      }
      super.request(renderVersion);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-graphics-device.js
var invalidateAttachments = [];
var WebglGraphicsDevice = class extends GraphicsDevice {
  constructor(canvas, options2 = {}) {
    var _options$antialias, _options$gl;
    super(canvas, options2);
    this.gl = void 0;
    this._defaultFramebuffer = null;
    this._defaultFramebufferChanged = false;
    options2 = this.initOptions;
    this.updateClientRect();
    this.initTextureUnits();
    this.contextLost = false;
    this._contextLostHandler = (event) => {
      event.preventDefault();
      this.loseContext();
      this.fire("devicelost");
    };
    this._contextRestoredHandler = () => {
      this.restoreContext();
      this.fire("devicerestored");
    };
    const ua2 = typeof navigator !== "undefined" && navigator.userAgent;
    this.forceDisableMultisampling = ua2 && ua2.includes("AppleWebKit") && (ua2.includes("15.4") || ua2.includes("15_4"));
    if (this.forceDisableMultisampling) {
      options2.antialias = false;
    }
    if (platform.browserName === "firefox" && platform.name === "windows") {
      const _ua = typeof navigator !== "undefined" ? navigator.userAgent : "";
      const match = _ua.match(/Firefox\/(\d+(\.\d+)*)/);
      const firefoxVersion = match ? match[1] : null;
      if (firefoxVersion) {
        const version2 = parseFloat(firefoxVersion);
        if (version2 >= 120 || version2 === 115) {
          options2.antialias = false;
        }
      }
    }
    this.backBufferAntialias = (_options$antialias = options2.antialias) != null ? _options$antialias : false;
    options2.antialias = false;
    const gl = (_options$gl = options2.gl) != null ? _options$gl : canvas.getContext("webgl2", options2);
    if (!gl) {
      throw new Error("WebGL not supported");
    }
    this.gl = gl;
    this.isWebGL2 = true;
    this._deviceType = DEVICETYPE_WEBGL2;
    this.updateBackbufferFormat(null);
    const isChrome = platform.browserName === "chrome";
    const isSafari = platform.browserName === "safari";
    const isMac = platform.browser && navigator.appVersion.indexOf("Mac") !== -1;
    this._tempEnableSafariTextureUnitWorkaround = isSafari;
    this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options2.alpha;
    canvas.addEventListener("webglcontextlost", this._contextLostHandler, false);
    canvas.addEventListener("webglcontextrestored", this._contextRestoredHandler, false);
    this.initializeExtensions();
    this.initializeCapabilities();
    this.initializeRenderState();
    this.initializeContextCaches();
    this.createBackbuffer(null);
    this.supportsImageBitmap = !isSafari && typeof ImageBitmap !== "undefined";
    this._samplerTypes = /* @__PURE__ */ new Set([gl.SAMPLER_2D, gl.SAMPLER_CUBE, gl.UNSIGNED_INT_SAMPLER_2D, gl.INT_SAMPLER_2D, gl.SAMPLER_2D_SHADOW, gl.SAMPLER_CUBE_SHADOW, gl.SAMPLER_3D, gl.INT_SAMPLER_3D, gl.UNSIGNED_INT_SAMPLER_3D, gl.SAMPLER_2D_ARRAY, gl.INT_SAMPLER_2D_ARRAY, gl.UNSIGNED_INT_SAMPLER_2D_ARRAY]);
    this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
    this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, gl.MIN, gl.MAX];
    this.glBlendFunctionColor = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_COLOR, gl.ONE_MINUS_CONSTANT_COLOR];
    this.glBlendFunctionAlpha = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA];
    this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];
    this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];
    this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];
    this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];
    this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
    this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
    this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT, gl.HALF_FLOAT];
    this.pcUniformType = {};
    this.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;
    this.pcUniformType[gl.INT] = UNIFORMTYPE_INT;
    this.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;
    this.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;
    this.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;
    this.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;
    this.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;
    this.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;
    this.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;
    this.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;
    this.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;
    this.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;
    this.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;
    this.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;
    this.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;
    this.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;
    this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;
    this.pcUniformType[gl.UNSIGNED_INT] = UNIFORMTYPE_UINT;
    this.pcUniformType[gl.UNSIGNED_INT_VEC2] = UNIFORMTYPE_UVEC2;
    this.pcUniformType[gl.UNSIGNED_INT_VEC3] = UNIFORMTYPE_UVEC3;
    this.pcUniformType[gl.UNSIGNED_INT_VEC4] = UNIFORMTYPE_UVEC4;
    this.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;
    this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
    this.pcUniformType[gl.SAMPLER_2D_ARRAY] = UNIFORMTYPE_TEXTURE2D_ARRAY;
    this.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;
    this.pcUniformType[gl.INT_SAMPLER_2D] = UNIFORMTYPE_ITEXTURE2D;
    this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURE2D;
    this.pcUniformType[gl.INT_SAMPLER_CUBE] = UNIFORMTYPE_ITEXTURECUBE;
    this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURECUBE;
    this.pcUniformType[gl.INT_SAMPLER_3D] = UNIFORMTYPE_ITEXTURE3D;
    this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_3D] = UNIFORMTYPE_UTEXTURE3D;
    this.pcUniformType[gl.INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_ITEXTURE2D_ARRAY;
    this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_UTEXTURE2D_ARRAY;
    this.targetToSlot = {};
    this.targetToSlot[gl.TEXTURE_2D] = 0;
    this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
    this.targetToSlot[gl.TEXTURE_3D] = 2;
    let scopeX, scopeY, scopeZ, scopeW;
    let uniformValue;
    this.commitFunction = [];
    this.commitFunction[UNIFORMTYPE_BOOL] = function(uniform, value) {
      if (uniform.value !== value) {
        gl.uniform1i(uniform.locationId, value);
        uniform.value = value;
      }
    };
    this.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];
    this.commitFunction[UNIFORMTYPE_FLOAT] = function(uniform, value) {
      if (uniform.value !== value) {
        gl.uniform1f(uniform.locationId, value);
        uniform.value = value;
      }
    };
    this.commitFunction[UNIFORMTYPE_VEC2] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
        gl.uniform2fv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
      }
    };
    this.commitFunction[UNIFORMTYPE_VEC3] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
        gl.uniform3fv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
      }
    };
    this.commitFunction[UNIFORMTYPE_VEC4] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      scopeW = value[3];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
        gl.uniform4fv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
        uniformValue[3] = scopeW;
      }
    };
    this.commitFunction[UNIFORMTYPE_IVEC2] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
        gl.uniform2iv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
      }
    };
    this.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];
    this.commitFunction[UNIFORMTYPE_IVEC3] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
        gl.uniform3iv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
      }
    };
    this.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];
    this.commitFunction[UNIFORMTYPE_IVEC4] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      scopeW = value[3];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
        gl.uniform4iv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
        uniformValue[3] = scopeW;
      }
    };
    this.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];
    this.commitFunction[UNIFORMTYPE_MAT2] = function(uniform, value) {
      gl.uniformMatrix2fv(uniform.locationId, false, value);
    };
    this.commitFunction[UNIFORMTYPE_MAT3] = function(uniform, value) {
      gl.uniformMatrix3fv(uniform.locationId, false, value);
    };
    this.commitFunction[UNIFORMTYPE_MAT4] = function(uniform, value) {
      gl.uniformMatrix4fv(uniform.locationId, false, value);
    };
    this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function(uniform, value) {
      gl.uniform1fv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function(uniform, value) {
      gl.uniform2fv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function(uniform, value) {
      gl.uniform3fv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function(uniform, value) {
      gl.uniform4fv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_UINT] = function(uniform, value) {
      if (uniform.value !== value) {
        gl.uniform1ui(uniform.locationId, value);
        uniform.value = value;
      }
    };
    this.commitFunction[UNIFORMTYPE_UVEC2] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
        gl.uniform2uiv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
      }
    };
    this.commitFunction[UNIFORMTYPE_UVEC3] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
        gl.uniform3uiv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
      }
    };
    this.commitFunction[UNIFORMTYPE_UVEC4] = function(uniform, value) {
      uniformValue = uniform.value;
      scopeX = value[0];
      scopeY = value[1];
      scopeZ = value[2];
      scopeW = value[3];
      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
        gl.uniform4uiv(uniform.locationId, value);
        uniformValue[0] = scopeX;
        uniformValue[1] = scopeY;
        uniformValue[2] = scopeZ;
        uniformValue[3] = scopeW;
      }
    };
    this.commitFunction[UNIFORMTYPE_INTARRAY] = function(uniform, value) {
      gl.uniform1iv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_UINTARRAY] = function(uniform, value) {
      gl.uniform1uiv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_BOOLARRAY] = this.commitFunction[UNIFORMTYPE_INTARRAY];
    this.commitFunction[UNIFORMTYPE_IVEC2ARRAY] = function(uniform, value) {
      gl.uniform2iv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_UVEC2ARRAY] = function(uniform, value) {
      gl.uniform2uiv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_BVEC2ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC2ARRAY];
    this.commitFunction[UNIFORMTYPE_IVEC3ARRAY] = function(uniform, value) {
      gl.uniform3iv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_UVEC3ARRAY] = function(uniform, value) {
      gl.uniform3uiv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_BVEC3ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC3ARRAY];
    this.commitFunction[UNIFORMTYPE_IVEC4ARRAY] = function(uniform, value) {
      gl.uniform4iv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_UVEC4ARRAY] = function(uniform, value) {
      gl.uniform4uiv(uniform.locationId, value);
    };
    this.commitFunction[UNIFORMTYPE_BVEC4ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC4ARRAY];
    this.commitFunction[UNIFORMTYPE_MAT4ARRAY] = function(uniform, value) {
      gl.uniformMatrix4fv(uniform.locationId, false, value);
    };
    this.constantTexSource = this.scope.resolve("source");
    this.textureFloatRenderable = !!this.extColorBufferFloat;
    this.extColorBufferHalfFloat = this.extColorBufferHalfFloat || !!this.extColorBufferFloat;
    this.postInit();
  }
  postInit() {
    super.postInit();
    this.gpuProfiler = new WebglGpuProfiler(this);
  }
  destroy() {
    super.destroy();
    const gl = this.gl;
    if (this.feedback) {
      gl.deleteTransformFeedback(this.feedback);
    }
    this.clearVertexArrayObjectCache();
    this.canvas.removeEventListener("webglcontextlost", this._contextLostHandler, false);
    this.canvas.removeEventListener("webglcontextrestored", this._contextRestoredHandler, false);
    this._contextLostHandler = null;
    this._contextRestoredHandler = null;
    this.gl = null;
    super.postDestroy();
  }
  createBackbuffer(frameBuffer) {
    this.supportsStencil = this.initOptions.stencil;
    this.backBuffer = new RenderTarget({
      name: "WebglFramebuffer",
      graphicsDevice: this,
      depth: this.initOptions.depth,
      stencil: this.supportsStencil,
      samples: this.samples
    });
    this.backBuffer.impl.suppliedColorFramebuffer = frameBuffer;
  }
  updateBackbufferFormat(framebuffer) {
    const gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    const alphaBits = this.gl.getParameter(this.gl.ALPHA_BITS);
    this.backBufferFormat = alphaBits ? PIXELFORMAT_RGBA8 : PIXELFORMAT_RGB8;
  }
  updateBackbuffer() {
    const resolutionChanged = this.canvas.width !== this.backBufferSize.x || this.canvas.height !== this.backBufferSize.y;
    if (this._defaultFramebufferChanged || resolutionChanged) {
      if (this._defaultFramebufferChanged) {
        this.updateBackbufferFormat(this._defaultFramebuffer);
      }
      this._defaultFramebufferChanged = false;
      this.backBufferSize.set(this.canvas.width, this.canvas.height);
      this.backBuffer.destroy();
      this.createBackbuffer(this._defaultFramebuffer);
    }
  }
  createVertexBufferImpl(vertexBuffer, format) {
    return new WebglVertexBuffer();
  }
  createIndexBufferImpl(indexBuffer) {
    return new WebglIndexBuffer(indexBuffer);
  }
  createShaderImpl(shader) {
    return new WebglShader(shader);
  }
  createTextureImpl(texture) {
    return new WebglTexture(texture);
  }
  createRenderTargetImpl(renderTarget) {
    return new WebglRenderTarget();
  }
  getPrecision() {
    const gl = this.gl;
    let precision = "highp";
    if (gl.getShaderPrecisionFormat) {
      const vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
      const vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
      const fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
      const fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
      if (vertexShaderPrecisionHighpFloat && vertexShaderPrecisionMediumpFloat && fragmentShaderPrecisionHighpFloat && fragmentShaderPrecisionMediumpFloat) {
        const highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
        const mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
        if (!highpAvailable) {
          if (mediumpAvailable) {
            precision = "mediump";
          } else {
            precision = "lowp";
          }
        }
      }
    }
    return precision;
  }
  getExtension() {
    for (let i = 0; i < arguments.length; i++) {
      if (this.supportedExtensions.indexOf(arguments[i]) !== -1) {
        return this.gl.getExtension(arguments[i]);
      }
    }
    return null;
  }
  get extDisjointTimerQuery() {
    if (!this._extDisjointTimerQuery) {
      this._extDisjointTimerQuery = this.getExtension("EXT_disjoint_timer_query_webgl2", "EXT_disjoint_timer_query");
    }
    return this._extDisjointTimerQuery;
  }
  initializeExtensions() {
    var _gl$getSupportedExten;
    const gl = this.gl;
    this.supportedExtensions = (_gl$getSupportedExten = gl.getSupportedExtensions()) != null ? _gl$getSupportedExten : [];
    this._extDisjointTimerQuery = null;
    this.textureRG11B10Renderable = true;
    this.extColorBufferFloat = this.getExtension("EXT_color_buffer_float");
    this.extDebugRendererInfo = this.getExtension("WEBGL_debug_renderer_info");
    this.extTextureFloatLinear = this.getExtension("OES_texture_float_linear");
    this.textureFloatFilterable = !!this.extTextureFloatLinear;
    this.extFloatBlend = this.getExtension("EXT_float_blend");
    this.extTextureFilterAnisotropic = this.getExtension("EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic");
    this.extParallelShaderCompile = this.getExtension("KHR_parallel_shader_compile");
    this.extCompressedTextureETC1 = this.getExtension("WEBGL_compressed_texture_etc1");
    this.extCompressedTextureETC = this.getExtension("WEBGL_compressed_texture_etc");
    this.extCompressedTexturePVRTC = this.getExtension("WEBGL_compressed_texture_pvrtc", "WEBKIT_WEBGL_compressed_texture_pvrtc");
    this.extCompressedTextureS3TC = this.getExtension("WEBGL_compressed_texture_s3tc", "WEBKIT_WEBGL_compressed_texture_s3tc");
    this.extCompressedTextureATC = this.getExtension("WEBGL_compressed_texture_atc");
    this.extCompressedTextureASTC = this.getExtension("WEBGL_compressed_texture_astc");
    this.extColorBufferHalfFloat = this.getExtension("EXT_color_buffer_half_float");
  }
  initializeCapabilities() {
    var _contextAttribs$antia, _contextAttribs$stenc;
    const gl = this.gl;
    let ext;
    const userAgent = typeof navigator !== "undefined" ? navigator.userAgent : "";
    this.maxPrecision = this.precision = this.getPrecision();
    const contextAttribs = gl.getContextAttributes();
    this.supportsMsaa = (_contextAttribs$antia = contextAttribs == null ? void 0 : contextAttribs.antialias) != null ? _contextAttribs$antia : false;
    this.supportsStencil = (_contextAttribs$stenc = contextAttribs == null ? void 0 : contextAttribs.stencil) != null ? _contextAttribs$stenc : false;
    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
    this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
    ext = this.extDebugRendererInfo;
    this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : "";
    this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : "";
    const maliRendererRegex = /\bMali-G52+/;
    const samsungModelRegex = /SM-[a-zA-Z0-9]+/;
    this.supportsGpuParticles = !(this.unmaskedVendor === "ARM" && userAgent.match(samsungModelRegex)) && !this.unmaskedRenderer.match(maliRendererRegex);
    ext = this.extTextureFilterAnisotropic;
    this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    const antialiasSupported = !this.forceDisableMultisampling;
    this.maxSamples = antialiasSupported ? gl.getParameter(gl.MAX_SAMPLES) : 1;
    this.maxSamples = Math.min(this.maxSamples, 4);
    this.samples = antialiasSupported && this.backBufferAntialias ? this.maxSamples : 1;
    this.supportsAreaLights = !platform.android;
    if (this.maxTextures <= 8) {
      this.supportsAreaLights = false;
    }
  }
  initializeRenderState() {
    super.initializeRenderState();
    const gl = this.gl;
    gl.disable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);
    gl.colorMask(true, true, true, true);
    gl.blendColor(0, 0, 0, 0);
    gl.enable(gl.CULL_FACE);
    this.cullFace = gl.BACK;
    gl.cullFace(gl.BACK);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.depthMask(true);
    this.stencil = false;
    gl.disable(gl.STENCIL_TEST);
    this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
    this.stencilRefFront = this.stencilRefBack = 0;
    this.stencilMaskFront = this.stencilMaskBack = 255;
    gl.stencilFunc(gl.ALWAYS, 0, 255);
    this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
    this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
    this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
    this.stencilWriteMaskFront = 255;
    this.stencilWriteMaskBack = 255;
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(255);
    this.alphaToCoverage = false;
    this.raster = true;
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.disable(gl.RASTERIZER_DISCARD);
    this.depthBiasEnabled = false;
    gl.disable(gl.POLYGON_OFFSET_FILL);
    this.clearDepth = 1;
    gl.clearDepth(1);
    this.clearColor = new Color(0, 0, 0, 0);
    gl.clearColor(0, 0, 0, 0);
    this.clearStencil = 0;
    gl.clearStencil(0);
    gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
    gl.enable(gl.SCISSOR_TEST);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    this.unpackFlipY = false;
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    this.unpackPremultiplyAlpha = false;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
  }
  initTextureUnits(count = 16) {
    this.textureUnits = [];
    for (let i = 0; i < count; i++) {
      this.textureUnits.push([null, null, null]);
    }
  }
  initializeContextCaches() {
    super.initializeContextCaches();
    this._vaoMap = /* @__PURE__ */ new Map();
    this.boundVao = null;
    this.activeFramebuffer = null;
    this.feedback = null;
    this.transformFeedbackBuffer = null;
    this.textureUnit = 0;
    this.initTextureUnits(this.maxCombinedTextures);
  }
  loseContext() {
    super.loseContext();
    for (const shader of this.shaders) {
      shader.loseContext();
    }
  }
  restoreContext() {
    this.initializeExtensions();
    this.initializeCapabilities();
    super.restoreContext();
    for (const shader of this.shaders) {
      shader.restoreContext();
    }
  }
  setViewport(x2, y2, w, h2) {
    if (this.vx !== x2 || this.vy !== y2 || this.vw !== w || this.vh !== h2) {
      this.gl.viewport(x2, y2, w, h2);
      this.vx = x2;
      this.vy = y2;
      this.vw = w;
      this.vh = h2;
    }
  }
  setScissor(x2, y2, w, h2) {
    if (this.sx !== x2 || this.sy !== y2 || this.sw !== w || this.sh !== h2) {
      this.gl.scissor(x2, y2, w, h2);
      this.sx = x2;
      this.sy = y2;
      this.sw = w;
      this.sh = h2;
    }
  }
  setFramebuffer(fb) {
    if (this.activeFramebuffer !== fb) {
      const gl = this.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      this.activeFramebuffer = fb;
    }
  }
  copyRenderTarget(source, dest, color, depth) {
    var _this$backBuffer, _this$backBuffer2;
    const gl = this.gl;
    if (source === this.backBuffer) {
      source = null;
    }
    if (color) {
      if (!dest) {
        if (!source._colorBuffer) {
          return false;
        }
      } else if (source) {
        if (!source._colorBuffer || !dest._colorBuffer) {
          return false;
        }
        if (source._colorBuffer._format !== dest._colorBuffer._format) {
          return false;
        }
      }
    }
    if (depth && source) {
      if (!source._depth) {
        if (!source._depthBuffer || !dest._depthBuffer) {
          return false;
        }
        if (source._depthBuffer._format !== dest._depthBuffer._format) {
          return false;
        }
      }
    }
    const prevRt = this.renderTarget;
    this.renderTarget = dest;
    this.updateBegin();
    const src = source ? source.impl._glFrameBuffer : (_this$backBuffer = this.backBuffer) == null ? void 0 : _this$backBuffer.impl._glFrameBuffer;
    const dst = dest ? dest.impl._glFrameBuffer : (_this$backBuffer2 = this.backBuffer) == null ? void 0 : _this$backBuffer2.impl._glFrameBuffer;
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
    const w = source ? source.width : dest ? dest.width : this.width;
    const h2 = source ? source.height : dest ? dest.height : this.height;
    gl.blitFramebuffer(0, 0, w, h2, 0, 0, w, h2, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
    this.renderTarget = prevRt;
    gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt.impl._glFrameBuffer : null);
    return true;
  }
  frameStart() {
    super.frameStart();
    this.updateBackbuffer();
    this.gpuProfiler.frameStart();
  }
  frameEnd() {
    super.frameEnd();
    this.gpuProfiler.frameEnd();
    this.gpuProfiler.request();
  }
  startRenderPass(renderPass) {
    var _renderPass$renderTar;
    const rt = (_renderPass$renderTar = renderPass.renderTarget) != null ? _renderPass$renderTar : this.backBuffer;
    this.renderTarget = rt;
    this.updateBegin();
    const {
      width,
      height
    } = rt;
    this.setViewport(0, 0, width, height);
    this.setScissor(0, 0, width, height);
    const colorOps = renderPass.colorOps;
    const depthStencilOps = renderPass.depthStencilOps;
    if (colorOps != null && colorOps.clear || depthStencilOps.clearDepth || depthStencilOps.clearStencil) {
      let clearFlags = 0;
      const clearOptions = {};
      if (colorOps != null && colorOps.clear) {
        clearFlags |= CLEARFLAG_COLOR;
        clearOptions.color = [colorOps.clearValue.r, colorOps.clearValue.g, colorOps.clearValue.b, colorOps.clearValue.a];
      }
      if (depthStencilOps.clearDepth) {
        clearFlags |= CLEARFLAG_DEPTH;
        clearOptions.depth = depthStencilOps.clearDepthValue;
      }
      if (depthStencilOps.clearStencil) {
        clearFlags |= CLEARFLAG_STENCIL;
        clearOptions.stencil = depthStencilOps.clearStencilValue;
      }
      clearOptions.flags = clearFlags;
      this.clear(clearOptions);
    }
    this.insideRenderPass = true;
  }
  endRenderPass(renderPass) {
    this.unbindVertexArray();
    const target2 = this.renderTarget;
    const colorBufferCount = renderPass.colorArrayOps.length;
    if (target2) {
      var _renderPass$colorOps;
      invalidateAttachments.length = 0;
      const gl = this.gl;
      for (let i = 0; i < colorBufferCount; i++) {
        const colorOps = renderPass.colorArrayOps[i];
        if (!(colorOps.store || colorOps.resolve)) {
          invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + i);
        }
      }
      if (target2 !== this.backBuffer) {
        if (!renderPass.depthStencilOps.storeDepth) {
          invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
        }
        if (!renderPass.depthStencilOps.storeStencil) {
          invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
        }
      }
      if (invalidateAttachments.length > 0) {
        if (renderPass.fullSizeClearRect) {
          gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, invalidateAttachments);
        }
      }
      if ((_renderPass$colorOps = renderPass.colorOps) != null && _renderPass$colorOps.resolve) {
        if (renderPass.samples > 1 && target2.autoResolve) {
          target2.resolve(true, false);
        }
      }
      for (let i = 0; i < colorBufferCount; i++) {
        const colorOps = renderPass.colorArrayOps[i];
        if (colorOps.mipmaps) {
          const colorBuffer = target2._colorBuffers[i];
          if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps) {
            this.activeTexture(this.maxCombinedTextures - 1);
            this.bindTexture(colorBuffer);
            this.gl.generateMipmap(colorBuffer.impl._glTarget);
          }
        }
      }
    }
    this.insideRenderPass = false;
  }
  set defaultFramebuffer(value) {
    if (this._defaultFramebuffer !== value) {
      this._defaultFramebuffer = value;
      this._defaultFramebufferChanged = true;
    }
  }
  get defaultFramebuffer() {
    return this._defaultFramebuffer;
  }
  updateBegin() {
    var _this$renderTarget;
    this.boundVao = null;
    if (this._tempEnableSafariTextureUnitWorkaround) {
      for (let unit = 0; unit < this.textureUnits.length; ++unit) {
        for (let slot = 0; slot < 3; ++slot) {
          this.textureUnits[unit][slot] = null;
        }
      }
    }
    const target2 = (_this$renderTarget = this.renderTarget) != null ? _this$renderTarget : this.backBuffer;
    const targetImpl = target2.impl;
    if (!targetImpl.initialized) {
      this.initRenderTarget(target2);
    }
    this.setFramebuffer(targetImpl._glFrameBuffer);
  }
  updateEnd() {
    this.unbindVertexArray();
    const target2 = this.renderTarget;
    if (target2 && target2 !== this.backBuffer) {
      if (target2._samples > 1 && target2.autoResolve) {
        target2.resolve();
      }
      const colorBuffer = target2._colorBuffer;
      if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps) {
        this.activeTexture(this.maxCombinedTextures - 1);
        this.bindTexture(colorBuffer);
        this.gl.generateMipmap(colorBuffer.impl._glTarget);
      }
    }
  }
  setUnpackFlipY(flipY) {
    if (this.unpackFlipY !== flipY) {
      this.unpackFlipY = flipY;
      const gl = this.gl;
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
    }
  }
  setUnpackPremultiplyAlpha(premultiplyAlpha) {
    if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
      this.unpackPremultiplyAlpha = premultiplyAlpha;
      const gl = this.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
    }
  }
  activeTexture(textureUnit) {
    if (this.textureUnit !== textureUnit) {
      this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
      this.textureUnit = textureUnit;
    }
  }
  bindTexture(texture) {
    const impl = texture.impl;
    const textureTarget = impl._glTarget;
    const textureObject = impl._glTexture;
    const textureUnit = this.textureUnit;
    const slot = this.targetToSlot[textureTarget];
    if (this.textureUnits[textureUnit][slot] !== textureObject) {
      this.gl.bindTexture(textureTarget, textureObject);
      this.textureUnits[textureUnit][slot] = textureObject;
    }
  }
  bindTextureOnUnit(texture, textureUnit) {
    const impl = texture.impl;
    const textureTarget = impl._glTarget;
    const textureObject = impl._glTexture;
    const slot = this.targetToSlot[textureTarget];
    if (this.textureUnits[textureUnit][slot] !== textureObject) {
      this.activeTexture(textureUnit);
      this.gl.bindTexture(textureTarget, textureObject);
      this.textureUnits[textureUnit][slot] = textureObject;
    }
  }
  setTextureParameters(texture) {
    const gl = this.gl;
    const flags = texture.impl.dirtyParameterFlags;
    const target2 = texture.impl._glTarget;
    if (flags & TEXPROPERTY_MIN_FILTER) {
      let filter = texture._minFilter;
      if (!texture._mipmaps || texture._compressed && texture._levels.length === 1) {
        if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
          filter = FILTER_NEAREST;
        } else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
          filter = FILTER_LINEAR;
        }
      }
      gl.texParameteri(target2, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
    }
    if (flags & TEXPROPERTY_MAG_FILTER) {
      gl.texParameteri(target2, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
    }
    if (flags & TEXPROPERTY_ADDRESS_U) {
      gl.texParameteri(target2, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
    }
    if (flags & TEXPROPERTY_ADDRESS_V) {
      gl.texParameteri(target2, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
    }
    if (flags & TEXPROPERTY_ADDRESS_W) {
      gl.texParameteri(target2, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
    }
    if (flags & TEXPROPERTY_COMPARE_ON_READ) {
      gl.texParameteri(target2, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
    }
    if (flags & TEXPROPERTY_COMPARE_FUNC) {
      gl.texParameteri(target2, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
    }
    if (flags & TEXPROPERTY_ANISOTROPY) {
      const ext = this.extTextureFilterAnisotropic;
      if (ext) {
        gl.texParameterf(target2, ext.TEXTURE_MAX_ANISOTROPY_EXT, math.clamp(Math.round(texture._anisotropy), 1, this.maxAnisotropy));
      }
    }
  }
  setTexture(texture, textureUnit) {
    const impl = texture.impl;
    if (!impl._glTexture) {
      impl.initialize(this, texture);
    }
    if (impl.dirtyParameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload) {
      this.activeTexture(textureUnit);
      this.bindTexture(texture);
      if (impl.dirtyParameterFlags) {
        this.setTextureParameters(texture);
        impl.dirtyParameterFlags = 0;
      }
      if (texture._needsUpload || texture._needsMipmapsUpload) {
        impl.upload(this, texture);
        texture._needsUpload = false;
        texture._needsMipmapsUpload = false;
      }
    } else {
      this.bindTextureOnUnit(texture, textureUnit);
    }
  }
  createVertexArray(vertexBuffers) {
    let key, vao;
    const useCache = vertexBuffers.length > 1;
    if (useCache) {
      key = "";
      for (let i = 0; i < vertexBuffers.length; i++) {
        const vertexBuffer = vertexBuffers[i];
        key += vertexBuffer.id + vertexBuffer.format.renderingHash;
      }
      vao = this._vaoMap.get(key);
    }
    if (!vao) {
      const gl = this.gl;
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      for (let i = 0; i < vertexBuffers.length; i++) {
        const vertexBuffer = vertexBuffers[i];
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer.impl.bufferId);
        const elements = vertexBuffer.format.elements;
        for (let j = 0; j < elements.length; j++) {
          const e = elements[j];
          const loc = semanticToLocation[e.name];
          if (e.asInt) {
            gl.vertexAttribIPointer(loc, e.numComponents, this.glType[e.dataType], e.stride, e.offset);
          } else {
            gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
          }
          gl.enableVertexAttribArray(loc);
          if (vertexBuffer.format.instancing) {
            gl.vertexAttribDivisor(loc, 1);
          }
        }
      }
      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      if (useCache) {
        this._vaoMap.set(key, vao);
      }
    }
    return vao;
  }
  unbindVertexArray() {
    if (this.boundVao) {
      this.boundVao = null;
      this.gl.bindVertexArray(null);
    }
  }
  setBuffers() {
    const gl = this.gl;
    let vao;
    if (this.vertexBuffers.length === 1) {
      const vertexBuffer = this.vertexBuffers[0];
      if (!vertexBuffer.impl.vao) {
        vertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);
      }
      vao = vertexBuffer.impl.vao;
    } else {
      vao = this.createVertexArray(this.vertexBuffers);
    }
    if (this.boundVao !== vao) {
      this.boundVao = vao;
      gl.bindVertexArray(vao);
    }
    this.clearVertexBuffer();
    const bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
  }
  draw(primitive2, numInstances, keepBuffers) {
    const gl = this.gl;
    this.activateShader(this);
    if (!this.shaderValid) {
      return;
    }
    let sampler, samplerValue, texture, numTextures;
    let uniform, scopeId, uniformVersion, programVersion;
    const shader = this.shader;
    if (!shader) {
      return;
    }
    const samplers = shader.impl.samplers;
    const uniforms = shader.impl.uniforms;
    if (!keepBuffers) {
      this.setBuffers();
    }
    let textureUnit = 0;
    for (let i = 0, len = samplers.length; i < len; i++) {
      sampler = samplers[i];
      samplerValue = sampler.scopeId.value;
      if (!samplerValue) {
        return;
      }
      if (samplerValue instanceof Texture) {
        texture = samplerValue;
        this.setTexture(texture, textureUnit);
        if (sampler.slot !== textureUnit) {
          gl.uniform1i(sampler.locationId, textureUnit);
          sampler.slot = textureUnit;
        }
        textureUnit++;
      } else {
        sampler.array.length = 0;
        numTextures = samplerValue.length;
        for (let j = 0; j < numTextures; j++) {
          texture = samplerValue[j];
          this.setTexture(texture, textureUnit);
          sampler.array[j] = textureUnit;
          textureUnit++;
        }
        gl.uniform1iv(sampler.locationId, sampler.array);
      }
    }
    for (let i = 0, len = uniforms.length; i < len; i++) {
      uniform = uniforms[i];
      scopeId = uniform.scopeId;
      uniformVersion = uniform.version;
      programVersion = scopeId.versionObject.version;
      if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
        uniformVersion.globalId = programVersion.globalId;
        uniformVersion.revision = programVersion.revision;
        if (scopeId.value !== null) {
          this.commitFunction[uniform.dataType](uniform, scopeId.value);
        }
      }
    }
    if (this.transformFeedbackBuffer) {
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);
      gl.beginTransformFeedback(gl.POINTS);
    }
    const mode = this.glPrimitive[primitive2.type];
    const count = primitive2.count;
    if (primitive2.indexed) {
      const indexBuffer = this.indexBuffer;
      const format = indexBuffer.impl.glFormat;
      const offset = primitive2.base * indexBuffer.bytesPerIndex;
      if (numInstances > 0) {
        gl.drawElementsInstanced(mode, count, format, offset, numInstances);
      } else {
        gl.drawElements(mode, count, format, offset);
      }
    } else {
      const first = primitive2.base;
      if (numInstances > 0) {
        gl.drawArraysInstanced(mode, first, count, numInstances);
      } else {
        gl.drawArrays(mode, first, count);
      }
    }
    if (this.transformFeedbackBuffer) {
      gl.endTransformFeedback();
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    }
    this._drawCallsPerFrame++;
  }
  clear(options2) {
    var _options$flags;
    const defaultOptions = this.defaultClearOptions;
    options2 = options2 || defaultOptions;
    const flags = (_options$flags = options2.flags) != null ? _options$flags : defaultOptions.flags;
    if (flags !== 0) {
      const gl = this.gl;
      if (flags & CLEARFLAG_COLOR) {
        var _options$color;
        const color = (_options$color = options2.color) != null ? _options$color : defaultOptions.color;
        const r = color[0];
        const g = color[1];
        const b = color[2];
        const a = color[3];
        const c2 = this.clearColor;
        if (r !== c2.r || g !== c2.g || b !== c2.b || a !== c2.a) {
          this.gl.clearColor(r, g, b, a);
          this.clearColor.set(r, g, b, a);
        }
        this.setBlendState(BlendState.NOBLEND);
      }
      if (flags & CLEARFLAG_DEPTH) {
        var _options$depth;
        const depth = (_options$depth = options2.depth) != null ? _options$depth : defaultOptions.depth;
        if (depth !== this.clearDepth) {
          this.gl.clearDepth(depth);
          this.clearDepth = depth;
        }
        this.setDepthState(DepthState.WRITEDEPTH);
      }
      if (flags & CLEARFLAG_STENCIL) {
        var _options$stencil;
        const stencil = (_options$stencil = options2.stencil) != null ? _options$stencil : defaultOptions.stencil;
        if (stencil !== this.clearStencil) {
          this.gl.clearStencil(stencil);
          this.clearStencil = stencil;
        }
        gl.stencilMask(255);
        this.stencilWriteMaskFront = 255;
        this.stencilWriteMaskBack = 255;
      }
      gl.clear(this.glClearFlag[flags]);
    }
  }
  submit() {
    this.gl.flush();
  }
  readPixels(x2, y2, w, h2, pixels) {
    const gl = this.gl;
    gl.readPixels(x2, y2, w, h2, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
  async readPixelsAsync(x2, y2, w, h2, pixels) {
    var _this$renderTarget$co, _impl$_glFormat, _impl$_glPixelType;
    const gl = this.gl;
    const clientWaitAsync = (flags, interval_ms) => {
      const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
      this.submit();
      return new Promise((resolve, reject) => {
        function test() {
          const res = gl.clientWaitSync(sync, flags, 0);
          if (res === gl.WAIT_FAILED) {
            gl.deleteSync(sync);
            reject(new Error("webgl clientWaitSync sync failed"));
          } else if (res === gl.TIMEOUT_EXPIRED) {
            setTimeout(test, interval_ms);
          } else {
            gl.deleteSync(sync);
            resolve();
          }
        }
        test();
      });
    };
    const impl = (_this$renderTarget$co = this.renderTarget.colorBuffer) == null ? void 0 : _this$renderTarget$co.impl;
    const format = (_impl$_glFormat = impl == null ? void 0 : impl._glFormat) != null ? _impl$_glFormat : gl.RGBA;
    const pixelType = (_impl$_glPixelType = impl == null ? void 0 : impl._glPixelType) != null ? _impl$_glPixelType : gl.UNSIGNED_BYTE;
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, pixels.byteLength, gl.STREAM_READ);
    gl.readPixels(x2, y2, w, h2, format, pixelType, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    await clientWaitAsync(0, 20);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, pixels);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    gl.deleteBuffer(buf);
    return pixels;
  }
  readTextureAsync(texture, x2, y2, width, height, options2) {
    var _options$face, _options$renderTarget;
    const face = (_options$face = options2.face) != null ? _options$face : 0;
    const renderTarget = (_options$renderTarget = options2.renderTarget) != null ? _options$renderTarget : new RenderTarget({
      colorBuffer: texture,
      depth: false,
      face
    });
    const buffer = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, 1, texture._format));
    const data2 = new (getPixelFormatArrayType(texture._format))(buffer);
    this.setRenderTarget(renderTarget);
    this.initRenderTarget(renderTarget);
    return new Promise((resolve, reject) => {
      this.readPixelsAsync(x2, y2, width, height, data2).then((data3) => {
        if (!options2.renderTarget) {
          renderTarget.destroy();
        }
        resolve(data3);
      });
    });
  }
  setAlphaToCoverage(state) {
    if (this.alphaToCoverage !== state) {
      this.alphaToCoverage = state;
      if (state) {
        this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
      } else {
        this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
      }
    }
  }
  setTransformFeedbackBuffer(tf) {
    if (this.transformFeedbackBuffer !== tf) {
      this.transformFeedbackBuffer = tf;
      const gl = this.gl;
      if (tf) {
        if (!this.feedback) {
          this.feedback = gl.createTransformFeedback();
        }
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
      } else {
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
      }
    }
  }
  setRaster(on) {
    if (this.raster !== on) {
      this.raster = on;
      if (on) {
        this.gl.disable(this.gl.RASTERIZER_DISCARD);
      } else {
        this.gl.enable(this.gl.RASTERIZER_DISCARD);
      }
    }
  }
  setStencilTest(enable) {
    if (this.stencil !== enable) {
      const gl = this.gl;
      if (enable) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      this.stencil = enable;
    }
  }
  setStencilFunc(func, ref, mask) {
    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
      this.gl.stencilFunc(this.glComparison[func], ref, mask);
      this.stencilFuncFront = this.stencilFuncBack = func;
      this.stencilRefFront = this.stencilRefBack = ref;
      this.stencilMaskFront = this.stencilMaskBack = mask;
    }
  }
  setStencilFuncFront(func, ref, mask) {
    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
      const gl = this.gl;
      gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
      this.stencilFuncFront = func;
      this.stencilRefFront = ref;
      this.stencilMaskFront = mask;
    }
  }
  setStencilFuncBack(func, ref, mask) {
    if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
      const gl = this.gl;
      gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
      this.stencilFuncBack = func;
      this.stencilRefBack = ref;
      this.stencilMaskBack = mask;
    }
  }
  setStencilOperation(fail, zfail, zpass, writeMask) {
    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
      this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
      this.stencilFailFront = this.stencilFailBack = fail;
      this.stencilZfailFront = this.stencilZfailBack = zfail;
      this.stencilZpassFront = this.stencilZpassBack = zpass;
    }
    if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
      this.gl.stencilMask(writeMask);
      this.stencilWriteMaskFront = writeMask;
      this.stencilWriteMaskBack = writeMask;
    }
  }
  setStencilOperationFront(fail, zfail, zpass, writeMask) {
    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
      this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
      this.stencilFailFront = fail;
      this.stencilZfailFront = zfail;
      this.stencilZpassFront = zpass;
    }
    if (this.stencilWriteMaskFront !== writeMask) {
      this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
      this.stencilWriteMaskFront = writeMask;
    }
  }
  setStencilOperationBack(fail, zfail, zpass, writeMask) {
    if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
      this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
      this.stencilFailBack = fail;
      this.stencilZfailBack = zfail;
      this.stencilZpassBack = zpass;
    }
    if (this.stencilWriteMaskBack !== writeMask) {
      this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
      this.stencilWriteMaskBack = writeMask;
    }
  }
  setBlendState(blendState) {
    const currentBlendState = this.blendState;
    if (!currentBlendState.equals(blendState)) {
      const gl = this.gl;
      const {
        blend,
        colorOp,
        alphaOp,
        colorSrcFactor,
        colorDstFactor,
        alphaSrcFactor,
        alphaDstFactor
      } = blendState;
      if (currentBlendState.blend !== blend) {
        if (blend) {
          gl.enable(gl.BLEND);
        } else {
          gl.disable(gl.BLEND);
        }
      }
      if (currentBlendState.colorOp !== colorOp || currentBlendState.alphaOp !== alphaOp) {
        const glBlendEquation = this.glBlendEquation;
        gl.blendEquationSeparate(glBlendEquation[colorOp], glBlendEquation[alphaOp]);
      }
      if (currentBlendState.colorSrcFactor !== colorSrcFactor || currentBlendState.colorDstFactor !== colorDstFactor || currentBlendState.alphaSrcFactor !== alphaSrcFactor || currentBlendState.alphaDstFactor !== alphaDstFactor) {
        gl.blendFuncSeparate(this.glBlendFunctionColor[colorSrcFactor], this.glBlendFunctionColor[colorDstFactor], this.glBlendFunctionAlpha[alphaSrcFactor], this.glBlendFunctionAlpha[alphaDstFactor]);
      }
      if (currentBlendState.allWrite !== blendState.allWrite) {
        this.gl.colorMask(blendState.redWrite, blendState.greenWrite, blendState.blueWrite, blendState.alphaWrite);
      }
      currentBlendState.copy(blendState);
    }
  }
  setBlendColor(r, g, b, a) {
    const c2 = this.blendColor;
    if (r !== c2.r || g !== c2.g || b !== c2.b || a !== c2.a) {
      this.gl.blendColor(r, g, b, a);
      c2.set(r, g, b, a);
    }
  }
  setStencilState(stencilFront, stencilBack) {
    if (stencilFront || stencilBack) {
      this.setStencilTest(true);
      if (stencilFront === stencilBack) {
        this.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
        this.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
      } else {
        var _stencilFront, _stencilBack;
        (_stencilFront = stencilFront) != null ? _stencilFront : stencilFront = StencilParameters.DEFAULT;
        this.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
        this.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
        (_stencilBack = stencilBack) != null ? _stencilBack : stencilBack = StencilParameters.DEFAULT;
        this.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
        this.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
      }
    } else {
      this.setStencilTest(false);
    }
  }
  setDepthState(depthState) {
    const currentDepthState = this.depthState;
    if (!currentDepthState.equals(depthState)) {
      const gl = this.gl;
      const write = depthState.write;
      if (currentDepthState.write !== write) {
        gl.depthMask(write);
      }
      let {
        func,
        test
      } = depthState;
      if (!test && write) {
        test = true;
        func = FUNC_ALWAYS;
      }
      if (currentDepthState.func !== func) {
        gl.depthFunc(this.glComparison[func]);
      }
      if (currentDepthState.test !== test) {
        if (test) {
          gl.enable(gl.DEPTH_TEST);
        } else {
          gl.disable(gl.DEPTH_TEST);
        }
      }
      const {
        depthBias,
        depthBiasSlope
      } = depthState;
      if (depthBias || depthBiasSlope) {
        if (!this.depthBiasEnabled) {
          this.depthBiasEnabled = true;
          this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
        }
        gl.polygonOffset(depthBiasSlope, depthBias);
      } else {
        if (this.depthBiasEnabled) {
          this.depthBiasEnabled = false;
          this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
        }
      }
      currentDepthState.copy(depthState);
    }
  }
  setCullMode(cullMode) {
    if (this.cullMode !== cullMode) {
      if (cullMode === CULLFACE_NONE) {
        this.gl.disable(this.gl.CULL_FACE);
      } else {
        if (this.cullMode === CULLFACE_NONE) {
          this.gl.enable(this.gl.CULL_FACE);
        }
        const mode = this.glCull[cullMode];
        if (this.cullFace !== mode) {
          this.gl.cullFace(mode);
          this.cullFace = mode;
        }
      }
      this.cullMode = cullMode;
    }
  }
  setShader(shader, asyncCompile = false) {
    if (shader !== this.shader) {
      this.shader = shader;
      this.shaderAsyncCompile = asyncCompile;
      this.shaderValid = void 0;
    }
  }
  activateShader(device) {
    const {
      shader
    } = this;
    const {
      impl
    } = shader;
    if (this.shaderValid === void 0) {
      if (shader.failed) {
        this.shaderValid = false;
      } else if (!shader.ready) {
        if (this.shaderAsyncCompile) {
          if (impl.isLinked(device)) {
            if (!impl.finalize(this, shader)) {
              shader.failed = true;
              this.shaderValid = false;
            }
          } else {
            this.shaderValid = false;
          }
        } else {
          if (!impl.finalize(this, shader)) {
            shader.failed = true;
            this.shaderValid = false;
          }
        }
      }
    }
    if (this.shaderValid === void 0) {
      this.gl.useProgram(impl.glProgram);
      this.shaderValid = true;
    }
  }
  clearVertexArrayObjectCache() {
    const gl = this.gl;
    this._vaoMap.forEach((item, key, mapObj) => {
      gl.deleteVertexArray(item);
    });
    this._vaoMap.clear();
  }
  set fullscreen(fullscreen) {
    if (fullscreen) {
      const canvas = this.gl.canvas;
      canvas.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  }
  get fullscreen() {
    return !!document.fullscreenElement;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/null/null-index-buffer.js
var NullIndexBuffer = class {
  unlock(indexBuffer) {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/null/null-render-target.js
var NullRenderTarget = class {
  destroy(device) {
  }
  init(device, renderTarget) {
  }
  loseContext() {
  }
  resolve(device, target2, color, depth) {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/null/null-shader.js
var NullShader = class {
  destroy(shader) {
  }
  loseContext() {
  }
  restoreContext(device, shader) {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/null/null-texture.js
var NullTexture = class {
  destroy(device) {
  }
  propertyChanged(flag) {
  }
  loseContext() {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/null/null-vertex-buffer.js
var NullVertexBuffer = class {
  destroy(device) {
  }
  unlock(vertexBuffer) {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/null/null-graphics-device.js
var NullGraphicsDevice = class extends GraphicsDevice {
  constructor(canvas, options2 = {}) {
    super(canvas, options2);
    options2 = this.initOptions;
    this.isNull = true;
    this._deviceType = DEVICETYPE_NULL;
    this.samples = 1;
  }
  destroy() {
    super.destroy();
  }
  initDeviceCaps() {
    this.disableParticleSystem = true;
    this.precision = "highp";
    this.maxPrecision = "highp";
    this.maxSamples = 4;
    this.maxTextures = 16;
    this.maxTextureSize = 4096;
    this.maxCubeMapSize = 4096;
    this.maxVolumeSize = 4096;
    this.maxColorAttachments = 8;
    this.maxPixelRatio = 1;
    this.maxAnisotropy = 16;
    this.supportsUniformBuffers = false;
    this.supportsAreaLights = true;
    this.supportsGpuParticles = false;
    this.textureFloatRenderable = true;
    this.textureHalfFloatRenderable = true;
    this.supportsImageBitmap = true;
  }
  postInit() {
    super.postInit();
  }
  frameStart() {
    super.frameStart();
  }
  frameEnd() {
    super.frameEnd();
  }
  updateBegin() {
  }
  updateEnd() {
  }
  readPixels(x2, y2, w, h2, pixels) {
  }
  createVertexBufferImpl(vertexBuffer, format) {
    return new NullVertexBuffer(vertexBuffer, format);
  }
  createIndexBufferImpl(indexBuffer) {
    return new NullIndexBuffer(indexBuffer);
  }
  createShaderImpl(shader) {
    return new NullShader(shader);
  }
  createTextureImpl(texture) {
    return new NullTexture(texture);
  }
  createRenderTargetImpl(renderTarget) {
    return new NullRenderTarget(renderTarget);
  }
  draw(primitive2, numInstances = 1, keepBuffers) {
  }
  setShader(shader, asyncCompile = false) {
  }
  setBlendState(blendState) {
  }
  setDepthState(depthState) {
  }
  setStencilState(stencilFront, stencilBack) {
  }
  setBlendColor(r, g, b, a) {
  }
  setCullMode(cullMode) {
  }
  setAlphaToCoverage(state) {
  }
  initializeContextCaches() {
    super.initializeContextCaches();
  }
  clear(options2) {
  }
  setViewport(x2, y2, w, h2) {
  }
  setScissor(x2, y2, w, h2) {
  }
  copyRenderTarget(source, dest, color, depth) {
    return true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/graphics-device-create.js
function createGraphicsDevice(canvas, options2 = {}) {
  var _options$deviceTypes;
  const deviceTypes = (_options$deviceTypes = options2.deviceTypes) != null ? _options$deviceTypes : [];
  if (!deviceTypes.includes(DEVICETYPE_WEBGL2)) {
    deviceTypes.push(DEVICETYPE_WEBGL2);
  }
  if (!deviceTypes.includes(DEVICETYPE_NULL)) {
    deviceTypes.push(DEVICETYPE_NULL);
  }
  if (platform.browser && !!navigator.xr) {
    var _options$xrCompatible;
    (_options$xrCompatible = options2.xrCompatible) != null ? _options$xrCompatible : options2.xrCompatible = true;
  }
  const deviceCreateFuncs = [];
  for (let i = 0; i < deviceTypes.length; i++) {
    var _window;
    const deviceType = deviceTypes[i];
    if (deviceType === DEVICETYPE_WEBGPU && (_window = window) != null && (_window = _window.navigator) != null && _window.gpu) {
      deviceCreateFuncs.push(() => {
        const device = new WebgpuGraphicsDevice(canvas, options2);
        return device.initWebGpu(options2.glslangUrl, options2.twgslUrl);
      });
    }
    if (deviceType === DEVICETYPE_WEBGL2) {
      deviceCreateFuncs.push(() => {
        return new WebglGraphicsDevice(canvas, options2);
      });
    }
    if (deviceType === DEVICETYPE_NULL) {
      deviceCreateFuncs.push(() => {
        return new NullGraphicsDevice(canvas, options2);
      });
    }
  }
  return new Promise((resolve, reject) => {
    let attempt = 0;
    const next = () => {
      if (attempt >= deviceCreateFuncs.length) {
        reject(new Error("Failed to create a graphics device"));
      } else {
        Promise.resolve(deviceCreateFuncs[attempt++]()).then((device) => {
          if (device) {
            resolve(device);
          } else {
            next();
          }
        }).catch((err3) => {
          console.log(err3);
          next();
        });
      }
    };
    next();
  });
}

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/compute.js
var ComputeParameter = class {
  constructor() {
    this.value = void 0;
    this.scopeId = null;
  }
};
var Compute = class {
  constructor(graphicsDevice, shader, name = "Unnamed") {
    this.shader = null;
    this.name = void 0;
    this.parameters = /* @__PURE__ */ new Map();
    this.countX = 1;
    this.countY = void 0;
    this.countZ = void 0;
    this.device = graphicsDevice;
    this.shader = shader;
    this.name = name;
    if (graphicsDevice.supportsCompute) {
      this.impl = graphicsDevice.createComputeImpl(this);
    }
  }
  setParameter(name, value) {
    let param = this.parameters.get(name);
    if (!param) {
      param = new ComputeParameter();
      param.scopeId = this.device.scope.resolve(name);
      this.parameters.set(name, param);
    }
    param.value = value;
  }
  getParameter(name) {
    var _this$parameters$get;
    return (_this$parameters$get = this.parameters.get(name)) == null ? void 0 : _this$parameters$get.value;
  }
  deleteParameter(name) {
    this.parameters.delete(name);
  }
  applyParameters() {
    for (const [, param] of this.parameters) {
      param.scopeId.setValue(param.value);
    }
  }
  setupDispatch(x2, y2, z2) {
    this.countX = x2;
    this.countY = y2;
    this.countZ = z2;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/index-buffer.js
var id7 = 0;
var IndexBuffer = class {
  constructor(graphicsDevice, format, numIndices, usage = BUFFER_STATIC, initialData, options2) {
    this.device = graphicsDevice;
    this.format = format;
    this.numIndices = numIndices;
    this.usage = usage;
    this.id = id7++;
    this.impl = graphicsDevice.createIndexBufferImpl(this, options2);
    const bytesPerIndex = typedArrayIndexFormatsByteSize[format];
    this.bytesPerIndex = bytesPerIndex;
    this.numBytes = this.numIndices * bytesPerIndex;
    if (initialData) {
      this.setData(initialData);
    } else {
      this.storage = new ArrayBuffer(this.numBytes);
    }
    this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
    this.device.buffers.push(this);
  }
  destroy() {
    const device = this.device;
    const idx = device.buffers.indexOf(this);
    if (idx !== -1) {
      device.buffers.splice(idx, 1);
    }
    if (this.device.indexBuffer === this) {
      this.device.indexBuffer = null;
    }
    if (this.impl.initialized) {
      this.impl.destroy(device);
      this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
    }
  }
  adjustVramSizeTracking(vram, size) {
    vram.ib += size;
  }
  loseContext() {
    this.impl.loseContext();
  }
  getFormat() {
    return this.format;
  }
  getNumIndices() {
    return this.numIndices;
  }
  lock() {
    return this.storage;
  }
  unlock() {
    this.impl.unlock(this);
  }
  setData(data2) {
    if (data2.byteLength !== this.numBytes) {
      return false;
    }
    this.storage = data2;
    this.unlock();
    return true;
  }
  _lockTypedArray() {
    const lock = this.lock();
    const indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);
    return indices;
  }
  writeData(data2, count) {
    const indices = this._lockTypedArray();
    if (data2.length > count) {
      if (ArrayBuffer.isView(data2)) {
        data2 = data2.subarray(0, count);
        indices.set(data2);
      } else {
        for (let i = 0; i < count; i++) {
          indices[i] = data2[i];
        }
      }
    } else {
      indices.set(data2);
    }
    this.unlock();
  }
  readData(data2) {
    const indices = this._lockTypedArray();
    const count = this.numIndices;
    if (ArrayBuffer.isView(data2)) {
      data2.set(indices);
    } else {
      data2.length = 0;
      for (let i = 0; i < count; i++) {
        data2[i] = indices[i];
      }
    }
    return count;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/render-pass.js
var ColorAttachmentOps = class {
  constructor() {
    this.clearValue = new Color(0, 0, 0, 1);
    this.clearValueLinear = new Color(0, 0, 0, 1);
    this.clear = false;
    this.store = false;
    this.resolve = true;
    this.mipmaps = false;
  }
};
var DepthStencilAttachmentOps = class {
  constructor() {
    this.clearDepthValue = 1;
    this.clearStencilValue = 0;
    this.clearDepth = false;
    this.clearStencil = false;
    this.storeDepth = false;
    this.storeStencil = false;
  }
};
var RenderPass = class {
  get colorOps() {
    return this.colorArrayOps[0];
  }
  constructor(graphicsDevice) {
    this._name = void 0;
    this.device = void 0;
    this._enabled = true;
    this.executeEnabled = true;
    this.renderTarget = void 0;
    this._options = void 0;
    this.samples = 0;
    this.colorArrayOps = [];
    this.depthStencilOps = void 0;
    this.requiresCubemaps = true;
    this.fullSizeClearRect = true;
    this.beforePasses = [];
    this.afterPasses = [];
    this.device = graphicsDevice;
  }
  set name(value) {
    this._name = value;
  }
  get name() {
    if (!this._name) {
      this._name = this.constructor.name;
    }
    return this._name;
  }
  set options(value) {
    this._options = value;
    if (value) {
      var _this$_options$scaleX, _this$_options$scaleY;
      this._options.scaleX = (_this$_options$scaleX = this._options.scaleX) != null ? _this$_options$scaleX : 1;
      this._options.scaleY = (_this$_options$scaleY = this._options.scaleY) != null ? _this$_options$scaleY : 1;
    }
  }
  get options() {
    return this._options;
  }
  init(renderTarget = null, options2) {
    var _renderTarget$_colorB;
    this.options = options2;
    this.renderTarget = renderTarget;
    this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1);
    this.depthStencilOps = new DepthStencilAttachmentOps();
    const numColorOps = renderTarget ? (_renderTarget$_colorB = renderTarget._colorBuffers) == null ? void 0 : _renderTarget$_colorB.length : 1;
    this.colorArrayOps.length = 0;
    for (let i = 0; i < numColorOps; i++) {
      var _this$renderTarget;
      const colorOps = new ColorAttachmentOps();
      this.colorArrayOps[i] = colorOps;
      if (this.samples === 1) {
        colorOps.store = true;
        colorOps.resolve = false;
      }
      if ((_this$renderTarget = this.renderTarget) != null && (_this$renderTarget = _this$renderTarget._colorBuffers) != null && _this$renderTarget[i].mipmaps) {
        colorOps.mipmaps = true;
      }
    }
    this.postInit();
  }
  destroy() {
  }
  postInit() {
  }
  frameUpdate() {
    if (this._options && this.renderTarget) {
      var _this$_options$resize;
      const resizeSource = (_this$_options$resize = this._options.resizeSource) != null ? _this$_options$resize : this.device.backBuffer;
      const width = Math.floor(resizeSource.width * this._options.scaleX);
      const height = Math.floor(resizeSource.height * this._options.scaleY);
      this.renderTarget.resize(width, height);
    }
  }
  before() {
  }
  execute() {
  }
  after() {
  }
  onEnable() {
  }
  onDisable() {
  }
  set enabled(value) {
    if (this._enabled !== value) {
      this._enabled = value;
      if (value) {
        this.onEnable();
      } else {
        this.onDisable();
      }
    }
  }
  get enabled() {
    return this._enabled;
  }
  setClearColor(color) {
    const count = this.colorArrayOps.length;
    for (let i = 0; i < count; i++) {
      const colorOps = this.colorArrayOps[i];
      if (color) {
        colorOps.clearValue.copy(color);
        colorOps.clearValueLinear.linear(color);
      }
      colorOps.clear = !!color;
    }
  }
  setClearDepth(depthValue) {
    if (depthValue) {
      this.depthStencilOps.clearDepthValue = depthValue;
    }
    this.depthStencilOps.clearDepth = depthValue !== void 0;
  }
  setClearStencil(stencilValue) {
    if (stencilValue) {
      this.depthStencilOps.clearStencilValue = stencilValue;
    }
    this.depthStencilOps.clearStencil = stencilValue !== void 0;
  }
  render() {
    if (this.enabled) {
      const device = this.device;
      const realPass = this.renderTarget !== void 0;
      this.before();
      if (this.executeEnabled) {
        if (realPass) {
          device.startRenderPass(this);
        }
        this.execute();
        if (realPass) {
          device.endRenderPass(this);
        }
      }
      this.after();
      device.renderPassIndex++;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/storage-buffer.js
var id8 = 0;
var StorageBuffer = class {
  constructor(graphicsDevice, byteSize, bufferUsage = 0) {
    this.id = id8++;
    this.device = graphicsDevice;
    this.byteSize = byteSize;
    this.bufferUsage = bufferUsage;
    this.impl = graphicsDevice.createBufferImpl(BUFFERUSAGE_STORAGE | bufferUsage);
    this.impl.allocate(graphicsDevice, byteSize);
    this.device.buffers.push(this);
    this.adjustVramSizeTracking(graphicsDevice._vram, this.byteSize);
  }
  destroy() {
    const device = this.device;
    const idx = device.buffers.indexOf(this);
    if (idx !== -1) {
      device.buffers.splice(idx, 1);
    }
    this.adjustVramSizeTracking(device._vram, -this.byteSize);
    this.impl.destroy(device);
  }
  adjustVramSizeTracking(vram, size) {
    vram.sb += size;
  }
  read(offset = 0, size = this.byteSize, data2 = null) {
    return this.impl.read(this.device, offset, size, data2);
  }
  write(bufferOffset = 0, data2, dataOffset = 0, size) {
    this.impl.write(this.device, bufferOffset, data2, dataOffset, size);
  }
  clear(offset = 0, size = this.byteSize) {
    this.impl.clear(this.device, offset, size);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/transform-feedback.js
var TransformFeedback = class {
  constructor(inputBuffer, usage = BUFFER_GPUDYNAMIC) {
    this.device = inputBuffer.device;
    const gl = this.device.gl;
    this._inputBuffer = inputBuffer;
    if (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
      gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.impl.bufferId);
      gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
    }
    this._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, {
      usage,
      data: inputBuffer.storage
    });
  }
  static createShader(graphicsDevice, vertexCode, name) {
    return new Shader(graphicsDevice, ShaderUtils.createDefinition(graphicsDevice, {
      name,
      vertexCode,
      useTransformFeedback: true
    }));
  }
  destroy() {
    this._outputBuffer.destroy();
  }
  process(shader, swap = true) {
    const device = this.device;
    const oldRt = device.getRenderTarget();
    device.setRenderTarget(null);
    device.updateBegin();
    device.setVertexBuffer(this._inputBuffer, 0);
    device.setRaster(false);
    device.setTransformFeedbackBuffer(this._outputBuffer);
    device.setShader(shader);
    device.draw({
      type: PRIMITIVE_POINTS,
      base: 0,
      count: this._inputBuffer.numVertices,
      indexed: false
    });
    device.setTransformFeedbackBuffer(null);
    device.setRaster(true);
    device.updateEnd();
    device.setRenderTarget(oldRt);
    if (swap) {
      let tmp = this._inputBuffer.impl.bufferId;
      this._inputBuffer.impl.bufferId = this._outputBuffer.impl.bufferId;
      this._outputBuffer.impl.bufferId = tmp;
      tmp = this._inputBuffer.impl.vao;
      this._inputBuffer.impl.vao = this._outputBuffer.impl.vao;
      this._outputBuffer.impl.vao = tmp;
    }
  }
  get inputBuffer() {
    return this._inputBuffer;
  }
  get outputBuffer() {
    return this._outputBuffer;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/vertex-iterator.js
function set1(a) {
  this.array[this.index] = a;
}
function set2(a, b) {
  this.array[this.index] = a;
  this.array[this.index + 1] = b;
}
function set3(a, b, c2) {
  this.array[this.index] = a;
  this.array[this.index + 1] = b;
  this.array[this.index + 2] = c2;
}
function set4(a, b, c2, d) {
  this.array[this.index] = a;
  this.array[this.index + 1] = b;
  this.array[this.index + 2] = c2;
  this.array[this.index + 3] = d;
}
function arraySet1(index, inputArray, inputIndex) {
  this.array[index] = inputArray[inputIndex];
}
function arraySet2(index, inputArray, inputIndex) {
  this.array[index] = inputArray[inputIndex];
  this.array[index + 1] = inputArray[inputIndex + 1];
}
function arraySet3(index, inputArray, inputIndex) {
  this.array[index] = inputArray[inputIndex];
  this.array[index + 1] = inputArray[inputIndex + 1];
  this.array[index + 2] = inputArray[inputIndex + 2];
}
function arraySet4(index, inputArray, inputIndex) {
  this.array[index] = inputArray[inputIndex];
  this.array[index + 1] = inputArray[inputIndex + 1];
  this.array[index + 2] = inputArray[inputIndex + 2];
  this.array[index + 3] = inputArray[inputIndex + 3];
}
function arrayGet1(offset, outputArray, outputIndex) {
  outputArray[outputIndex] = this.array[offset];
}
function arrayGet2(offset, outputArray, outputIndex) {
  outputArray[outputIndex] = this.array[offset];
  outputArray[outputIndex + 1] = this.array[offset + 1];
}
function arrayGet3(offset, outputArray, outputIndex) {
  outputArray[outputIndex] = this.array[offset];
  outputArray[outputIndex + 1] = this.array[offset + 1];
  outputArray[outputIndex + 2] = this.array[offset + 2];
}
function arrayGet4(offset, outputArray, outputIndex) {
  outputArray[outputIndex] = this.array[offset];
  outputArray[outputIndex + 1] = this.array[offset + 1];
  outputArray[outputIndex + 2] = this.array[offset + 2];
  outputArray[outputIndex + 3] = this.array[offset + 3];
}
var VertexIteratorAccessor = class {
  constructor(buffer, vertexElement, vertexFormat) {
    this.index = 0;
    this.numComponents = vertexElement.numComponents;
    if (vertexFormat.interleaved) {
      this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
    } else {
      this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
    }
    this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;
    switch (vertexElement.numComponents) {
      case 1:
        this.set = set1;
        this.getToArray = arrayGet1;
        this.setFromArray = arraySet1;
        break;
      case 2:
        this.set = set2;
        this.getToArray = arrayGet2;
        this.setFromArray = arraySet2;
        break;
      case 3:
        this.set = set3;
        this.getToArray = arrayGet3;
        this.setFromArray = arraySet3;
        break;
      case 4:
        this.set = set4;
        this.getToArray = arrayGet4;
        this.setFromArray = arraySet4;
        break;
    }
  }
  get(offset) {
    return this.array[this.index + offset];
  }
  set(a, b, c2, d) {
  }
  getToArray(offset, outputArray, outputIndex) {
  }
  setFromArray(index, inputArray, inputIndex) {
  }
};
var VertexIterator = class {
  constructor(vertexBuffer) {
    this.vertexBuffer = vertexBuffer;
    this.vertexFormatSize = vertexBuffer.getFormat().size;
    this.buffer = this.vertexBuffer.lock();
    this.accessors = [];
    this.element = {};
    const vertexFormat = this.vertexBuffer.getFormat();
    for (let i = 0; i < vertexFormat.elements.length; i++) {
      const vertexElement = vertexFormat.elements[i];
      this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
      this.element[vertexElement.name] = this.accessors[i];
    }
  }
  next(count = 1) {
    let i = 0;
    const accessors = this.accessors;
    const numAccessors = this.accessors.length;
    while (i < numAccessors) {
      const accessor = accessors[i++];
      accessor.index += count * accessor.stride;
    }
  }
  end() {
    this.vertexBuffer.unlock();
  }
  writeData(semantic, data2, numVertices) {
    const element = this.element[semantic];
    if (element) {
      if (numVertices > this.vertexBuffer.numVertices) {
        numVertices = this.vertexBuffer.numVertices;
      }
      const numComponents = element.numComponents;
      if (this.vertexBuffer.getFormat().interleaved) {
        let index = 0;
        for (let i = 0; i < numVertices; i++) {
          element.setFromArray(index, data2, i * numComponents);
          index += element.stride;
        }
      } else {
        if (data2.length > numVertices * numComponents) {
          const copyCount = numVertices * numComponents;
          if (ArrayBuffer.isView(data2)) {
            data2 = data2.subarray(0, copyCount);
            element.array.set(data2);
          } else {
            for (let i = 0; i < copyCount; i++) {
              element.array[i] = data2[i];
            }
          }
        } else {
          element.array.set(data2);
        }
      }
    }
  }
  readData(semantic, data2) {
    const element = this.element[semantic];
    let count = 0;
    if (element) {
      count = this.vertexBuffer.numVertices;
      let i;
      const numComponents = element.numComponents;
      if (this.vertexBuffer.getFormat().interleaved) {
        if (Array.isArray(data2)) {
          data2.length = 0;
        }
        element.index = 0;
        let offset = 0;
        for (i = 0; i < count; i++) {
          element.getToArray(offset, data2, i * numComponents);
          offset += element.stride;
        }
      } else {
        if (ArrayBuffer.isView(data2)) {
          data2.set(element.array);
        } else {
          data2.length = 0;
          const copyCount = count * numComponents;
          for (i = 0; i < copyCount; i++) {
            data2[i] = element.array[i];
          }
        }
      }
    }
    return count;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/input/constants.js
var ACTION_MOUSE = "mouse";
var ACTION_KEYBOARD = "keyboard";
var ACTION_GAMEPAD = "gamepad";
var AXIS_MOUSE_X = "mousex";
var AXIS_MOUSE_Y = "mousey";
var AXIS_PAD_L_X = "padlx";
var AXIS_PAD_L_Y = "padly";
var AXIS_PAD_R_X = "padrx";
var AXIS_PAD_R_Y = "padry";
var AXIS_KEY = "key";
var EVENT_KEYDOWN = "keydown";
var EVENT_KEYUP = "keyup";
var EVENT_MOUSEDOWN = "mousedown";
var EVENT_MOUSEMOVE = "mousemove";
var EVENT_MOUSEUP = "mouseup";
var EVENT_MOUSEWHEEL = "mousewheel";
var EVENT_TOUCHSTART = "touchstart";
var EVENT_TOUCHEND = "touchend";
var EVENT_TOUCHMOVE = "touchmove";
var EVENT_TOUCHCANCEL = "touchcancel";
var EVENT_SELECT = "select";
var EVENT_SELECTSTART = "selectstart";
var EVENT_SELECTEND = "selectend";
var KEY_BACKSPACE = 8;
var KEY_TAB = 9;
var KEY_RETURN = 13;
var KEY_ENTER = 13;
var KEY_SHIFT = 16;
var KEY_CONTROL = 17;
var KEY_ALT = 18;
var KEY_PAUSE = 19;
var KEY_CAPS_LOCK = 20;
var KEY_ESCAPE = 27;
var KEY_SPACE = 32;
var KEY_PAGE_UP = 33;
var KEY_PAGE_DOWN = 34;
var KEY_END = 35;
var KEY_HOME = 36;
var KEY_LEFT = 37;
var KEY_UP = 38;
var KEY_RIGHT = 39;
var KEY_DOWN = 40;
var KEY_PRINT_SCREEN = 44;
var KEY_INSERT = 45;
var KEY_DELETE = 46;
var KEY_0 = 48;
var KEY_1 = 49;
var KEY_2 = 50;
var KEY_3 = 51;
var KEY_4 = 52;
var KEY_5 = 53;
var KEY_6 = 54;
var KEY_7 = 55;
var KEY_8 = 56;
var KEY_9 = 57;
var KEY_SEMICOLON = 59;
var KEY_EQUAL = 61;
var KEY_A = 65;
var KEY_B = 66;
var KEY_C = 67;
var KEY_D = 68;
var KEY_E = 69;
var KEY_F = 70;
var KEY_G = 71;
var KEY_H = 72;
var KEY_I = 73;
var KEY_J = 74;
var KEY_K = 75;
var KEY_L = 76;
var KEY_M = 77;
var KEY_N = 78;
var KEY_O = 79;
var KEY_P = 80;
var KEY_Q = 81;
var KEY_R = 82;
var KEY_S = 83;
var KEY_T = 84;
var KEY_U = 85;
var KEY_V = 86;
var KEY_W = 87;
var KEY_X = 88;
var KEY_Y = 89;
var KEY_Z = 90;
var KEY_WINDOWS = 91;
var KEY_CONTEXT_MENU = 93;
var KEY_NUMPAD_0 = 96;
var KEY_NUMPAD_1 = 97;
var KEY_NUMPAD_2 = 98;
var KEY_NUMPAD_3 = 99;
var KEY_NUMPAD_4 = 100;
var KEY_NUMPAD_5 = 101;
var KEY_NUMPAD_6 = 102;
var KEY_NUMPAD_7 = 103;
var KEY_NUMPAD_8 = 104;
var KEY_NUMPAD_9 = 105;
var KEY_MULTIPLY = 106;
var KEY_ADD = 107;
var KEY_SEPARATOR = 108;
var KEY_SUBTRACT = 109;
var KEY_DECIMAL = 110;
var KEY_DIVIDE = 111;
var KEY_F1 = 112;
var KEY_F2 = 113;
var KEY_F3 = 114;
var KEY_F4 = 115;
var KEY_F5 = 116;
var KEY_F6 = 117;
var KEY_F7 = 118;
var KEY_F8 = 119;
var KEY_F9 = 120;
var KEY_F10 = 121;
var KEY_F11 = 122;
var KEY_F12 = 123;
var KEY_COMMA = 188;
var KEY_PERIOD = 190;
var KEY_SLASH = 191;
var KEY_OPEN_BRACKET = 219;
var KEY_BACK_SLASH = 220;
var KEY_CLOSE_BRACKET = 221;
var KEY_META = 224;
var MOUSEBUTTON_NONE = -1;
var MOUSEBUTTON_LEFT = 0;
var MOUSEBUTTON_MIDDLE = 1;
var MOUSEBUTTON_RIGHT = 2;
var PAD_1 = 0;
var PAD_2 = 1;
var PAD_3 = 2;
var PAD_4 = 3;
var PAD_FACE_1 = 0;
var PAD_FACE_2 = 1;
var PAD_FACE_3 = 2;
var PAD_FACE_4 = 3;
var PAD_L_SHOULDER_1 = 4;
var PAD_R_SHOULDER_1 = 5;
var PAD_L_SHOULDER_2 = 6;
var PAD_R_SHOULDER_2 = 7;
var PAD_SELECT = 8;
var PAD_START = 9;
var PAD_L_STICK_BUTTON = 10;
var PAD_R_STICK_BUTTON = 11;
var PAD_UP = 12;
var PAD_DOWN = 13;
var PAD_LEFT = 14;
var PAD_RIGHT = 15;
var PAD_VENDOR = 16;
var PAD_L_STICK_X = 0;
var PAD_L_STICK_Y = 1;
var PAD_R_STICK_X = 2;
var PAD_R_STICK_Y = 3;
var EVENT_GAMEPADCONNECTED = "gamepadconnected";
var EVENT_GAMEPADDISCONNECTED = "gamepaddisconnected";
var XRPAD_TOUCHPAD_X = 0;
var XRPAD_TOUCHPAD_Y = 1;
var XRPAD_STICK_X = 2;
var XRPAD_STICK_Y = 3;
var XRPAD_TOUCHPAD_BUTTON = 2;
var XRPAD_TRIGGER = 0;
var XRPAD_SQUEEZE = 1;
var XRPAD_STICK_BUTTON = 3;
var XRPAD_A = 4;
var XRPAD_B = 5;

// ../node_modules/playcanvas/build/playcanvas/src/platform/input/keyboard-event.js
var KeyboardEvent = class {
  constructor(keyboard, event) {
    this.key = null;
    this.element = null;
    this.event = null;
    if (event) {
      this.key = event.keyCode;
      this.element = event.target;
      this.event = event;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/input/keyboard.js
var _keyboardEvent = new KeyboardEvent();
function makeKeyboardEvent(event) {
  _keyboardEvent.key = event.keyCode;
  _keyboardEvent.element = event.target;
  _keyboardEvent.event = event;
  return _keyboardEvent;
}
function toKeyCode(s2) {
  if (typeof s2 === "string") {
    return s2.toUpperCase().charCodeAt(0);
  }
  return s2;
}
var _keyCodeToKeyIdentifier = {
  "9": "Tab",
  "13": "Enter",
  "16": "Shift",
  "17": "Control",
  "18": "Alt",
  "27": "Escape",
  "37": "Left",
  "38": "Up",
  "39": "Right",
  "40": "Down",
  "46": "Delete",
  "91": "Win"
};
var Keyboard = class extends EventHandler {
  constructor(element, options2 = {}) {
    super();
    this._element = null;
    this._keymap = {};
    this._lastmap = {};
    this._keyDownHandler = this._handleKeyDown.bind(this);
    this._keyUpHandler = this._handleKeyUp.bind(this);
    this._keyPressHandler = this._handleKeyPress.bind(this);
    this._visibilityChangeHandler = this._handleVisibilityChange.bind(this);
    this._windowBlurHandler = this._handleWindowBlur.bind(this);
    if (element) {
      this.attach(element);
    }
    this.preventDefault = options2.preventDefault || false;
    this.stopPropagation = options2.stopPropagation || false;
  }
  attach(element) {
    if (this._element) {
      this.detach();
    }
    this._element = element;
    this._element.addEventListener("keydown", this._keyDownHandler, false);
    this._element.addEventListener("keypress", this._keyPressHandler, false);
    this._element.addEventListener("keyup", this._keyUpHandler, false);
    document.addEventListener("visibilitychange", this._visibilityChangeHandler, false);
    window.addEventListener("blur", this._windowBlurHandler, false);
  }
  detach() {
    if (!this._element) {
      return;
    }
    this._element.removeEventListener("keydown", this._keyDownHandler);
    this._element.removeEventListener("keypress", this._keyPressHandler);
    this._element.removeEventListener("keyup", this._keyUpHandler);
    this._element = null;
    document.removeEventListener("visibilitychange", this._visibilityChangeHandler, false);
    window.removeEventListener("blur", this._windowBlurHandler, false);
  }
  toKeyIdentifier(keyCode) {
    keyCode = toKeyCode(keyCode);
    const id13 = _keyCodeToKeyIdentifier[keyCode.toString()];
    if (id13) {
      return id13;
    }
    let hex = keyCode.toString(16).toUpperCase();
    const length = hex.length;
    for (let count = 0; count < 4 - length; count++) {
      hex = `0${hex}`;
    }
    return `U+${hex}`;
  }
  _handleKeyDown(event) {
    const code = event.keyCode || event.charCode;
    if (code === void 0) return;
    const id13 = this.toKeyIdentifier(code);
    this._keymap[id13] = true;
    this.fire("keydown", makeKeyboardEvent(event));
    if (this.preventDefault) {
      event.preventDefault();
    }
    if (this.stopPropagation) {
      event.stopPropagation();
    }
  }
  _handleKeyUp(event) {
    const code = event.keyCode || event.charCode;
    if (code === void 0) return;
    const id13 = this.toKeyIdentifier(code);
    delete this._keymap[id13];
    this.fire("keyup", makeKeyboardEvent(event));
    if (this.preventDefault) {
      event.preventDefault();
    }
    if (this.stopPropagation) {
      event.stopPropagation();
    }
  }
  _handleKeyPress(event) {
    this.fire("keypress", makeKeyboardEvent(event));
    if (this.preventDefault) {
      event.preventDefault();
    }
    if (this.stopPropagation) {
      event.stopPropagation();
    }
  }
  _handleVisibilityChange() {
    if (document.visibilityState === "hidden") {
      this._handleWindowBlur();
    }
  }
  _handleWindowBlur() {
    this._keymap = {};
    this._lastmap = {};
  }
  update() {
    for (const prop in this._lastmap) {
      delete this._lastmap[prop];
    }
    for (const prop in this._keymap) {
      if (this._keymap.hasOwnProperty(prop)) {
        this._lastmap[prop] = this._keymap[prop];
      }
    }
  }
  isPressed(key) {
    const keyCode = toKeyCode(key);
    const id13 = this.toKeyIdentifier(keyCode);
    return !!this._keymap[id13];
  }
  wasPressed(key) {
    const keyCode = toKeyCode(key);
    const id13 = this.toKeyIdentifier(keyCode);
    return !!this._keymap[id13] && !!!this._lastmap[id13];
  }
  wasReleased(key) {
    const keyCode = toKeyCode(key);
    const id13 = this.toKeyIdentifier(keyCode);
    return !!!this._keymap[id13] && !!this._lastmap[id13];
  }
};
Keyboard.EVENT_KEYDOWN = "keydown";
Keyboard.EVENT_KEYUP = "keyup";

// ../node_modules/playcanvas/build/playcanvas/src/platform/input/mouse-event.js
function isMousePointerLocked() {
  return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
}
var MouseEvent = class _MouseEvent {
  constructor(mouse, event) {
    var _event$ctrlKey, _event$altKey, _event$shiftKey, _event$metaKey;
    this.x = 0;
    this.y = 0;
    this.dx = 0;
    this.dy = 0;
    this.button = MOUSEBUTTON_NONE;
    this.wheelDelta = 0;
    this.element = void 0;
    this.ctrlKey = false;
    this.altKey = false;
    this.shiftKey = false;
    this.metaKey = false;
    this.event = void 0;
    let coords = {
      x: 0,
      y: 0
    };
    if (event) {
      if (event instanceof _MouseEvent) {
        throw Error("Expected MouseEvent");
      }
      coords = mouse._getTargetCoords(event);
    } else {
      event = {};
    }
    if (coords) {
      this.x = coords.x;
      this.y = coords.y;
    } else if (isMousePointerLocked()) {
      this.x = 0;
      this.y = 0;
    } else {
      return;
    }
    if (event.type === "wheel") {
      if (event.deltaY > 0) {
        this.wheelDelta = 1;
      } else if (event.deltaY < 0) {
        this.wheelDelta = -1;
      }
    }
    if (isMousePointerLocked()) {
      this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
      this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
    } else {
      this.dx = this.x - mouse._lastX;
      this.dy = this.y - mouse._lastY;
    }
    if (event.type === "mousedown" || event.type === "mouseup") {
      this.button = event.button;
    }
    this.buttons = mouse._buttons.slice(0);
    this.element = event.target;
    this.ctrlKey = (_event$ctrlKey = event.ctrlKey) != null ? _event$ctrlKey : false;
    this.altKey = (_event$altKey = event.altKey) != null ? _event$altKey : false;
    this.shiftKey = (_event$shiftKey = event.shiftKey) != null ? _event$shiftKey : false;
    this.metaKey = (_event$metaKey = event.metaKey) != null ? _event$metaKey : false;
    this.event = event;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/input/mouse.js
var Mouse = class extends EventHandler {
  constructor(element) {
    super();
    this._lastX = 0;
    this._lastY = 0;
    this._buttons = [false, false, false];
    this._lastbuttons = [false, false, false];
    this._target = null;
    this._attached = false;
    this._upHandler = this._handleUp.bind(this);
    this._downHandler = this._handleDown.bind(this);
    this._moveHandler = this._handleMove.bind(this);
    this._wheelHandler = this._handleWheel.bind(this);
    this._contextMenuHandler = (event) => {
      event.preventDefault();
    };
    this.attach(element);
  }
  static isPointerLocked() {
    return isMousePointerLocked();
  }
  attach(element) {
    this._target = element;
    if (this._attached) return;
    this._attached = true;
    const passiveOptions = {
      passive: false
    };
    const options2 = platform.passiveEvents ? passiveOptions : false;
    window.addEventListener("mouseup", this._upHandler, options2);
    window.addEventListener("mousedown", this._downHandler, options2);
    window.addEventListener("mousemove", this._moveHandler, options2);
    window.addEventListener("wheel", this._wheelHandler, options2);
  }
  detach() {
    if (!this._attached) return;
    this._attached = false;
    this._target = null;
    const passiveOptions = {
      passive: false
    };
    const options2 = platform.passiveEvents ? passiveOptions : false;
    window.removeEventListener("mouseup", this._upHandler, options2);
    window.removeEventListener("mousedown", this._downHandler, options2);
    window.removeEventListener("mousemove", this._moveHandler, options2);
    window.removeEventListener("wheel", this._wheelHandler, options2);
  }
  disableContextMenu() {
    if (!this._target) return;
    this._target.addEventListener("contextmenu", this._contextMenuHandler);
  }
  enableContextMenu() {
    if (!this._target) return;
    this._target.removeEventListener("contextmenu", this._contextMenuHandler);
  }
  enablePointerLock(success, error) {
    if (!document.body.requestPointerLock) {
      if (error) {
        error();
      }
      return;
    }
    const s2 = () => {
      success();
      document.removeEventListener("pointerlockchange", s2);
    };
    const e = () => {
      error();
      document.removeEventListener("pointerlockerror", e);
    };
    if (success) {
      document.addEventListener("pointerlockchange", s2, false);
    }
    if (error) {
      document.addEventListener("pointerlockerror", e, false);
    }
    document.body.requestPointerLock();
  }
  disablePointerLock(success) {
    if (!document.exitPointerLock) {
      return;
    }
    const s2 = () => {
      success();
      document.removeEventListener("pointerlockchange", s2);
    };
    if (success) {
      document.addEventListener("pointerlockchange", s2, false);
    }
    document.exitPointerLock();
  }
  update() {
    this._lastbuttons[0] = this._buttons[0];
    this._lastbuttons[1] = this._buttons[1];
    this._lastbuttons[2] = this._buttons[2];
  }
  isPressed(button) {
    return this._buttons[button];
  }
  wasPressed(button) {
    return this._buttons[button] && !this._lastbuttons[button];
  }
  wasReleased(button) {
    return !this._buttons[button] && this._lastbuttons[button];
  }
  _handleUp(event) {
    this._buttons[event.button] = false;
    const e = new MouseEvent(this, event);
    if (!e.event) return;
    this.fire(EVENT_MOUSEUP, e);
  }
  _handleDown(event) {
    this._buttons[event.button] = true;
    const e = new MouseEvent(this, event);
    if (!e.event) return;
    this.fire(EVENT_MOUSEDOWN, e);
  }
  _handleMove(event) {
    const e = new MouseEvent(this, event);
    if (!e.event) return;
    this.fire(EVENT_MOUSEMOVE, e);
    this._lastX = e.x;
    this._lastY = e.y;
  }
  _handleWheel(event) {
    const e = new MouseEvent(this, event);
    if (!e.event) return;
    this.fire(EVENT_MOUSEWHEEL, e);
  }
  _getTargetCoords(event) {
    const rect = this._target.getBoundingClientRect();
    const left = Math.floor(rect.left);
    const top = Math.floor(rect.top);
    if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
      return null;
    }
    return {
      x: event.clientX - left,
      y: event.clientY - top
    };
  }
};
Mouse.EVENT_MOUSEMOVE = EVENT_MOUSEMOVE;
Mouse.EVENT_MOUSEDOWN = EVENT_MOUSEDOWN;
Mouse.EVENT_MOUSEUP = EVENT_MOUSEUP;
Mouse.EVENT_MOUSEWHEEL = EVENT_MOUSEWHEEL;

// ../node_modules/playcanvas/build/playcanvas/src/platform/input/controller.js
var Controller = class {
  constructor(element, options2 = {}) {
    this._keyboard = void 0;
    this._mouse = void 0;
    this._gamepads = void 0;
    this._element = null;
    this._actions = {};
    this._axes = {};
    this._axesValues = {};
    this._keyboard = options2.keyboard || null;
    this._mouse = options2.mouse || null;
    this._gamepads = options2.gamepads || null;
    if (element) {
      this.attach(element);
    }
  }
  attach(element) {
    this._element = element;
    if (this._keyboard) {
      this._keyboard.attach(element);
    }
    if (this._mouse) {
      this._mouse.attach(element);
    }
  }
  detach() {
    if (this._keyboard) {
      this._keyboard.detach();
    }
    if (this._mouse) {
      this._mouse.detach();
    }
    this._element = null;
  }
  disableContextMenu() {
    if (!this._mouse) {
      this._enableMouse();
    }
    this._mouse.disableContextMenu();
  }
  enableContextMenu() {
    if (!this._mouse) {
      this._enableMouse();
    }
    this._mouse.enableContextMenu();
  }
  update(dt) {
    if (this._keyboard) {
      this._keyboard.update();
    }
    if (this._mouse) {
      this._mouse.update();
    }
    if (this._gamepads) {
      this._gamepads.update();
    }
    this._axesValues = {};
    for (const key in this._axes) {
      this._axesValues[key] = [];
    }
  }
  appendAction(action_name, action) {
    this._actions[action_name] = this._actions[action_name] || [];
    this._actions[action_name].push(action);
  }
  registerKeys(action, keys) {
    if (!this._keyboard) {
      this._enableKeyboard();
    }
    if (this._actions[action]) {
      throw new Error(`Action: ${action} already registered`);
    }
    if (keys === void 0) {
      throw new Error("Invalid button");
    }
    if (!keys.length) {
      keys = [keys];
    }
    this.appendAction(action, {
      type: ACTION_KEYBOARD,
      keys
    });
  }
  registerMouse(action, button) {
    if (!this._mouse) {
      this._enableMouse();
    }
    if (button === void 0) {
      throw new Error("Invalid button");
    }
    this.appendAction(action, {
      type: ACTION_MOUSE,
      button
    });
  }
  registerPadButton(action, pad, button) {
    if (button === void 0) {
      throw new Error("Invalid button");
    }
    this.appendAction(action, {
      type: ACTION_GAMEPAD,
      button,
      pad
    });
  }
  registerAxis(options2) {
    const name = options2.name;
    if (!this._axes[name]) {
      this._axes[name] = [];
    }
    const i = this._axes[name].push(name);
    options2 = options2 || {};
    options2.pad = options2.pad || PAD_1;
    const bind = function bind2(controller, source, value, key) {
      switch (source) {
        case "mousex":
          controller._mouse.on(EVENT_MOUSEMOVE, (e) => {
            controller._axesValues[name][i] = e.dx / 10;
          });
          break;
        case "mousey":
          controller._mouse.on(EVENT_MOUSEMOVE, (e) => {
            controller._axesValues[name][i] = e.dy / 10;
          });
          break;
        case "key":
          controller._axes[name].push(() => {
            return controller._keyboard.isPressed(key) ? value : 0;
          });
          break;
        case "padrx":
          controller._axes[name].push(() => {
            return controller._gamepads.getAxis(options2.pad, PAD_R_STICK_X);
          });
          break;
        case "padry":
          controller._axes[name].push(() => {
            return controller._gamepads.getAxis(options2.pad, PAD_R_STICK_Y);
          });
          break;
        case "padlx":
          controller._axes[name].push(() => {
            return controller._gamepads.getAxis(options2.pad, PAD_L_STICK_X);
          });
          break;
        case "padly":
          controller._axes[name].push(() => {
            return controller._gamepads.getAxis(options2.pad, PAD_L_STICK_Y);
          });
          break;
        default:
          throw new Error("Unknown axis");
      }
    };
    bind(this, options2.positive, 1, options2.positiveKey);
    if (options2.negativeKey || options2.negative !== options2.positive) {
      bind(this, options2.negative, -1, options2.negativeKey);
    }
  }
  isPressed(actionName) {
    if (!this._actions[actionName]) {
      return false;
    }
    const length = this._actions[actionName].length;
    for (let index = 0; index < length; ++index) {
      const action = this._actions[actionName][index];
      switch (action.type) {
        case ACTION_KEYBOARD:
          if (this._keyboard) {
            const len = action.keys.length;
            for (let i = 0; i < len; i++) {
              if (this._keyboard.isPressed(action.keys[i])) {
                return true;
              }
            }
          }
          break;
        case ACTION_MOUSE:
          if (this._mouse && this._mouse.isPressed(action.button)) {
            return true;
          }
          break;
        case ACTION_GAMEPAD:
          if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
            return true;
          }
          break;
      }
    }
    return false;
  }
  wasPressed(actionName) {
    if (!this._actions[actionName]) {
      return false;
    }
    const length = this._actions[actionName].length;
    for (let index = 0; index < length; ++index) {
      const action = this._actions[actionName][index];
      switch (action.type) {
        case ACTION_KEYBOARD:
          if (this._keyboard) {
            const len = action.keys.length;
            for (let i = 0; i < len; i++) {
              if (this._keyboard.wasPressed(action.keys[i])) {
                return true;
              }
            }
          }
          break;
        case ACTION_MOUSE:
          if (this._mouse && this._mouse.wasPressed(action.button)) {
            return true;
          }
          break;
        case ACTION_GAMEPAD:
          if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
            return true;
          }
          break;
      }
    }
    return false;
  }
  getAxis(name) {
    let value = 0;
    if (this._axes[name]) {
      const len = this._axes[name].length;
      for (let i = 0; i < len; i++) {
        if (typeof this._axes[name][i] === "function") {
          const v = this._axes[name][i]();
          if (Math.abs(v) > Math.abs(value)) {
            value = v;
          }
        } else if (this._axesValues[name]) {
          if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
            value = this._axesValues[name][i];
          }
        }
      }
    }
    return value;
  }
  _enableMouse() {
    this._mouse = new Mouse();
    if (!this._element) {
      throw new Error("Controller must be attached to an Element");
    }
    this._mouse.attach(this._element);
  }
  _enableKeyboard() {
    this._keyboard = new Keyboard();
    if (!this._element) {
      throw new Error("Controller must be attached to an Element");
    }
    this._keyboard.attach(this._element);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/input/game-pads.js
var dummyArray = Object.freeze([]);
var _getGamepads = function getGamepads() {
  return dummyArray;
};
if (typeof navigator !== "undefined") {
  _getGamepads = (navigator.getGamepads || navigator.webkitGetGamepads || _getGamepads).bind(navigator);
}
var MAPS_INDEXES = {
  buttons: {
    PAD_FACE_1,
    PAD_FACE_2,
    PAD_FACE_3,
    PAD_FACE_4,
    PAD_L_SHOULDER_1,
    PAD_R_SHOULDER_1,
    PAD_L_SHOULDER_2,
    PAD_R_SHOULDER_2,
    PAD_SELECT,
    PAD_START,
    PAD_L_STICK_BUTTON,
    PAD_R_STICK_BUTTON,
    PAD_UP,
    PAD_DOWN,
    PAD_LEFT,
    PAD_RIGHT,
    PAD_VENDOR,
    XRPAD_TRIGGER,
    XRPAD_SQUEEZE,
    XRPAD_TOUCHPAD_BUTTON,
    XRPAD_STICK_BUTTON,
    XRPAD_A,
    XRPAD_B
  },
  axes: {
    PAD_L_STICK_X,
    PAD_L_STICK_Y,
    PAD_R_STICK_X,
    PAD_R_STICK_Y,
    XRPAD_TOUCHPAD_X,
    XRPAD_TOUCHPAD_Y,
    XRPAD_STICK_X,
    XRPAD_STICK_Y
  }
};
var MAPS = {
  DEFAULT: {
    buttons: ["PAD_FACE_1", "PAD_FACE_2", "PAD_FACE_3", "PAD_FACE_4", "PAD_L_SHOULDER_1", "PAD_R_SHOULDER_1", "PAD_L_SHOULDER_2", "PAD_R_SHOULDER_2", "PAD_SELECT", "PAD_START", "PAD_L_STICK_BUTTON", "PAD_R_STICK_BUTTON", "PAD_UP", "PAD_DOWN", "PAD_LEFT", "PAD_RIGHT", "PAD_VENDOR"],
    axes: ["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]
  },
  DEFAULT_DUAL: {
    buttons: ["PAD_FACE_1", "PAD_FACE_2", "PAD_FACE_3", "PAD_FACE_4", "PAD_L_SHOULDER_1", "PAD_R_SHOULDER_1", "PAD_L_SHOULDER_2", "PAD_R_SHOULDER_2", "PAD_SELECT", "PAD_START", "PAD_L_STICK_BUTTON", "PAD_R_STICK_BUTTON", "PAD_VENDOR"],
    axes: ["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"],
    synthesizedButtons: {
      PAD_UP: {
        axis: 0,
        min: 0,
        max: 1
      },
      PAD_DOWN: {
        axis: 0,
        min: -1,
        max: 0
      },
      PAD_LEFT: {
        axis: 0,
        min: -1,
        max: 0
      },
      PAD_RIGHT: {
        axis: 0,
        min: 0,
        max: 1
      }
    }
  },
  PS3: {
    buttons: ["PAD_FACE_1", "PAD_FACE_2", "PAD_FACE_4", "PAD_FACE_3", "PAD_L_SHOULDER_1", "PAD_R_SHOULDER_1", "PAD_L_SHOULDER_2", "PAD_R_SHOULDER_2", "PAD_SELECT", "PAD_START", "PAD_L_STICK_BUTTON", "PAD_R_STICK_BUTTON", "PAD_UP", "PAD_DOWN", "PAD_LEFT", "PAD_RIGHT", "PAD_VENDOR"],
    axes: ["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"],
    mapping: "standard"
  },
  DEFAULT_XR: {
    buttons: ["XRPAD_TRIGGER", "XRPAD_SQUEEZE", "XRPAD_TOUCHPAD_BUTTON", "XRPAD_STICK_BUTTON", "XRPAD_A", "XRPAD_B"],
    axes: ["XRPAD_TOUCHPAD_X", "XRPAD_TOUCHPAD_Y", "XRPAD_STICK_X", "XRPAD_STICK_Y"],
    mapping: "xr-standard"
  }
};
var PRODUCT_CODES = {
  "Product: 0268": "PS3"
};
var custom_maps = {};
function getMap(pad) {
  const custom = custom_maps[pad.id];
  if (custom) {
    return custom;
  }
  for (const code in PRODUCT_CODES) {
    if (pad.id.indexOf(code) !== -1) {
      const product = PRODUCT_CODES[code];
      if (!pad.mapping) {
        const raw = MAPS[`RAW_${product}`];
        if (raw) {
          return raw;
        }
      }
      return MAPS[product];
    }
  }
  if (pad.mapping === "xr-standard") {
    return MAPS.DEFAULT_XR;
  }
  const defaultmap = MAPS.DEFAULT;
  const map = pad.buttons.length < defaultmap.buttons.length ? MAPS.DEFAULT_DUAL : defaultmap;
  map.mapping = pad.mapping;
  return map;
}
var deadZone = 0.25;
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
var GamePadButton = class {
  constructor(current, previous) {
    this.value = 0;
    this.pressed = false;
    this.touched = false;
    this.wasPressed = false;
    this.wasReleased = false;
    this.wasTouched = false;
    if (typeof current === "number") {
      this.value = current;
      this.pressed = current === 1;
      this.touched = current > 0;
    } else {
      var _current$touched;
      this.value = current.value;
      this.pressed = current.pressed;
      this.touched = (_current$touched = current.touched) != null ? _current$touched : current.value > 0;
    }
    if (previous) {
      if (typeof previous === "number") {
        this.wasPressed = previous !== 1 && this.pressed;
        this.wasReleased = previous === 1 && !this.pressed;
        this.wasTouched = previous === 0 && this.touched;
      } else {
        var _previous$touched;
        this.wasPressed = !previous.pressed && this.pressed;
        this.wasReleased = previous.pressed && !this.pressed;
        this.wasTouched = !((_previous$touched = previous.touched) != null ? _previous$touched : previous.value > 0) && this.touched;
      }
    }
  }
  update(button) {
    var _button$touched;
    const {
      value,
      pressed
    } = button;
    const touched = (_button$touched = button.touched) != null ? _button$touched : value > 0;
    this.wasPressed = !this.pressed && pressed;
    this.wasReleased = this.pressed && !pressed;
    this.wasTouched = !this.touched && touched;
    this.value = value;
    this.pressed = pressed;
    this.touched = touched;
  }
};
var dummyButton = Object.freeze(new GamePadButton(0));
var GamePad = class {
  constructor(gamepad, map) {
    this._compiledMapping = {
      buttons: [],
      axes: []
    };
    this.id = gamepad.id;
    this.index = gamepad.index;
    this._buttons = gamepad.buttons.map((b) => new GamePadButton(b));
    this._axes = [...gamepad.axes];
    this._previousAxes = [...gamepad.axes];
    this.mapping = map.mapping;
    this.map = map;
    this.hand = gamepad.hand || "none";
    this.pad = gamepad;
    this._compileMapping();
  }
  get connected() {
    return this.pad.connected;
  }
  _compileMapping() {
    const {
      axes,
      buttons
    } = this._compiledMapping;
    const axesIndexes = MAPS_INDEXES.axes;
    const buttonsIndexes = MAPS_INDEXES.buttons;
    axes.length = 0;
    buttons.length = 0;
    const axesMap = this.map.axes;
    if (axesMap) {
      this.map.axes.forEach((axis, i) => {
        axes[axesIndexes[axis]] = () => this.pad.axes[i] || 0;
      });
    }
    for (let i = 0, l = axes.length; i < l; i++) {
      if (!axes[i]) {
        axes[i] = () => 0;
      }
    }
    const buttonsMap = this.map.buttons;
    if (buttonsMap) {
      buttonsMap.forEach((button, i) => {
        buttons[buttonsIndexes[button]] = () => this._buttons[i] || dummyButton;
      });
    }
    const synthesizedButtonsMap = this.map.synthesizedButtons;
    if (synthesizedButtonsMap) {
      Object.entries(synthesizedButtonsMap).forEach((button) => {
        const {
          axis,
          max,
          min
        } = button[1];
        buttons[buttonsIndexes[button[0]]] = () => {
          var _this$_axes$axis, _this$_previousAxes$a;
          return new GamePadButton(Math.abs(math.clamp((_this$_axes$axis = this._axes[axis]) != null ? _this$_axes$axis : 0, min, max)), Math.abs(math.clamp((_this$_previousAxes$a = this._previousAxes[axis]) != null ? _this$_previousAxes$a : 0, min, max)));
        };
      });
    }
    for (let i = 0, l = buttons.length; i < l; i++) {
      if (!buttons[i]) {
        buttons[i] = () => dummyButton;
      }
    }
  }
  update(gamepad) {
    this.pad = gamepad;
    const previousAxes = this._previousAxes;
    const axes = this._axes;
    previousAxes.length = 0;
    previousAxes.push(...axes);
    axes.length = 0;
    axes.push(...gamepad.axes);
    const buttons = this._buttons;
    for (let i = 0, l = buttons.length; i < l; i++) {
      buttons[i].update(gamepad.buttons[i]);
    }
    return this;
  }
  updateMap(map) {
    map.mapping = "custom";
    custom_maps[this.id] = map;
    this.map = map;
    this.mapping = "custom";
    this._compileMapping();
  }
  resetMap() {
    if (custom_maps[this.id]) {
      delete custom_maps[this.id];
      const map = getMap(this.pad);
      this.map = map;
      this.mapping = map.mapping;
      this._compileMapping();
    }
  }
  get axes() {
    return this._compiledMapping.axes.map((a) => a());
  }
  get buttons() {
    return this._compiledMapping.buttons.map((b) => b());
  }
  async pulse(intensity, duration, options2) {
    const actuators = this.pad.vibrationActuator ? [this.pad.vibrationActuator] : this.pad.hapticActuators || dummyArray;
    if (actuators.length) {
      var _options$startDelay, _options$strongMagnit, _options$weakMagnitud;
      const startDelay = (_options$startDelay = options2 == null ? void 0 : options2.startDelay) != null ? _options$startDelay : 0;
      const strongMagnitude = (_options$strongMagnit = options2 == null ? void 0 : options2.strongMagnitude) != null ? _options$strongMagnit : intensity;
      const weakMagnitude = (_options$weakMagnitud = options2 == null ? void 0 : options2.weakMagnitude) != null ? _options$weakMagnitud : intensity;
      const results = await Promise.all(actuators.map(async function(actuator) {
        if (!actuator) {
          return true;
        }
        if (actuator.playEffect) {
          return actuator.playEffect(actuator.type, {
            duration,
            startDelay,
            strongMagnitude,
            weakMagnitude
          });
        } else if (actuator.pulse) {
          await sleep(startDelay);
          return actuator.pulse(intensity, duration);
        }
        return false;
      }));
      return results.some((r) => r === true || r === "complete");
    }
    return false;
  }
  getButton(index) {
    const button = this._compiledMapping.buttons[index];
    return button ? button() : dummyButton;
  }
  isPressed(button) {
    return this.getButton(button).pressed;
  }
  wasPressed(button) {
    return this.getButton(button).wasPressed;
  }
  wasReleased(button) {
    return this.getButton(button).wasReleased;
  }
  isTouched(button) {
    return this.getButton(button).touched;
  }
  wasTouched(button) {
    return this.getButton(button).wasTouched;
  }
  getValue(button) {
    return this.getButton(button).value;
  }
  getAxis(axis) {
    const a = this.axes[axis];
    return a && Math.abs(a) > deadZone ? a : 0;
  }
};
var GamePads = class extends EventHandler {
  constructor() {
    super();
    this.gamepadsSupported = platform.gamepads;
    this.current = [];
    this._previous = [];
    this._ongamepadconnectedHandler = this._ongamepadconnected.bind(this);
    this._ongamepaddisconnectedHandler = this._ongamepaddisconnected.bind(this);
    window.addEventListener("gamepadconnected", this._ongamepadconnectedHandler, false);
    window.addEventListener("gamepaddisconnected", this._ongamepaddisconnectedHandler, false);
    this.poll();
  }
  set deadZone(value) {
    deadZone = value;
  }
  get deadZone() {
    return deadZone;
  }
  get previous() {
    const current = this.current;
    for (let i = 0, l = current.length; i < l; i++) {
      const buttons = current[i]._buttons;
      if (!this._previous[i]) {
        this._previous[i] = [];
      }
      for (let j = 0, m = buttons.length; j < m; j++) {
        const button = buttons[i];
        this.previous[i][j] = button ? !button.wasPressed && button.pressed || button.wasReleased : false;
      }
    }
    this._previous.length = this.current.length;
    return this._previous;
  }
  _ongamepadconnected(event) {
    const pad = new GamePad(event.gamepad, this.getMap(event.gamepad));
    const current = this.current;
    let padIndex = current.findIndex((gp) => gp.index === pad.index);
    while (padIndex !== -1) {
      current.splice(padIndex, 1);
      padIndex = current.findIndex((gp) => gp.index === pad.index);
    }
    current.push(pad);
    this.fire(EVENT_GAMEPADCONNECTED, pad);
  }
  _ongamepaddisconnected(event) {
    const current = this.current;
    const padIndex = current.findIndex((gp) => gp.index === event.gamepad.index);
    if (padIndex !== -1) {
      this.fire(EVENT_GAMEPADDISCONNECTED, current[padIndex]);
      current.splice(padIndex, 1);
    }
  }
  update() {
    this.poll();
  }
  poll(pads = []) {
    if (pads.length > 0) {
      pads.length = 0;
    }
    const padDevices = _getGamepads();
    for (let i = 0, len = padDevices.length; i < len; i++) {
      if (padDevices[i]) {
        const pad = this.findByIndex(padDevices[i].index);
        if (pad) {
          pads.push(pad.update(padDevices[i]));
        } else {
          const nPad = new GamePad(padDevices[i], this.getMap(padDevices[i]));
          this.current.push(nPad);
          pads.push(nPad);
        }
      }
    }
    return pads;
  }
  destroy() {
    window.removeEventListener("gamepadconnected", this._ongamepadconnectedHandler, false);
    window.removeEventListener("gamepaddisconnected", this._ongamepaddisconnectedHandler, false);
  }
  getMap(pad) {
    return getMap(pad);
  }
  isPressed(orderIndex, button) {
    var _this$current$orderIn;
    return ((_this$current$orderIn = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn.isPressed(button)) || false;
  }
  wasPressed(orderIndex, button) {
    var _this$current$orderIn2;
    return ((_this$current$orderIn2 = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn2.wasPressed(button)) || false;
  }
  wasReleased(orderIndex, button) {
    var _this$current$orderIn3;
    return ((_this$current$orderIn3 = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn3.wasReleased(button)) || false;
  }
  getAxis(orderIndex, axis) {
    var _this$current$orderIn4;
    return ((_this$current$orderIn4 = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn4.getAxis(axis)) || 0;
  }
  pulse(orderIndex, intensity, duration, options2) {
    const pad = this.current[orderIndex];
    return pad ? pad.pulse(intensity, duration, options2) : Promise.resolve(false);
  }
  pulseAll(intensity, duration, options2) {
    return Promise.all(this.current.map((pad) => pad.pulse(intensity, duration, options2)));
  }
  findById(id13) {
    return this.current.find((gp) => gp && gp.id === id13) || null;
  }
  findByIndex(index) {
    return this.current.find((gp) => gp && gp.index === index) || null;
  }
};
GamePads.EVENT_GAMEPADCONNECTED = "gamepadconnected";
GamePads.EVENT_GAMEPADDISCONNECTED = "gamepaddisconnected";

// ../node_modules/playcanvas/build/playcanvas/src/platform/input/touch-event.js
function getTouchTargetCoords(touch2) {
  let totalOffsetX = 0;
  let totalOffsetY = 0;
  let target2 = touch2.target;
  while (!(target2 instanceof HTMLElement) && target2) {
    target2 = target2.parentNode;
  }
  while (target2) {
    totalOffsetX += target2.offsetLeft - target2.scrollLeft;
    totalOffsetY += target2.offsetTop - target2.scrollTop;
    target2 = target2.offsetParent;
  }
  return {
    x: touch2.pageX - totalOffsetX,
    y: touch2.pageY - totalOffsetY
  };
}
var Touch = class {
  constructor(touch2) {
    this.id = void 0;
    this.x = void 0;
    this.y = void 0;
    this.target = void 0;
    this.touch = void 0;
    const coords = getTouchTargetCoords(touch2);
    this.id = touch2.identifier;
    this.x = coords.x;
    this.y = coords.y;
    this.target = touch2.target;
    this.touch = touch2;
  }
};
var TouchEvent = class {
  constructor(device, event) {
    this.element = void 0;
    this.event = void 0;
    this.touches = [];
    this.changedTouches = [];
    this.element = event.target;
    this.event = event;
    this.touches = Array.from(event.touches).map((touch2) => new Touch(touch2));
    this.changedTouches = Array.from(event.changedTouches).map((touch2) => new Touch(touch2));
  }
  getTouchById(id13, list) {
    return list.find((touch2) => touch2.id === id13) || null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/input/touch-device.js
var TouchDevice = class extends EventHandler {
  constructor(element) {
    super();
    this._element = null;
    this._startHandler = this._handleTouchStart.bind(this);
    this._endHandler = this._handleTouchEnd.bind(this);
    this._moveHandler = this._handleTouchMove.bind(this);
    this._cancelHandler = this._handleTouchCancel.bind(this);
    this.attach(element);
  }
  attach(element) {
    if (this._element) {
      this.detach();
    }
    this._element = element;
    this._element.addEventListener("touchstart", this._startHandler, false);
    this._element.addEventListener("touchend", this._endHandler, false);
    this._element.addEventListener("touchmove", this._moveHandler, false);
    this._element.addEventListener("touchcancel", this._cancelHandler, false);
  }
  detach() {
    if (this._element) {
      this._element.removeEventListener("touchstart", this._startHandler, false);
      this._element.removeEventListener("touchend", this._endHandler, false);
      this._element.removeEventListener("touchmove", this._moveHandler, false);
      this._element.removeEventListener("touchcancel", this._cancelHandler, false);
    }
    this._element = null;
  }
  _handleTouchStart(e) {
    this.fire("touchstart", new TouchEvent(this, e));
  }
  _handleTouchEnd(e) {
    this.fire("touchend", new TouchEvent(this, e));
  }
  _handleTouchMove(e) {
    e.preventDefault();
    this.fire("touchmove", new TouchEvent(this, e));
  }
  _handleTouchCancel(e) {
    this.fire("touchcancel", new TouchEvent(this, e));
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/net/http.js
var Http = class _Http {
  get(url, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    return this.request("GET", url, options2, callback);
  }
  post(url, data2, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    options2.postdata = data2;
    return this.request("POST", url, options2, callback);
  }
  put(url, data2, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    options2.postdata = data2;
    return this.request("PUT", url, options2, callback);
  }
  del(url, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    return this.request("DELETE", url, options2, callback);
  }
  request(method, url, options2, callback) {
    let uri, query, postdata;
    let errored = false;
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    if (options2.retry) {
      options2 = Object.assign({
        retries: 0,
        maxRetries: 5
      }, options2);
    }
    options2.callback = callback;
    if (options2.async == null) {
      options2.async = true;
    }
    if (options2.headers == null) {
      options2.headers = {};
    }
    if (options2.postdata != null) {
      if (options2.postdata instanceof Document) {
        postdata = options2.postdata;
      } else if (options2.postdata instanceof FormData) {
        postdata = options2.postdata;
      } else if (options2.postdata instanceof Object) {
        let contentType = options2.headers["Content-Type"];
        if (contentType === void 0) {
          options2.headers["Content-Type"] = _Http.ContentType.FORM_URLENCODED;
          contentType = options2.headers["Content-Type"];
        }
        switch (contentType) {
          case _Http.ContentType.FORM_URLENCODED: {
            postdata = "";
            let bFirstItem = true;
            for (const key in options2.postdata) {
              if (options2.postdata.hasOwnProperty(key)) {
                if (bFirstItem) {
                  bFirstItem = false;
                } else {
                  postdata += "&";
                }
                const encodedKey = encodeURIComponent(key);
                const encodedValue = encodeURIComponent(options2.postdata[key]);
                postdata += `${encodedKey}=${encodedValue}`;
              }
            }
            break;
          }
          default:
          case _Http.ContentType.JSON:
            if (contentType == null) {
              options2.headers["Content-Type"] = _Http.ContentType.JSON;
            }
            postdata = JSON.stringify(options2.postdata);
            break;
        }
      } else {
        postdata = options2.postdata;
      }
    }
    if (options2.cache === false) {
      const timestamp = now();
      uri = new URI(url);
      if (!uri.query) {
        uri.query = `ts=${timestamp}`;
      } else {
        uri.query = `${uri.query}&ts=${timestamp}`;
      }
      url = uri.toString();
    }
    if (options2.query) {
      uri = new URI(url);
      query = extend(uri.getQuery(), options2.query);
      uri.setQuery(query);
      url = uri.toString();
    }
    const xhr = new XMLHttpRequest();
    xhr.open(method, url, options2.async);
    xhr.withCredentials = options2.withCredentials !== void 0 ? options2.withCredentials : false;
    xhr.responseType = options2.responseType || this._guessResponseType(url);
    for (const header2 in options2.headers) {
      if (options2.headers.hasOwnProperty(header2)) {
        xhr.setRequestHeader(header2, options2.headers[header2]);
      }
    }
    xhr.onreadystatechange = () => {
      this._onReadyStateChange(method, url, options2, xhr);
    };
    xhr.onerror = () => {
      this._onError(method, url, options2, xhr);
      errored = true;
    };
    try {
      xhr.send(postdata);
    } catch (e) {
      if (!errored) {
        options2.error(xhr.status, xhr, e);
      }
    }
    return xhr;
  }
  _guessResponseType(url) {
    const uri = new URI(url);
    const ext = path.getExtension(uri.path).toLowerCase();
    if (_Http.binaryExtensions.indexOf(ext) >= 0) {
      return _Http.ResponseType.ARRAY_BUFFER;
    } else if (ext === ".json") {
      return _Http.ResponseType.JSON;
    } else if (ext === ".xml") {
      return _Http.ResponseType.DOCUMENT;
    }
    return _Http.ResponseType.TEXT;
  }
  _isBinaryContentType(contentType) {
    const binTypes = [_Http.ContentType.BASIS, _Http.ContentType.BIN, _Http.ContentType.DDS, _Http.ContentType.GLB, _Http.ContentType.MP3, _Http.ContentType.MP4, _Http.ContentType.OGG, _Http.ContentType.OPUS, _Http.ContentType.WAV];
    if (binTypes.indexOf(contentType) >= 0) {
      return true;
    }
    return false;
  }
  _isBinaryResponseType(responseType) {
    return responseType === _Http.ResponseType.ARRAY_BUFFER || responseType === _Http.ResponseType.BLOB || responseType === _Http.ResponseType.JSON;
  }
  _onReadyStateChange(method, url, options2, xhr) {
    if (xhr.readyState === 4) {
      switch (xhr.status) {
        case 0: {
          if (xhr.responseURL && xhr.responseURL.startsWith("file:///")) {
            this._onSuccess(method, url, options2, xhr);
          } else {
            this._onError(method, url, options2, xhr);
          }
          break;
        }
        case 200:
        case 201:
        case 206:
        case 304: {
          this._onSuccess(method, url, options2, xhr);
          break;
        }
        default: {
          this._onError(method, url, options2, xhr);
          break;
        }
      }
    }
  }
  _onSuccess(method, url, options2, xhr) {
    let response;
    let contentType;
    const header2 = xhr.getResponseHeader("Content-Type");
    if (header2) {
      const parts = header2.split(";");
      contentType = parts[0].trim();
    }
    try {
      if (this._isBinaryContentType(contentType) || this._isBinaryResponseType(xhr.responseType)) {
        response = xhr.response;
      } else if (contentType === _Http.ContentType.JSON || url.split("?")[0].endsWith(".json")) {
        response = JSON.parse(xhr.responseText);
      } else if (xhr.responseType === _Http.ResponseType.DOCUMENT || contentType === _Http.ContentType.XML) {
        response = xhr.responseXML;
      } else {
        response = xhr.responseText;
      }
      options2.callback(null, response);
    } catch (err3) {
      options2.callback(err3);
    }
  }
  _onError(method, url, options2, xhr) {
    if (options2.retrying) {
      return;
    }
    if (options2.retry && options2.retries < options2.maxRetries) {
      options2.retries++;
      options2.retrying = true;
      const retryDelay = math.clamp(Math.pow(2, options2.retries) * _Http.retryDelay, 0, options2.maxRetryDelay || 5e3);
      console.log(`${method}: ${url} - Error ${xhr.status}. Retrying in ${retryDelay} ms`);
      setTimeout(() => {
        options2.retrying = false;
        this.request(method, url, options2, options2.callback);
      }, retryDelay);
    } else {
      options2.callback(xhr.status === 0 ? "Network error" : xhr.status, null);
    }
  }
};
Http.ContentType = {
  AAC: "audio/aac",
  BASIS: "image/basis",
  BIN: "application/octet-stream",
  DDS: "image/dds",
  FORM_URLENCODED: "application/x-www-form-urlencoded",
  GIF: "image/gif",
  GLB: "model/gltf-binary",
  JPEG: "image/jpeg",
  JSON: "application/json",
  MP3: "audio/mpeg",
  MP4: "audio/mp4",
  OGG: "audio/ogg",
  OPUS: 'audio/ogg; codecs="opus"',
  PNG: "image/png",
  TEXT: "text/plain",
  WAV: "audio/x-wav",
  XML: "application/xml"
};
Http.ResponseType = {
  TEXT: "text",
  ARRAY_BUFFER: "arraybuffer",
  BLOB: "blob",
  DOCUMENT: "document",
  JSON: "json"
};
Http.binaryExtensions = [".model", ".wav", ".ogg", ".mp3", ".mp4", ".m4a", ".aac", ".dds", ".basis", ".glb", ".opus"];
Http.retryDelay = 100;
var http = new Http();

// ../node_modules/playcanvas/build/playcanvas/src/platform/audio/capabilities.js
function hasAudioContext() {
  return !!(typeof AudioContext !== "undefined" || typeof webkitAudioContext !== "undefined");
}

// ../node_modules/playcanvas/build/playcanvas/src/platform/audio/channel.js
var Channel = class {
  constructor(manager, sound, options2 = {}) {
    var _options$volume, _options$loop, _options$pitch;
    this.volume = (_options$volume = options2.volume) != null ? _options$volume : 1;
    this.loop = (_options$loop = options2.loop) != null ? _options$loop : false;
    this.pitch = (_options$pitch = options2.pitch) != null ? _options$pitch : 1;
    this.sound = sound;
    this.paused = false;
    this.suspended = false;
    this.manager = manager;
    this.source = null;
    if (hasAudioContext()) {
      this.startTime = 0;
      this.startOffset = 0;
      const context = manager.context;
      this.gain = context.createGain();
    } else if (sound.audio) {
      this.source = sound.audio.cloneNode(false);
      this.source.pause();
    }
  }
  getVolume() {
    return this.volume;
  }
  getLoop() {
    return this.loop;
  }
  setLoop(loop) {
    this.loop = loop;
    if (this.source) {
      this.source.loop = loop;
    }
  }
  getPitch() {
    return this.pitch;
  }
  onManagerVolumeChange() {
    this.setVolume(this.getVolume());
  }
  onManagerSuspend() {
    if (this.isPlaying() && !this.suspended) {
      this.suspended = true;
      this.pause();
    }
  }
  onManagerResume() {
    if (this.suspended) {
      this.suspended = false;
      this.unpause();
    }
  }
  play() {
    if (this.source) {
      throw new Error("Call stop() before calling play()");
    }
    this._createSource();
    if (!this.source) {
      return;
    }
    this.startTime = this.manager.context.currentTime;
    this.source.start(0, this.startOffset % this.source.buffer.duration);
    this.setVolume(this.volume);
    this.setLoop(this.loop);
    this.setPitch(this.pitch);
    this.manager.on("volumechange", this.onManagerVolumeChange, this);
    this.manager.on("suspend", this.onManagerSuspend, this);
    this.manager.on("resume", this.onManagerResume, this);
    if (this.manager.suspended) {
      this.onManagerSuspend();
    }
  }
  pause() {
    if (this.source) {
      this.paused = true;
      this.startOffset += this.manager.context.currentTime - this.startTime;
      this.source.stop(0);
      this.source = null;
    }
  }
  unpause() {
    if (this.source || !this.paused) {
      console.warn("Call pause() before unpausing.");
      return;
    }
    this._createSource();
    if (!this.source) {
      return;
    }
    this.startTime = this.manager.context.currentTime;
    this.source.start(0, this.startOffset % this.source.buffer.duration);
    this.setVolume(this.volume);
    this.setLoop(this.loop);
    this.setPitch(this.pitch);
    this.paused = false;
  }
  stop() {
    if (this.source) {
      this.source.stop(0);
      this.source = null;
    }
    this.manager.off("volumechange", this.onManagerVolumeChange, this);
    this.manager.off("suspend", this.onManagerSuspend, this);
    this.manager.off("resume", this.onManagerResume, this);
  }
  setVolume(volume) {
    volume = math.clamp(volume, 0, 1);
    this.volume = volume;
    if (this.gain) {
      this.gain.gain.value = volume * this.manager.volume;
    }
  }
  setPitch(pitch) {
    this.pitch = pitch;
    if (this.source) {
      this.source.playbackRate.value = pitch;
    }
  }
  isPlaying() {
    return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
  }
  getDuration() {
    return this.source ? this.source.buffer.duration : 0;
  }
  _createSource() {
    const context = this.manager.context;
    if (this.sound.buffer) {
      this.source = context.createBufferSource();
      this.source.buffer = this.sound.buffer;
      this.source.connect(this.gain);
      this.gain.connect(context.destination);
      if (!this.loop) {
        this.source.onended = this.pause.bind(this);
      }
    }
  }
};
if (!hasAudioContext()) {
  Object.assign(Channel.prototype, {
    play: function() {
      if (this.source) {
        this.paused = false;
        this.setVolume(this.volume);
        this.setLoop(this.loop);
        this.setPitch(this.pitch);
        this.source.play();
      }
      this.manager.on("volumechange", this.onManagerVolumeChange, this);
      this.manager.on("suspend", this.onManagerSuspend, this);
      this.manager.on("resume", this.onManagerResume, this);
      if (this.manager.suspended) {
        this.onManagerSuspend();
      }
    },
    pause: function() {
      if (this.source) {
        this.paused = true;
        this.source.pause();
      }
    },
    unpause: function() {
      if (this.source) {
        this.paused = false;
        this.source.play();
      }
    },
    stop: function() {
      if (this.source) {
        this.source.pause();
      }
      this.manager.off("volumechange", this.onManagerVolumeChange, this);
      this.manager.off("suspend", this.onManagerSuspend, this);
      this.manager.off("resume", this.onManagerResume, this);
    },
    setVolume: function(volume) {
      volume = math.clamp(volume, 0, 1);
      this.volume = volume;
      if (this.source) {
        this.source.volume = volume * this.manager.volume;
      }
    },
    setPitch: function(pitch) {
      this.pitch = pitch;
      if (this.source) {
        this.source.playbackRate = pitch;
      }
    },
    getDuration: function() {
      return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
    },
    isPlaying: function() {
      return !this.source.paused;
    }
  });
}

// ../node_modules/playcanvas/build/playcanvas/src/platform/audio/channel3d.js
var MAX_DISTANCE = 1e4;
var Channel3d = class extends Channel {
  constructor(manager, sound, options2) {
    super(manager, sound, options2);
    this.position = new Vec3();
    this.velocity = new Vec3();
    if (hasAudioContext()) {
      this.panner = manager.context.createPanner();
    } else {
      this.maxDistance = MAX_DISTANCE;
      this.minDistance = 1;
      this.rollOffFactor = 1;
      this.distanceModel = DISTANCE_INVERSE;
    }
  }
  getPosition() {
    return this.position;
  }
  setPosition(position3) {
    this.position.copy(position3);
    const panner = this.panner;
    if ("positionX" in panner) {
      panner.positionX.value = position3.x;
      panner.positionY.value = position3.y;
      panner.positionZ.value = position3.z;
    } else if (panner.setPosition) {
      panner.setPosition(position3.x, position3.y, position3.z);
    }
  }
  getVelocity() {
    return this.velocity;
  }
  setVelocity(velocity) {
    this.velocity.copy(velocity);
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(max) {
    this.panner.maxDistance = max;
  }
  getMinDistance() {
    return this.panner.refDistance;
  }
  setMinDistance(min) {
    this.panner.refDistance = min;
  }
  getRollOffFactor() {
    return this.panner.rolloffFactor;
  }
  setRollOffFactor(factor) {
    this.panner.rolloffFactor = factor;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(distanceModel) {
    this.panner.distanceModel = distanceModel;
  }
  _createSource() {
    const context = this.manager.context;
    this.source = context.createBufferSource();
    this.source.buffer = this.sound.buffer;
    this.source.connect(this.panner);
    this.panner.connect(this.gain);
    this.gain.connect(context.destination);
    if (!this.loop) {
      this.source.onended = this.pause.bind(this);
    }
  }
};
if (!hasAudioContext()) {
  let offset = new Vec3();
  const fallOff = function fallOff2(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
    offset = offset.sub2(posOne, posTwo);
    const distance = offset.length();
    if (distance < refDistance) {
      return 1;
    } else if (distance > maxDistance) {
      return 0;
    }
    let result = 0;
    if (distanceModel === DISTANCE_LINEAR) {
      result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
    } else if (distanceModel === DISTANCE_INVERSE) {
      result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
    } else if (distanceModel === DISTANCE_EXPONENTIAL) {
      result = Math.pow(distance / refDistance, -rolloffFactor);
    }
    return math.clamp(result, 0, 1);
  };
  Object.assign(Channel3d.prototype, {
    setPosition: function(position3) {
      this.position.copy(position3);
      if (this.source) {
        const listener = this.manager.listener;
        const lpos = listener.getPosition();
        const factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
        const v = this.getVolume();
        this.source.volume = v * factor;
      }
    },
    getMaxDistance: function() {
      return this.maxDistance;
    },
    setMaxDistance: function(max) {
      this.maxDistance = max;
    },
    getMinDistance: function() {
      return this.minDistance;
    },
    setMinDistance: function(min) {
      this.minDistance = min;
    },
    getRollOffFactor: function() {
      return this.rollOffFactor;
    },
    setRollOffFactor: function(factor) {
      this.rollOffFactor = factor;
    },
    getDistanceModel: function() {
      return this.distanceModel;
    },
    setDistanceModel: function(distanceModel) {
      this.distanceModel = distanceModel;
    }
  });
}

// ../node_modules/playcanvas/build/playcanvas/src/platform/sound/listener.js
var Listener = class {
  constructor(manager) {
    this._manager = void 0;
    this.position = new Vec3();
    this.orientation = new Mat4();
    this._manager = manager;
  }
  getPosition() {
    return this.position;
  }
  setPosition(position3) {
    this.position.copy(position3);
    const listener = this.listener;
    if (listener) {
      if ("positionX" in listener) {
        listener.positionX.value = position3.x;
        listener.positionY.value = position3.y;
        listener.positionZ.value = position3.z;
      } else if (listener.setPosition) {
        listener.setPosition(position3.x, position3.y, position3.z);
      }
    }
  }
  setOrientation(orientation) {
    this.orientation.copy(orientation);
    const listener = this.listener;
    if (listener) {
      const m = orientation.data;
      if ("forwardX" in listener) {
        listener.forwardX.value = -m[8];
        listener.forwardY.value = -m[9];
        listener.forwardZ.value = -m[10];
        listener.upX.value = m[4];
        listener.upY.value = m[5];
        listener.upZ.value = m[6];
      } else if (listener.setOrientation) {
        listener.setOrientation(-m[8], -m[9], -m[10], m[4], m[5], m[6]);
      }
    }
  }
  getOrientation() {
    return this.orientation;
  }
  get listener() {
    const context = this._manager.context;
    return context ? context.listener : null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/sound/manager.js
var CONTEXT_STATE_RUNNING = "running";
var USER_INPUT_EVENTS = ["click", "touchstart", "mousedown"];
var SoundManager = class extends EventHandler {
  constructor() {
    super();
    this._context = null;
    this.AudioContext = typeof AudioContext !== "undefined" && AudioContext || typeof webkitAudioContext !== "undefined" && webkitAudioContext;
    if (!this.AudioContext) ;
    this._unlockHandlerFunc = this._unlockHandler.bind(this);
    this._userSuspended = false;
    this.listener = new Listener(this);
    this._volume = 1;
  }
  set volume(volume) {
    volume = math.clamp(volume, 0, 1);
    this._volume = volume;
    this.fire("volumechange", volume);
  }
  get volume() {
    return this._volume;
  }
  get suspended() {
    return this._userSuspended;
  }
  get context() {
    if (!this._context && this.AudioContext) {
      this._context = new this.AudioContext();
      if (this._context.state !== CONTEXT_STATE_RUNNING) {
        this._registerUnlockListeners();
      }
    }
    return this._context;
  }
  suspend() {
    if (!this._userSuspended) {
      this._userSuspended = true;
      if (this._context && this._context.state === CONTEXT_STATE_RUNNING) {
        this._suspend();
      }
    }
  }
  resume() {
    if (this._userSuspended) {
      this._userSuspended = false;
      if (this._context && this._context.state !== CONTEXT_STATE_RUNNING) {
        this._resume();
      }
    }
  }
  destroy() {
    this.fire("destroy");
    if (this._context) {
      var _this$_context;
      this._removeUnlockListeners();
      (_this$_context = this._context) == null || _this$_context.close();
      this._context = null;
    }
  }
  playSound(sound, options2 = {}) {
    let channel = null;
    if (Channel) {
      channel = new Channel(this, sound, options2);
      channel.play();
    }
    return channel;
  }
  playSound3d(sound, position3, options2 = {}) {
    let channel = null;
    if (Channel3d) {
      channel = new Channel3d(this, sound, options2);
      channel.setPosition(position3);
      if (options2.volume) {
        channel.setVolume(options2.volume);
      }
      if (options2.loop) {
        channel.setLoop(options2.loop);
      }
      if (options2.maxDistance) {
        channel.setMaxDistance(options2.maxDistance);
      }
      if (options2.minDistance) {
        channel.setMinDistance(options2.minDistance);
      }
      if (options2.rollOffFactor) {
        channel.setRollOffFactor(options2.rollOffFactor);
      }
      if (options2.distanceModel) {
        channel.setDistanceModel(options2.distanceModel);
      }
      channel.play();
    }
    return channel;
  }
  _resume() {
    this._context.resume().then(() => {
      const source = this._context.createBufferSource();
      source.buffer = this._context.createBuffer(1, 1, this._context.sampleRate);
      source.connect(this._context.destination);
      source.start(0);
      source.onended = (event) => {
        source.disconnect(0);
        this.fire("resume");
      };
    }, (e) => {
    }).catch((e) => {
    });
  }
  _suspend() {
    this._context.suspend().then(() => {
      this.fire("suspend");
    }, (e) => {
    }).catch((e) => {
    });
  }
  _unlockHandler() {
    this._removeUnlockListeners();
    if (!this._userSuspended && this._context.state !== CONTEXT_STATE_RUNNING) {
      this._resume();
    }
  }
  _registerUnlockListeners() {
    USER_INPUT_EVENTS.forEach((eventName) => {
      window.addEventListener(eventName, this._unlockHandlerFunc, false);
    });
  }
  _removeUnlockListeners() {
    USER_INPUT_EVENTS.forEach((eventName) => {
      window.removeEventListener(eventName, this._unlockHandlerFunc, false);
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/sound/sound.js
var Sound = class {
  constructor(resource) {
    this.audio = void 0;
    this.buffer = void 0;
    if (resource instanceof Audio) {
      this.audio = resource;
    } else {
      this.buffer = resource;
    }
  }
  get duration() {
    let duration = 0;
    if (this.buffer) {
      duration = this.buffer.duration;
    } else if (this.audio) {
      duration = this.audio.duration;
    }
    return duration || 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/platform/sound/instance.js
var STATE_PLAYING = 0;
var STATE_PAUSED = 1;
var STATE_STOPPED = 2;
function capTime(time, duration) {
  return time % duration || 0;
}
var SoundInstance = class extends EventHandler {
  constructor(manager, sound, options2) {
    super();
    this.source = null;
    this._manager = manager;
    this._volume = options2.volume !== void 0 ? math.clamp(Number(options2.volume) || 0, 0, 1) : 1;
    this._pitch = options2.pitch !== void 0 ? Math.max(0.01, Number(options2.pitch) || 0) : 1;
    this._loop = !!(options2.loop !== void 0 ? options2.loop : false);
    this._sound = sound;
    this._state = STATE_STOPPED;
    this._suspended = false;
    this._suspendEndEvent = 0;
    this._suspendInstanceEvents = false;
    this._playWhenLoaded = true;
    this._startTime = Math.max(0, Number(options2.startTime) || 0);
    this._duration = Math.max(0, Number(options2.duration) || 0);
    this._startOffset = null;
    this._onPlayCallback = options2.onPlay;
    this._onPauseCallback = options2.onPause;
    this._onResumeCallback = options2.onResume;
    this._onStopCallback = options2.onStop;
    this._onEndCallback = options2.onEnd;
    if (hasAudioContext()) {
      this._startedAt = 0;
      this._currentTime = 0;
      this._currentOffset = 0;
      this._inputNode = null;
      this._connectorNode = null;
      this._firstNode = null;
      this._lastNode = null;
      this._waitingContextSuspension = false;
      this._initializeNodes();
      this._endedHandler = this._onEnded.bind(this);
    } else {
      this._isReady = false;
      this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
      this._timeUpdateHandler = this._onTimeUpdate.bind(this);
      this._endedHandler = this._onEnded.bind(this);
      this._createSource();
    }
  }
  set currentTime(value) {
    if (value < 0) return;
    if (this._state === STATE_PLAYING) {
      const suspend = this._suspendInstanceEvents;
      this._suspendInstanceEvents = true;
      this.stop();
      this._startOffset = value;
      this.play();
      this._suspendInstanceEvents = suspend;
    } else {
      this._startOffset = value;
      this._currentTime = value;
    }
  }
  get currentTime() {
    if (this._startOffset !== null) {
      return this._startOffset;
    }
    if (this._state === STATE_PAUSED) {
      return this._currentTime;
    }
    if (this._state === STATE_STOPPED || !this.source) {
      return 0;
    }
    this._updateCurrentTime();
    return this._currentTime;
  }
  set duration(value) {
    this._duration = Math.max(0, Number(value) || 0);
    const isPlaying = this._state === STATE_PLAYING;
    this.stop();
    if (isPlaying) {
      this.play();
    }
  }
  get duration() {
    if (!this._sound) {
      return 0;
    }
    if (this._duration) {
      return capTime(this._duration, this._sound.duration);
    }
    return this._sound.duration;
  }
  get isPaused() {
    return this._state === STATE_PAUSED;
  }
  get isPlaying() {
    return this._state === STATE_PLAYING;
  }
  get isStopped() {
    return this._state === STATE_STOPPED;
  }
  get isSuspended() {
    return this._suspended;
  }
  set loop(value) {
    this._loop = !!value;
    if (this.source) {
      this.source.loop = this._loop;
    }
  }
  get loop() {
    return this._loop;
  }
  set pitch(pitch) {
    this._currentOffset = this.currentTime;
    this._startedAt = this._manager.context.currentTime;
    this._pitch = Math.max(Number(pitch) || 0, 0.01);
    if (this.source) {
      this.source.playbackRate.value = this._pitch;
    }
  }
  get pitch() {
    return this._pitch;
  }
  set sound(value) {
    this._sound = value;
    if (this._state !== STATE_STOPPED) {
      this.stop();
    } else {
      this._createSource();
    }
  }
  get sound() {
    return this._sound;
  }
  set startTime(value) {
    this._startTime = Math.max(0, Number(value) || 0);
    const isPlaying = this._state === STATE_PLAYING;
    this.stop();
    if (isPlaying) {
      this.play();
    }
  }
  get startTime() {
    return this._startTime;
  }
  set volume(volume) {
    volume = math.clamp(volume, 0, 1);
    this._volume = volume;
    if (this.gain) {
      this.gain.gain.value = volume * this._manager.volume;
    }
  }
  get volume() {
    return this._volume;
  }
  _onPlay() {
    this.fire("play");
    if (this._onPlayCallback) {
      this._onPlayCallback(this);
    }
  }
  _onPause() {
    this.fire("pause");
    if (this._onPauseCallback) {
      this._onPauseCallback(this);
    }
  }
  _onResume() {
    this.fire("resume");
    if (this._onResumeCallback) {
      this._onResumeCallback(this);
    }
  }
  _onStop() {
    this.fire("stop");
    if (this._onStopCallback) {
      this._onStopCallback(this);
    }
  }
  _onEnded() {
    if (this._suspendEndEvent > 0) {
      this._suspendEndEvent--;
      return;
    }
    this.fire("end");
    if (this._onEndCallback) {
      this._onEndCallback(this);
    }
    this.stop();
  }
  _onManagerVolumeChange() {
    this.volume = this._volume;
  }
  _onManagerSuspend() {
    if (this._state === STATE_PLAYING && !this._suspended) {
      this._suspended = true;
      this.pause();
    }
  }
  _onManagerResume() {
    if (this._suspended) {
      this._suspended = false;
      this.resume();
    }
  }
  _initializeNodes() {
    this.gain = this._manager.context.createGain();
    this._inputNode = this.gain;
    this._connectorNode = this.gain;
    this._connectorNode.connect(this._manager.context.destination);
  }
  play() {
    if (this._state !== STATE_STOPPED) {
      this.stop();
    }
    this._state = STATE_PLAYING;
    this._playWhenLoaded = false;
    if (this._waitingContextSuspension) {
      return false;
    }
    if (this._manager.suspended) {
      this._manager.once("resume", this._playAudioImmediate, this);
      this._waitingContextSuspension = true;
      return false;
    }
    this._playAudioImmediate();
    return true;
  }
  _playAudioImmediate() {
    this._waitingContextSuspension = false;
    if (this._state !== STATE_PLAYING) {
      return;
    }
    if (!this.source) {
      this._createSource();
    }
    let offset = capTime(this._startOffset, this.duration);
    offset = capTime(this._startTime + offset, this._sound.duration);
    this._startOffset = null;
    if (this._duration) {
      this.source.start(0, offset, this._duration);
    } else {
      this.source.start(0, offset);
    }
    this._startedAt = this._manager.context.currentTime;
    this._currentTime = 0;
    this._currentOffset = offset;
    this.volume = this._volume;
    this.loop = this._loop;
    this.pitch = this._pitch;
    this._manager.on("volumechange", this._onManagerVolumeChange, this);
    this._manager.on("suspend", this._onManagerSuspend, this);
    this._manager.on("resume", this._onManagerResume, this);
    this._manager.on("destroy", this._onManagerDestroy, this);
    if (!this._suspendInstanceEvents) {
      this._onPlay();
    }
  }
  pause() {
    this._playWhenLoaded = false;
    if (this._state !== STATE_PLAYING) {
      return false;
    }
    this._state = STATE_PAUSED;
    if (this._waitingContextSuspension) {
      return true;
    }
    this._updateCurrentTime();
    this._suspendEndEvent++;
    this.source.stop(0);
    this.source = null;
    this._startOffset = null;
    if (!this._suspendInstanceEvents) {
      this._onPause();
    }
    return true;
  }
  resume() {
    if (this._state !== STATE_PAUSED) {
      return false;
    }
    let offset = this.currentTime;
    this._state = STATE_PLAYING;
    if (this._waitingContextSuspension) {
      return true;
    }
    if (!this.source) {
      this._createSource();
    }
    if (this._startOffset !== null) {
      offset = capTime(this._startOffset, this.duration);
      offset = capTime(this._startTime + offset, this._sound.duration);
      this._startOffset = null;
    }
    if (this._duration) {
      this.source.start(0, offset, this._duration);
    } else {
      this.source.start(0, offset);
    }
    this._startedAt = this._manager.context.currentTime;
    this._currentOffset = offset;
    this.volume = this._volume;
    this.loop = this._loop;
    this.pitch = this._pitch;
    this._playWhenLoaded = false;
    if (!this._suspendInstanceEvents) {
      this._onResume();
    }
    return true;
  }
  stop() {
    this._playWhenLoaded = false;
    if (this._state === STATE_STOPPED) {
      return false;
    }
    const wasPlaying = this._state === STATE_PLAYING;
    this._state = STATE_STOPPED;
    if (this._waitingContextSuspension) {
      return true;
    }
    this._manager.off("volumechange", this._onManagerVolumeChange, this);
    this._manager.off("suspend", this._onManagerSuspend, this);
    this._manager.off("resume", this._onManagerResume, this);
    this._manager.off("destroy", this._onManagerDestroy, this);
    this._startedAt = 0;
    this._currentTime = 0;
    this._currentOffset = 0;
    this._startOffset = null;
    this._suspendEndEvent++;
    if (wasPlaying && this.source) {
      this.source.stop(0);
    }
    this.source = null;
    if (!this._suspendInstanceEvents) {
      this._onStop();
    }
    return true;
  }
  setExternalNodes(firstNode, lastNode) {
    if (!firstNode) {
      console.error("The firstNode must be a valid Audio Node");
      return;
    }
    if (!lastNode) {
      lastNode = firstNode;
    }
    const speakers = this._manager.context.destination;
    if (this._firstNode !== firstNode) {
      if (this._firstNode) {
        this._connectorNode.disconnect(this._firstNode);
      } else {
        this._connectorNode.disconnect(speakers);
      }
      this._firstNode = firstNode;
      this._connectorNode.connect(firstNode);
    }
    if (this._lastNode !== lastNode) {
      if (this._lastNode) {
        this._lastNode.disconnect(speakers);
      }
      this._lastNode = lastNode;
      this._lastNode.connect(speakers);
    }
  }
  clearExternalNodes() {
    const speakers = this._manager.context.destination;
    if (this._firstNode) {
      this._connectorNode.disconnect(this._firstNode);
      this._firstNode = null;
    }
    if (this._lastNode) {
      this._lastNode.disconnect(speakers);
      this._lastNode = null;
    }
    this._connectorNode.connect(speakers);
  }
  getExternalNodes() {
    return [this._firstNode, this._lastNode];
  }
  _createSource() {
    if (!this._sound) {
      return null;
    }
    const context = this._manager.context;
    if (this._sound.buffer) {
      this.source = context.createBufferSource();
      this.source.buffer = this._sound.buffer;
      this.source.connect(this._inputNode);
      this.source.onended = this._endedHandler;
      this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);
      if (this._duration) {
        this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
      }
    }
    return this.source;
  }
  _updateCurrentTime() {
    this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
  }
  _onManagerDestroy() {
    if (this.source && this._state === STATE_PLAYING) {
      this.source.stop(0);
      this.source = null;
    }
  }
};
SoundInstance.EVENT_PLAY = "play";
SoundInstance.EVENT_PAUSE = "pause";
SoundInstance.EVENT_RESUME = "resume";
SoundInstance.EVENT_STOP = "stop";
SoundInstance.EVENT_END = "end";
if (!hasAudioContext()) {
  Object.assign(SoundInstance.prototype, {
    play: function() {
      if (this._state !== STATE_STOPPED) {
        this.stop();
      }
      if (!this.source) {
        if (!this._createSource()) {
          return false;
        }
      }
      this.volume = this._volume;
      this.pitch = this._pitch;
      this.loop = this._loop;
      this.source.play();
      this._state = STATE_PLAYING;
      this._playWhenLoaded = false;
      this._manager.on("volumechange", this._onManagerVolumeChange, this);
      this._manager.on("suspend", this._onManagerSuspend, this);
      this._manager.on("resume", this._onManagerResume, this);
      this._manager.on("destroy", this._onManagerDestroy, this);
      if (this._manager.suspended) {
        this._onManagerSuspend();
      }
      if (!this._suspendInstanceEvents) {
        this._onPlay();
      }
      return true;
    },
    pause: function() {
      if (!this.source || this._state !== STATE_PLAYING) {
        return false;
      }
      this._suspendEndEvent++;
      this.source.pause();
      this._playWhenLoaded = false;
      this._state = STATE_PAUSED;
      this._startOffset = null;
      if (!this._suspendInstanceEvents) {
        this._onPause();
      }
      return true;
    },
    resume: function() {
      if (!this.source || this._state !== STATE_PAUSED) {
        return false;
      }
      this._state = STATE_PLAYING;
      this._playWhenLoaded = false;
      if (this.source.paused) {
        this.source.play();
        if (!this._suspendInstanceEvents) {
          this._onResume();
        }
      }
      return true;
    },
    stop: function() {
      if (!this.source || this._state === STATE_STOPPED) {
        return false;
      }
      this._manager.off("volumechange", this._onManagerVolumeChange, this);
      this._manager.off("suspend", this._onManagerSuspend, this);
      this._manager.off("resume", this._onManagerResume, this);
      this._manager.off("destroy", this._onManagerDestroy, this);
      this._suspendEndEvent++;
      this.source.pause();
      this._playWhenLoaded = false;
      this._state = STATE_STOPPED;
      this._startOffset = null;
      if (!this._suspendInstanceEvents) {
        this._onStop();
      }
      return true;
    },
    setExternalNodes: function() {
    },
    clearExternalNodes: function() {
    },
    getExternalNodes: function() {
      return [null, null];
    },
    _onLoadedMetadata: function() {
      this.source.removeEventListener("loadedmetadata", this._loadedMetadataHandler);
      this._isReady = true;
      let offset = capTime(this._startOffset, this.duration);
      offset = capTime(this._startTime + offset, this._sound.duration);
      this._startOffset = null;
      this.source.currentTime = offset;
    },
    _createSource: function() {
      if (this._sound && this._sound.audio) {
        this._isReady = false;
        this.source = this._sound.audio.cloneNode(true);
        this.source.addEventListener("loadedmetadata", this._loadedMetadataHandler);
        this.source.addEventListener("timeupdate", this._timeUpdateHandler);
        this.source.onended = this._endedHandler;
      }
      return this.source;
    },
    _onTimeUpdate: function() {
      if (!this._duration) {
        return;
      }
      if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
        if (this.loop) {
          this.source.currentTime = capTime(this._startTime, this.source.duration);
        } else {
          this.source.removeEventListener("timeupdate", this._timeUpdateHandler);
          this.source.pause();
          this._onEnded();
        }
      }
    },
    _onManagerDestroy: function() {
      if (this.source) {
        this.source.pause();
      }
    }
  });
  Object.defineProperty(SoundInstance.prototype, "volume", {
    get: function() {
      return this._volume;
    },
    set: function(volume) {
      volume = math.clamp(volume, 0, 1);
      this._volume = volume;
      if (this.source) {
        this.source.volume = volume * this._manager.volume;
      }
    }
  });
  Object.defineProperty(SoundInstance.prototype, "pitch", {
    get: function() {
      return this._pitch;
    },
    set: function(pitch) {
      this._pitch = Math.max(Number(pitch) || 0, 0.01);
      if (this.source) {
        this.source.playbackRate = this._pitch;
      }
    }
  });
  Object.defineProperty(SoundInstance.prototype, "sound", {
    get: function() {
      return this._sound;
    },
    set: function(value) {
      this.stop();
      this._sound = value;
    }
  });
  Object.defineProperty(SoundInstance.prototype, "currentTime", {
    get: function() {
      if (this._startOffset !== null) {
        return this._startOffset;
      }
      if (this._state === STATE_STOPPED || !this.source) {
        return 0;
      }
      return this.source.currentTime - this._startTime;
    },
    set: function(value) {
      if (value < 0) return;
      this._startOffset = value;
      if (this.source && this._isReady) {
        this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
        this._startOffset = null;
      }
    }
  });
}

// ../node_modules/playcanvas/build/playcanvas/src/platform/sound/instance3d.js
var MAX_DISTANCE2 = 1e4;
var SoundInstance3d = class extends SoundInstance {
  constructor(manager, sound, options2 = {}) {
    super(manager, sound, options2);
    this._position = new Vec3();
    this._velocity = new Vec3();
    if (options2.position) {
      this.position = options2.position;
    }
    this.maxDistance = options2.maxDistance !== void 0 ? Number(options2.maxDistance) : MAX_DISTANCE2;
    this.refDistance = options2.refDistance !== void 0 ? Number(options2.refDistance) : 1;
    this.rollOffFactor = options2.rollOffFactor !== void 0 ? Number(options2.rollOffFactor) : 1;
    this.distanceModel = options2.distanceModel !== void 0 ? options2.distanceModel : DISTANCE_LINEAR;
  }
  _initializeNodes() {
    this.gain = this._manager.context.createGain();
    this.panner = this._manager.context.createPanner();
    this.panner.connect(this.gain);
    this._inputNode = this.panner;
    this._connectorNode = this.gain;
    this._connectorNode.connect(this._manager.context.destination);
  }
  set position(value) {
    this._position.copy(value);
    const panner = this.panner;
    if ("positionX" in panner) {
      panner.positionX.value = value.x;
      panner.positionY.value = value.y;
      panner.positionZ.value = value.z;
    } else if (panner.setPosition) {
      panner.setPosition(value.x, value.y, value.z);
    }
  }
  get position() {
    return this._position;
  }
  set velocity(velocity) {
    this._velocity.copy(velocity);
  }
  get velocity() {
    return this._velocity;
  }
  set maxDistance(value) {
    this.panner.maxDistance = value;
  }
  get maxDistance() {
    return this.panner.maxDistance;
  }
  set refDistance(value) {
    this.panner.refDistance = value;
  }
  get refDistance() {
    return this.panner.refDistance;
  }
  set rollOffFactor(value) {
    this.panner.rolloffFactor = value;
  }
  get rollOffFactor() {
    return this.panner.rolloffFactor;
  }
  set distanceModel(value) {
    this.panner.distanceModel = value;
  }
  get distanceModel() {
    return this.panner.distanceModel;
  }
};
if (!hasAudioContext()) {
  let offset = new Vec3();
  const fallOff = function fallOff2(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
    offset = offset.sub2(posOne, posTwo);
    const distance = offset.length();
    if (distance < refDistance) {
      return 1;
    } else if (distance > maxDistance) {
      return 0;
    }
    let result = 0;
    if (distanceModel === DISTANCE_LINEAR) {
      result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
    } else if (distanceModel === DISTANCE_INVERSE) {
      result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
    } else if (distanceModel === DISTANCE_EXPONENTIAL) {
      result = Math.pow(distance / refDistance, -rollOffFactor);
    }
    return math.clamp(result, 0, 1);
  };
  Object.defineProperty(SoundInstance3d.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(position3) {
      this._position.copy(position3);
      if (this.source) {
        const listener = this._manager.listener;
        const lpos = listener.getPosition();
        const factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
        const v = this.volume;
        this.source.volume = v * factor * this._manager.volume;
      }
    }
  });
  Object.defineProperty(SoundInstance3d.prototype, "maxDistance", {
    get: function() {
      return this._maxDistance;
    },
    set: function(value) {
      this._maxDistance = value;
    }
  });
  Object.defineProperty(SoundInstance3d.prototype, "refDistance", {
    get: function() {
      return this._refDistance;
    },
    set: function(value) {
      this._refDistance = value;
    }
  });
  Object.defineProperty(SoundInstance3d.prototype, "rollOffFactor", {
    get: function() {
      return this._rollOffFactor;
    },
    set: function(value) {
      this._rollOffFactor = value;
    }
  });
  Object.defineProperty(SoundInstance3d.prototype, "distanceModel", {
    get: function() {
      return this._distanceModel;
    },
    set: function(value) {
      this._distanceModel = value;
    }
  });
}

// ../node_modules/playcanvas/build/playcanvas/src/scene/constants.js
var BLEND_SUBTRACTIVE = 0;
var BLEND_ADDITIVE = 1;
var BLEND_NORMAL = 2;
var BLEND_NONE = 3;
var BLEND_PREMULTIPLIED = 4;
var BLEND_MULTIPLICATIVE = 5;
var BLEND_ADDITIVEALPHA = 6;
var BLEND_MULTIPLICATIVE2X = 7;
var BLEND_SCREEN = 8;
var BLEND_MIN = 9;
var BLEND_MAX = 10;
var FOG_NONE = "none";
var FOG_LINEAR = "linear";
var FOG_EXP = "exp";
var FOG_EXP2 = "exp2";
var FRESNEL_NONE = 0;
var FRESNEL_SCHLICK = 2;
var LAYER_HUD = 0;
var LAYER_GIZMO = 1;
var LAYER_FX = 2;
var LAYER_WORLD = 15;
var LAYERID_WORLD = 0;
var LAYERID_DEPTH = 1;
var LAYERID_SKYBOX = 2;
var LAYERID_IMMEDIATE = 3;
var LAYERID_UI = 4;
var LIGHTTYPE_DIRECTIONAL = 0;
var LIGHTTYPE_OMNI = 1;
var LIGHTTYPE_POINT = LIGHTTYPE_OMNI;
var LIGHTTYPE_SPOT = 2;
var LIGHTTYPE_COUNT = 3;
var LIGHTSHAPE_PUNCTUAL = 0;
var LIGHTSHAPE_RECT = 1;
var LIGHTSHAPE_DISK = 2;
var LIGHTSHAPE_SPHERE = 3;
var LIGHTFALLOFF_LINEAR = 0;
var LIGHTFALLOFF_INVERSESQUARED = 1;
var SHADOW_PCF3 = 0;
var SHADOW_DEPTH = 0;
var SHADOW_VSM8 = 1;
var SHADOW_VSM16 = 2;
var SHADOW_VSM32 = 3;
var SHADOW_PCF5 = 4;
var SHADOW_PCF1 = 5;
var SHADOW_PCSS = 6;
var shadowTypeToString = {};
shadowTypeToString[SHADOW_PCF3] = "PCF3";
shadowTypeToString[SHADOW_VSM8] = "VSM8";
shadowTypeToString[SHADOW_VSM16] = "VSM16";
shadowTypeToString[SHADOW_VSM32] = "VSM32";
shadowTypeToString[SHADOW_PCF5] = "PCF5";
shadowTypeToString[SHADOW_PCF1] = "PCF1";
shadowTypeToString[SHADOW_PCSS] = "PCSS";
var BLUR_BOX = 0;
var BLUR_GAUSSIAN = 1;
var PARTICLESORT_NONE = 0;
var PARTICLESORT_DISTANCE = 1;
var PARTICLESORT_NEWER_FIRST = 2;
var PARTICLESORT_OLDER_FIRST = 3;
var PARTICLEMODE_GPU = 0;
var PARTICLEMODE_CPU = 1;
var EMITTERSHAPE_BOX = 0;
var EMITTERSHAPE_SPHERE = 1;
var PARTICLEORIENTATION_SCREEN = 0;
var PARTICLEORIENTATION_WORLD = 1;
var PARTICLEORIENTATION_EMITTER = 2;
var PROJECTION_PERSPECTIVE = 0;
var PROJECTION_ORTHOGRAPHIC = 1;
var RENDERSTYLE_SOLID = 0;
var RENDERSTYLE_WIREFRAME = 1;
var RENDERSTYLE_POINTS = 2;
var CUBEPROJ_NONE = 0;
var CUBEPROJ_BOX = 1;
var DETAILMODE_MUL = "mul";
var DETAILMODE_ADD = "add";
var DETAILMODE_SCREEN = "screen";
var DETAILMODE_OVERLAY = "overlay";
var DETAILMODE_MIN = "min";
var DETAILMODE_MAX = "max";
var GAMMA_NONE = 0;
var GAMMA_SRGB = 1;
var TONEMAP_LINEAR = 0;
var TONEMAP_FILMIC = 1;
var TONEMAP_HEJL = 2;
var TONEMAP_ACES = 3;
var TONEMAP_ACES2 = 4;
var TONEMAP_NEUTRAL = 5;
var TONEMAP_NONE = 6;
var SPECOCC_NONE = 0;
var SPECOCC_AO = 1;
var SPECOCC_GLOSSDEPENDENT = 2;
var SHADERDEF_NOSHADOW = 1;
var SHADERDEF_SKIN = 2;
var SHADERDEF_UV0 = 4;
var SHADERDEF_UV1 = 8;
var SHADERDEF_VCOLOR = 16;
var SHADERDEF_INSTANCING = 32;
var SHADERDEF_LM = 64;
var SHADERDEF_DIRLM = 128;
var SHADERDEF_SCREENSPACE = 256;
var SHADERDEF_TANGENTS = 512;
var SHADERDEF_MORPH_POSITION = 1024;
var SHADERDEF_MORPH_NORMAL = 2048;
var SHADERDEF_LMAMBIENT = 4096;
var SHADERDEF_MORPH_TEXTURE_BASED_INT = 8192;
var SHADERDEF_BATCH = 16384;
var SHADOWUPDATE_NONE = 0;
var SHADOWUPDATE_THISFRAME = 1;
var SHADOWUPDATE_REALTIME = 2;
var SORTKEY_FORWARD = 0;
var SORTKEY_DEPTH = 1;
var MASK_AFFECT_DYNAMIC = 1;
var MASK_AFFECT_LIGHTMAPPED = 2;
var MASK_BAKE = 4;
var SHADER_FORWARD = 0;
var SHADER_PREPASS_VELOCITY = 1;
var SHADER_DEPTH = 2;
var SHADER_PICK = 3;
var SHADER_SHADOW = 4;
var SHADERPASS_FORWARD = "forward";
var SHADERPASS_ALBEDO = "debug_albedo";
var SHADERPASS_WORLDNORMAL = "debug_world_normal";
var SHADERPASS_OPACITY = "debug_opacity";
var SHADERPASS_SPECULARITY = "debug_specularity";
var SHADERPASS_GLOSS = "debug_gloss";
var SHADERPASS_METALNESS = "debug_metalness";
var SHADERPASS_AO = "debug_ao";
var SHADERPASS_EMISSION = "debug_emission";
var SHADERPASS_LIGHTING = "debug_lighting";
var SHADERPASS_UV0 = "debug_uv0";
var SPRITE_RENDERMODE_SIMPLE = 0;
var SPRITE_RENDERMODE_SLICED = 1;
var SPRITE_RENDERMODE_TILED = 2;
var BAKE_COLOR = 0;
var BAKE_COLORDIR = 1;
var VIEW_CENTER = 0;
var VIEW_LEFT = 1;
var VIEW_RIGHT = 2;
var SORTMODE_NONE = 0;
var SORTMODE_MANUAL = 1;
var SORTMODE_MATERIALMESH = 2;
var SORTMODE_BACK2FRONT = 3;
var SORTMODE_FRONT2BACK = 4;
var SORTMODE_CUSTOM = 5;
var ASPECT_AUTO = 0;
var ASPECT_MANUAL = 1;
var ORIENTATION_HORIZONTAL = 0;
var ORIENTATION_VERTICAL = 1;
var SKYTYPE_INFINITE = "infinite";
var SKYTYPE_BOX = "box";
var SKYTYPE_DOME = "dome";
var DITHER_NONE = "none";
var DITHER_BAYER8 = "bayer8";
var DITHER_BLUENOISE = "bluenoise";
var DITHER_IGNNOISE = "ignnoise";

// ../node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-processor-options.js
var ShaderProcessorOptions = class {
  constructor(viewUniformFormat, viewBindGroupFormat, vertexFormat) {
    this.uniformFormats = [];
    this.bindGroupFormats = [];
    this.vertexFormat = void 0;
    this.uniformFormats[BINDGROUP_VIEW] = viewUniformFormat;
    this.bindGroupFormats[BINDGROUP_VIEW] = viewBindGroupFormat;
    this.vertexFormat = vertexFormat;
  }
  hasUniform(name) {
    for (let i = 0; i < this.uniformFormats.length; i++) {
      const uniformFormat = this.uniformFormats[i];
      if (uniformFormat != null && uniformFormat.get(name)) {
        return true;
      }
    }
    return false;
  }
  hasTexture(name) {
    for (let i = 0; i < this.bindGroupFormats.length; i++) {
      const groupFormat = this.bindGroupFormats[i];
      if (groupFormat != null && groupFormat.getTexture(name)) {
        return true;
      }
    }
    return false;
  }
  getVertexElement(semantic) {
    var _this$vertexFormat;
    return (_this$vertexFormat = this.vertexFormat) == null ? void 0 : _this$vertexFormat.elements.find((element) => element.name === semantic);
  }
  generateKey(device) {
    let key = JSON.stringify(this.uniformFormats) + JSON.stringify(this.bindGroupFormats);
    if (device.isWebGPU) {
      var _this$vertexFormat2;
      key += (_this$vertexFormat2 = this.vertexFormat) == null ? void 0 : _this$vertexFormat2.shaderProcessingHashString;
    }
    return key;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/alphaTest.js
var alphaTestPS = `
uniform float alpha_ref;
void alphaTest(float a) {
	if (a < alpha_ref) discard;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/ambientConstant.js
var ambientConstantPS = `
void addAmbient(vec3 worldNormal) {
	dDiffuseLight += light_globalAmbient;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/ambientEnv.js
var ambientEnvPS = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
void addAmbient(vec3 worldNormal) {
	vec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));
	vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);
	vec4 raw = texture2D(texture_envAtlas, uv);
	vec3 linear = $DECODE(raw);
	dDiffuseLight += processEnvironment(linear);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/ambientSH.js
var ambientSHPS = `
uniform vec3 ambientSH[9];
void addAmbient(vec3 worldNormal) {
	vec3 n = cubeMapRotate(worldNormal);
	vec3 color =
		ambientSH[0] +
		ambientSH[1] * n.x +
		ambientSH[2] * n.y +
		ambientSH[3] * n.z +
		ambientSH[4] * n.x * n.z +
		ambientSH[5] * n.z * n.y +
		ambientSH[6] * n.y * n.x +
		ambientSH[7] * (3.0 * n.z * n.z - 1.0) +
		ambientSH[8] * (n.x * n.x - n.y * n.y);
	dDiffuseLight += processEnvironment(max(color, vec3(0.0)));
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/ao.js
var aoPS = `
uniform float material_aoIntensity;
void getAO() {
	dAo = 1.0;
	#ifdef MAPTEXTURE
	float aoBase = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	dAo *= addAoDetail(aoBase);
	#endif
	#ifdef MAPVERTEX
	dAo *= saturate(vVertexColor.$VC);
	#endif
	dAo = mix(1.0, dAo, material_aoIntensity);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/aoDetailMap.js
var aoDetailMapPS = `
float addAoDetail(float ao) {
#ifdef MAPTEXTURE
	float aoDetail = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	return detailMode_$DETAILMODE(vec3(ao), vec3(aoDetail)).r;
#else
	return ao;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoDiffuseOcc.js
var aoDiffuseOccPS = `
void occludeDiffuse(float ao) {
	dDiffuseLight *= ao;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoSpecOcc.js
var aoSpecOccPS = `
uniform float material_occludeSpecularIntensity;
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	float specPow = exp2(gloss * 11.0);
	float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);
	specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);
	dSpecularLight *= specOcc;
	dReflection *= specOcc;
	
#ifdef LIT_SHEEN
	sSpecularLight *= specOcc;
	sReflection *= specOcc;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoSpecOccConst.js
var aoSpecOccConstPS = `
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	float specPow = exp2(gloss * 11.0);
	float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);
	dSpecularLight *= specOcc;
	dReflection *= specOcc;
	
#ifdef LIT_SHEEN
	sSpecularLight *= specOcc;
	sReflection *= specOcc;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoSpecOccConstSimple.js
var aoSpecOccConstSimplePS = `
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	dSpecularLight *= ao;
	dReflection *= ao;
#ifdef LIT_SHEEN
	sSpecularLight *= ao;
	sReflection *= ao;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoSpecOccSimple.js
var aoSpecOccSimplePS = `
uniform float material_occludeSpecularIntensity;
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	float specOcc = mix(1.0, ao, material_occludeSpecularIntensity);
	dSpecularLight *= specOcc;
	dReflection *= specOcc;
#ifdef LIT_SHEEN
	sSpecularLight *= specOcc;
	sReflection *= specOcc;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/base.js
var basePS = `
uniform vec3 view_position;
uniform vec3 light_globalAmbient;
float square(float x) {
	return x*x;
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec3 saturate(vec3 x) {
	return clamp(x, vec3(0.0), vec3(1.0));
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/base.js
var baseVS = `
attribute vec4 vertex_tangent;
attribute vec2 vertex_texCoord0;
attribute vec2 vertex_texCoord1;
attribute vec4 vertex_color;
vec3 dPositionW;
mat4 dModelMatrix;
#include "transformCore"
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/baseNineSliced.js
var baseNineSlicedPS = `
#define NINESLICED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
vec2 nineSlicedUv;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/baseNineSliced.js
var baseNineSlicedVS = `
#define NINESLICED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/baseNineSlicedTiled.js
var baseNineSlicedTiledPS = `
#define NINESLICED
#define NINESLICETILED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
vec2 nineSlicedUv;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/bayer.js
var bayerPS = `
float bayer2(vec2 p) {
	return mod(2.0 * p.y + p.x + 1.0, 4.0);
}
float bayer4(vec2 p) {
	vec2 p1 = mod(p, 2.0);
	vec2 p2 = floor(0.5 * mod(p, 4.0));
	return 4.0 * bayer2(p1) + bayer2(p2);
}
float bayer8(vec2 p) {
	vec2 p1 = mod(p, 2.0);
	vec2 p2 = floor(0.5 * mod(p, 4.0));
	vec2 p4 = floor(0.25 * mod(p, 8.0));
	return 4.0 * (4.0 * bayer2(p1) + bayer2(p2)) + bayer2(p4);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/blurVSM.js
var blurVSMPS = `
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
#ifdef GAUSS
uniform float weight[SAMPLES];
#endif
#ifdef PACKED
float decodeFloatRG(vec2 rg) {
	return rg.y*(1.0/255.0) + rg.x;
}
vec2 encodeFloatRG( float v ) {
	vec2 enc = vec2(1.0, 255.0) * v;
	enc = fract(enc);
	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
	return enc;
}
#endif
void main(void) {
	vec3 moments = vec3(0.0);
	vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);
	for (int i=0; i<SAMPLES; i++) {
		vec4 c = texture2D(source, uv + pixelOffset * float(i));
		#ifdef PACKED
		c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));
		#endif
		#ifdef GAUSS
		moments += c.xyz * weight[i];
		#else
		moments += c.xyz;
		#endif
	}
	#ifndef GAUSS
	moments /= float(SAMPLES);
	#endif
	#ifdef PACKED
	gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));
	#else
	gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);
	#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/clearCoat.js
var clearCoatPS = `
#ifdef MAPFLOAT
uniform float material_clearCoat;
#endif
void getClearCoat() {
	ccSpecularity = 1.0;
	#ifdef MAPFLOAT
	ccSpecularity *= material_clearCoat;
	#endif
	#ifdef MAPTEXTURE
	ccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	ccSpecularity *= saturate(vVertexColor.$VC);
	#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/clearCoatGloss.js
var clearCoatGlossPS = `
#ifdef MAPFLOAT
uniform float material_clearCoatGloss;
#endif
void getClearCoatGlossiness() {
	ccGlossiness = 1.0;
	#ifdef MAPFLOAT
	ccGlossiness *= material_clearCoatGloss;
	#endif
	#ifdef MAPTEXTURE
	ccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	ccGlossiness *= saturate(vVertexColor.$VC);
	#endif
	#ifdef MAPINVERT
	ccGlossiness = 1.0 - ccGlossiness;
	#endif
	ccGlossiness += 0.0000001;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/clearCoatNormal.js
var clearCoatNormalPS = `
#ifdef MAPTEXTURE
uniform float material_clearCoatBumpiness;
#endif
void getClearCoatNormal() {
#ifdef MAPTEXTURE
	vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);
	ccNormalW = normalize(dTBN * normalMap);
#else
	ccNormalW = dVertexNormalW;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/clusteredLightUtils.js
var clusteredLightUtilsPS = `
vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)
{
	vec3 vAbs = abs(dir);
	float ma;
	vec2 uv;
	if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {
		faceIndex = dir.z < 0.0 ? 5.0 : 4.0;
		ma = 0.5 / vAbs.z;
		uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);
		tileOffset.x = 2.0;
		tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;
	} else if(vAbs.y >= vAbs.x) {
		faceIndex = dir.y < 0.0 ? 3.0 : 2.0;
		ma = 0.5 / vAbs.y;
		uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);
		tileOffset.x = 1.0;
		tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;
	} else {
		faceIndex = dir.x < 0.0 ? 1.0 : 0.0;
		ma = 0.5 / vAbs.x;
		uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);
		tileOffset.x = 0.0;
		tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;
	}
	return uv * ma + 0.5;
}
vec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {
	float faceIndex;
	vec2 tileOffset;
	vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);
	float atlasFaceSize = omniAtlasViewport.z;
	float tileSize = shadowTextureResolution * atlasFaceSize;
	float offset = shadowEdgePixels / tileSize;
	uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);
	uv *= atlasFaceSize;
	uv += tileOffset * atlasFaceSize;
	uv += omniAtlasViewport.xy;
	return uv;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/clusteredLightCookies.js
var clusteredLightCookiesPS = `
vec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {
	vec4 pixel = mix(vec4(1.0), texture2DLodEXT(tex, uv, 0.0), intensity);
	return isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));
}
vec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {
	vec4 projPos = transform * vec4(worldPosition, 1.0);
	return _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, isRgb, cookieChannel);
}
vec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);
	return _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, isRgb, cookieChannel);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/clusteredLightShadows.js
var clusteredLightShadowsPS = `
void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {
	vec4 projPos = shadowMatrix * vec4(wPos, 1.0);
	projPos.xyz /= projPos.w;
	dShadowCoord = projPos.xyz;
}
void getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {
	vec3 wPos = vPositionW + normal * shadowParams.y;
	_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);
}
vec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
	float distScale = length(lightDir);
	vec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
	vec3 dir = wPos - lightPos;
	return dir;
}
#if defined(CLUSTER_SHADOW_TYPE_PCF1)
float getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
	float shadowTextureResolution = shadowParams.x;
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
	return textureShadow(shadowMap, vec3(uv, shadowZ));
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF3)
float getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
	float shadowTextureResolution = shadowParams.x;
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
	vec3 shadowCoord = vec3(uv, shadowZ);
	return getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF5)
float getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
	float shadowTextureResolution = shadowParams.x;
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
	vec3 shadowCoord = vec3(uv, shadowZ);
	return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF1)
float getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF3)
float getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF5)
float getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
}
#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/clusteredLight.js
var clusteredLightPS = `
uniform highp sampler2D clusterWorldTexture;
uniform highp sampler2D lightsTexture8;
uniform highp sampler2D lightsTextureFloat;
#if defined(CLUSTER_COOKIES)
	#define CLUSTER_COOKIES_OR_SHADOWS
#endif
#if defined(CLUSTER_SHADOWS)
	#define CLUSTER_COOKIES_OR_SHADOWS
#endif
#ifdef CLUSTER_SHADOWS
	uniform sampler2DShadow shadowAtlasTexture;
#endif
#ifdef CLUSTER_COOKIES
	uniform sampler2D cookieAtlasTexture;
#endif
uniform int clusterMaxCells;
uniform float clusterSkip;
uniform vec3 clusterCellsCountByBoundsSize;
uniform vec3 clusterTextureSize;
uniform vec3 clusterBoundsMin;
uniform vec3 clusterBoundsDelta;
uniform vec3 clusterCellsDot;
uniform vec3 clusterCellsMax;
uniform vec2 clusterCompressionLimit0;
uniform vec2 shadowAtlasParams;
struct ClusterLightData {
	vec3 halfWidth;
	float lightType;
	vec3 halfHeight;
	int lightIndex;
	vec3 position;
	float shape;
	vec3 direction;
	float falloffMode;
	vec3 color;
	float shadowIntensity;
	vec3 omniAtlasViewport;
	float range;
	vec4 cookieChannelMask;
	float shadowBias;
	float shadowNormalBias;
	float innerConeAngleCos;
	float outerConeAngleCos;
	float cookie;
	float cookieRgb;
	float cookieIntensity;
	float mask;
};
mat4 lightProjectionMatrix;
#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )
#define isClusteredLightCookie(light) (light.cookie > 0.5 )
#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )
#define isClusteredLightSpot(light) ( light.lightType > 0.5 )
#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )
#define isClusteredLightArea(light) ( light.shape > 0.1 )
#define isClusteredLightRect(light) ( light.shape < 0.3 )
#define isClusteredLightDisk(light) ( light.shape < 0.6 )
#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS
	#define acceptLightMask(light) ( light.mask < 0.75)
#else
	#define acceptLightMask(light) ( light.mask > 0.25)
#endif
vec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {
	return vec4(
		bytes2floatRange4(d0, -2.0, 2.0),
		bytes2floatRange4(d1, -2.0, 2.0),
		bytes2floatRange4(d2, -2.0, 2.0),
		bytes2floatRange4(d3, -2.0, 2.0)
	);
}
vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {
	return texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);
}
vec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {
	return texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);
}
void decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {
	clusterLightData.lightIndex = int(lightIndex);
	vec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);
	clusterLightData.lightType = lightInfo.x;
	clusterLightData.shape = lightInfo.y;
	clusterLightData.falloffMode = lightInfo.z;
	clusterLightData.shadowIntensity = lightInfo.w;
	vec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);
	vec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);
	clusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;
	clusterLightData.cookie = colorB.z;
	clusterLightData.mask = colorB.w;
	vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);
	clusterLightData.position = lightPosRange.xyz;
	clusterLightData.range = lightPosRange.w;
	vec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);
	clusterLightData.direction = lightDir_Unused.xyz;
}
void decodeClusterLightSpot(inout ClusterLightData clusterLightData) {
	vec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);
	clusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;
	clusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;
}
void decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {
	clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;
}
void decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {
	clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;
	clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;
}
void decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {
	
	vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);
	vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);
	vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);
	vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);
	lightProjectionMatrix = mat4(m0, m1, m2, m3);
}
void decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {
	
	vec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);
	clusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),
	clusterLightData.shadowNormalBias = bytes2float2(biases.zw);
}
void decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {
	vec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);
	clusterLightData.cookieIntensity = cookieA.x;
	clusterLightData.cookieRgb = cookieA.y;
	clusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);
}
void evaluateLight(
	ClusterLightData light, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir,
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	vec3 cookieAttenuation = vec3(1.0);
	float diffuseAttenuation = 1.0;
	float falloffAttenuation = 1.0;
	getLightDirPoint(light.position);
	#ifdef CLUSTER_AREALIGHTS
	if (isClusteredLightArea(light)) {
		decodeClusterLightAreaData(light);
		if (isClusteredLightRect(light)) {
			calcRectLightValues(light.position, light.halfWidth, light.halfHeight);
		} else if (isClusteredLightDisk(light)) {
			calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);
		} else {
			calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);
		}
		falloffAttenuation = getFalloffWindow(light.range, dLightDirW);
	} else
	#endif
	{
		if (isClusteredLightFalloffLinear(light))
			falloffAttenuation = getFalloffLinear(light.range, dLightDirW);
		else
			falloffAttenuation = getFalloffInvSquared(light.range, dLightDirW);
	}
	if (falloffAttenuation > 0.00001) {
		#ifdef CLUSTER_AREALIGHTS
		if (isClusteredLightArea(light)) {
			if (isClusteredLightRect(light)) {
				diffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
			} else if (isClusteredLightDisk(light)) {
				diffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
			} else {
				diffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
			}
		} else
		#endif
		{
			falloffAttenuation *= getLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW); 
		}
		if (isClusteredLightSpot(light)) {
			decodeClusterLightSpot(light);
			falloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, dLightDirNormW);
		}
		#if defined(CLUSTER_COOKIES_OR_SHADOWS)
		if (falloffAttenuation > 0.00001) {
			if (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {
				if (isClusteredLightSpot(light)) {
					decodeClusterLightProjectionMatrixData(light);
				} else {
					decodeClusterLightOmniAtlasViewport(light);
				}
				float shadowTextureResolution = shadowAtlasParams.x;
				float shadowEdgePixels = shadowAtlasParams.y;
				#ifdef CLUSTER_COOKIES
				if (isClusteredLightCookie(light)) {
					decodeClusterLightCookieData(light);
					if (isClusteredLightSpot(light)) {
						cookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);
					} else {
						cookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);
					}
				}
				#endif
				#ifdef CLUSTER_SHADOWS
				if (isClusteredLightCastShadow(light)) {
					decodeClusterLightShadowData(light);
					vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);
					if (isClusteredLightSpot(light)) {
						getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);
						
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							float shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							float shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							float shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCSS)
							float shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#endif
						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
					} else {
						vec3 dir = normalOffsetPointShadow(shadowParams, dLightPosW, dLightDirW, dLightDirNormW, geometricNormal);
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							float shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							float shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							float shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#endif
						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
					}
				}
				#endif
			}
		}
		#endif
		#ifdef CLUSTER_AREALIGHTS
		if (isClusteredLightArea(light)) {
			{
				vec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;
				#if defined(LIT_SPECULAR)
					areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);
				#endif
				dDiffuseLight += areaDiffuse;
			}
			#ifdef LIT_SPECULAR
				float areaLightSpecular;
				if (isClusteredLightRect(light)) {
					areaLightSpecular = getRectLightSpecular(worldNormal, viewDir);
				} else if (isClusteredLightDisk(light)) {
					areaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);
				} else {
					areaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);
				}
				dSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;
				#ifdef LIT_CLEARCOAT
					float areaLightSpecularCC;
					if (isClusteredLightRect(light)) {
						areaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);
					} else if (isClusteredLightDisk(light)) {
						areaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);
					} else {
						areaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);
					}
					ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;
				#endif
			#endif
		} else
		#endif
		{
			{
				vec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;
				#if defined(CLUSTER_AREALIGHTS)
				#if defined(LIT_SPECULAR)
					punctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);
				#endif
				#endif
				dDiffuseLight += punctualDiffuse;
			}
	 
			#ifdef LIT_SPECULAR
				vec3 halfDir = normalize(-dLightDirNormW + viewDir);
				
				#ifdef LIT_SPECULAR_FRESNEL
					dSpecularLight += 
						getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * 
						getFresnel(
							dot(viewDir, halfDir), 
							gloss, 
							specularity
						#if defined(LIT_IRIDESCENCE)
							, iridescenceFresnel,
							iridescence_intensity
						#endif
							);
				#else
					dSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;
				#endif
				#ifdef LIT_CLEARCOAT
					#ifdef LIT_SPECULAR_FRESNEL
						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));
					#else
						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; 
					#endif
				#endif
				#ifdef LIT_SHEEN
					sSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, dLightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;
				#endif
			#endif
		}
	}
	dAtten = falloffAttenuation;
	dAttenD = diffuseAttenuation;
	dAtten3 = cookieAttenuation;
}
void evaluateClusterLight(
	float lightIndex, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	ClusterLightData clusterLightData;
	decodeClusterLightCore(clusterLightData, lightIndex);
	if (acceptLightMask(clusterLightData))
		evaluateLight(
			clusterLightData, 
			worldNormal, 
			viewDir, 
			reflectionDir, 
#if defined(LIT_CLEARCOAT)
			clearcoatReflectionDir, 
#endif
			gloss, 
			specularity, 
			geometricNormal, 
			tbn, 
#if defined(LIT_IRIDESCENCE)
			iridescenceFresnel,
#endif
			clearcoat_worldNormal,
			clearcoat_gloss,
			sheen_gloss,
			iridescence_intensity
		);
}
void addClusteredLights(
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	if (clusterSkip > 0.5)
		return;
	vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);
	if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {
		float cellIndex = dot(clusterCellsDot, cellCoords);
		float clusterV = floor(cellIndex * clusterTextureSize.y);
		float clusterU = cellIndex - (clusterV * clusterTextureSize.x);
		for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {
			float lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;
			if (lightIndex <= 0.0)
					return;
			evaluateClusterLight(
				lightIndex * 255.0, 
				worldNormal, 
				viewDir, 
				reflectionDir,
#if defined(LIT_CLEARCOAT)
				clearcoatReflectionDir,
#endif
				gloss, 
				specularity, 
				geometricNormal, 
				tbn, 
#if defined(LIT_IRIDESCENCE)
				iridescenceFresnel,
#endif
				clearcoat_worldNormal,
				clearcoat_gloss,
				sheen_gloss,
				iridescence_intensity
			); 
		}
	}
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/combine.js
var combinePS = `
vec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {
	vec3 ret = vec3(0);
#ifdef LIT_OLD_AMBIENT
	ret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;
#else
	ret += albedo * dDiffuseLight;
#endif
#ifdef LIT_SPECULAR
	ret += dSpecularLight;
#endif
#ifdef LIT_REFLECTIONS
	ret += dReflection.rgb * dReflection.a;
#endif
#ifdef LIT_SHEEN
	float sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;
	ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;
#endif
#ifdef LIT_CLEARCOAT
	float clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;
	ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;
#endif
	return ret;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/cookie.js
var cookiePS = `
vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}
vec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}
vec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	projPos.xy += cookieOffset;
	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
	return mix(vec4(1.0), texture2D(tex, uv), intensity);
}
vec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	projPos.xy += cookieOffset;
	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
	return mix(vec4(1.0), texture2D(tex, uv), intensity);
}
vec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {
	return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/cubeMapProjectBox.js
var cubeMapProjectBoxPS = `
uniform vec3 envBoxMin;
uniform vec3 envBoxMax;
vec3 cubeMapProject(vec3 nrdir) {
	nrdir = cubeMapRotate(nrdir);
	vec3 rbmax = (envBoxMax - vPositionW) / nrdir;
	vec3 rbmin = (envBoxMin - vPositionW) / nrdir;
	vec3 rbminmax;
	rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;
	rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;
	rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;
	float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
	vec3 posonbox = vPositionW + nrdir * fa;
	vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;
	return normalize(posonbox - envBoxPos);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/cubeMapProjectNone.js
var cubeMapProjectNonePS = `
vec3 cubeMapProject(vec3 dir) {
	return cubeMapRotate(dir);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/cubeMapRotate.js
var cubeMapRotatePS = `
#ifdef CUBEMAP_ROTATION
uniform mat3 cubeMapRotationMatrix;
#endif
vec3 cubeMapRotate(vec3 refDir) {
#ifdef CUBEMAP_ROTATION
	return refDir * cubeMapRotationMatrix;
#else
	return refDir;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/debug-output.js
var debugOutputPS = `
#ifdef DEBUG_ALBEDO_PASS
gl_FragColor = vec4(gammaCorrectOutput(dAlbedo), 1.0);
#endif
#ifdef DEBUG_UV0_PASS
gl_FragColor = vec4(litArgs_albedo , 1.0);
#endif
#ifdef DEBUG_WORLD_NORMAL_PASS
gl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);
#endif
#ifdef DEBUG_OPACITY_PASS
gl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);
#endif
#ifdef DEBUG_SPECULARITY_PASS
gl_FragColor = vec4(litArgs_specularity, 1.0);
#endif
#ifdef DEBUG_GLOSS_PASS
gl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);
#endif
#ifdef DEBUG_METALNESS_PASS
gl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);
#endif
#ifdef DEBUG_AO_PASS
gl_FragColor = vec4(vec3(litArgs_ao) , 1.0);
#endif
#ifdef DEBUG_EMISSION_PASS
gl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);
#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/debug-process-frontend.js
var debugProcessFrontendPS = `
#ifdef DEBUG_LIGHTING_PASS
litArgs_albedo = vec3(0.5);
#endif
#ifdef DEBUG_UV0_PASS
#ifdef VARYING_VUV0
litArgs_albedo = vec3(vUv0, 0);
#else
litArgs_albedo = vec3(0);
#endif
#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/decode.js
var decodePS = `
vec3 decodeLinear(vec4 raw) {
	return raw.rgb;
}
float decodeGamma(float raw) {
	return pow(raw, 2.2);
}
vec3 decodeGamma(vec3 raw) {
	return pow(raw, vec3(2.2));
}
vec3 decodeGamma(vec4 raw) {
	return pow(raw.xyz, vec3(2.2));
}
vec3 decodeRGBM(vec4 raw) {
	vec3 color = (8.0 * raw.a) * raw.rgb;
	return color * color;
}
vec3 decodeRGBP(vec4 raw) {
	vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);
	return color * color;
}
vec3 decodeRGBE(vec4 raw) {
	if (raw.a == 0.0) {
		return vec3(0.0, 0.0, 0.0);
	} else {
		return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);
	}
}
vec4 passThrough(vec4 raw) {
	return raw;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/detailModes.js
var detailModesPS = `
vec3 detailMode_mul(vec3 c1, vec3 c2) {
	return c1 * c2;
}
vec3 detailMode_add(vec3 c1, vec3 c2) {
	return c1 + c2;
}
vec3 detailMode_screen(vec3 c1, vec3 c2) {
	return 1.0 - (1.0 - c1)*(1.0 - c2);
}
vec3 detailMode_overlay(vec3 c1, vec3 c2) {
	return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));
}
vec3 detailMode_min(vec3 c1, vec3 c2) {
	return min(c1, c2);
}
vec3 detailMode_max(vec3 c1, vec3 c2) {
	return max(c1, c2);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/diffuse.js
var diffusePS = `
uniform vec3 material_diffuse;
void getAlbedo() {
	dAlbedo = material_diffuse.rgb;
#ifdef MAPTEXTURE
	vec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	dAlbedo *= addAlbedoDetail(albedoBase);
#endif
#ifdef MAPVERTEX
	dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/diffuseDetailMap.js
var diffuseDetailMapPS = `
vec3 addAlbedoDetail(vec3 albedo) {
#ifdef MAPTEXTURE
	vec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	return detailMode_$DETAILMODE(albedo, albedoDetail);
#else
	return albedo;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/emissive.js
var emissivePS = `
uniform vec3 material_emissive;
uniform float material_emissiveIntensity;
void getEmission() {
	dEmission = material_emissive * material_emissiveIntensity;
	#ifdef MAPTEXTURE
	dEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));
	#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/encode.js
var encodePS = `
vec4 encodeLinear(vec3 source) {
	return vec4(source, 1.0);
}
vec4 encodeGamma(vec3 source) {
	return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);
}
vec4 encodeRGBM(vec3 source) {
	vec4 result;
	result.rgb = pow(source.rgb, vec3(0.5));
	result.rgb *= 1.0 / 8.0;
	result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );
	result.a = ceil(result.a * 255.0) / 255.0;
	result.rgb /= result.a;
	return result;
}
vec4 encodeRGBP(vec3 source) {
	vec3 gamma = pow(source, vec3(0.5));
	float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));
	float v = 1.0 - ((maxVal - 1.0) / 7.0);
	v = ceil(v * 255.0) / 255.0;
	return vec4(gamma / (-v * 7.0 + 8.0), v);	
}
vec4 encodeRGBE(vec3 source) {
	float maxVal = max(source.x, max(source.y, source.z));
	if (maxVal < 1e-32) {
		return vec4(0, 0, 0, 0);
	} else {
		float e = ceil(log2(maxVal));
		return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);
	}
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/end.js
var endPS = `
	gl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);
	gl_FragColor.rgb += litArgs_emission;
	gl_FragColor.rgb = addFog(gl_FragColor.rgb);
	gl_FragColor.rgb = toneMap(gl_FragColor.rgb);
	gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/end.js
var endVS = `
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/envAtlas.js
var envAtlasPS = `
const float atlasSize = 512.0;
const float seamSize = 1.0 / atlasSize;
vec2 mapUv(vec2 uv, vec4 rect) {
	return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),
				mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));
}
vec2 mapRoughnessUv(vec2 uv, float level) {
	float t = 1.0 / exp2(level);
	return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));
}
vec2 mapShinyUv(vec2 uv, float level) {
	float t = 1.0 / exp2(level);
	return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/envConst.js
var envConstPS = `
vec3 processEnvironment(vec3 color) {
	return color;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/envMultiply.js
var envMultiplyPS = `
uniform float skyboxIntensity;
vec3 processEnvironment(vec3 color) {
	return color * skyboxIntensity;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/falloffInvSquared.js
var falloffInvSquaredPS = `
float getFalloffWindow(float lightRadius, vec3 lightDir) {
	float sqrDist = dot(lightDir, lightDir);
	float invRadius = 1.0 / lightRadius;
	return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );
}
float getFalloffInvSquared(float lightRadius, vec3 lightDir) {
	float sqrDist = dot(lightDir, lightDir);
	float falloff = 1.0 / (sqrDist + 1.0);
	float invRadius = 1.0 / lightRadius;
	falloff *= 16.0;
	falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );
	return falloff;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/falloffLinear.js
var falloffLinearPS = `
float getFalloffLinear(float lightRadius, vec3 lightDir) {
	float d = length(lightDir);
	return max(((lightRadius - d) / lightRadius), 0.0);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/float-unpacking.js
var floatUnpackingPS = `
float bytes2float2(vec2 data) {
	return dot(data, vec2(1.0, 1.0 / 255.0));
}
float bytes2float3(vec3 data) {
	return dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));
}
float bytes2float4(vec4 data) {
	return dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
}
float bytes2floatRange2(vec2 data, float min, float max) {
	return mix(min, max, bytes2float2(data));
}
float bytes2floatRange3(vec3 data, float min, float max) {
	return mix(min, max, bytes2float3(data));
}
float bytes2floatRange4(vec4 data, float min, float max) {
	return mix(min, max, bytes2float4(data));
}
float mantissaExponent2Float(vec4 pack)
{
	float value = bytes2floatRange3(pack.xyz, -1.0, 1.0);
	float exponent = floor(pack.w * 255.0 - 127.0);
	return value * exp2(exponent);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fogExp.js
var fogExpPS = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = exp(-depth * fog_density);
	fogFactor = clamp(fogFactor, 0.0, 1.0);
	return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fogExp2.js
var fogExp2PS = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = exp(-depth * depth * fog_density * fog_density);
	fogFactor = clamp(fogFactor, 0.0, 1.0);
	return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fogLinear.js
var fogLinearPS = `
uniform vec3 fog_color;
uniform float fog_start;
uniform float fog_end;
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = (fog_end - depth) / (fog_end - fog_start);
	fogFactor = clamp(fogFactor, 0.0, 1.0);
	return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fogNone.js
var fogNonePS = `
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	return color;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fresnelSchlick.js
var fresnelSchlickPS = `
vec3 getFresnel(
		float cosTheta, 
		float gloss, 
		vec3 specularity
#if defined(LIT_IRIDESCENCE)
		, vec3 iridescenceFresnel, 
		float iridescenceIntensity
#endif
	) {
	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
	float glossSq = gloss * gloss;
	vec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;
#if defined(LIT_IRIDESCENCE)
	return mix(ret, iridescenceFresnel, iridescenceIntensity);
#else
	return ret;
#endif	
}
float getFresnelCC(float cosTheta) {
	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
	return 0.04 + (1.0 - 0.04) * fresnel;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/fullscreenQuad.js
var fullscreenQuadPS = `
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
	gl_FragColor = texture2D(source, vUv0);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/fullscreenQuad.js
var fullscreenQuadVS = `
attribute vec2 vertex_position;
varying vec2 vUv0;
void main(void)
{
	gl_Position = vec4(vertex_position, 0.5, 1.0);
	vUv0 = vertex_position.xy*0.5+0.5;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/gamma1_0.js
var gamma1_0PS = `
float gammaCorrectInput(float color) {
	return color;
}
vec3 gammaCorrectInput(vec3 color) {
	return color;
}
vec4 gammaCorrectInput(vec4 color) {
	return color;
}
vec3 gammaCorrectOutput(vec3 color) {
	return color;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/gamma2_2.js
var gamma2_2PS = `
float gammaCorrectInput(float color) {
	return decodeGamma(color);
}
vec3 gammaCorrectInput(vec3 color) {
	return decodeGamma(color);
}
vec4 gammaCorrectInput(vec4 color) {
	return vec4(decodeGamma(color.xyz), color.w);
}
vec3 gammaCorrectOutput(vec3 color) {
	return pow(color + 0.0000001, vec3(1.0 / 2.2));
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/gloss.js
var glossPS = `
#ifdef MAPFLOAT
uniform float material_gloss;
#endif
void getGlossiness() {
	dGlossiness = 1.0;
	#ifdef MAPFLOAT
	dGlossiness *= material_gloss;
	#endif
	#ifdef MAPTEXTURE
	dGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	dGlossiness *= saturate(vVertexColor.$VC);
	#endif
	#ifdef MAPINVERT
	dGlossiness = 1.0 - dGlossiness;
	#endif
	dGlossiness += 0.0000001;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/iridescenceDiffraction.js
var iridescenceDiffractionPS = `
uniform float material_iridescenceRefractionIndex;
#ifndef PI
#define PI 3.14159265
#endif
float iridescence_iorToFresnel(float transmittedIor, float incidentIor) {
	return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);
}
vec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {
	return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));
}
vec3 iridescence_fresnelToIor(vec3 f0) {
	vec3 sqrtF0 = sqrt(f0);
	return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}
vec3 iridescence_sensitivity(float opd, vec3 shift) {
	float phase = 2.0 * PI * opd * 1.0e-9;
	const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
	const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
	const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);
	vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);
	xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));
	xyz /= vec3(1.0685e-07);
	const mat3 XYZ_TO_REC709 = mat3(
		3.2404542, -0.9692660,  0.0556434,
	   -1.5371385,  1.8760108, -0.2040259,
	   -0.4985314,  0.0415560,  1.0572252
	);
	return XYZ_TO_REC709 * xyz;
}
float iridescence_fresnel(float cosTheta, float f0) {
	float x = clamp(1.0 - cosTheta, 0.0, 1.0);
	float x2 = x * x;
	float x5 = x * x2 * x2;
	return f0 + (1.0 - f0) * x5;
} 
vec3 iridescence_fresnel(float cosTheta, vec3 f0) {
	float x = clamp(1.0 - cosTheta, 0.0, 1.0);
	float x2 = x * x;
	float x5 = x * x2 * x2; 
	return f0 + (vec3(1.0) - f0) * x5;
}
vec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {
	float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));
	float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));
	float cosTheta2Sq = 1.0 - sinTheta2Sq;
	if (cosTheta2Sq < 0.0) {
		return vec3(1.0);
	}
	float cosTheta2 = sqrt(cosTheta2Sq);
	float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);
	float r12 = iridescence_fresnel(cosTheta, r0);
	float r21 = r12;
	float t121 = 1.0 - r12;
	float phi12 = iridescenceIor < outsideIor ? PI : 0.0;
	float phi21 = PI - phi12;
	vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));
	vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);
	vec3 r23 = iridescence_fresnel(cosTheta2, r1);
	vec3 phi23 = vec3(0.0);
	if (baseIor[0] < iridescenceIor) phi23[0] = PI;
	if (baseIor[1] < iridescenceIor) phi23[1] = PI;
	if (baseIor[2] < iridescenceIor) phi23[2] = PI;
	float opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;
	vec3 phi = vec3(phi21) + phi23; 
	vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);
	vec3 r123 = sqrt(r123Sq);
	vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);
	vec3 c0 = r12 + rs;
	vec3 i = c0;
	vec3 cm = rs - t121;
	for (int m = 1; m <= 2; m++) {
		cm *= r123;
		vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);
		i += cm * sm;
	}
	return max(i, vec3(0.0));
}
vec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {
	return calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/iridescence.js
var iridescencePS = `
#ifdef MAPFLOAT
uniform float material_iridescence;
#endif
void getIridescence() {
	float iridescence = 1.0;
	#ifdef MAPFLOAT
	iridescence *= material_iridescence;
	#endif
	#ifdef MAPTEXTURE
	iridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	dIridescence = iridescence; 
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/iridescenceThickness.js
var iridescenceThicknessPS = `
uniform float material_iridescenceThicknessMax;
#ifdef MAPTEXTURE
uniform float material_iridescenceThicknessMin;
#endif
void getIridescenceThickness() {
	#ifdef MAPTEXTURE
	float blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);
	#else
	float iridescenceThickness = material_iridescenceThicknessMax;
	#endif
	dIridescenceThickness = iridescenceThickness; 
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/ior.js
var iorPS = `
#ifdef MAPFLOAT
uniform float material_refractionIndex;
#endif
void getIor() {
#ifdef MAPFLOAT
	dIor = material_refractionIndex;
#else
	dIor = 1.0 / 1.5;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightDiffuseLambert.js
var lightDiffuseLambertPS = `
float getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return max(dot(worldNormal, -lightDirNorm), 0.0);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightDirPoint.js
var lightDirPointPS = `
void getLightDirPoint(vec3 lightPosW) {
	dLightDirW = vPositionW - lightPosW;
	dLightDirNormW = normalize(dLightDirW);
	dLightPosW = lightPosW;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightmapAdd.js
var lightmapAddPS = `
void addLightMap(
	vec3 lightmap, 
	vec3 dir, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
	float gloss, 
	vec3 specularity, 
	vec3 vertexNormal, 
	mat3 tbn
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel, 
	float iridescenceIntensity
#endif
) {
	dDiffuseLight += lightmap;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightmapDirAdd.js
var lightmapDirAddPS = `
void addLightMap(
	vec3 lightmap, 
	vec3 dir, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
	float gloss, 
	vec3 specularity, 
	vec3 vertexNormal, 
	mat3 tbn
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel, 
	float iridescenceIntensity
#endif
) {
	if (dot(dir, dir) < 0.0001) {
		dDiffuseLight += lightmap;
	} else {
		float vlight = saturate(dot(dir, -vertexNormal));
		float flight = saturate(dot(dir, -worldNormal));
		float nlight = (flight / max(vlight, 0.01)) * 0.5;
		dDiffuseLight += lightmap * nlight * 2.0;
		vec3 halfDir = normalize(-dir + viewDir);
		vec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);
#ifdef LIT_SPECULAR_FRESNEL
		specularLight *= 
			getFresnel(dot(viewDir, halfDir), 
			gloss, 
			specularity
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			iridescenceIntensity
		#endif
			);
#endif
		dSpecularLight += specularLight;
	}
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/lightmapDir.js
var lightmapDirPS = `
uniform sampler2D texture_lightMap;
uniform sampler2D texture_dirLightMap;
void getLightMap() {
	dLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;
	vec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;
	float dirDot = dot(dir, dir);
	dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/lightmapSingle.js
var lightmapSinglePS = `
void getLightMap() {
	dLightmap = vec3(1.0);
	#ifdef MAPTEXTURE
	dLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	dLightmap *= saturate(vVertexColor.$VC);
	#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightSpecularAnisoGGX.js
var lightSpecularAnisoGGXPS = `
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {
	float PI = 3.141592653589793;
	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	float anisotropy = material_anisotropy * roughness;
 
	float at = max((roughness + anisotropy), roughness / 4.0);
	float ab = max((roughness - anisotropy), roughness / 4.0);
	float NoH = dot(worldNormal, h);
	float ToH = dot(tbn[0], h);
	float BoH = dot(tbn[1], h);
	float a2 = at * ab;
	vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
	float v2 = dot(v, v);
	float w2 = a2 / v2;
	float D = a2 * w2 * w2 * (1.0 / PI);
	float ToV = dot(tbn[0], viewDir);
	float BoV = dot(tbn[1], viewDir);
	float ToL = dot(tbn[0], -lightDirNorm);
	float BoL = dot(tbn[1], -lightDirNorm);
	float NoV = dot(worldNormal, viewDir);
	float NoL = dot(worldNormal, -lightDirNorm);
	float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));
	float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));
	float G = 0.5 / (lambdaV + lambdaL);
	return D * G;
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightSpecularBlinn.js
var lightSpecularBlinnPS = `
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {
	float nh = max( dot( h, worldNormal ), 0.0 );
	float specPow = exp2(gloss * 11.0);
	specPow = max(specPow, 0.0001);
	return pow(nh, specPow) * (specPow + 2.0) / 8.0;
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, worldNormal, h);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightSheen.js
var lightSheenPS = `
float sheenD(vec3 normal, vec3 h, float roughness) {
	float invR = 1.0 / (roughness * roughness);
	float cos2h = max(dot(normal, h), 0.0);
	cos2h *= cos2h;
	float sin2h = max(1.0 - cos2h, 0.0078125);
	return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);
}
float sheenV(vec3 normal, vec3 viewDir, vec3 light) {
	float NoV = max(dot(normal, viewDir), 0.000001);
	float NoL = max(dot(normal, light), 0.000001);
	return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
}
float getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {
	float D = sheenD(worldNormal, h, sheenGloss);
	float V = sheenV(worldNormal, viewDir, -lightDirNorm);
	return D * V;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/linearizeDepth.js
var linearizeDepthPS = `
#ifndef LINEARIZE_DEPTH
#define LINEARIZE_DEPTH
float linearizeDepth(float z, vec4 cameraParams) {
	if (cameraParams.w == 0.0)
		return (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));
	else
		return cameraParams.z + z * (cameraParams.y - cameraParams.z);
}
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
float linearizeDepth(float z) {
	return linearizeDepth(z, camera_params);
}
#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/litShaderArgs.js
var litShaderArgsPS = `
vec3 litArgs_albedo;
float litArgs_opacity;
vec3 litArgs_emission;
vec3 litArgs_worldNormal;
float litArgs_ao;
vec3 litArgs_lightmap;
vec3 litArgs_lightmapDir;
float litArgs_metalness;
vec3 litArgs_specularity;
float litArgs_specularityFactor;
float litArgs_gloss;
float litArgs_sheen_gloss;
vec3 litArgs_sheen_specularity;
float litArgs_transmission;
float litArgs_thickness;
float litArgs_ior;
float litArgs_dispersion;
float litArgs_iridescence_intensity;
float litArgs_iridescence_thickness;
vec3 litArgs_clearcoat_worldNormal;
float litArgs_clearcoat_specularity;
float litArgs_clearcoat_gloss;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/ltc.js
var ltcPS = `
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
struct Coords {
	vec3 coord0;
	vec3 coord1;
	vec3 coord2;
	vec3 coord3;
};
float LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {
	vec3 v1 = rectCoords.coord1 - rectCoords.coord0;
	vec3 v2 = rectCoords.coord3 - rectCoords.coord0;
	
	vec3 lightNormal = cross( v1, v2 );
	float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 =  factor * cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords.coord0 - P );
	coords[ 1 ] = mat * ( rectCoords.coord1 - P );
	coords[ 2 ] = mat * ( rectCoords.coord2 - P );
	coords[ 3 ] = mat * ( rectCoords.coord3 - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return result;
}
Coords dLTCCoords;
Coords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
	Coords coords;
	coords.coord0 = lightPos + halfWidth - halfHeight;
	coords.coord1 = lightPos - halfWidth - halfHeight;
	coords.coord2 = lightPos - halfWidth + halfHeight;
	coords.coord3 = lightPos + halfWidth + halfHeight;
	return coords;
}
float dSphereRadius;
Coords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
	dSphereRadius = max(length(halfWidth), length(halfHeight));
	vec3 f = reflect(normalize(lightPos - view_position), vNormalW);
	vec3 w = normalize(cross(f, halfHeight));
	vec3 h = normalize(cross(f, w));
	return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);
}
vec2 dLTCUV;
#ifdef LIT_CLEARCOAT
vec2 ccLTCUV;
#endif
vec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)
{
	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	return LTC_Uv( worldNormal, viewDir, roughness );
}
vec3 dLTCSpecFres;
#ifdef LIT_CLEARCOAT
vec3 ccLTCSpecFres;
#endif
vec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)
{
	vec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);
	return specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;
}
void calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)
{
	dLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);
	dLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); 
#ifdef LIT_CLEARCOAT
	ccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);
	ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));
#endif
}
void calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
	dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);
}
void calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
	calcRectLightValues(lightPos, halfWidth, halfHeight);
}
void calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
	dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);
}
vec3 SolveCubic(vec4 Coefficient)
{
	float pi = 3.14159;
	Coefficient.xyz /= Coefficient.w;
	Coefficient.yz /= 3.0;
	float A = Coefficient.w;
	float B = Coefficient.z;
	float C = Coefficient.y;
	float D = Coefficient.x;
	vec3 Delta = vec3(
		-Coefficient.z * Coefficient.z + Coefficient.y,
		-Coefficient.y * Coefficient.z + Coefficient.x,
		dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)
	);
	float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);
	vec3 RootsA, RootsD;
	vec2 xlc, xsc;
	{
		float A_a = 1.0;
		float C_a = Delta.x;
		float D_a = -2.0 * B * Delta.x + Delta.y;
		float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;
		float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);
		float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);
		float xl;
		if ((x_1a + x_3a) > 2.0 * B)
			xl = x_1a;
		else
			xl = x_3a;
		xlc = vec2(xl - B, A);
	}
	{
		float A_d = D;
		float C_d = Delta.z;
		float D_d = -D * Delta.y + 2.0 * C * Delta.z;
		float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;
		float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);
		float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);
		float xs;
		if (x_1d + x_3d < 2.0 * C)
			xs = x_1d;
		else
			xs = x_3d;
		xsc = vec2(-D, xs + C);
	}
	float E =  xlc.y * xsc.y;
	float F = -xlc.x * xsc.y - xlc.y * xsc.x;
	float G =  xlc.x * xsc.x;
	vec2 xmc = vec2(C * F - B * G, -B * F + C * E);
	vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);
	if (Root.x < Root.y && Root.x < Root.z)
		Root.xyz = Root.yxz;
	else if (Root.z < Root.x && Root.z < Root.y)
		Root.xyz = Root.xzy;
	return Root;
}
float LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)
{
	vec3 T1, T2;
	T1 = normalize(V - N * dot(V, N));
	T2 = cross(N, T1);
	mat3 R = transposeMat3( mat3( T1, T2, N ) );
	vec3 L_[ 3 ];
	L_[ 0 ] = R * ( points.coord0 - P );
	L_[ 1 ] = R * ( points.coord1 - P );
	L_[ 2 ] = R * ( points.coord2 - P );
	vec3 Lo_i = vec3(0);
	vec3 C  = 0.5 * (L_[0] + L_[2]);
	vec3 V1 = 0.5 * (L_[1] - L_[2]);
	vec3 V2 = 0.5 * (L_[1] - L_[0]);
	C  = Minv * C;
	V1 = Minv * V1;
	V2 = Minv * V2;
	float a, b;
	float d11 = dot(V1, V1);
	float d22 = dot(V2, V2);
	float d12 = dot(V1, V2);
	if (abs(d12) / sqrt(d11 * d22) > 0.0001)
	{
		float tr = d11 + d22;
		float det = -d12 * d12 + d11 * d22;
		det = sqrt(det);
		float u = 0.5 * sqrt(tr - 2.0 * det);
		float v = 0.5 * sqrt(tr + 2.0 * det);
		float e_max = (u + v) * (u + v);
		float e_min = (u - v) * (u - v);
		vec3 V1_, V2_;
		if (d11 > d22)
		{
			V1_ = d12 * V1 + (e_max - d11) * V2;
			V2_ = d12 * V1 + (e_min - d11) * V2;
		}
		else
		{
			V1_ = d12*V2 + (e_max - d22)*V1;
			V2_ = d12*V2 + (e_min - d22)*V1;
		}
		a = 1.0 / e_max;
		b = 1.0 / e_min;
		V1 = normalize(V1_);
		V2 = normalize(V2_);
	}
	else
	{
		a = 1.0 / dot(V1, V1);
		b = 1.0 / dot(V2, V2);
		V1 *= sqrt(a);
		V2 *= sqrt(b);
	}
	vec3 V3 = cross(V1, V2);
	if (dot(C, V3) < 0.0)
		V3 *= -1.0;
	float L  = dot(V3, C);
	float x0 = dot(V1, C) / L;
	float y0 = dot(V2, C) / L;
	float E1 = inversesqrt(a);
	float E2 = inversesqrt(b);
	a *= L * L;
	b *= L * L;
	float c0 = a * b;
	float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;
	float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);
	float c3 = 1.0;
	vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));
	float e1 = roots.x;
	float e2 = roots.y;
	float e3 = roots.z;
	vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);
	mat3 rotate = mat3(V1, V2, V3);
	avgDir = rotate * avgDir;
	avgDir = normalize(avgDir);
	float L1 = sqrt(-e2 / e3);
	float L2 = sqrt(-e2 / e1);
	float formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));
	
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);
	uv = uv*LUT_SCALE + LUT_BIAS;
	float scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;
	return formFactor*scale;
}
float getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}
float getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}
float getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	float falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);
	return getLightDiffuse(worldNormal, viewDir, lightDir, lightDirNorm) * falloff;
}
mat3 getLTCLightInvMat(vec2 uv)
{
	vec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);
	return mat3(
		vec3( t1.x, 0, t1.y ),
		vec3(	0, 1,	0 ),
		vec3( t1.z, 0, t1.w )
	);
}
float calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
	mat3 mInv = getLTCLightInvMat(uv);
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
float getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcRectLightSpecular(worldNormal, viewDir, dLTCUV);
}
float calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
	mat3 mInv = getLTCLightInvMat(uv);
	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
float getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
float getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/metalness.js
var metalnessPS = `
#ifdef MAPFLOAT
uniform float material_metalness;
#endif
void getMetalness() {
	float metalness = 1.0;
	#ifdef MAPFLOAT
	metalness *= material_metalness;
	#endif
	#ifdef MAPTEXTURE
	metalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	metalness *= saturate(vVertexColor.$VC);
	#endif
	dMetalness = metalness;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/msdf.js
var msdfPS = `
uniform sampler2D texture_msdfMap;
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
float map (float min, float max, float v) {
	return (v - min) / (max - min);
}
uniform float font_sdfIntensity;
uniform float font_pxrange;
uniform float font_textureWidth;
#ifdef UNIFORM_TEXT_PARAMETERS
uniform vec4 outline_color;
uniform float outline_thickness;
uniform vec4 shadow_color;
uniform vec2 shadow_offset;
#else
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
#endif
vec4 applyMsdf(vec4 color) {
	vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;
	vec2 uvShdw = vUv0 - shadow_offset;
	vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;
	float sigDist = median(tsample.r, tsample.g, tsample.b);
	float sigDistShdw = median(ssample.r, ssample.g, ssample.b);
	float smoothingMax = 0.2;
	vec2 w = fwidth(vUv0);
	float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);
	float mapMin = 0.05;
	float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);
	float sigDistInner = map(mapMin, mapMax, sigDist);
	float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);
	sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);
	float center = 0.5;
	float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);
	float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);
	float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);
	vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);
	tcolor = mix(tcolor, color, inside);
	vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;
	tcolor = mix(scolor, tcolor, outline);
	
	return tcolor;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/metalnessModulate.js
var metalnessModulatePS = `
vec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {
	vec3 dielectricF0 = f0 * specularity;
	return mix(dielectricF0, albedo, metalness);
}
vec3 getAlbedoModulate(in vec3 albedo, in float metalness) {
	return albedo * (1.0 - metalness);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/msdf.js
var msdfVS = `
attribute vec3 vertex_outlineParameters;
attribute vec3 vertex_shadowParameters;
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
void unpackMsdfParams() {
	vec3 little = mod(vertex_outlineParameters, 256.);
	vec3 big = (vertex_outlineParameters - little) / 256.;
	outline_color.rb = little.xy / 255.;
	outline_color.ga = big.xy / 255.;
	outline_thickness = little.z / 255. * 0.2;
	little = mod(vertex_shadowParameters, 256.);
	big = (vertex_shadowParameters - little) / 256.;
	shadow_color.rb = little.xy / 255.;
	shadow_color.ga = big.xy / 255.;
	shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/normal.js
var normalVS = `
mat3 dNormalMatrix;
vec3 getNormal() {
	dNormalMatrix = getNormalMatrix(dModelMatrix);
	vec3 localNormal = getLocalNormal(vertex_normal);
	return normalize(dNormalMatrix * localNormal);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/normalCore.js
var normalCoreVS = `
attribute vec3 vertex_normal;
#ifdef MORPHING_NORMAL
	#ifdef MORPHING_INT
		uniform highp usampler2D morphNormalTex;
	#else
		uniform highp sampler2D morphNormalTex;
	#endif
#endif
vec3 getLocalNormal(vec3 vertexNormal) {
	vec3 localNormal = vertex_normal;
	#ifdef MORPHING_NORMAL
		ivec2 morphUV = getTextureMorphCoords();
		#ifdef MORPHING_INT
			vec3 morphNormal = vec3(texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz) / 65535.0 * 2.0 - 1.0;
		#else
			vec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;
		#endif
		localNormal += morphNormal;
	#endif
	return localNormal;
}
#ifdef SKIN
	mat3 getNormalMatrix(mat4 modelMatrix) {
		return mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);
	}
#elif defined(INSTANCING)
	mat3 getNormalMatrix(mat4 modelMatrix) {
		return mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);
	}
#else
	mat3 getNormalMatrix(mat4 modelMatrix) {
		return matrix_normal;
	}
#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/normalDetailMap.js
var normalDetailMapPS = `
#ifdef MAPTEXTURE
uniform float material_normalDetailMapBumpiness;
vec3 blendNormals(vec3 n1, vec3 n2) {
	n1 += vec3(0, 0, 1);
	n2 *= vec3(-1, -1, 1);
	return n1 * dot(n1, n2) / n1.z - n2;
}
#endif
vec3 addNormalDetail(vec3 normalMap) {
#ifdef MAPTEXTURE
	vec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
	normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);
	return blendNormals(normalMap, normalDetailMap);
#else
	return normalMap;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/normalMap.js
var normalMapPS = `
#ifdef MAPTEXTURE
uniform float material_bumpiness;
#endif
void getNormal() {
#ifdef MAPTEXTURE
	vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);
	dNormalW = normalize(dTBN * addNormalDetail(normalMap));
#else
	dNormalW = dVertexNormalW;
#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/normalXY.js
var normalXYPS = `
vec3 unpackNormal(vec4 nmap) {
	vec3 normal;
	normal.xy = nmap.wy * 2.0 - 1.0;
	normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));
	return normal;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/normalXYZ.js
var normalXYZPS = `
vec3 unpackNormal(vec4 nmap) {
	return nmap.xyz * 2.0 - 1.0;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/opacity.js
var opacityPS = `
uniform float material_opacity;
void getOpacity() {
	dAlpha = material_opacity;
	#ifdef MAPTEXTURE
	dAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);
	#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/opacity-dither.js
var opacityDitherPS = `
uniform vec4 blueNoiseJitter;
#ifdef DITHER_BLUENOISE
	uniform sampler2D blueNoiseTex32;
#endif
void opacityDither(float alpha, float id) {
	#ifdef DITHER_BAYER8
		float noise = bayer8(floor(mod(gl_FragCoord.xy + blueNoiseJitter.xy + id, 8.0))) / 64.0;
	#else
		#ifdef DITHER_BLUENOISE
			vec2 uv = fract(gl_FragCoord.xy / 32.0 + blueNoiseJitter.xy + id);
			float noise = texture2DLodEXT(blueNoiseTex32, uv, 0.0).y;
		#endif
		#ifdef DITHER_IGNNOISE
			vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
			float noise = fract(magic.z * fract(dot(gl_FragCoord.xy + blueNoiseJitter.xy + id, magic.xy)));
		#endif
	#endif
	noise = pow(noise, 2.2);
	if (alpha < noise)
		discard;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/output.js
var outputPS = `
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/outputAlpha.js
var outputAlphaPS = `
gl_FragColor.a = litArgs_opacity;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/outputAlphaOpaque.js
var outputAlphaOpaquePS = `
	gl_FragColor.a = 1.0;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/outputAlphaPremul.js
var outputAlphaPremulPS = `
gl_FragColor.rgb *= litArgs_opacity;
gl_FragColor.a = litArgs_opacity;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/outputTex2D.js
var outputTex2DPS = `
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
	gl_FragColor = texture2D(source, vUv0);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/packDepth.js
var packDepthPS = `
vec4 packFloat(float depth) {
	const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
	const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
	vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
	res -= res.xxyz * bit_mask;
	return res;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/sheen.js
var sheenPS = `
uniform vec3 material_sheen;
void getSheen() {
	vec3 sheenColor = material_sheen;
	#ifdef MAPTEXTURE
	sheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	sheenColor *= saturate(vVertexColor.$VC);
	#endif
	sSpecularity = sheenColor;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/sheenGloss.js
var sheenGlossPS = `
uniform float material_sheenGloss;
void getSheenGlossiness() {
	float sheenGlossiness = material_sheenGloss;
	#ifdef MAPTEXTURE
	sheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	sheenGlossiness *= saturate(vVertexColor.$VC);
	#endif
	#ifdef MAPINVERT
	sheenGlossiness = 1.0 - sheenGlossiness;
	#endif
	sheenGlossiness += 0.0000001;
	sGlossiness = sheenGlossiness;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/parallax.js
var parallaxPS = `
uniform float material_heightMapFactor;
void getParallax() {
	float parallaxScale = material_heightMapFactor;
	float height = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	height = height * parallaxScale - parallaxScale*0.5;
	vec3 viewDirT = dViewDirW * dTBN;
	viewDirT.z += 0.42;
	dUvOffset = height * (viewDirT.xy / viewDirT.z);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle.js
var particlePS = `
varying vec4 texCoordsAlphaLife;
uniform sampler2D colorMap;
uniform sampler2D colorParam;
uniform float graphSampleSize;
uniform float graphNumSamples;
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
uniform float softening;
uniform float colorMult;
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
	const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	float depth = dot(rgbaDepth, bitShift);
	return depth;
}
#endif
void main(void) {
	vec4 tex  = texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));
	vec4 ramp = texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0));
	ramp.rgb *= colorMult;
	ramp.a += texCoordsAlphaLife.z;
	vec3 rgb = tex.rgb * ramp.rgb;
	float a  = tex.a * ramp.a;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle.js
var particleVS = `
vec3 unpack3NFloats(float src) {
	float r = fract(src);
	float g = fract(src * 256.0);
	float b = fract(src * 65536.0);
	return vec3(r, g, b);
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc) {
	return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );
}
vec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {
	vec4 a = texture2D(tex,tc);
	vec4 b = texture2D(tex,tc + graphSampleSize);
	float c = fract(tc.x*graphNumSamples);
	vec3 unpackedA = unpack3NFloats(a.w);
	vec3 unpackedB = unpack3NFloats(b.w);
	w = mix(unpackedA, unpackedB, c);
	return mix(a, b, c);
}
vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {
	float c = cos(pRotation);
	float s = sin(pRotation);
	mat2 m = mat2(c, -s, s, c);
	rotMatrix = m;
	return m * quadXY;
}
vec3 billboard(vec3 InstanceCoords, vec2 quadXY) {
	#ifdef SCREEN_SPACE
		vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;
	#else
		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
	#endif
	return pos;
}
vec3 customFace(vec3 InstanceCoords, vec2 quadXY) {
	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
	return pos;
}
vec2 safeNormalize(vec2 v) {
	float l = length(v);
	return (l > 1e-06) ? v / l : v;
}
void main(void) {
	vec3 meshLocalPos = particle_vertexData.xyz;
	float id = floor(particle_vertexData.w);
	float rndFactor = fract(sin(id + 1.0 + seed));
	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
	float uv = id / numParticlesPot;
	readInput(uv);
#ifdef LOCAL_SPACE
	inVel = mat3(matrix_model) * inVel;
#endif
	vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);
	float particleLifetime = lifetime;
	if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);
	vec2 quadXY = meshLocalPos.xy;
	float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);
	vec3 paramDiv;
	vec4 params = tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);
	float scale = params.y;
	float scaleDiv = paramDiv.x;
	float alphaDiv = paramDiv.z;
	scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);
#ifndef USE_MESH
	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#else
	texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#endif
	vec3 particlePos = inPos;
	vec3 particlePosMoved = vec3(0.0);
	mat2 rotMatrix;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particleAnimFrameClamp.js
var particleAnimFrameClampVS = `
	float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particleAnimFrameLoop.js
var particleAnimFrameLoopVS = `
	float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particleAnimTex.js
var particleAnimTexVS = `
	float animationIndex;
	if (animTexIndexParams.y == 1.0) {
		animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);
	} else {
		animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);
	}
	float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;
	float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;
	atlasX = fract(atlasX);
	texCoordsAlphaLife.xy *= animTexTilesParams.xy;
	texCoordsAlphaLife.xy += vec2(atlasX, atlasY);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleInputFloat.js
var particleInputFloatPS = `
void readInput(float uv) {
	vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));
	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));
	inPos = tex.xyz;
	inVel = tex2.xyz;
	inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;
	inShow = tex.w >= 0.0;
	inLife = tex2.w;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleInputRgba8.js
var particleInputRgba8PS = `
#define PI2 6.283185307179586
uniform vec3 inBoundsSize;
uniform vec3 inBoundsCenter;
uniform float maxVel;
float decodeFloatRG(vec2 rg) {
	return rg.y*(1.0/255.0) + rg.x;
}
float decodeFloatRGBA( vec4 rgba ) {
	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );
}
void readInput(float uv) {
	vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));
	vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));
	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));
	vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));
	inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));
	inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;
	inVel = tex2.xyz;
	inVel = (inVel - vec3(0.5)) * maxVel;
	inAngle = decodeFloatRG(tex1.ba) * PI2;
	inShow = tex2.a > 0.5;
	inLife = decodeFloatRGBA(tex3);
	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
	float maxPosLife = lifetime+1.0;
	inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleOutputFloat.js
var particleOutputFloatPS = `
void writeOutput() {
	if (gl_FragCoord.y<1.0) {
		gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);
	} else {
		gl_FragColor = vec4(outVel, outLife);
	}
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleOutputRgba8.js
var particleOutputRgba8PS = `
uniform vec3 outBoundsMul;
uniform vec3 outBoundsAdd;
vec2 encodeFloatRG( float v ) {
	vec2 enc = vec2(1.0, 255.0) * v;
	enc = fract(enc);
	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
	return enc;
}
vec4 encodeFloatRGBA( float v ) {
	vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
	enc = fract(enc);
	enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
	return enc;
}
void writeOutput() {
	outPos = outPos * outBoundsMul + outBoundsAdd;
	outAngle = fract(outAngle / PI2);
	outVel = (outVel / maxVel) + vec3(0.5);
	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
	float maxPosLife = lifetime+1.0;
	outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);
	if (gl_FragCoord.y < 1.0) {
		gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));
	} else if (gl_FragCoord.y < 2.0) {
		gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));
	} else if (gl_FragCoord.y < 3.0) {
		gl_FragColor = vec4(outVel, visMode*0.5+0.5);
	} else {
		gl_FragColor = encodeFloatRGBA(outLife);
	}
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterAABB.js
var particleUpdaterAABBPS = `
uniform mat3 spawnBounds;
uniform vec3 spawnPosInnerRatio;
vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
	vec3 pos = inBounds - vec3(0.5);
	vec3 posAbs = abs(pos);
	vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));
	vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;
	pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);
	pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);
	pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);
#ifndef LOCAL_SPACE
	return emitterPos + spawnBounds * pos;
#else
	return spawnBounds * pos;
#endif
}
void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
	localVelocity -= vec3(0, 0, initialVelocity);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterEnd.js
var particleUpdaterEndPS = `
	writeOutput();
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterInit.js
var particleUpdaterInitPS = `
varying vec2 vUv0;
uniform highp sampler2D particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform highp sampler2D internalTex3;
uniform mat3 emitterMatrix;
uniform mat3 emitterMatrixInv;
uniform vec3 emitterScale;
uniform vec3 emitterPos;
uniform vec3 frameRandom;
uniform vec3 localVelocityDivMult;
uniform vec3 velocityDivMult;
uniform float delta;
uniform float rate;
uniform float rateDiv;
uniform float lifetime;
uniform float numParticles;
uniform float rotSpeedDivMult;
uniform float radialSpeedDivMult;
uniform float seed;
uniform float startAngle;
uniform float startAngle2;
uniform float initialVelocity;
uniform float graphSampleSize;
uniform float graphNumSamples;
vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
float visMode;
vec3 outPos;
vec3 outVel;
float outAngle;
bool outShow;
float outLife;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterNoRespawn.js
var particleUpdaterNoRespawnPS = `
	if (outLife >= lifetime) {
		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
		visMode = -1.0;
	}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterOnStop.js
var particleUpdaterOnStopPS = `
	visMode = outLife < 0.0? -1.0: visMode;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterRespawn.js
var particleUpdaterRespawnPS = `
	if (outLife >= lifetime) {
		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
		visMode = 1.0;
	}
	visMode = outLife < 0.0? 1.0: visMode;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterSphere.js
var particleUpdaterSpherePS = `
uniform float spawnBoundsSphere;
uniform float spawnBoundsSphereInnerRatio;
vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
	float rnd4 = fract(rndFactor * 1000.0);
	vec3 norm = normalize(inBounds.xyz - vec3(0.5));
	float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
#ifndef LOCAL_SPACE
	return emitterPos + norm * r * spawnBoundsSphere;
#else
	return norm * r * spawnBoundsSphere;
#endif
}
void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
	localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterStart.js
var particleUpdaterStartPS = `
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec3 unpack3NFloats(float src) {
	float r = fract(src);
	float g = fract(src * 256.0);
	float b = fract(src * 65536.0);
	return vec3(r, g, b);
}
vec3 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {
	vec4 a = texture2D(tex, tc);
	vec4 b = texture2D(tex, tc + graphSampleSize);
	float c = fract(tc.x * graphNumSamples);
	vec3 unpackedA = unpack3NFloats(a.w);
	vec3 unpackedB = unpack3NFloats(b.w);
	w = mix(unpackedA, unpackedB, c);
	return mix(a.xyz, b.xyz, c);
}
#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)
vec4 hash41(float p) {
	vec4 p4 = fract(vec4(p) * HASHSCALE4);
	p4 += dot(p4, p4.wzxy+19.19);
	return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));
}
void main(void) {
	if (gl_FragCoord.x > numParticles) discard;
	readInput(vUv0.x);
	visMode = inShow? 1.0 : -1.0;
	vec4 rndFactor = hash41(gl_FragCoord.x + seed);
	float particleRate = rate + rateDiv * rndFactor.x;
	outLife = inLife + delta;
	float nlife = clamp(outLife / lifetime, 0.0, 1.0);
	vec3 localVelocityDiv;
	vec3 velocityDiv;
	vec3 paramDiv;
	vec3 localVelocity = tex1Dlod_lerp(TEXTURE_PASS(internalTex0), vec2(nlife, 0), localVelocityDiv);
	vec3 velocity =	  tex1Dlod_lerp(TEXTURE_PASS(internalTex1), vec2(nlife, 0), velocityDiv);
	vec3 params =		tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);
	float rotSpeed = params.x;
	float rotSpeedDiv = paramDiv.y;
	vec3 radialParams = tex1Dlod_lerp(TEXTURE_PASS(internalTex3), vec2(nlife, 0), paramDiv);
	float radialSpeed = radialParams.x;
	float radialSpeedDiv = radialParams.y;
	bool respawn = inLife <= 0.0 || outLife >= lifetime;
	inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;
	inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;
#ifndef LOCAL_SPACE
	vec3 radialVel = inPos - emitterPos;
#else
	vec3 radialVel = inPos;
#endif
	radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);
	radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;
	localVelocity +=	(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;
	velocity +=		 (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;
	rotSpeed +=		 (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;
	addInitialVelocity(localVelocity, rndFactor.xyz);
#ifndef LOCAL_SPACE
	outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;
#else
	outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;
#endif
	outPos = inPos + outVel * delta;
	outAngle = inAngle + rotSpeed * delta;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_billboard.js
var particle_billboardVS = `
	quadXY = rotate(quadXY, inAngle, rotMatrix);
	vec3 localPos = billboard(particlePos, quadXY);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_blendAdd.js
var particle_blendAddPS = `
	dBlendModeFogFactor = 0.0;
	rgb *= saturate(gammaCorrectInput(max(a, 0.0)));
	if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_blendMultiply.js
var particle_blendMultiplyPS = `
	rgb = mix(vec3(1.0), rgb, vec3(a));
	if (rgb.r + rgb.g + rgb.b > 2.99) discard;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_blendNormal.js
var particle_blendNormalPS = `
	if (a < 0.01) discard;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_cpu.js
var particle_cpuVS = `
attribute vec4 particle_vertexData;
attribute vec4 particle_vertexData2;
attribute vec4 particle_vertexData3;
attribute float particle_vertexData4;
#ifndef USE_MESH
attribute vec2 particle_vertexData5;
#else
attribute vec4 particle_vertexData5;
#endif
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;
uniform float numParticles;
uniform float lifetime;
uniform float stretch;
uniform float seed;
uniform vec3 wrapBounds;
uniform vec3 emitterScale;
uniform vec3 faceTangent;
uniform vec3 faceBinorm;
#ifdef PARTICLE_GPU
	uniform highp sampler2D internalTex0;
	uniform highp sampler2D internalTex1;
	uniform highp sampler2D internalTex2;
#endif
uniform vec3 emitterPos;
varying vec4 texCoordsAlphaLife;
vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)
{
	float c = cos(pRotation);
	float s = sin(pRotation);
	mat2 m = mat2(c, -s, s, c);
	rotMatrix = m;
	return m * quadXY;
}
vec3 billboard(vec3 InstanceCoords, vec2 quadXY)
{
	vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
	return pos;
}
vec3 customFace(vec3 InstanceCoords, vec2 quadXY)
{
	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
	return pos;
}
void main(void)
{
	vec3 particlePos = particle_vertexData.xyz;
	vec3 inPos = particlePos;
	vec3 vertPos = particle_vertexData3.xyz;
	vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);
	float id = floor(particle_vertexData4);
	float rndFactor = fract(sin(id + 1.0 + seed));
	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
#ifdef LOCAL_SPACE
	inVel = mat3(matrix_model) * inVel;
#endif
	vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);
	vec2 quadXY = vertPos.xy;
#ifdef USE_MESH
	texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);
#else
	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);
#endif
	mat2 rotMatrix;
	float inAngle = particle_vertexData2.x;
	vec3 particlePosMoved = vec3(0.0);
	vec3 meshLocalPos = particle_vertexData3.xyz;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_cpu_end.js
var particle_cpu_endVS = `
	localPos *= particle_vertexData2.y * emitterScale;
	localPos += particlePos;
	gl_Position = matrix_viewProjection * vec4(localPos, 1.0);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_customFace.js
var particle_customFaceVS = `
	quadXY = rotate(quadXY, inAngle, rotMatrix);
	vec3 localPos = customFace(particlePos, quadXY);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_end.js
var particle_endPS = `
	rgb = addFog(rgb);
	rgb = toneMap(rgb);
	rgb = gammaCorrectOutput(rgb);
	gl_FragColor = vec4(rgb, a);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_end.js
var particle_endVS = `
	localPos *= scale * emitterScale;
	localPos += particlePos;
	#ifdef SCREEN_SPACE
	gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);
	#else
	gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);
	#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_halflambert.js
var particle_halflambertPS = `
	vec3 negNormal = normal*0.5+0.5;
	vec3 posNormal = -normal*0.5+0.5;
	negNormal *= negNormal;
	posNormal *= posNormal;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_init.js
var particle_initVS = `
attribute vec4 particle_vertexData;
#ifdef USE_MESH
attribute vec2 particle_uv;
#endif
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform float numParticles;
uniform float numParticlesPot;
uniform float graphSampleSize;
uniform float graphNumSamples;
uniform float stretch;
uniform vec3 wrapBounds;
uniform vec3 emitterScale;
uniform vec3 emitterPos;
uniform vec3 faceTangent;
uniform vec3 faceBinorm;
uniform float rate;
uniform float rateDiv;
uniform float lifetime;
uniform float deltaRandomnessStatic;
uniform float scaleDivMult;
uniform float alphaDivMult;
uniform float seed;
uniform float delta;
uniform sampler2D particleTexOUT;
uniform sampler2D particleTexIN;
#ifdef PARTICLE_GPU
	uniform highp sampler2D internalTex0;
	uniform highp sampler2D internalTex1;
	uniform highp sampler2D internalTex2;
#endif
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
varying vec4 texCoordsAlphaLife;
vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_lambert.js
var particle_lambertPS = `
	vec3 negNormal = max(normal, vec3(0.0));
	vec3 posNormal = max(-normal, vec3(0.0));
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_lighting.js
var particle_lightingPS = `
	vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +
						negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +
						negNormal.z*lightCube[4] + posNormal.z*lightCube[5];
	rgb *= light;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_localShift.js
var particle_localShiftVS = `
	particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_mesh.js
var particle_meshVS = `
	vec3 localPos = meshLocalPos;
	localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);
	localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);
	billboard(particlePos, quadXY);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_normal.js
var particle_normalVS = `
	Normal = normalize(localPos + matrix_viewInverse[2].xyz);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_normalMap.js
var particle_normalMapPS = `
	vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);
	vec3 normal = ParticleMat * normalMap;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_pointAlong.js
var particle_pointAlongVS = `
	inAngle = atan(velocityV.x, velocityV.y);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_soft.js
var particle_softPS = `
	float depth = getLinearScreenDepth();
	float particleDepth = vDepth;
	float depthDiff = saturate(abs(particleDepth - depth) * softening);
	a *= depthDiff;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_soft.js
var particle_softVS = `
	vDepth = getLinearDepth(localPos);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_stretch.js
var particle_stretchVS = `
	vec3 moveDir = inVel * stretch;
	vec3 posPrev = particlePos - moveDir;
	posPrev += particlePosMoved;
	vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);
	float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;
	particlePos = mix(particlePos, posPrev, interpolation);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_TBN.js
var particle_TBNVS = `
	mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);
	ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_wrap.js
var particle_wrapVS = `
	vec3 origParticlePos = particlePos;
	particlePos -= matrix_model[3].xyz;
	particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;
	particlePos += matrix_model[3].xyz;
	particlePosMoved = particlePos - origParticlePos;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/pick.js
var pickPS = `
uniform uint meshInstanceId;
vec4 getPickOutput() {
	const vec4 inv = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
	const uvec4 shifts = uvec4(16, 8, 0, 24);
	uvec4 col = (uvec4(meshInstanceId) >> shifts) & uvec4(0xff);
	return vec4(col) * inv;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflDir.js
var reflDirPS = `
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
	dReflDirW = normalize(-reflect(viewDir, worldNormal));
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflDirAniso.js
var reflDirAnisoPS = `
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
	float roughness = sqrt(1.0 - min(gloss, 1.0));
	float anisotropy = material_anisotropy * roughness;
	vec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];
	vec3 anisotropicTangent = cross(anisotropicDirection, viewDir);
	vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);
	vec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));
	dReflDirW = reflect(-viewDir, bentNormal);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionCC.js
var reflectionCCPS = `
#ifdef LIT_CLEARCOAT
void addReflectionCC(vec3 reflDir, float gloss) {
	ccReflection += calcReflection(reflDir, gloss);
}
#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionCube.js
var reflectionCubePS = `
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 lookupVec = cubeMapProject(reflDir);
	lookupVec.x *= -1.0;
	return $DECODE(textureCube(texture_cubeMap, lookupVec));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionEnvHQ.js
var reflectionEnvHQPS = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(dir);
	float level = saturate(1.0 - gloss) * 5.0;
	float ilevel = floor(level);
	float flevel = level - ilevel;
	vec3 sharp = $DECODE_CUBEMAP(textureCube(texture_cubeMap, dir));
	vec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));
	vec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionEnv.js
var reflectionEnvPS = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform float material_reflectivity;
float shinyMipLevel(vec2 uv) {
	vec2 dx = dFdx(uv);
	vec2 dy = dFdy(uv);
	vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);
	vec2 dx2 = dFdx(uv2);
	vec2 dy2 = dFdy(uv2);
	float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));
	return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);
}
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(dir);
	float level = saturate(1.0 - gloss) * 5.0;
	float ilevel = floor(level);
	float level2 = shinyMipLevel(uv * atlasSize);
	float ilevel2 = floor(level2);
	vec2 uv0, uv1;
	float weight;
	if (ilevel == 0.0) {
		uv0 = mapShinyUv(uv, ilevel2);
		uv1 = mapShinyUv(uv, ilevel2 + 1.0);
		weight = level2 - ilevel2;
	} else {
		uv0 = uv1 = mapRoughnessUv(uv, ilevel);
		weight = 0.0;
	}
	vec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));
	vec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));
	vec3 linear0 = mix(linearA, linearB, weight);
	vec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(linear0, linear1, level - ilevel));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionSphere.js
var reflectionSpherePS = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;
	float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );
	vec2 sphereMapUv = reflDirV.xy / m + 0.5;
	return $DECODE(texture2D(texture_sphereMap, sphereMapUv));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionSheen.js
var reflectionSheenPS = `
void addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {
	float NoV = dot(worldNormal, viewDir);
	float alphaG = gloss * gloss;
	float a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;
	float b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;
	float DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );
	sReflection += calcReflection(worldNormal, 0.0) * saturate(DG);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/refractionCube.js
var refractionCubePS = `
vec3 refract2(vec3 viewVec, vec3 normal, float IOR) {
	float vn = dot(viewVec, normal);
	float k = 1.0 - IOR * IOR * (1.0 - vn * vn);
	vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;
	return refrVec;
}
void addRefraction(
	vec3 worldNormal, 
	vec3 viewDir, 
	float thickness, 
	float gloss, 
	vec3 specularity, 
	vec3 albedo, 
	float transmission,
	float refractionIndex,
	float dispersion
#if defined(LIT_IRIDESCENCE)
	, vec3 iridescenceFresnel,
	float iridescenceIntensity
#endif 
) {
	vec4 tmpRefl = dReflection;
	vec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);
	dReflection = vec4(0);
	addReflection(reflectionDir, gloss);
	dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);
	dReflection = tmpRefl;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/refractionDynamic.js
var refractionDynamicPS = `
uniform float material_invAttenuationDistance;
uniform vec3 material_attenuation;
vec3 evalRefractionColor(vec3 refractionVector, float gloss, float refractionIndex) {
	vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);
	vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;
	vec2 uv = getGrabScreenPos(projectionPoint);
	float iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);
	float refractionLod = log2(uScreenSize.x) * iorToRoughness;
	vec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;
	return refraction;
}
void addRefraction(
	vec3 worldNormal, 
	vec3 viewDir, 
	float thickness, 
	float gloss, 
	vec3 specularity, 
	vec3 albedo, 
	float transmission,
	float refractionIndex,
	float dispersion
#if defined(LIT_IRIDESCENCE)
	, vec3 iridescenceFresnel,
	float iridescenceIntensity
#endif
) {
	vec3 modelScale;
	modelScale.x = length(vec3(matrix_model[0].xyz));
	modelScale.y = length(vec3(matrix_model[1].xyz));
	modelScale.z = length(vec3(matrix_model[2].xyz));
	vec3 scale = thickness * modelScale;
	vec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;
	vec3 refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);
	#ifdef DISPERSION
		float halfSpread = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;
		float refractionIndexR = refractionIndex - halfSpread;
		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;
		refraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;
		float refractionIndexB = refractionIndex + halfSpread;
		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;
		refraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;
	#endif
	vec3 transmittance;
	if (material_invAttenuationDistance != 0.0)
	{
		vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;
		transmittance = exp(-attenuation * length(refractionVector));
	}
	else
	{
		transmittance = refraction;
	}
	vec3 fresnel = vec3(1.0) - 
		getFresnel(
			dot(viewDir, worldNormal), 
			gloss, 
			specularity
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			iridescenceIntensity
		#endif
		);
	dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/reproject.js
var reprojectPS = `
varying vec2 vUv0;
#ifdef CUBEMAP_SOURCE
	uniform samplerCube sourceCube;
#else
	uniform sampler2D sourceTex;
#endif
#ifdef USE_SAMPLES_TEX
	uniform sampler2D samplesTex;
	uniform vec2 samplesTexInverseSize;
#endif
uniform vec4 params;
float targetFace() { return params.x; }
float specularPower() { return params.y; }
float targetTotalPixels() { return params.z; }
float sourceTotalPixels() { return params.w; }
float PI = 3.141592653589793;
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
${decodePS}
${encodePS}
vec3 modifySeams(vec3 dir, float scale) {
	vec3 adir = abs(dir);
	float M = max(max(adir.x, adir.y), adir.z);
	return dir / M * vec3(
		adir.x == M ? 1.0 : scale,
		adir.y == M ? 1.0 : scale,
		adir.z == M ? 1.0 : scale
	);
}
vec2 toSpherical(vec3 dir) {
	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}
vec3 fromSpherical(vec2 uv) {
	return vec3(cos(uv.y) * sin(uv.x),
				sin(uv.y),
				cos(uv.y) * cos(uv.x));
}
vec3 getDirectionEquirect() {
	return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));
}
float signNotZero(float k){
	return(k >= 0.0) ? 1.0 : -1.0;
}
vec2 signNotZero(vec2 v) {
	return vec2(signNotZero(v.x), signNotZero(v.y));
}
vec3 octDecode(vec2 o) {
	vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);
	if (v.y < 0.0) {
		v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);
	}
	return normalize(v);
}
vec3 getDirectionOctahedral() {
	return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);
}
vec2 octEncode(in vec3 v) {
	float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
	vec2 result = v.xz * (1.0 / l1norm);
	if (v.y < 0.0) {
		result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
	}
	return result;
}
#ifdef CUBEMAP_SOURCE
	vec4 sampleCubemap(vec3 dir) {
		return textureCube(sourceCube, modifySeams(dir, 1.0));
	}
	vec4 sampleCubemap(vec2 sph) {
	return sampleCubemap(fromSpherical(sph));
}
	vec4 sampleCubemap(vec3 dir, float mipLevel) {
		return textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0), mipLevel);
	}
	vec4 sampleCubemap(vec2 sph, float mipLevel) {
		return sampleCubemap(fromSpherical(sph), mipLevel);
	}
#else
	vec4 sampleEquirect(vec2 sph) {
		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
	}
	vec4 sampleEquirect(vec3 dir) {
		return sampleEquirect(toSpherical(dir));
	}
	vec4 sampleEquirect(vec2 sph, float mipLevel) {
		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
		return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
	}
	vec4 sampleEquirect(vec3 dir, float mipLevel) {
		return sampleEquirect(toSpherical(dir), mipLevel);
	}
	vec4 sampleOctahedral(vec3 dir) {
		vec2 uv = octEncode(dir) * 0.5 + 0.5;
		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
	}
	vec4 sampleOctahedral(vec2 sph) {
		return sampleOctahedral(fromSpherical(sph));
	}
	vec4 sampleOctahedral(vec3 dir, float mipLevel) {
		vec2 uv = octEncode(dir) * 0.5 + 0.5;
		return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
	}
	vec4 sampleOctahedral(vec2 sph, float mipLevel) {
		return sampleOctahedral(fromSpherical(sph), mipLevel);
	}
#endif
vec3 getDirectionCubemap() {
	vec2 st = vUv0 * 2.0 - 1.0;
	float face = targetFace();
	vec3 vec;
	if (face == 0.0) {
		vec = vec3(1, -st.y, -st.x);
	} else if (face == 1.0) {
		vec = vec3(-1, -st.y, st.x);
	} else if (face == 2.0) {
		vec = vec3(st.x, 1, st.y);
	} else if (face == 3.0) {
		vec = vec3(st.x, -1, -st.y);
	} else if (face == 4.0) {
		vec = vec3(st.x, -st.y, 1);
	} else {
		vec = vec3(-st.x, -st.y, -1);
	}
	return normalize(modifySeams(vec, 1.0));
}
mat3 matrixFromVector(vec3 n) {
	float a = 1.0 / (1.0 + n.z);
	float b = -n.x * n.y * a;
	vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);
	vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);
	return mat3(b1, b2, n);
}
mat3 matrixFromVectorSlow(vec3 n) {
	vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);
	vec3 x = normalize(cross(up, n));
	vec3 y = cross(n, x);
	return mat3(x, y, n);
}
vec4 reproject() {
	if (NUM_SAMPLES <= 1) {
		return ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));
	} else {
		vec3 t = TARGET_FUNC();
		vec3 tu = dFdx(t);
		vec3 tv = dFdy(t);
		vec3 result = vec3(0.0);
		for (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {
			for (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {
				result += DECODE_FUNC(SOURCE_FUNC(normalize(t +
															tu * (u / NUM_SAMPLES_SQRT - 0.5) +
															tv * (v / NUM_SAMPLES_SQRT - 0.5))));
			}
		}
		return ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));
	}
}
vec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);
#ifdef USE_SAMPLES_TEX
	void unpackSample(int i, out vec3 L, out float mipLevel) {
		float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;
		float v = (floor(u) + 0.5) * samplesTexInverseSize.y;
		vec4 raw;
		raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);
		L.xyz = raw.xyz * 2.0 - 1.0;
		mipLevel = raw.w * 8.0;
	}
	vec4 prefilterSamples() {
		mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());
		vec3 L;
		float mipLevel;
		vec3 result = vec3(0.0);
		float totalWeight = 0.0;
		for (int i = 0; i < NUM_SAMPLES; ++i) {
			unpackSample(i, L, mipLevel);
			result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;
			totalWeight += L.z;
		}
		return ENCODE_FUNC(result / totalWeight);
	}
	vec4 prefilterSamplesUnweighted() {
		mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());
		vec3 L;
		float mipLevel;
		vec3 result = vec3(0.0);
		float totalWeight = 0.0;
		for (int i = 0; i < NUM_SAMPLES; ++i) {
			unpackSample(i, L, mipLevel);
			result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));
		}
		return ENCODE_FUNC(result / float(NUM_SAMPLES));
	}
#endif
void main(void) {
	gl_FragColor = PROCESS_FUNC();
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/sampleCatmullRom.js
var sampleCatmullRomPS = `
vec4 SampleTextureCatmullRom(TEXTURE_ACCEPT(tex), vec2 uv, vec2 texSize) {
	vec2 samplePos = uv * texSize;
	vec2 texPos1 = floor(samplePos - 0.5) + 0.5;
	vec2 f = samplePos - texPos1;
	vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));
	vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);
	vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));
	vec2 w3 = f * f * (-0.5 + 0.5 * f);
	vec2 w12 = w1 + w2;
	vec2 offset12 = w2 / (w1 + w2);
	vec2 texPos0 = (texPos1 - 1.0) / texSize;
	vec2 texPos3 = (texPos1 + 2.0) / texSize;
	vec2 texPos12 = (texPos1 + offset12) / texSize;
	vec4 result = vec4(0.0);
	result += texture2DLodEXT(tex, vec2(texPos0.x, texPos0.y), 0.0) * w0.x * w0.y;
	result += texture2DLodEXT(tex, vec2(texPos12.x, texPos0.y), 0.0) * w12.x * w0.y;
	result += texture2DLodEXT(tex, vec2(texPos3.x, texPos0.y), 0.0) * w3.x * w0.y;
	result += texture2DLodEXT(tex, vec2(texPos0.x, texPos12.y), 0.0) * w0.x * w12.y;
	result += texture2DLodEXT(tex, vec2(texPos12.x, texPos12.y), 0.0) * w12.x * w12.y;
	result += texture2DLodEXT(tex, vec2(texPos3.x, texPos12.y), 0.0) * w3.x * w12.y;
	result += texture2DLodEXT(tex, vec2(texPos0.x, texPos3.y), 0.0) * w0.x * w3.y;
	result += texture2DLodEXT(tex, vec2(texPos12.x, texPos3.y), 0.0) * w12.x * w3.y;
	result += texture2DLodEXT(tex, vec2(texPos3.x, texPos3.y), 0.0) * w3.x * w3.y;
	return result;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/screenDepth.js
var screenDepthPS = `
uniform highp sampler2D uSceneDepthMap;
#ifndef SCREENSIZE
#define SCREENSIZE
uniform vec4 uScreenSize;
#endif
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
#ifndef LINEARIZE_DEPTH
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
#define LINEARIZE_DEPTH
float linearizeDepth(float z) {
	if (camera_params.w == 0.0)
		return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));
	else
		return camera_params.z + z * (camera_params.y - camera_params.z);
}
#endif
float getLinearScreenDepth(vec2 uv) {
	return linearizeDepth(texture2D(uSceneDepthMap, uv).r);
}
#ifndef VERTEXSHADER
float getLinearScreenDepth() {
	vec2 uv = gl_FragCoord.xy * uScreenSize.zw;
	return getLinearScreenDepth(uv);
}
#endif
float getLinearDepth(vec3 pos) {
	return -(matrix_view * vec4(pos, 1.0)).z;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowCascades.js
var shadowCascadesPS = `
const float maxCascades = 4.0;
mat4 cascadeShadowMat;
void getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {
	float depth = 1.0 / gl_FragCoord.w;
	float cascadeIndex = 0.0;
	for (float i = 0.0; i < maxCascades; i++) {
		if (depth < shadowCascadeDistances[int(i)]) {
			cascadeIndex = i;
			break;
		}
	}
	cascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);
	cascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];
}
void fadeShadow(float shadowCascadeDistances[4]) {				  
	float depth = 1.0 / gl_FragCoord.w;
	if (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {
		dShadowCoord.z = -9999999.0;
	}
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowEVSM.js
var shadowEVSMPS = `
float VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	vec3 moments = texture2D(tex, texCoords).xyz;
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
float getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
float getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowEVSMn.js
var shadowEVSMnPS = `
float VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	float pixelSize = 1.0 / resolution;
	texCoords -= vec2(pixelSize);
	vec3 s00 = texture2D(tex, texCoords).xyz;
	vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;
	vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;
	vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;
	vec2 fr = fract(texCoords * resolution);
	vec3 h0 = mix(s00, s10, fr.x);
	vec3 h1 = mix(s01, s11, fr.x);
	vec3 moments = mix(h0, h1, fr.y);
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
float getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
float getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowPCSS.js
var shadowPCSSPS = `
#define PCSS_SAMPLE_COUNT 16
uniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];
uniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];
vec2 vogelDisk(int sampleIndex, float count, float phi, float r) {
	const float GoldenAngle = 2.4;
	float theta = float(sampleIndex) * GoldenAngle + phi;
	float sine = sin(theta);
	float cosine = cos(theta);
	return vec2(r * cosine, r * sine);
}
vec3 vogelSphere(int sampleIndex, float count, float phi, float r) {
	const float GoldenAngle = 2.4;
	float theta = float(sampleIndex) * GoldenAngle + phi;
	float weight = float(sampleIndex) / count;
	return vec3(cos(theta) * r, weight, sin(theta) * r);
}
float noise(vec2 screenPos) {
	const float PHI = 1.61803398874989484820459;
	return fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);
}
float viewSpaceDepth(float depth, mat4 invProjection) {
	float z = depth * 2.0 - 1.0;
	vec4 clipSpace = vec4(0.0, 0.0, z, 1.0);
	vec4 viewSpace = invProjection * clipSpace;
	return viewSpace.z;
}
float PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z) {
	float blockers = 0.0;
	float averageBlocker = 0.0;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		vec2 offset = sampleCoords[i] * searchSize;
		vec2 sampleUV = shadowCoords + offset;
		float blocker = textureLod(shadowMap, sampleUV, 0.0).r;
		float isBlocking = step(blocker, z);
		blockers += isBlocking;
		averageBlocker += blocker * isBlocking;
	}
	if (blockers > 0.0)
		return averageBlocker /= blockers;
	return -1.0;
}
float PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {
	float receiverDepth = shadowCoords.z;
	vec2 samplePoints[PCSS_SAMPLE_COUNT];
	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		float pcssPresample = pcssDiskSamples[i];
		samplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);
	}
	float averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth);
	if (averageBlocker == -1.0) {
		return 1.0;
	} else {
		vec2 filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea * cameraParams.x;
		float shadow = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)
		{
			vec2 sampleUV = samplePoints[i] * filterRadius;
			sampleUV = shadowCoords.xy + sampleUV;
			float depth = textureLod(shadowMap, sampleUV, 0.0).r;
			shadow += step(receiverDepth, depth);
		}
		return shadow / float(PCSS_SAMPLE_COUNT);
	} 
}
float PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {
	float blockers = 0.0;
	float averageBlocker = 0.0;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		vec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;
		sampleDir = normalize(sampleDir);
		float blocker = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
		float isBlocking = step(blocker, z);
		blockers += isBlocking;
		averageBlocker += blocker * isBlocking;
	}
	if (blockers > 0.0)
		return averageBlocker /= float(blockers);
	return -1.0;
}
float PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {
	
	vec3 samplePoints[PCSS_SAMPLE_COUNT];
	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		float r = pcssSphereSamples[i];
		samplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);
	}
	float receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;
	vec3 lightDirNorm = normalize(lightDir);
	
	float averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);
	if (averageBlocker == -1.0) {
		return 1.0;
	} else {
		float filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;
		float shadow = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++)
		{
			vec3 offset = samplePoints[i] * filterRadius;
			vec3 sampleDir = lightDirNorm + offset;
			sampleDir = normalize(sampleDir);
			float depth = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
			shadow += step(receiverDepth, depth);
		}
		return shadow / float(PCSS_SAMPLE_COUNT);
	}
}
float getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);
}
float getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}
float getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowSampleCoord.js
var shadowSampleCoordPS = `
vec3 getShadowSampleCoord$LIGHT(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
	vec3 surfacePosition = worldPosition;
#ifdef SHADOW_SAMPLE_POINT
	#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
		float distScale = length(lightDir);
		surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
		lightDir = surfacePosition - lightPos;
		return lightDir;
	#endif
#else
	#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
		#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
			surfacePosition = worldPosition + normal * shadowParams.y;
		#endif
	#else
		#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
			#ifdef SHADOW_SAMPLE_ORTHO
				float distScale = 1.0;
			#else
				float distScale = abs(dot(vPositionW - lightPos, lightDirNorm));
			#endif
			surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
		#endif
	#endif
	vec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);
	#ifdef SHADOW_SAMPLE_ORTHO
		positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;
	#else
		#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
			positionInShadowSpace.xyz /= positionInShadowSpace.w;
		#else
			positionInShadowSpace.xy /= positionInShadowSpace.w;
			positionInShadowSpace.z = length(lightDir) * shadowParams.w;
		#endif
	#endif
	#ifdef SHADOW_SAMPLE_Z_BIAS
		positionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);
	#endif
	surfacePosition = positionInShadowSpace.xyz;
#endif
	return surfacePosition;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowStandard.js
var shadowStandardPS = `
vec3 lessThan2(vec3 a, vec3 b) {
	return clamp((b - a)*1000.0, 0.0, 1.0);
}
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
	float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
	}
#endif
float _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
	float z = shadowCoord.z;
	vec2 uv = shadowCoord.xy * shadowParams.x;
	float shadowMapSizeInv = 1.0 / shadowParams.x;
	vec2 base_uv = floor(uv + 0.5);
	float s = (uv.x + 0.5 - base_uv.x);
	float t = (uv.y + 0.5 - base_uv.y);
	base_uv -= vec2(0.5);
	base_uv *= shadowMapSizeInv;
	float sum = 0.0;
	float uw0 = (3.0 - 2.0 * s);
	float uw1 = (1.0 + 2.0 * s);
	float u0 = (2.0 - s) / uw0 - 1.0;
	float u1 = s / uw1 + 1.0;
	float vw0 = (3.0 - 2.0 * t);
	float vw1 = (1.0 + 2.0 * t);
	float v0 = (2.0 - t) / vw0 - 1.0;
	float v1 = t / vw1 + 1.0;
	u0 = u0 * shadowMapSizeInv + base_uv.x;
	v0 = v0 * shadowMapSizeInv + base_uv.y;
	u1 = u1 * shadowMapSizeInv + base_uv.x;
	v1 = v1 * shadowMapSizeInv + base_uv.y;
	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
	sum *= 1.0f / 16.0;
	return sum;
}
float getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
float getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
#ifndef WEBGPU
float _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {
	vec3 tc = normalize(dir);
	vec3 tcAbs = abs(tc);
	vec4 dirX = vec4(1,0,0, tc.x);
	vec4 dirY = vec4(0,1,0, tc.y);
	float majorAxisLength = tc.z;
	if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {
		dirX = vec4(0,0,1, tc.z);
		dirY = vec4(0,1,0, tc.y);
		majorAxisLength = tc.x;
	} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {
		dirX = vec4(1,0,0, tc.x);
		dirY = vec4(0,0,1, tc.z);
		majorAxisLength = tc.y;
	}
	float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);
	vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);
	vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);
	vec3 dx0 = -xoffset;
	vec3 dy0 = -yoffset;
	vec3 dx1 = xoffset;
	vec3 dy1 = yoffset;
	mat3 shadowKernel;
	mat3 depthKernel;
	depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));
	depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));
	depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));
	depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));
	depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));
	depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));
	depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));
	depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));
	depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));
	vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);
	shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));
	shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));
	shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));
	vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;
	vec2 fractionalCoord = fract( uv * shadowParams.x );
	shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
	shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);
	vec4 shadowValues;
	shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
	shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
	shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
	shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);
	return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}
float getShadowPointPCF3x3(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {
	return _getShadowPoint(shadowMap, shadowParams, lightDir);
}
#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowStandardGL2.js
var shadowStandardGL2PS = `
float _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
	float z = shadowCoord.z;
	vec2 uv = shadowCoord.xy * shadowParams.x;
	float shadowMapSizeInv = 1.0 / shadowParams.x;
	vec2 base_uv = floor(uv + 0.5);
	float s = (uv.x + 0.5 - base_uv.x);
	float t = (uv.y + 0.5 - base_uv.y);
	base_uv -= vec2(0.5);
	base_uv *= shadowMapSizeInv;
	float uw0 = (4.0 - 3.0 * s);
	float uw1 = 7.0;
	float uw2 = (1.0 + 3.0 * s);
	float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;
	float u1 = (3.0 + s) / uw1;
	float u2 = s / uw2 + 2.0;
	float vw0 = (4.0 - 3.0 * t);
	float vw1 = 7.0;
	float vw2 = (1.0 + 3.0 * t);
	float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;
	float v1 = (3.0 + t) / vw1;
	float v2 = t / vw2 + 2.0;
	float sum = 0.0;
	u0 = u0 * shadowMapSizeInv + base_uv.x;
	v0 = v0 * shadowMapSizeInv + base_uv.y;
	u1 = u1 * shadowMapSizeInv + base_uv.x;
	v1 = v1 * shadowMapSizeInv + base_uv.y;
	u2 = u2 * shadowMapSizeInv + base_uv.x;
	v2 = v2 * shadowMapSizeInv + base_uv.y;
	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
	sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));
	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
	sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));
	sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));
	sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));
	sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));
	sum *= 1.0f / 144.0;
	sum = saturate(sum);
	return sum;
}
float getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowVSM8.js
var shadowVSM8PS = `
float calculateVSM8(vec3 moments, float Z, float vsmBias) {
	float VSMBias = vsmBias;
	float depthScale = VSMBias * Z;
	float minVariance1 = depthScale * depthScale;
	return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);
}
float decodeFloatRG(vec2 rg) {
	return rg.y*(1.0/255.0) + rg.x;
}
float VSM8(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	vec4 c = texture2D(tex, texCoords);
	vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);
	return calculateVSM8(moments, Z, vsmBias);
}
float getShadowVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, 0.0);
}
float getShadowSpotVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowVSM_common.js
var shadowVSM_commonPS = `
float linstep(float a, float b, float v) {
	return saturate((v - a) / (b - a));
}
float reduceLightBleeding(float pMax, float amount) {
	 return linstep(amount, 1.0, pMax);
}
float chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {
	float variance = moments.y - (moments.x * moments.x);
	variance = max(variance, minVariance);
	float d = mean - moments.x;
	float pMax = variance / (variance + (d * d));
	pMax = reduceLightBleeding(pMax, lightBleedingReduction);
	return (mean <= moments.x ? 1.0 : pMax);
}
float calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {
	Z = 2.0 * Z - 1.0;
	float warpedDepth = exp(exponent * Z);
	moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);
	float VSMBias = vsmBias;
	float depthScale = VSMBias * exponent * warpedDepth;
	float minVariance1 = depthScale * depthScale;
	return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/skinBatchTex.js
var skinBatchTexVS = `
attribute float vertex_boneIndices;
uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;
mat4 getBoneMatrix(const in float i) {
	float j = i * 3.0;
	float dx = texture_poseMapSize.z;
	float dy = texture_poseMapSize.w;
	float y = floor(j * dx);
	float x = j - (y * texture_poseMapSize.x);
	y = dy * (y + 0.5);
	vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
	vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
	vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, 1
	);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/skinTex.js
var skinTexVS = `
attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;
uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;
void getBoneMatrix(const in float index, out vec4 v1, out vec4 v2, out vec4 v3) {
	float i = float(index);
	float j = i * 3.0;
	float dx = texture_poseMapSize.z;
	float dy = texture_poseMapSize.w;
	
	float y = floor(j * dx);
	float x = j - (y * texture_poseMapSize.x);
	y = dy * (y + 0.5);
	v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
	v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
	v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));
}
mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
	vec4 a1, a2, a3;
	getBoneMatrix(indices.x, a1, a2, a3);
	vec4 b1, b2, b3;
	getBoneMatrix(indices.y, b1, b2, b3);
	vec4 c1, c2, c3;
	getBoneMatrix(indices.z, c1, c2, c3);
	vec4 d1, d2, d3;
	getBoneMatrix(indices.w, d1, d2, d3);
	vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
	vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
	vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;
	float one = dot(weights, vec4(1.0));
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, one
	);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/skybox/frag/skyboxEnv.js
var skyboxEnvPS = `
varying vec3 vViewDir;
uniform sampler2D texture_envAtlas;
uniform float mipLevel;
void main(void) {
	vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(normalize(dir));
	vec3 linear = SKYBOX_DECODE_FNC(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));
	gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/skybox/frag/skyboxHDR.js
var skyboxHDRPS = `
varying vec3 vViewDir;
uniform samplerCube texture_cubeMap;
#ifdef SKYMESH
	varying vec3 vWorldPos;
	uniform mat3 cubeMapRotationMatrix;
	uniform vec3 projectedSkydomeCenter;
#endif
void main(void) {
	#ifdef SKYMESH
		vec3 envDir = normalize(vWorldPos - projectedSkydomeCenter);
		vec3 dir = envDir * cubeMapRotationMatrix;
	#else
		vec3 dir = vViewDir;
	#endif
	dir.x *= -1.0;
	vec3 linear = SKYBOX_DECODE_FNC(textureCube(texture_cubeMap, dir));
	gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/skybox/vert/skybox.js
var skyboxVS = `
attribute vec3 aPosition;
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform mat4 matrix_projectionSkybox;
uniform mat3 cubeMapRotationMatrix;
varying vec3 vViewDir;
#ifdef SKYMESH
	uniform mat4 matrix_model;
	varying vec3 vWorldPos;
#endif
void main(void) {
	mat4 view = matrix_view;
	#ifdef SKYMESH
		vec4 worldPos = matrix_model * vec4(aPosition, 1.0);
		vWorldPos = worldPos.xyz;
		gl_Position = matrix_projectionSkybox * view * worldPos;
	#else
		view[3][0] = view[3][1] = view[3][2] = 0.0;
		gl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);
		vViewDir = aPosition * cubeMapRotationMatrix;
	#endif
	gl_Position.z = gl_Position.w - 1.0e-7;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/specular.js
var specularPS = `
#ifdef MAPCOLOR
uniform vec3 material_specular;
#endif
void getSpecularity() {
	vec3 specularColor = vec3(1,1,1);
	#ifdef MAPCOLOR
	specularColor *= material_specular;
	#endif
	#ifdef MAPTEXTURE
	specularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	specularColor *= saturate(vVertexColor.$VC);
	#endif
	dSpecularity = specularColor;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/spherical.js
var sphericalPS = `
const float PI = 3.141592653589793;
vec2 toSpherical(vec3 dir) {
	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}
vec2 toSphericalUv(vec3 dir) {
	vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;
	return vec2(uv.x, 1.0 - uv.y);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/specularityFactor.js
var specularityFactorPS = `
#ifdef MAPFLOAT
uniform float material_specularityFactor;
#endif
void getSpecularityFactor() {
	float specularityFactor = 1.0;
	#ifdef MAPFLOAT
	specularityFactor *= material_specularityFactor;
	#endif
	#ifdef MAPTEXTURE
	specularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	specularityFactor *= saturate(vVertexColor.$VC);
	#endif
	dSpecularityFactor = specularityFactor;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/spot.js
var spotPS = `
float getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {
	float cosAngle = dot(lightDirNorm, lightSpotDir);
	return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/start.js
var startPS = `
void main(void) {
	dReflection = vec4(0);
	#ifdef LIT_CLEARCOAT
	ccSpecularLight = vec3(0);
	ccReflection = vec3(0);
	#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/start.js
var startVS = `
void main(void) {
	gl_Position = getPosition();
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/startNineSliced.js
var startNineSlicedPS = `
	nineSlicedUv = vUv0;
	nineSlicedUv.y = 1.0 - nineSlicedUv.y;
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/startNineSlicedTiled.js
var startNineSlicedTiledPS = `
	vec2 tileMask = step(vMask, vec2(0.99999));
	vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);
	vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);
	vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));
	clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;
	nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);
	nineSlicedUv.y = 1.0 - nineSlicedUv.y;
	
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/storeEVSM.js
var storeEVSMPS = `
float exponent = VSM_EXPONENT;
depth = 2.0 * depth - 1.0;
depth =  exp(exponent * depth);
gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/tangentBinormal.js
var tangentBinormalVS = `
vec3 getTangent() {
	return normalize(dNormalMatrix * vertex_tangent.xyz);
}
vec3 getBinormal() {
	return cross(vNormalW, vTangentW) * vertex_tangent.w;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/TBN.js
var TBNPS = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	dTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/TBNderivative.js
var TBNderivativePS = `
uniform float tbnBasis;
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	vec2 uv = $UV;
	vec3 dp1 = dFdx( vPositionW );
	vec3 dp2 = dFdy( vPositionW );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	vec3 dp2perp = cross( dp2, normal );
	vec3 dp1perp = cross( normal, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
	float denom = max( dot(T,T), dot(B,B) );
	float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );
	dTBN = mat3(T * invmax, -B * invmax, normal );
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/TBNObjectSpace.js
var TBNObjectSpacePS = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	vec3 B = cross(normal, vObjectSpaceUpW);
	vec3 T = cross(normal, B);
	if (dot(B,B)==0.0)
	{
		float major=max(max(normal.x, normal.y), normal.z);
		if (normal.x == major)
		{
			B=cross(normal, vec3(0,1,0));
			T=cross(normal, B);
		}
		else if (normal.y == major)
		{
			B=cross(normal, vec3(0,0,1));
			T=cross(normal, B);
		}
		else if (normal.z == major)
		{
			B=cross(normal, vec3(1,0,0));
			T=cross(normal, B);
		}
	}
	dTBN = mat3(normalize(T), normalize(B), normalize(normal));
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/thickness.js
var thicknessPS = `
#ifdef MAPFLOAT
uniform float material_thickness;
#endif
void getThickness() {
	dThickness = 1.0;
	#ifdef MAPFLOAT
	dThickness *= material_thickness;
	#endif
	#ifdef MAPTEXTURE
	dThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	dThickness *= saturate(vVertexColor.$VC);
	#endif
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingAces.js
var tonemappingAcesPS = `
uniform float exposure;
vec3 toneMap(vec3 color) {
	float tA = 2.51;
	float tB = 0.03;
	float tC = 2.43;
	float tD = 0.59;
	float tE = 0.14;
	vec3 x = color * exposure;
	return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingAces2.js
var tonemappingAces2PS = `
uniform float exposure;
const mat3 ACESInputMat = mat3(
	0.59719, 0.35458, 0.04823,
	0.07600, 0.90834, 0.01566,
	0.02840, 0.13383, 0.83777
);
const mat3 ACESOutputMat = mat3(
	 1.60475, -0.53108, -0.07367,
	-0.10208,  1.10813, -0.00605,
	-0.00327, -0.07276,  1.07602
);
vec3 RRTAndODTFit(vec3 v) {
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return a / b;
}
vec3 toneMap(vec3 color) {
	color *= exposure / 0.6;
	color = color * ACESInputMat;
	color = RRTAndODTFit(color);
	color = color * ACESOutputMat;
	color = clamp(color, 0.0, 1.0);
	return color;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingFilmic.js
var tonemappingFilmicPS = `
const float A =  0.15;
const float B =  0.50;
const float C =  0.10;
const float D =  0.20;
const float E =  0.02;
const float F =  0.30;
const float W =  11.2;
uniform float exposure;
vec3 uncharted2Tonemap(vec3 x) {
	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}
vec3 toneMap(vec3 color) {
	color = uncharted2Tonemap(color * exposure);
	vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));
	color = color * whiteScale;
	return color;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingHejl.js
var tonemappingHejlPS = `
uniform float exposure;
vec3 toneMap(vec3 color) {
	color *= exposure;
	const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;
	const float Scl = 1.25;
	vec3 h = max( vec3(0.0), color - vec3(0.004) );
	return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingLinear.js
var tonemappingLinearPS = `
uniform float exposure;
vec3 toneMap(vec3 color) {
	return color * exposure;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingNeutral.js
var tonemappingNeutralPS = `
uniform float exposure;
vec3 toneMap(vec3 color) {
	color *= exposure;
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, newPeak * vec3(1, 1, 1), g);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingNone.js
var tonemappingNonePS = `
vec3 toneMap(vec3 color) {
	return color;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/transform.js
var transformVS = `
#ifdef PIXELSNAP
uniform vec4 uScreenSize;
#endif
#ifdef SCREENSPACE
uniform float projectionFlipY;
#endif
vec4 evalWorldPosition(vec3 vertexPosition, mat4 modelMatrix) {
	vec3 localPos = getLocalPosition(vertexPosition);
	#ifdef NINESLICED
		localPos.xz *= outerScale;
		vec2 positiveUnitOffset = clamp(vertexPosition.xz, vec2(0.0), vec2(1.0));
		vec2 negativeUnitOffset = clamp(-vertexPosition.xz, vec2(0.0), vec2(1.0));
		localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;
		vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;
		localPos.xz *= -0.5;
		localPos = localPos.xzy;
	#endif
	vec4 posW = modelMatrix * vec4(localPos, 1.0);
	#ifdef SCREENSPACE
		posW.zw = vec2(0.0, 1.0);
	#endif
	return posW;
}
vec4 getPosition() {
	dModelMatrix = getModelMatrix();
	vec4 posW = evalWorldPosition(vertex_position.xyz, dModelMatrix);
	dPositionW = posW.xyz;
	vec4 screenPos;
	#ifdef UV1LAYOUT
	screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);
		#ifdef WEBGPU
		screenPos.y *= -1.0;
		#endif
	#else
	#ifdef SCREENSPACE
	screenPos = posW;
	screenPos.y *= projectionFlipY;
	#else
	screenPos = matrix_viewProjection * posW;
	#endif
	#ifdef PIXELSNAP
	screenPos.xy = (screenPos.xy * 0.5) + 0.5;
	screenPos.xy *= uScreenSize.xy;
	screenPos.xy = floor(screenPos.xy);
	screenPos.xy *= uScreenSize.zw;
	screenPos.xy = (screenPos.xy * 2.0) - 1.0;
	#endif
	#endif
	return screenPos;
}
vec3 getWorldPosition() {
	return dPositionW;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/transformCore.js
var transformCoreVS = `
attribute vec4 vertex_position;
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
#ifdef MORPHING
	uniform vec2 morph_tex_params;
	attribute uint morph_vertex_id;
	ivec2 getTextureMorphCoords() {
		ivec2 textureSize = ivec2(morph_tex_params);
		int morphGridV = int(morph_vertex_id) / textureSize.x;
		int morphGridU = int(morph_vertex_id) - (morphGridV * textureSize.x);
		#ifdef WEBGPU
			morphGridV = textureSize.y - morphGridV - 1;
		#endif
		return ivec2(morphGridU, morphGridV);
	}
	#ifdef MORPHING_POSITION
		#ifdef MORPHING_INT
			uniform vec3 aabbSize;
			uniform vec3 aabbMin;
			uniform usampler2D morphPositionTex;
		#else
			uniform highp sampler2D morphPositionTex;
		#endif
	#endif
#endif
#ifdef defined(BATCH)
	#include "skinBatchTexVS"
	mat4 getModelMatrix() {
		return getBoneMatrix(vertex_boneIndices);
	}
#elif defined(SKIN)
	#include "skinTexVS"
	mat4 getModelMatrix() {
		return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);
	}
#elif defined(INSTANCING)
	#include "transformInstancing"
#else
	mat4 getModelMatrix() {
		return matrix_model;
	}
#endif
vec3 getLocalPosition(vec3 vertexPosition) {
	vec3 localPos = vertexPosition;
	#ifdef MORPHING_POSITION
		ivec2 morphUV = getTextureMorphCoords();
		#ifdef MORPHING_INT
			vec3 morphPos = vec3(texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz) / 65535.0 * aabbSize + aabbMin;
		#else
			vec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;
		#endif
		localPos += morphPos;
	#endif
	return localPos;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/transformInstancing.js
var transformInstancingVS = `
attribute vec4 instance_line1;
attribute vec4 instance_line2;
attribute vec4 instance_line3;
attribute vec4 instance_line4;
mat4 getModelMatrix() {
	return matrix_model * mat4(instance_line1, instance_line2, instance_line3, instance_line4);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/transmission.js
var transmissionPS = `
#ifdef MAPFLOAT
uniform float material_refraction;
#endif
void getRefraction() {
	float refraction = 1.0;
	#ifdef MAPFLOAT
	refraction = material_refraction;
	#endif
	#ifdef MAPTEXTURE
	refraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	refraction *= saturate(vVertexColor.$VC);
	#endif
	dTransmission = refraction;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/twoSidedLighting.js
var twoSidedLightingPS = `
uniform float twoSidedLightingNegScaleFactor;
void handleTwoSidedLighting() {
	dTBN[2] *= gl_FrontFacing ? twoSidedLightingNegScaleFactor : -twoSidedLightingNegScaleFactor;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/uv0.js
var uv0VS = `
#ifdef NINESLICED
vec2 getUv0() {
	vec2 uv = vertex_position.xz;
	vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
	vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
	uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;
	uv = uv * -0.5 + 0.5;
	uv = uv * atlasRect.zw + atlasRect.xy;
	vMask = vertex_texCoord0.xy;
	return uv;
}
#else
vec2 getUv0() {
	return vertex_texCoord0;
}
#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/uv1.js
var uv1VS = `
vec2 getUv1() {
	return vertex_texCoord1;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/viewDir.js
var viewDirPS = `
void getViewDir() {
	dViewDirW = normalize(view_position - vPositionW);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/viewNormal.js
var viewNormalVS = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
vec3 getViewNormal() {
	return mat3(matrix_view) * vNormalW;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/chunks.js
var shaderChunks = {
  alphaTestPS,
  ambientConstantPS,
  ambientEnvPS,
  ambientSHPS,
  aoPS,
  aoDetailMapPS,
  aoDiffuseOccPS,
  aoSpecOccPS,
  aoSpecOccConstPS,
  aoSpecOccConstSimplePS,
  aoSpecOccSimplePS,
  basePS,
  baseVS,
  baseNineSlicedPS,
  baseNineSlicedVS,
  baseNineSlicedTiledPS,
  bayerPS,
  blurVSMPS,
  clearCoatPS,
  clearCoatGlossPS,
  clearCoatNormalPS,
  clusteredLightCookiesPS,
  clusteredLightShadowsPS,
  clusteredLightUtilsPS,
  clusteredLightPS,
  combinePS,
  cookiePS,
  cubeMapProjectBoxPS,
  cubeMapProjectNonePS,
  cubeMapRotatePS,
  debugOutputPS,
  debugProcessFrontendPS,
  detailModesPS,
  diffusePS,
  diffuseDetailMapPS,
  decodePS,
  emissivePS,
  encodePS,
  endPS,
  endVS,
  envAtlasPS,
  envConstPS,
  envMultiplyPS,
  falloffInvSquaredPS,
  falloffLinearPS,
  floatUnpackingPS,
  fogExpPS,
  fogExp2PS,
  fogLinearPS,
  fogNonePS,
  fresnelSchlickPS,
  fullscreenQuadPS,
  fullscreenQuadVS,
  gamma1_0PS,
  gamma2_2PS,
  gles3PS,
  gles3VS,
  glossPS,
  iridescenceDiffractionPS,
  iridescencePS,
  iridescenceThicknessPS,
  iorPS,
  lightDiffuseLambertPS,
  lightDirPointPS,
  lightmapAddPS,
  lightmapDirAddPS,
  lightmapDirPS,
  lightmapSinglePS,
  lightSpecularAnisoGGXPS,
  lightSpecularBlinnPS,
  lightSheenPS,
  linearizeDepthPS,
  litShaderArgsPS,
  ltcPS,
  metalnessPS,
  metalnessModulatePS,
  msdfPS,
  msdfVS,
  normalVS,
  normalCoreVS,
  normalDetailMapPS,
  normalMapPS,
  normalXYPS,
  normalXYZPS,
  opacityPS,
  opacityDitherPS,
  outputPS,
  outputAlphaPS,
  outputAlphaOpaquePS,
  outputAlphaPremulPS,
  outputTex2DPS,
  packDepthPS,
  sheenPS,
  sheenGlossPS,
  parallaxPS,
  particlePS,
  particleVS,
  particleAnimFrameClampVS,
  particleAnimFrameLoopVS,
  particleAnimTexVS,
  particleInputFloatPS,
  particleInputRgba8PS,
  particleOutputFloatPS,
  particleOutputRgba8PS,
  particleUpdaterAABBPS,
  particleUpdaterEndPS,
  particleUpdaterInitPS,
  particleUpdaterNoRespawnPS,
  particleUpdaterOnStopPS,
  particleUpdaterRespawnPS,
  particleUpdaterSpherePS,
  particleUpdaterStartPS,
  particle_billboardVS,
  particle_blendAddPS,
  particle_blendMultiplyPS,
  particle_blendNormalPS,
  particle_cpuVS,
  particle_cpu_endVS,
  particle_customFaceVS,
  particle_endPS,
  particle_endVS,
  particle_halflambertPS,
  particle_initVS,
  particle_lambertPS,
  particle_lightingPS,
  particle_localShiftVS,
  particle_meshVS,
  particle_normalVS,
  particle_normalMapPS,
  particle_pointAlongVS,
  particle_softPS,
  particle_softVS,
  particle_stretchVS,
  particle_TBNVS,
  particle_wrapVS,
  pickPS,
  reflDirPS,
  reflDirAnisoPS,
  reflectionCCPS,
  reflectionCubePS,
  reflectionEnvHQPS,
  reflectionEnvPS,
  reflectionSpherePS,
  reflectionSheenPS,
  refractionCubePS,
  refractionDynamicPS,
  reprojectPS,
  sampleCatmullRomPS,
  screenDepthPS,
  shadowCascadesPS,
  shadowEVSMPS,
  shadowEVSMnPS,
  shadowPCSSPS,
  shadowSampleCoordPS,
  shadowStandardPS,
  shadowStandardGL2PS,
  shadowVSM8PS,
  shadowVSM_commonPS,
  skinBatchTexVS,
  skinTexVS,
  skyboxEnvPS,
  skyboxHDRPS,
  skyboxVS,
  specularPS,
  sphericalPS,
  specularityFactorPS,
  spotPS,
  startPS,
  startVS,
  startNineSlicedPS,
  startNineSlicedTiledPS,
  storeEVSMPS,
  tangentBinormalVS,
  TBNPS,
  TBNderivativePS,
  TBNObjectSpacePS,
  thicknessPS,
  tonemappingAcesPS,
  tonemappingAces2PS,
  tonemappingFilmicPS,
  tonemappingHejlPS,
  tonemappingLinearPS,
  tonemappingNeutralPS,
  tonemappingNonePS,
  transformVS,
  transformCoreVS,
  transformInstancingVS,
  transmissionPS,
  twoSidedLightingPS,
  uv0VS,
  uv1VS,
  viewDirPS,
  viewNormalVS,
  webgpuPS,
  webgpuVS
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/get-program-library.js
var programLibraryDeviceCache = new DeviceCache();
function getProgramLibrary(device) {
  const library = programLibraryDeviceCache.get(device);
  return library;
}
function setProgramLibrary(device, library) {
  programLibraryDeviceCache.get(device, () => {
    return library;
  });
}

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/shader-generator.js
var ShaderGenerator = class {
  static begin() {
    return "void main(void)\n{\n";
  }
  static end() {
    return "}\n";
  }
  static definesHash(defines) {
    const sortedArray = Array.from(defines).sort((a, b) => a[0] > b[0] ? 1 : -1);
    return hashCode(JSON.stringify(sortedArray));
  }
  static fogCode(value, chunks = shaderChunks) {
    if (value === "linear") {
      var _chunks$fogLinearPS;
      return (_chunks$fogLinearPS = chunks.fogLinearPS) != null ? _chunks$fogLinearPS : shaderChunks.fogLinearPS;
    } else if (value === "exp") {
      var _chunks$fogExpPS;
      return (_chunks$fogExpPS = chunks.fogExpPS) != null ? _chunks$fogExpPS : shaderChunks.fogExpPS;
    } else if (value === "exp2") {
      var _chunks$fogExp2PS;
      return (_chunks$fogExp2PS = chunks.fogExp2PS) != null ? _chunks$fogExp2PS : shaderChunks.fogExp2PS;
    }
    return chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;
  }
  static gammaCode(value, chunks = shaderChunks) {
    var _chunks$gamma1_0PS;
    if (value === GAMMA_SRGB) {
      var _chunks$gamma2_2PS;
      return (_chunks$gamma2_2PS = chunks.gamma2_2PS) != null ? _chunks$gamma2_2PS : shaderChunks.gamma2_2PS;
    }
    return (_chunks$gamma1_0PS = chunks.gamma1_0PS) != null ? _chunks$gamma1_0PS : shaderChunks.gamma1_0PS;
  }
  static tonemapCode(value, chunks = shaderChunks) {
    var _chunks$tonemappingFi, _chunks$tonemappingLi, _chunks$tonemappingHe, _chunks$tonemappingAc, _chunks$tonemappingAc2, _chunks$tonemappingNe, _chunks$tonemapingNon;
    switch (value) {
      case TONEMAP_FILMIC:
        return (_chunks$tonemappingFi = chunks.tonemappingFilmicPS) != null ? _chunks$tonemappingFi : shaderChunks.tonemappingFilmicPS;
      case TONEMAP_LINEAR:
        return (_chunks$tonemappingLi = chunks.tonemappingLinearPS) != null ? _chunks$tonemappingLi : shaderChunks.tonemappingLinearPS;
      case TONEMAP_HEJL:
        return (_chunks$tonemappingHe = chunks.tonemappingHejlPS) != null ? _chunks$tonemappingHe : shaderChunks.tonemappingHejlPS;
      case TONEMAP_ACES:
        return (_chunks$tonemappingAc = chunks.tonemappingAcesPS) != null ? _chunks$tonemappingAc : shaderChunks.tonemappingAcesPS;
      case TONEMAP_ACES2:
        return (_chunks$tonemappingAc2 = chunks.tonemappingAces2PS) != null ? _chunks$tonemappingAc2 : shaderChunks.tonemappingAces2PS;
      case TONEMAP_NEUTRAL:
        return (_chunks$tonemappingNe = chunks.tonemappingNeutralPS) != null ? _chunks$tonemappingNe : shaderChunks.tonemappingNeutralPS;
    }
    return (_chunks$tonemapingNon = chunks.tonemapingNonePS) != null ? _chunks$tonemapingNon : shaderChunks.tonemappingNonePS;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/utils.js
function createShader(device, vsName, fsName, useTransformFeedback = false, shaderDefinitionOptions = {}) {
  if (typeof useTransformFeedback === "boolean") {
    shaderDefinitionOptions.useTransformFeedback = useTransformFeedback;
  } else if (typeof useTransformFeedback === "object") {
    shaderDefinitionOptions = _extends({}, shaderDefinitionOptions, useTransformFeedback);
  }
  return new Shader(device, ShaderUtils.createDefinition(device, _extends({}, shaderDefinitionOptions, {
    name: `${vsName}_${fsName}`,
    vertexCode: shaderChunks[vsName],
    fragmentCode: shaderChunks[fsName]
  })));
}
function createShaderFromCode(device, vsCode2, fsCode, uniqueName, attributes, useTransformFeedback = false, shaderDefinitionOptions = {}) {
  if (typeof useTransformFeedback === "boolean") {
    shaderDefinitionOptions.useTransformFeedback = useTransformFeedback;
  } else if (typeof useTransformFeedback === "object") {
    shaderDefinitionOptions = _extends({}, shaderDefinitionOptions, useTransformFeedback);
  }
  const programLibrary = getProgramLibrary(device);
  let shader = programLibrary.getCachedShader(uniqueName);
  if (!shader) {
    shader = new Shader(device, ShaderUtils.createDefinition(device, _extends({}, shaderDefinitionOptions, {
      name: uniqueName,
      vertexCode: vsCode2,
      fragmentCode: fsCode,
      attributes
    })));
    programLibrary.setCachedShader(uniqueName, shader);
  }
  return shader;
}
var ShaderGeneratorPassThrough = class extends ShaderGenerator {
  constructor(key, shaderDefinition) {
    super();
    this.key = key;
    this.shaderDefinition = shaderDefinition;
  }
  generateKey(options2) {
    return this.key;
  }
  createShaderDefinition(device, options2) {
    return this.shaderDefinition;
  }
};
function processShader(shader, processingOptions) {
  var _shaderDefinition$nam;
  const shaderDefinition = shader.definition;
  const name = (_shaderDefinition$nam = shaderDefinition.name) != null ? _shaderDefinition$nam : "shader";
  const key = `${name}-id-${shader.id}`;
  const materialGenerator = new ShaderGeneratorPassThrough(key, shaderDefinition);
  const libraryModuleName = "shader";
  const library = getProgramLibrary(shader.device);
  library.register(libraryModuleName, materialGenerator);
  const variant = library.getProgram(libraryModuleName, {}, processingOptions);
  if (shader.definition.shaderLanguage === SHADERLANGUAGE_WGSL) {
    variant.meshUniformBufferFormat = shaderDefinition.meshUniformBufferFormat;
    variant.meshBindGroupFormat = shaderDefinition.meshBindGroupFormat;
  }
  library.unregister(libraryModuleName);
  return variant;
}

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/quad-render.js
var _quadPrimitive = {
  type: PRIMITIVE_TRISTRIP,
  base: 0,
  count: 4,
  indexed: false
};
var _tempViewport = new Vec4();
var _tempScissor = new Vec4();
var _dynamicBindGroup = new DynamicBindGroup();
var QuadRender = class {
  constructor(shader) {
    this.uniformBuffer = void 0;
    this.bindGroup = void 0;
    const device = shader.device;
    this.shader = shader;
    if (device.supportsUniformBuffers) {
      const processingOptions = new ShaderProcessorOptions();
      this.shader = processShader(shader, processingOptions);
      const ubFormat = this.shader.meshUniformBufferFormat;
      if (ubFormat) {
        this.uniformBuffer = new UniformBuffer(device, ubFormat, false);
      }
      const bindGroupFormat = this.shader.meshBindGroupFormat;
      this.bindGroup = new BindGroup(device, bindGroupFormat);
    }
  }
  destroy() {
    var _this$uniformBuffer, _this$bindGroup;
    (_this$uniformBuffer = this.uniformBuffer) == null || _this$uniformBuffer.destroy();
    this.uniformBuffer = null;
    (_this$bindGroup = this.bindGroup) == null || _this$bindGroup.destroy();
    this.bindGroup = null;
  }
  render(viewport2, scissor) {
    const device = this.shader.device;
    if (viewport2) {
      var _scissor2;
      _tempViewport.set(device.vx, device.vy, device.vw, device.vh);
      _tempScissor.set(device.sx, device.sy, device.sw, device.sh);
      scissor = (_scissor2 = scissor) != null ? _scissor2 : viewport2;
      device.setViewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      device.setScissor(scissor.x, scissor.y, scissor.z, scissor.w);
    }
    device.setVertexBuffer(device.quadVertexBuffer, 0);
    const shader = this.shader;
    device.setShader(shader);
    if (device.supportsUniformBuffers) {
      device.setBindGroup(BINDGROUP_VIEW, device.emptyBindGroup);
      const bindGroup = this.bindGroup;
      bindGroup.update();
      device.setBindGroup(BINDGROUP_MESH, bindGroup);
      const uniformBuffer = this.uniformBuffer;
      if (uniformBuffer) {
        uniformBuffer.update(_dynamicBindGroup);
        device.setBindGroup(BINDGROUP_MESH_UB, _dynamicBindGroup.bindGroup, _dynamicBindGroup.offsets);
      } else {
        device.setBindGroup(BINDGROUP_MESH_UB, device.emptyBindGroup);
      }
    }
    device.draw(_quadPrimitive);
    if (viewport2) {
      device.setViewport(_tempViewport.x, _tempViewport.y, _tempViewport.z, _tempViewport.w);
      device.setScissor(_tempScissor.x, _tempScissor.y, _tempScissor.z, _tempScissor.w);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/render-pass-quad.js
var RenderPassQuad = class extends RenderPass {
  constructor(device, quad, rect, scissorRect) {
    super(device);
    this.quad = quad;
    this.rect = rect;
    this.scissorRect = scissorRect;
  }
  execute() {
    const {
      device
    } = this;
    device.setCullMode(CULLFACE_NONE);
    device.setDepthState(DepthState.NODEPTH);
    device.setStencilState(null, null);
    this.quad.render(this.rect, this.scissorRect);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/quad-render-utils.js
var _tempRect = new Vec4();
function drawQuadWithShader(device, target2, shader, rect, scissorRect) {
  const quad = new QuadRender(shader);
  if (!rect) {
    rect = _tempRect;
    rect.x = 0;
    rect.y = 0;
    rect.z = target2 ? target2.width : device.width;
    rect.w = target2 ? target2.height : device.height;
  }
  const renderPass = new RenderPassQuad(device, quad, rect, scissorRect);
  renderPass.init(target2);
  renderPass.colorOps.clear = false;
  renderPass.depthStencilOps.clearDepth = false;
  if (device.isWebGPU && target2 === null && device.samples > 1) {
    renderPass.colorOps.store = true;
  }
  renderPass.render();
  quad.destroy();
}

// ../node_modules/playcanvas/build/playcanvas/src/scene/batching/batch.js
var Batch = class {
  constructor(meshInstances, dynamic, batchGroupId) {
    this._aabb = new BoundingBox();
    this.origMeshInstances = void 0;
    this.meshInstance = null;
    this.dynamic = void 0;
    this.batchGroupId = void 0;
    this.origMeshInstances = meshInstances;
    this.dynamic = dynamic;
    this.batchGroupId = batchGroupId;
  }
  destroy(scene, layers) {
    if (this.meshInstance) {
      this.removeFromLayers(scene, layers);
      this.meshInstance.destroy();
      this.meshInstance = null;
    }
  }
  addToLayers(scene, layers) {
    for (let i = 0; i < layers.length; i++) {
      const layer = scene.layers.getLayerById(layers[i]);
      if (layer) {
        layer.addMeshInstances([this.meshInstance]);
      }
    }
  }
  removeFromLayers(scene, layers) {
    for (let i = 0; i < layers.length; i++) {
      const layer = scene.layers.getLayerById(layers[i]);
      if (layer) {
        layer.removeMeshInstances([this.meshInstance]);
      }
    }
  }
  updateBoundingBox() {
    this._aabb.copy(this.origMeshInstances[0].aabb);
    for (let i = 1; i < this.origMeshInstances.length; i++) {
      this._aabb.add(this.origMeshInstances[i].aabb);
    }
    this.meshInstance.aabb = this._aabb;
    this.meshInstance._aabbVer = 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/batching/batch-group.js
var BatchGroup = class {
  constructor(id13, name, dynamic, maxAabbSize, layers = [LAYERID_WORLD]) {
    this._ui = false;
    this._sprite = false;
    this._obj = {
      model: [],
      element: [],
      sprite: [],
      render: []
    };
    this.id = void 0;
    this.name = void 0;
    this.dynamic = void 0;
    this.maxAabbSize = void 0;
    this.layers = void 0;
    this.id = id13;
    this.name = name;
    this.dynamic = dynamic;
    this.maxAabbSize = maxAabbSize;
    this.layers = layers;
  }
};
BatchGroup.MODEL = "model";
BatchGroup.ELEMENT = "element";
BatchGroup.SPRITE = "sprite";
BatchGroup.RENDER = "render";

// ../node_modules/playcanvas/build/playcanvas/src/scene/skin-instance.js
var _invMatrix = new Mat4();
var SkinInstance = class {
  constructor(skin) {
    this.bones = void 0;
    this.boneTextureSize = void 0;
    this._dirty = true;
    this._rootBone = null;
    this._skinUpdateIndex = -1;
    this._updateBeforeCull = true;
    if (skin) {
      this.initSkin(skin);
    }
  }
  set rootBone(rootBone) {
    this._rootBone = rootBone;
  }
  get rootBone() {
    return this._rootBone;
  }
  init(device, numBones) {
    const numPixels = numBones * 3;
    let width = Math.ceil(Math.sqrt(numPixels));
    width = math.roundUp(width, 3);
    const height = Math.ceil(numPixels / width);
    this.boneTexture = new Texture(device, {
      width,
      height,
      format: PIXELFORMAT_RGBA32F,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      name: "skin"
    });
    this.boneTextureSize = [width, height, 1 / width, 1 / height];
    this.matrixPalette = this.boneTexture.lock({
      mode: TEXTURELOCK_READ
    });
    this.boneTexture.unlock();
  }
  destroy() {
    if (this.boneTexture) {
      this.boneTexture.destroy();
      this.boneTexture = null;
    }
  }
  resolve(rootBone, entity) {
    this.rootBone = rootBone;
    const skin = this.skin;
    const bones = [];
    for (let j = 0; j < skin.boneNames.length; j++) {
      const boneName = skin.boneNames[j];
      let bone = rootBone.findByName(boneName);
      if (!bone) {
        bone = entity;
      }
      bones.push(bone);
    }
    this.bones = bones;
  }
  initSkin(skin) {
    this.skin = skin;
    this.bones = [];
    const numBones = skin.inverseBindPose.length;
    this.init(skin.device, numBones);
    this.matrices = [];
    for (let i = 0; i < numBones; i++) {
      this.matrices[i] = new Mat4();
    }
  }
  uploadBones(device) {
    this.boneTexture.upload();
  }
  _updateMatrices(rootNode, skinUpdateIndex) {
    if (this._skinUpdateIndex !== skinUpdateIndex) {
      this._skinUpdateIndex = skinUpdateIndex;
      _invMatrix.copy(rootNode.getWorldTransform()).invert();
      for (let i = this.bones.length - 1; i >= 0; i--) {
        this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
        this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
      }
    }
  }
  updateMatrices(rootNode, skinUpdateIndex) {
    if (this._updateBeforeCull) {
      this._updateMatrices(rootNode, skinUpdateIndex);
    }
  }
  updateMatrixPalette(rootNode, skinUpdateIndex) {
    this._updateMatrices(rootNode, skinUpdateIndex);
    const mp = this.matrixPalette;
    const count = this.bones.length;
    for (let i = 0; i < count; i++) {
      const pe = this.matrices[i].data;
      const base = i * 12;
      mp[base] = pe[0];
      mp[base + 1] = pe[4];
      mp[base + 2] = pe[8];
      mp[base + 3] = pe[12];
      mp[base + 4] = pe[1];
      mp[base + 5] = pe[5];
      mp[base + 6] = pe[9];
      mp[base + 7] = pe[13];
      mp[base + 8] = pe[2];
      mp[base + 9] = pe[6];
      mp[base + 10] = pe[10];
      mp[base + 11] = pe[14];
    }
    this.uploadBones(this.skin.device);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/batching/skin-batch-instance.js
var SkinBatchInstance = class extends SkinInstance {
  constructor(device, nodes, rootNode) {
    super();
    const numBones = nodes.length;
    this.init(device, numBones);
    this.device = device;
    this.rootNode = rootNode;
    this.bones = nodes;
  }
  updateMatrices(rootNode, skinUpdateIndex) {
  }
  updateMatrixPalette(rootNode, skinUpdateIndex) {
    const mp = this.matrixPalette;
    const count = this.bones.length;
    for (let i = 0; i < count; i++) {
      const pe = this.bones[i].getWorldTransform().data;
      const base = i * 12;
      mp[base] = pe[0];
      mp[base + 1] = pe[4];
      mp[base + 2] = pe[8];
      mp[base + 3] = pe[12];
      mp[base + 4] = pe[1];
      mp[base + 5] = pe[5];
      mp[base + 6] = pe[9];
      mp[base + 7] = pe[13];
      mp[base + 8] = pe[2];
      mp[base + 9] = pe[6];
      mp[base + 10] = pe[10];
      mp[base + 11] = pe[14];
    }
    this.uploadBones(this.device);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/ref-counted-object.js
var RefCountedObject = class {
  constructor() {
    this._refCount = 0;
  }
  incRefCount() {
    this._refCount++;
  }
  decRefCount() {
    this._refCount--;
  }
  get refCount() {
    return this._refCount;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/mesh.js
var id9 = 0;
var GeometryData = class {
  constructor() {
    this.initDefaults();
  }
  initDefaults() {
    this.recreate = false;
    this.verticesUsage = BUFFER_STATIC;
    this.indicesUsage = BUFFER_STATIC;
    this.maxVertices = 0;
    this.maxIndices = 0;
    this.vertexCount = 0;
    this.indexCount = 0;
    this.vertexStreamsUpdated = false;
    this.indexStreamUpdated = false;
    this.vertexStreamDictionary = {};
    this.indices = null;
  }
  _changeVertexCount(count, semantic) {
    if (!this.vertexCount) {
      this.vertexCount = count;
    }
  }
};
GeometryData.DEFAULT_COMPONENTS_POSITION = 3;
GeometryData.DEFAULT_COMPONENTS_NORMAL = 3;
GeometryData.DEFAULT_COMPONENTS_UV = 2;
GeometryData.DEFAULT_COMPONENTS_COLORS = 4;
var GeometryVertexStream = class {
  constructor(data2, componentCount, dataType, dataTypeNormalize, asInt) {
    this.data = data2;
    this.componentCount = componentCount;
    this.dataType = dataType;
    this.dataTypeNormalize = dataTypeNormalize;
    this.asInt = asInt;
  }
};
var Mesh = class _Mesh extends RefCountedObject {
  constructor(graphicsDevice, options2) {
    super();
    this.indexBuffer = [null];
    this.vertexBuffer = null;
    this.primitive = [{
      type: 0,
      base: 0,
      count: 0
    }];
    this.skin = null;
    this.boneAabb = null;
    this._aabbVer = 0;
    this._aabb = new BoundingBox();
    this._geometryData = null;
    this._morph = null;
    this._storageIndex = false;
    this._storageVertex = false;
    this.id = id9++;
    this.device = graphicsDevice;
    this._storageIndex = (options2 == null ? void 0 : options2.storageIndex) || false;
    this._storageVertex = (options2 == null ? void 0 : options2.storageVertex) || false;
  }
  static fromGeometry(graphicsDevice, geometry, options2 = {}) {
    const mesh = new _Mesh(graphicsDevice, options2);
    const {
      positions,
      normals,
      tangents,
      colors,
      uvs,
      uvs1,
      blendIndices,
      blendWeights,
      indices
    } = geometry;
    if (positions) {
      mesh.setPositions(positions);
    }
    if (normals) {
      mesh.setNormals(normals);
    }
    if (tangents) {
      mesh.setVertexStream(SEMANTIC_TANGENT, tangents, 4);
    }
    if (colors) {
      mesh.setColors32(colors);
    }
    if (uvs) {
      mesh.setUvs(0, uvs);
    }
    if (uvs1) {
      mesh.setUvs(1, uvs1);
    }
    if (blendIndices) {
      mesh.setVertexStream(SEMANTIC_BLENDINDICES, blendIndices, 4, blendIndices.length / 4, TYPE_UINT8);
    }
    if (blendWeights) {
      mesh.setVertexStream(SEMANTIC_BLENDWEIGHT, blendWeights, 4);
    }
    if (indices) {
      mesh.setIndices(indices);
    }
    mesh.update();
    return mesh;
  }
  set morph(morph) {
    if (morph !== this._morph) {
      if (this._morph) {
        this._morph.decRefCount();
      }
      this._morph = morph;
      if (morph) {
        morph.incRefCount();
      }
    }
  }
  get morph() {
    return this._morph;
  }
  set aabb(aabb3) {
    this._aabb = aabb3;
    this._aabbVer++;
  }
  get aabb() {
    return this._aabb;
  }
  destroy() {
    const morph = this.morph;
    if (morph) {
      this.morph = null;
      if (morph.refCount < 1) {
        morph.destroy();
      }
    }
    if (this.vertexBuffer) {
      this.vertexBuffer.destroy();
      this.vertexBuffer = null;
    }
    for (let j = 0; j < this.indexBuffer.length; j++) {
      this._destroyIndexBuffer(j);
    }
    this.indexBuffer.length = 0;
    this._geometryData = null;
  }
  _destroyIndexBuffer(index) {
    if (this.indexBuffer[index]) {
      this.indexBuffer[index].destroy();
      this.indexBuffer[index] = null;
    }
  }
  _initBoneAabbs(morphTargets) {
    this.boneAabb = [];
    this.boneUsed = [];
    let x2, y2, z2;
    let bMax2, bMin2;
    const boneMin = [];
    const boneMax = [];
    const boneUsed = this.boneUsed;
    const numBones = this.skin.boneNames.length;
    let maxMorphX, maxMorphY, maxMorphZ;
    for (let i = 0; i < numBones; i++) {
      boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    }
    const iterator = new VertexIterator(this.vertexBuffer);
    const posElement = iterator.element[SEMANTIC_POSITION];
    const weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
    const indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
    const numVerts = this.vertexBuffer.numVertices;
    for (let j = 0; j < numVerts; j++) {
      for (let k = 0; k < 4; k++) {
        const boneWeight = weightsElement.array[weightsElement.index + k];
        if (boneWeight > 0) {
          const boneIndex = indicesElement.array[indicesElement.index + k];
          boneUsed[boneIndex] = true;
          x2 = posElement.array[posElement.index];
          y2 = posElement.array[posElement.index + 1];
          z2 = posElement.array[posElement.index + 2];
          bMax2 = boneMax[boneIndex];
          bMin2 = boneMin[boneIndex];
          if (bMin2.x > x2) bMin2.x = x2;
          if (bMin2.y > y2) bMin2.y = y2;
          if (bMin2.z > z2) bMin2.z = z2;
          if (bMax2.x < x2) bMax2.x = x2;
          if (bMax2.y < y2) bMax2.y = y2;
          if (bMax2.z < z2) bMax2.z = z2;
          if (morphTargets) {
            let minMorphX = maxMorphX = x2;
            let minMorphY = maxMorphY = y2;
            let minMorphZ = maxMorphZ = z2;
            for (let l = 0; l < morphTargets.length; l++) {
              const target2 = morphTargets[l];
              const dx = target2.deltaPositions[j * 3];
              const dy = target2.deltaPositions[j * 3 + 1];
              const dz = target2.deltaPositions[j * 3 + 2];
              if (dx < 0) {
                minMorphX += dx;
              } else {
                maxMorphX += dx;
              }
              if (dy < 0) {
                minMorphY += dy;
              } else {
                maxMorphY += dy;
              }
              if (dz < 0) {
                minMorphZ += dz;
              } else {
                maxMorphZ += dz;
              }
            }
            if (bMin2.x > minMorphX) bMin2.x = minMorphX;
            if (bMin2.y > minMorphY) bMin2.y = minMorphY;
            if (bMin2.z > minMorphZ) bMin2.z = minMorphZ;
            if (bMax2.x < maxMorphX) bMax2.x = maxMorphX;
            if (bMax2.y < maxMorphY) bMax2.y = maxMorphY;
            if (bMax2.z < maxMorphZ) bMax2.z = maxMorphZ;
          }
        }
      }
      iterator.next();
    }
    const positionElement = this.vertexBuffer.getFormat().elements.find((e) => e.name === SEMANTIC_POSITION);
    if (positionElement && positionElement.normalize) {
      const func = (() => {
        switch (positionElement.dataType) {
          case TYPE_INT8:
            return (x3) => Math.max(x3 / 127, -1);
          case TYPE_UINT8:
            return (x3) => x3 / 255;
          case TYPE_INT16:
            return (x3) => Math.max(x3 / 32767, -1);
          case TYPE_UINT16:
            return (x3) => x3 / 65535;
          default:
            return (x3) => x3;
        }
      })();
      for (let i = 0; i < numBones; i++) {
        if (boneUsed[i]) {
          const min = boneMin[i];
          const max = boneMax[i];
          min.set(func(min.x), func(min.y), func(min.z));
          max.set(func(max.x), func(max.y), func(max.z));
        }
      }
    }
    for (let i = 0; i < numBones; i++) {
      const aabb3 = new BoundingBox();
      aabb3.setMinMax(boneMin[i], boneMax[i]);
      this.boneAabb.push(aabb3);
    }
  }
  _initGeometryData() {
    if (!this._geometryData) {
      this._geometryData = new GeometryData();
      if (this.vertexBuffer) {
        this._geometryData.vertexCount = this.vertexBuffer.numVertices;
        this._geometryData.maxVertices = this.vertexBuffer.numVertices;
      }
      if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
        this._geometryData.indexCount = this.indexBuffer[0].numIndices;
        this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
      }
    }
  }
  clear(verticesDynamic, indicesDynamic, maxVertices = 0, maxIndices = 0) {
    this._initGeometryData();
    this._geometryData.initDefaults();
    this._geometryData.recreate = true;
    this._geometryData.maxVertices = maxVertices;
    this._geometryData.maxIndices = maxIndices;
    this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
    this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
  }
  setVertexStream(semantic, data2, componentCount, numVertices, dataType = TYPE_FLOAT32, dataTypeNormalize = false, asInt = false) {
    this._initGeometryData();
    const vertexCount = numVertices || data2.length / componentCount;
    this._geometryData._changeVertexCount(vertexCount, semantic);
    this._geometryData.vertexStreamsUpdated = true;
    this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data2, componentCount, dataType, dataTypeNormalize, asInt);
  }
  getVertexStream(semantic, data2) {
    let count = 0;
    let done = false;
    if (this._geometryData) {
      const stream = this._geometryData.vertexStreamDictionary[semantic];
      if (stream) {
        done = true;
        count = this._geometryData.vertexCount;
        if (ArrayBuffer.isView(data2)) {
          data2.set(stream.data);
        } else {
          data2.length = 0;
          data2.push(stream.data);
        }
      }
    }
    if (!done) {
      if (this.vertexBuffer) {
        const iterator = new VertexIterator(this.vertexBuffer);
        count = iterator.readData(semantic, data2);
      }
    }
    return count;
  }
  setPositions(positions, componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION, numVertices) {
    this.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);
  }
  setNormals(normals, componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL, numVertices) {
    this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);
  }
  setUvs(channel, uvs, componentCount = GeometryData.DEFAULT_COMPONENTS_UV, numVertices) {
    this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);
  }
  setColors(colors, componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices) {
    this.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);
  }
  setColors32(colors, numVertices) {
    this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
  }
  setIndices(indices, numIndices) {
    this._initGeometryData();
    this._geometryData.indexStreamUpdated = true;
    this._geometryData.indices = indices;
    this._geometryData.indexCount = numIndices || indices.length;
  }
  getPositions(positions) {
    return this.getVertexStream(SEMANTIC_POSITION, positions);
  }
  getNormals(normals) {
    return this.getVertexStream(SEMANTIC_NORMAL, normals);
  }
  getUvs(channel, uvs) {
    return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
  }
  getColors(colors) {
    return this.getVertexStream(SEMANTIC_COLOR, colors);
  }
  getIndices(indices) {
    let count = 0;
    if (this._geometryData && this._geometryData.indices) {
      const streamIndices = this._geometryData.indices;
      count = this._geometryData.indexCount;
      if (ArrayBuffer.isView(indices)) {
        indices.set(streamIndices);
      } else {
        indices.length = 0;
        for (let i = 0, il = streamIndices.length; i < il; i++) {
          indices.push(streamIndices[i]);
        }
      }
    } else {
      if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
        const indexBuffer = this.indexBuffer[0];
        count = indexBuffer.readData(indices);
      }
    }
    return count;
  }
  update(primitiveType = PRIMITIVE_TRIANGLES, updateBoundingBox = true) {
    if (this._geometryData) {
      if (updateBoundingBox) {
        const stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];
        if (stream) {
          if (stream.componentCount === 3) {
            this._aabb.compute(stream.data, this._geometryData.vertexCount);
            this._aabbVer++;
          }
        }
      }
      let destroyVB = this._geometryData.recreate;
      if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
        destroyVB = true;
        this._geometryData.maxVertices = this._geometryData.vertexCount;
      }
      if (destroyVB) {
        if (this.vertexBuffer) {
          this.vertexBuffer.destroy();
          this.vertexBuffer = null;
        }
      }
      let destroyIB = this._geometryData.recreate;
      if (this._geometryData.indexCount > this._geometryData.maxIndices) {
        destroyIB = true;
        this._geometryData.maxIndices = this._geometryData.indexCount;
      }
      if (destroyIB) {
        if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
          this.indexBuffer[0].destroy();
          this.indexBuffer[0] = null;
        }
      }
      if (this._geometryData.vertexStreamsUpdated) {
        this._updateVertexBuffer();
      }
      if (this._geometryData.indexStreamUpdated) {
        this._updateIndexBuffer();
      }
      this.primitive[0].type = primitiveType;
      if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
        if (this._geometryData.indexStreamUpdated) {
          this.primitive[0].count = this._geometryData.indexCount;
          this.primitive[0].indexed = true;
        }
      } else {
        if (this._geometryData.vertexStreamsUpdated) {
          this.primitive[0].count = this._geometryData.vertexCount;
          this.primitive[0].indexed = false;
        }
      }
      this._geometryData.vertexCount = 0;
      this._geometryData.indexCount = 0;
      this._geometryData.vertexStreamsUpdated = false;
      this._geometryData.indexStreamUpdated = false;
      this._geometryData.recreate = false;
      this.updateRenderStates();
    }
  }
  _buildVertexFormat(vertexCount) {
    const vertexDesc = [];
    for (const semantic in this._geometryData.vertexStreamDictionary) {
      const stream = this._geometryData.vertexStreamDictionary[semantic];
      vertexDesc.push({
        semantic,
        components: stream.componentCount,
        type: stream.dataType,
        normalize: stream.dataTypeNormalize,
        asInt: stream.asInt
      });
    }
    return new VertexFormat(this.device, vertexDesc, vertexCount);
  }
  _updateVertexBuffer() {
    if (!this.vertexBuffer) {
      const allocateVertexCount = this._geometryData.maxVertices;
      const format = this._buildVertexFormat(allocateVertexCount);
      this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, {
        usage: this._geometryData.verticesUsage,
        storage: this._storageVertex
      });
    }
    const iterator = new VertexIterator(this.vertexBuffer);
    const numVertices = this._geometryData.vertexCount;
    for (const semantic in this._geometryData.vertexStreamDictionary) {
      const stream = this._geometryData.vertexStreamDictionary[semantic];
      iterator.writeData(semantic, stream.data, numVertices);
      delete this._geometryData.vertexStreamDictionary[semantic];
    }
    iterator.end();
  }
  _updateIndexBuffer() {
    if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
      const maxVertices = this._geometryData.maxVertices;
      const createFormat = maxVertices > 65535 || maxVertices === 0 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
      const options2 = this._storageIndex ? {
        storage: true
      } : void 0;
      this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage, void 0, options2);
    }
    const srcIndices = this._geometryData.indices;
    if (srcIndices) {
      const indexBuffer = this.indexBuffer[0];
      indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
      this._geometryData.indices = null;
    }
  }
  prepareRenderState(renderStyle) {
    if (renderStyle === RENDERSTYLE_WIREFRAME) {
      this.generateWireframe();
    } else if (renderStyle === RENDERSTYLE_POINTS) {
      this.primitive[RENDERSTYLE_POINTS] = {
        type: PRIMITIVE_POINTS,
        base: 0,
        count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
        indexed: false
      };
    }
  }
  updateRenderStates() {
    if (this.primitive[RENDERSTYLE_POINTS]) {
      this.prepareRenderState(RENDERSTYLE_POINTS);
    }
    if (this.primitive[RENDERSTYLE_WIREFRAME]) {
      this.prepareRenderState(RENDERSTYLE_WIREFRAME);
    }
  }
  generateWireframe() {
    this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);
    const numVertices = this.vertexBuffer.numVertices;
    const lines = [];
    let format;
    if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
      const offsets = [[0, 1], [1, 2], [2, 0]];
      const base = this.primitive[RENDERSTYLE_SOLID].base;
      const count = this.primitive[RENDERSTYLE_SOLID].count;
      const indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
      const srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);
      const seen = /* @__PURE__ */ new Set();
      for (let j = base; j < base + count; j += 3) {
        for (let k = 0; k < 3; k++) {
          const i1 = srcIndices[j + offsets[k][0]];
          const i2 = srcIndices[j + offsets[k][1]];
          const hash = i1 > i2 ? i2 * numVertices + i1 : i1 * numVertices + i2;
          if (!seen.has(hash)) {
            seen.add(hash);
            lines.push(i1, i2);
          }
        }
      }
      format = indexBuffer.format;
    } else {
      for (let i = 0; i < numVertices; i += 3) {
        lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
      }
      format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
    }
    const wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
    const dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);
    dstIndices.set(lines);
    wireBuffer.unlock();
    this.primitive[RENDERSTYLE_WIREFRAME] = {
      type: PRIMITIVE_LINES,
      base: 0,
      count: lines.length,
      indexed: true
    };
    this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/default-material.js
var defaultMaterialDeviceCache = new DeviceCache();
function getDefaultMaterial(device) {
  const material = defaultMaterialDeviceCache.get(device);
  return material;
}
function setDefaultMaterial(device, material) {
  defaultMaterialDeviceCache.get(device, () => {
    return material;
  });
}

// ../node_modules/playcanvas/build/playcanvas/src/core/ref-counted-cache.js
var RefCountedCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.cache.forEach((refCount, object) => {
      object.destroy();
    });
    this.cache.clear();
  }
  incRef(object) {
    const refCount = (this.cache.get(object) || 0) + 1;
    this.cache.set(object, refCount);
  }
  decRef(object) {
    if (object) {
      let refCount = this.cache.get(object);
      if (refCount) {
        refCount--;
        if (refCount === 0) {
          this.cache.delete(object);
          object.destroy();
        } else {
          this.cache.set(object, refCount);
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/lightmap-cache.js
var LightmapCache = class {
  static incRef(texture) {
    this.cache.incRef(texture);
  }
  static decRef(texture) {
    this.cache.decRef(texture);
  }
  static destroy() {
    this.cache.destroy();
  }
};
LightmapCache.cache = new RefCountedCache();

// ../node_modules/playcanvas/build/playcanvas/src/scene/mesh-instance.js
var id10 = 0;
var _tmpAabb = new BoundingBox();
var _tempBoneAabb = new BoundingBox();
var _tempSphere = new BoundingSphere();
var _meshSet = /* @__PURE__ */ new Set();
var lookupHashes = new Uint32Array(4);
var InstancingData = class {
  constructor(numObjects) {
    this.vertexBuffer = null;
    this._destroyVertexBuffer = false;
    this.count = numObjects;
  }
  destroy() {
    if (this._destroyVertexBuffer) {
      var _this$vertexBuffer;
      (_this$vertexBuffer = this.vertexBuffer) == null || _this$vertexBuffer.destroy();
    }
    this.vertexBuffer = null;
  }
};
var ShaderInstance = class {
  constructor() {
    this.shader = void 0;
    this.bindGroup = null;
    this.uniformBuffer = null;
    this.hashes = void 0;
  }
  getBindGroup(device) {
    if (!this.bindGroup) {
      const shader = this.shader;
      const bindGroupFormat = shader.meshBindGroupFormat;
      this.bindGroup = new BindGroup(device, bindGroupFormat);
    }
    return this.bindGroup;
  }
  getUniformBuffer(device) {
    if (!this.uniformBuffer) {
      const shader = this.shader;
      const ubFormat = shader.meshUniformBufferFormat;
      this.uniformBuffer = new UniformBuffer(device, ubFormat, false);
    }
    return this.uniformBuffer;
  }
  destroy() {
    var _this$bindGroup, _this$uniformBuffer;
    (_this$bindGroup = this.bindGroup) == null || _this$bindGroup.destroy();
    this.bindGroup = null;
    (_this$uniformBuffer = this.uniformBuffer) == null || _this$uniformBuffer.destroy();
    this.uniformBuffer = null;
  }
};
var MeshInstance = class _MeshInstance {
  constructor(mesh, material, node = null) {
    this.castShadow = false;
    this.cull = true;
    this.drawOrder = 0;
    this.node = void 0;
    this.visible = true;
    this.visibleThisFrame = false;
    this.flipFacesFactor = 1;
    this.gsplatInstance = null;
    this.id = id10++;
    this.isVisibleFunc = null;
    this.instancingData = null;
    this.parameters = {};
    this.pick = true;
    this.stencilFront = null;
    this.stencilBack = null;
    this.transparent = false;
    this._aabb = new BoundingBox();
    this._aabbVer = -1;
    this._aabbMeshVer = -1;
    this._customAabb = null;
    this._updateAabb = true;
    this._updateAabbFunc = null;
    this._key = [0, 0];
    this._layer = LAYER_WORLD;
    this._material = null;
    this._skinInstance = null;
    this._morphInstance = null;
    this._receiveShadow = true;
    this._renderStyle = RENDERSTYLE_SOLID;
    this._screenSpace = false;
    this._shaderCache = /* @__PURE__ */ new Map();
    this._shaderDefs = MASK_AFFECT_DYNAMIC << 16;
    this._calculateSortDistance = null;
    this.node = node;
    this._mesh = mesh;
    mesh.incRefCount();
    this.material = material;
    if (mesh.vertexBuffer) {
      const format = mesh.vertexBuffer.format;
      this._shaderDefs |= format.hasUv0 ? SHADERDEF_UV0 : 0;
      this._shaderDefs |= format.hasUv1 ? SHADERDEF_UV1 : 0;
      this._shaderDefs |= format.hasColor ? SHADERDEF_VCOLOR : 0;
      this._shaderDefs |= format.hasTangents ? SHADERDEF_TANGENTS : 0;
    }
    this.updateKey();
  }
  set renderStyle(renderStyle) {
    this._renderStyle = renderStyle;
    this.mesh.prepareRenderState(renderStyle);
  }
  get renderStyle() {
    return this._renderStyle;
  }
  set mesh(mesh) {
    if (mesh === this._mesh) {
      return;
    }
    if (this._mesh) {
      this._mesh.decRefCount();
    }
    this._mesh = mesh;
    if (mesh) {
      mesh.incRefCount();
    }
  }
  get mesh() {
    return this._mesh;
  }
  set aabb(aabb3) {
    this._aabb = aabb3;
  }
  get aabb() {
    if (!this._updateAabb) {
      return this._aabb;
    }
    if (this._updateAabbFunc) {
      return this._updateAabbFunc(this._aabb);
    }
    let localAabb = this._customAabb;
    let toWorldSpace = !!localAabb;
    if (!localAabb) {
      localAabb = _tmpAabb;
      if (this.skinInstance) {
        if (!this.mesh.boneAabb) {
          const morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;
          this.mesh._initBoneAabbs(morphTargets);
        }
        const boneUsed = this.mesh.boneUsed;
        let first = true;
        for (let i = 0; i < this.mesh.boneAabb.length; i++) {
          if (boneUsed[i]) {
            _tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);
            if (first) {
              first = false;
              localAabb.center.copy(_tempBoneAabb.center);
              localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
            } else {
              localAabb.add(_tempBoneAabb);
            }
          }
        }
        toWorldSpace = true;
      } else if (this.node._aabbVer !== this._aabbVer || this.mesh._aabbVer !== this._aabbMeshVer) {
        if (this.mesh) {
          localAabb.center.copy(this.mesh.aabb.center);
          localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
        } else {
          localAabb.center.set(0, 0, 0);
          localAabb.halfExtents.set(0, 0, 0);
        }
        if (this.mesh && this.mesh.morph) {
          const morphAabb = this.mesh.morph.aabb;
          localAabb._expand(morphAabb.getMin(), morphAabb.getMax());
        }
        toWorldSpace = true;
        this._aabbVer = this.node._aabbVer;
        this._aabbMeshVer = this.mesh._aabbVer;
      }
    }
    if (toWorldSpace) {
      this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
    }
    return this._aabb;
  }
  clearShaders() {
    this._shaderCache.forEach((shaderInstance) => {
      shaderInstance.destroy();
    });
    this._shaderCache.clear();
  }
  getShaderInstance(shaderPass, lightHash, scene, renderParams, viewUniformFormat, viewBindGroupFormat, sortedLights) {
    const shaderDefs = this._shaderDefs;
    lookupHashes[0] = shaderPass;
    lookupHashes[1] = lightHash;
    lookupHashes[2] = shaderDefs;
    lookupHashes[3] = renderParams.hash;
    const hash = hash32Fnv1a(lookupHashes);
    let shaderInstance = this._shaderCache.get(hash);
    if (!shaderInstance) {
      const mat2 = this._material;
      shaderInstance = new ShaderInstance();
      shaderInstance.shader = mat2.variants.get(hash);
      shaderInstance.hashes = new Uint32Array(lookupHashes);
      if (!shaderInstance.shader) {
        var _this$mesh$vertexBuff;
        const shader = mat2.getShaderVariant({
          device: this.mesh.device,
          scene,
          objDefs: shaderDefs,
          renderParams,
          pass: shaderPass,
          sortedLights,
          viewUniformFormat,
          viewBindGroupFormat,
          vertexFormat: (_this$mesh$vertexBuff = this.mesh.vertexBuffer) == null ? void 0 : _this$mesh$vertexBuff.format
        });
        mat2.variants.set(hash, shader);
        shaderInstance.shader = shader;
      }
      this._shaderCache.set(hash, shaderInstance);
    }
    return shaderInstance;
  }
  set material(material) {
    this.clearShaders();
    const prevMat = this._material;
    if (prevMat) {
      prevMat.removeMeshInstanceRef(this);
    }
    this._material = material;
    if (material) {
      material.addMeshInstanceRef(this);
      this.transparent = material.transparent;
      this.updateKey();
    }
  }
  get material() {
    return this._material;
  }
  set layer(layer) {
    this._layer = layer;
    this.updateKey();
  }
  get layer() {
    return this._layer;
  }
  _updateShaderDefs(shaderDefs) {
    if (shaderDefs !== this._shaderDefs) {
      this._shaderDefs = shaderDefs;
      this.clearShaders();
    }
  }
  set calculateSortDistance(calculateSortDistance) {
    this._calculateSortDistance = calculateSortDistance;
  }
  get calculateSortDistance() {
    return this._calculateSortDistance;
  }
  set receiveShadow(val) {
    if (this._receiveShadow !== val) {
      this._receiveShadow = val;
      this._updateShaderDefs(val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW);
    }
  }
  get receiveShadow() {
    return this._receiveShadow;
  }
  set batching(val) {
    this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_BATCH : this._shaderDefs & ~SHADERDEF_BATCH);
  }
  get batching() {
    return (this._shaderDefs & SHADERDEF_BATCH) !== 0;
  }
  set skinInstance(val) {
    this._skinInstance = val;
    this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN);
    this._setupSkinUpdate();
  }
  get skinInstance() {
    return this._skinInstance;
  }
  set morphInstance(val) {
    var _this$_morphInstance;
    (_this$_morphInstance = this._morphInstance) == null || _this$_morphInstance.destroy();
    this._morphInstance = val;
    let shaderDefs = this._shaderDefs;
    shaderDefs = val && val.morph.morphPositions ? shaderDefs | SHADERDEF_MORPH_POSITION : shaderDefs & ~SHADERDEF_MORPH_POSITION;
    shaderDefs = val && val.morph.morphNormals ? shaderDefs | SHADERDEF_MORPH_NORMAL : shaderDefs & ~SHADERDEF_MORPH_NORMAL;
    shaderDefs = val && val.morph.intRenderFormat ? shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED_INT : shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED_INT;
    this._updateShaderDefs(shaderDefs);
  }
  get morphInstance() {
    return this._morphInstance;
  }
  set screenSpace(val) {
    if (this._screenSpace !== val) {
      this._screenSpace = val;
      this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE);
    }
  }
  get screenSpace() {
    return this._screenSpace;
  }
  set key(val) {
    this._key[SORTKEY_FORWARD] = val;
  }
  get key() {
    return this._key[SORTKEY_FORWARD];
  }
  set mask(val) {
    const toggles = this._shaderDefs & 65535;
    this._updateShaderDefs(toggles | val << 16);
  }
  get mask() {
    return this._shaderDefs >> 16;
  }
  set instancingCount(value) {
    if (this.instancingData) {
      this.instancingData.count = value;
    }
  }
  get instancingCount() {
    return this.instancingData ? this.instancingData.count : 0;
  }
  destroy() {
    var _this$_skinInstance, _this$morphInstance, _this$instancingData;
    const mesh = this.mesh;
    if (mesh) {
      this.mesh = null;
      if (mesh.refCount < 1) {
        mesh.destroy();
      }
    }
    this.setRealtimeLightmap(_MeshInstance.lightmapParamNames[0], null);
    this.setRealtimeLightmap(_MeshInstance.lightmapParamNames[1], null);
    (_this$_skinInstance = this._skinInstance) == null || _this$_skinInstance.destroy();
    this._skinInstance = null;
    (_this$morphInstance = this.morphInstance) == null || _this$morphInstance.destroy();
    this.morphInstance = null;
    this.clearShaders();
    this.material = null;
    (_this$instancingData = this.instancingData) == null || _this$instancingData.destroy();
  }
  static _prepareRenderStyleForArray(meshInstances, renderStyle) {
    if (meshInstances) {
      for (let i = 0; i < meshInstances.length; i++) {
        meshInstances[i]._renderStyle = renderStyle;
        const mesh = meshInstances[i].mesh;
        if (!_meshSet.has(mesh)) {
          _meshSet.add(mesh);
          mesh.prepareRenderState(renderStyle);
        }
      }
      _meshSet.clear();
    }
  }
  _isVisible(camera) {
    if (this.visible) {
      if (this.isVisibleFunc) {
        return this.isVisibleFunc(camera);
      }
      _tempSphere.center = this.aabb.center;
      _tempSphere.radius = this._aabb.halfExtents.length();
      return camera.frustum.containsSphere(_tempSphere) > 0;
    }
    return false;
  }
  updateKey() {
    const material = this.material;
    const blendType = material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType;
    this._key[SORTKEY_FORWARD] = (this.layer & 15) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (material.id & 33554431) << 0;
  }
  setInstancing(vertexBuffer, cull = false) {
    if (vertexBuffer) {
      this.instancingData = new InstancingData(vertexBuffer.numVertices);
      this.instancingData.vertexBuffer = vertexBuffer;
      vertexBuffer.format.instancing = true;
      this.cull = cull;
    } else {
      this.instancingData = null;
      this.cull = true;
    }
    this._updateShaderDefs(vertexBuffer ? this._shaderDefs | SHADERDEF_INSTANCING : this._shaderDefs & ~SHADERDEF_INSTANCING);
  }
  ensureMaterial(device) {
    if (!this.material) {
      this.material = getDefaultMaterial(device);
    }
  }
  clearParameters() {
    this.parameters = {};
  }
  getParameters() {
    return this.parameters;
  }
  getParameter(name) {
    return this.parameters[name];
  }
  setParameter(name, data2, passFlags = -262141) {
    if (data2 === void 0 && typeof name === "object") {
      const uniformObject = name;
      if (uniformObject.length) {
        for (let i = 0; i < uniformObject.length; i++) {
          this.setParameter(uniformObject[i]);
        }
        return;
      }
      name = uniformObject.name;
      data2 = uniformObject.value;
    }
    const param = this.parameters[name];
    if (param) {
      param.data = data2;
      param.passFlags = passFlags;
    } else {
      this.parameters[name] = {
        scopeId: null,
        data: data2,
        passFlags
      };
    }
  }
  setRealtimeLightmap(name, texture) {
    const old = this.getParameter(name);
    if (old === texture) {
      return;
    }
    if (old) {
      LightmapCache.decRef(old.data);
    }
    if (texture) {
      LightmapCache.incRef(texture);
      this.setParameter(name, texture);
    } else {
      this.deleteParameter(name);
    }
  }
  deleteParameter(name) {
    if (this.parameters[name]) {
      delete this.parameters[name];
    }
  }
  setParameters(device, passFlag) {
    const parameters = this.parameters;
    for (const paramName in parameters) {
      const parameter = parameters[paramName];
      if (parameter.passFlags & passFlag) {
        if (!parameter.scopeId) {
          parameter.scopeId = device.scope.resolve(paramName);
        }
        parameter.scopeId.setValue(parameter.data);
      }
    }
  }
  setLightmapped(value) {
    if (value) {
      this.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);
    } else {
      this.setRealtimeLightmap(_MeshInstance.lightmapParamNames[0], null);
      this.setRealtimeLightmap(_MeshInstance.lightmapParamNames[1], null);
      this._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);
      this.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);
    }
  }
  setCustomAabb(aabb3) {
    if (aabb3) {
      if (this._customAabb) {
        this._customAabb.copy(aabb3);
      } else {
        this._customAabb = aabb3.clone();
      }
    } else {
      this._customAabb = null;
      this._aabbVer = -1;
    }
    this._setupSkinUpdate();
  }
  _setupSkinUpdate() {
    if (this._skinInstance) {
      this._skinInstance._updateBeforeCull = !this._customAabb;
    }
  }
};
MeshInstance.lightmapParamNames = ["texture_lightMap", "texture_dirLightMap"];

// ../node_modules/playcanvas/build/playcanvas/src/scene/batching/batch-manager.js
var _triFanIndices = [0, 1, 3, 2, 3, 1];
var _triStripIndices = [0, 1, 3, 0, 3, 2];
var mat3 = new Mat3();
function paramsIdentical(a, b) {
  if (a && !b) return false;
  if (!a && b) return false;
  a = a.data;
  b = b.data;
  if (a === b) return true;
  if (a instanceof Float32Array && b instanceof Float32Array) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  return false;
}
function equalParamSets(params1, params2) {
  for (const param in params1) {
    if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) {
      return false;
    }
  }
  for (const param in params2) {
    if (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param])) {
      return false;
    }
  }
  return true;
}
function getScaleSign(mi) {
  return mi.node.worldTransform.scaleSign;
}
var BatchManager = class {
  constructor(device, root, scene) {
    this.device = device;
    this.rootNode = root;
    this.scene = scene;
    this._init = false;
    this._batchGroups = {};
    this._batchGroupCounter = 0;
    this._batchList = [];
    this._dirtyGroups = [];
  }
  destroy() {
    this.device = null;
    this.rootNode = null;
    this.scene = null;
    this._batchGroups = {};
    this._batchList = [];
    this._dirtyGroups = [];
  }
  addGroup(name, dynamic, maxAabbSize, id13, layers) {
    if (id13 === void 0) {
      id13 = this._batchGroupCounter;
      this._batchGroupCounter++;
    }
    if (this._batchGroups[id13]) {
      return void 0;
    }
    const group = new BatchGroup(id13, name, dynamic, maxAabbSize, layers);
    this._batchGroups[id13] = group;
    return group;
  }
  removeGroup(id13) {
    if (!this._batchGroups[id13]) {
      return;
    }
    const newBatchList = [];
    for (let i = 0; i < this._batchList.length; i++) {
      if (this._batchList[i].batchGroupId === id13) {
        this.destroyBatch(this._batchList[i]);
      } else {
        newBatchList.push(this._batchList[i]);
      }
    }
    this._batchList = newBatchList;
    this._removeModelsFromBatchGroup(this.rootNode, id13);
    delete this._batchGroups[id13];
  }
  markGroupDirty(id13) {
    if (this._dirtyGroups.indexOf(id13) < 0) {
      this._dirtyGroups.push(id13);
    }
  }
  getGroupByName(name) {
    const groups = this._batchGroups;
    for (const group in groups) {
      if (!groups.hasOwnProperty(group)) continue;
      if (groups[group].name === name) {
        return groups[group];
      }
    }
    return null;
  }
  getBatches(batchGroupId) {
    const results = [];
    const len = this._batchList.length;
    for (let i = 0; i < len; i++) {
      const batch = this._batchList[i];
      if (batch.batchGroupId === batchGroupId) {
        results.push(batch);
      }
    }
    return results;
  }
  _removeModelsFromBatchGroup(node, id13) {
    if (!node.enabled) return;
    if (node.model && node.model.batchGroupId === id13) {
      node.model.batchGroupId = -1;
    }
    if (node.render && node.render.batchGroupId === id13) {
      node.render.batchGroupId = -1;
    }
    if (node.element && node.element.batchGroupId === id13) {
      node.element.batchGroupId = -1;
    }
    if (node.sprite && node.sprite.batchGroupId === id13) {
      node.sprite.batchGroupId = -1;
    }
    for (let i = 0; i < node._children.length; i++) {
      this._removeModelsFromBatchGroup(node._children[i], id13);
    }
  }
  insert(type, groupId, node) {
    const group = this._batchGroups[groupId];
    if (group) {
      if (group._obj[type].indexOf(node) < 0) {
        group._obj[type].push(node);
        this.markGroupDirty(groupId);
      }
    }
  }
  remove(type, groupId, node) {
    const group = this._batchGroups[groupId];
    if (group) {
      const idx = group._obj[type].indexOf(node);
      if (idx >= 0) {
        group._obj[type].splice(idx, 1);
        this.markGroupDirty(groupId);
      }
    }
  }
  _extractRender(node, arr, group, groupMeshInstances) {
    if (node.render) {
      arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);
      node.render.removeFromLayers();
    }
    return arr;
  }
  _extractModel(node, arr, group, groupMeshInstances) {
    if (node.model && node.model.model) {
      arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
      node.model.removeModelFromLayers();
    }
    return arr;
  }
  _extractElement(node, arr, group) {
    if (!node.element) return;
    let valid = false;
    if (node.element._text && node.element._text._model.meshInstances.length > 0) {
      arr.push(node.element._text._model.meshInstances[0]);
      node.element.removeModelFromLayers(node.element._text._model);
      valid = true;
    } else if (node.element._image) {
      arr.push(node.element._image._renderable.meshInstance);
      node.element.removeModelFromLayers(node.element._image._renderable.model);
      if (node.element._image._renderable.unmaskMeshInstance) {
        arr.push(node.element._image._renderable.unmaskMeshInstance);
        if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
          node.element._dirtifyMask();
          node.element._onPrerender();
        }
      }
      valid = true;
    }
    if (valid) {
      group._ui = true;
    }
  }
  _collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {
    for (let g = 0; g < groupIds.length; g++) {
      const id13 = groupIds[g];
      const group = this._batchGroups[id13];
      if (!group) continue;
      let arr = groupMeshInstances[id13];
      if (!arr) arr = groupMeshInstances[id13] = [];
      for (let m = 0; m < group._obj.model.length; m++) {
        arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
      }
      for (let r = 0; r < group._obj.render.length; r++) {
        arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);
      }
      for (let e = 0; e < group._obj.element.length; e++) {
        this._extractElement(group._obj.element[e], arr, group);
      }
      for (let s2 = 0; s2 < group._obj.sprite.length; s2++) {
        const node = group._obj.sprite[s2];
        if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
          arr.push(node.sprite._meshInstance);
          node.sprite.removeModelFromLayers();
          group._sprite = true;
          node.sprite._batchGroup = group;
        }
      }
    }
  }
  generate(groupIds) {
    const groupMeshInstances = {};
    if (!groupIds) {
      groupIds = Object.keys(this._batchGroups);
    }
    const newBatchList = [];
    for (let i = 0; i < this._batchList.length; i++) {
      if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
        newBatchList.push(this._batchList[i]);
        continue;
      }
      this.destroyBatch(this._batchList[i]);
    }
    this._batchList = newBatchList;
    this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);
    if (groupIds === this._dirtyGroups) {
      this._dirtyGroups.length = 0;
    } else {
      const newDirtyGroups = [];
      for (let i = 0; i < this._dirtyGroups.length; i++) {
        if (groupIds.indexOf(this._dirtyGroups[i]) < 0) newDirtyGroups.push(this._dirtyGroups[i]);
      }
      this._dirtyGroups = newDirtyGroups;
    }
    let group, lists, groupData, batch;
    for (const groupId in groupMeshInstances) {
      if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
      group = groupMeshInstances[groupId];
      groupData = this._batchGroups[groupId];
      if (!groupData) {
        continue;
      }
      lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);
      for (let i = 0; i < lists.length; i++) {
        batch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));
        if (batch) {
          batch.addToLayers(this.scene, groupData.layers);
        }
      }
    }
  }
  prepare(meshInstances, dynamic, maxAabbSize = Number.POSITIVE_INFINITY, translucent) {
    if (meshInstances.length === 0) return [];
    const halfMaxAabbSize = maxAabbSize * 0.5;
    const maxInstanceCount = 1024;
    const maxNumVertices = 4294967295;
    const aabb3 = new BoundingBox();
    const testAabb = new BoundingBox();
    let skipTranslucentAabb = null;
    let sf;
    const lists = [];
    let j = 0;
    if (translucent) {
      meshInstances.sort((a, b) => {
        return a.drawOrder - b.drawOrder;
      });
    }
    let meshInstancesLeftA = meshInstances;
    let meshInstancesLeftB;
    const skipMesh = translucent ? function(mi) {
      if (skipTranslucentAabb) {
        skipTranslucentAabb.add(mi.aabb);
      } else {
        skipTranslucentAabb = mi.aabb.clone();
      }
      meshInstancesLeftB.push(mi);
    } : function(mi) {
      meshInstancesLeftB.push(mi);
    };
    while (meshInstancesLeftA.length > 0) {
      lists[j] = [meshInstancesLeftA[0]];
      meshInstancesLeftB = [];
      const material = meshInstancesLeftA[0].material;
      const layer = meshInstancesLeftA[0].layer;
      const defs = meshInstancesLeftA[0]._shaderDefs;
      const params = meshInstancesLeftA[0].parameters;
      const stencil = meshInstancesLeftA[0].stencilFront;
      let vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
      const drawOrder = meshInstancesLeftA[0].drawOrder;
      aabb3.copy(meshInstancesLeftA[0].aabb);
      const scaleSign = getScaleSign(meshInstancesLeftA[0]);
      const vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
      const indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
      skipTranslucentAabb = null;
      for (let i = 1; i < meshInstancesLeftA.length; i++) {
        const mi = meshInstancesLeftA[i];
        if (dynamic && lists[j].length >= maxInstanceCount) {
          meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
          break;
        }
        if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {
          skipMesh(mi);
          continue;
        }
        testAabb.copy(aabb3);
        testAabb.add(mi.aabb);
        if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
          skipMesh(mi);
          continue;
        }
        if (stencil) {
          if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {
            skipMesh(mi);
            continue;
          }
        }
        if (scaleSign !== getScaleSign(mi)) {
          skipMesh(mi);
          continue;
        }
        if (!equalParamSets(params, mi.parameters)) {
          skipMesh(mi);
          continue;
        }
        if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
          skipMesh(mi);
          continue;
        }
        aabb3.add(mi.aabb);
        vertCount += mi.mesh.vertexBuffer.getNumVertices();
        lists[j].push(mi);
      }
      j++;
      meshInstancesLeftA = meshInstancesLeftB;
    }
    return lists;
  }
  collectBatchedMeshData(meshInstances, dynamic) {
    let streams = null;
    let batchNumVerts = 0;
    let batchNumIndices = 0;
    let material = null;
    for (let i = 0; i < meshInstances.length; i++) {
      if (meshInstances[i].visible) {
        const mesh = meshInstances[i].mesh;
        const numVerts = mesh.vertexBuffer.numVertices;
        batchNumVerts += numVerts;
        if (mesh.primitive[0].indexed) {
          batchNumIndices += mesh.primitive[0].count;
        } else {
          const primitiveType = mesh.primitive[0].type;
          if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
            if (mesh.primitive[0].count === 4) {
              batchNumIndices += 6;
            }
          }
        }
        if (!streams) {
          material = meshInstances[i].material;
          streams = {};
          const elems = mesh.vertexBuffer.format.elements;
          for (let j = 0; j < elems.length; j++) {
            const semantic = elems[j].name;
            streams[semantic] = {
              numComponents: elems[j].numComponents,
              dataType: elems[j].dataType,
              normalize: elems[j].normalize,
              count: 0
            };
          }
          if (dynamic) {
            streams[SEMANTIC_BLENDINDICES] = {
              numComponents: 1,
              dataType: TYPE_FLOAT32,
              normalize: false,
              count: 0
            };
          }
        }
      }
    }
    return {
      streams,
      batchNumVerts,
      batchNumIndices,
      material
    };
  }
  create(meshInstances, dynamic, batchGroupId) {
    if (!this._init) {
      this.vertexFormats = {};
      this._init = true;
    }
    let stream = null;
    let semantic;
    let mesh, numVerts;
    let batch = null;
    const batchData = this.collectBatchedMeshData(meshInstances, dynamic);
    if (batchData.streams) {
      const streams = batchData.streams;
      let material = batchData.material;
      const batchNumVerts = batchData.batchNumVerts;
      const batchNumIndices = batchData.batchNumIndices;
      batch = new Batch(meshInstances, dynamic, batchGroupId);
      this._batchList.push(batch);
      let indexBase, numIndices, indexData;
      let verticesOffset = 0;
      let indexOffset = 0;
      let transform;
      const vec2 = new Vec3();
      const indexArrayType = batchNumVerts <= 65535 ? Uint16Array : Uint32Array;
      const indices = new indexArrayType(batchNumIndices);
      for (semantic in streams) {
        stream = streams[semantic];
        stream.typeArrayType = typedArrayTypes[stream.dataType];
        stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
        stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
      }
      for (let i = 0; i < meshInstances.length; i++) {
        if (!meshInstances[i].visible) {
          continue;
        }
        mesh = meshInstances[i].mesh;
        numVerts = mesh.vertexBuffer.numVertices;
        if (!dynamic) {
          transform = meshInstances[i].node.getWorldTransform();
        }
        for (semantic in streams) {
          if (semantic !== SEMANTIC_BLENDINDICES) {
            stream = streams[semantic];
            const subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
            const totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
            stream.count += totalComponents;
            if (!dynamic && stream.numComponents >= 3) {
              if (semantic === SEMANTIC_POSITION) {
                for (let j = 0; j < totalComponents; j += stream.numComponents) {
                  vec2.set(subarray[j], subarray[j + 1], subarray[j + 2]);
                  transform.transformPoint(vec2, vec2);
                  subarray[j] = vec2.x;
                  subarray[j + 1] = vec2.y;
                  subarray[j + 2] = vec2.z;
                }
              } else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {
                mat3.invertMat4(transform).transpose();
                for (let j = 0; j < totalComponents; j += stream.numComponents) {
                  vec2.set(subarray[j], subarray[j + 1], subarray[j + 2]);
                  mat3.transformVector(vec2, vec2);
                  subarray[j] = vec2.x;
                  subarray[j + 1] = vec2.y;
                  subarray[j + 2] = vec2.z;
                }
              }
            }
          }
        }
        if (dynamic) {
          stream = streams[SEMANTIC_BLENDINDICES];
          for (let j = 0; j < numVerts; j++) {
            stream.buffer[stream.count++] = i;
          }
        }
        if (mesh.primitive[0].indexed) {
          indexBase = mesh.primitive[0].base;
          numIndices = mesh.primitive[0].count;
          const srcFormat = mesh.indexBuffer[0].getFormat();
          indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
        } else {
          const primitiveType = mesh.primitive[0].type;
          if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
            if (mesh.primitive[0].count === 4) {
              indexBase = 0;
              numIndices = 6;
              indexData = primitiveType === PRIMITIVE_TRIFAN ? _triFanIndices : _triStripIndices;
            } else {
              numIndices = 0;
              continue;
            }
          }
        }
        for (let j = 0; j < numIndices; j++) {
          indices[j + indexOffset] = indexData[indexBase + j] + verticesOffset;
        }
        indexOffset += numIndices;
        verticesOffset += numVerts;
      }
      mesh = new Mesh(this.device);
      for (semantic in streams) {
        stream = streams[semantic];
        mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, void 0, stream.dataType, stream.normalize);
      }
      if (indices.length > 0) {
        mesh.setIndices(indices);
      }
      mesh.update(PRIMITIVE_TRIANGLES, false);
      if (dynamic) {
        material = material.clone();
        material.update();
      }
      const meshInstance = new MeshInstance(mesh, material, this.rootNode);
      meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
      meshInstance.parameters = batch.origMeshInstances[0].parameters;
      meshInstance.layer = batch.origMeshInstances[0].layer;
      meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
      meshInstance.batching = true;
      meshInstance.cull = batch.origMeshInstances[0].cull;
      const batchGroup = this._batchGroups[batchGroupId];
      if (batchGroup && batchGroup._ui) {
        meshInstance.cull = false;
      }
      if (dynamic) {
        const nodes = [];
        for (let i = 0; i < batch.origMeshInstances.length; i++) {
          nodes.push(batch.origMeshInstances[i].node);
        }
        meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
      }
      meshInstance._updateAabb = false;
      meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
      meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
      meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
      meshInstance.flipFacesFactor = getScaleSign(batch.origMeshInstances[0]);
      meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
      batch.meshInstance = meshInstance;
      batch.updateBoundingBox();
    }
    return batch;
  }
  updateAll() {
    if (this._dirtyGroups.length > 0) {
      this.generate(this._dirtyGroups);
    }
    for (let i = 0; i < this._batchList.length; i++) {
      if (!this._batchList[i].dynamic) continue;
      this._batchList[i].updateBoundingBox();
    }
  }
  clone(batch, clonedMeshInstances) {
    const batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);
    this._batchList.push(batch2);
    const nodes = [];
    for (let i = 0; i < clonedMeshInstances.length; i++) {
      nodes.push(clonedMeshInstances[i].node);
    }
    batch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);
    batch2.meshInstance._updateAabb = false;
    batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
    batch2.meshInstance.cull = clonedMeshInstances[0].cull;
    batch2.meshInstance.layer = clonedMeshInstances[0].layer;
    if (batch.dynamic) {
      batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
    }
    batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
    return batch2;
  }
  destroyBatch(batch) {
    batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/render-pass-color-grab.js
var _colorUniformName = "uSceneColorMap";
var RenderPassColorGrab = class extends RenderPass {
  constructor(...args) {
    super(...args);
    this.colorRenderTarget = null;
    this.source = null;
  }
  destroy() {
    super.destroy();
    this.releaseRenderTarget(this.colorRenderTarget);
  }
  shouldReallocate(targetRT, sourceTexture, sourceFormat) {
    const targetFormat = targetRT == null ? void 0 : targetRT.colorBuffer.format;
    if (targetFormat !== sourceFormat) {
      return true;
    }
    const width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
    const height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
    return !targetRT || width !== targetRT.width || height !== targetRT.height;
  }
  allocateRenderTarget(renderTarget, sourceRenderTarget, device, format) {
    const texture = new Texture(device, {
      name: _colorUniformName,
      format,
      width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
      height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
      mipmaps: true,
      minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
      magFilter: FILTER_LINEAR,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
    if (renderTarget) {
      renderTarget.destroyFrameBuffers();
      renderTarget._colorBuffer = texture;
      renderTarget._colorBuffers = [texture];
    } else {
      renderTarget = new RenderTarget({
        name: "ColorGrabRT",
        colorBuffer: texture,
        depth: false,
        stencil: false,
        autoResolve: false
      });
    }
    return renderTarget;
  }
  releaseRenderTarget(rt) {
    if (rt) {
      rt.destroyTextureBuffers();
      rt.destroy();
    }
  }
  frameUpdate() {
    var _sourceRt$colorBuffer;
    const device = this.device;
    const sourceRt = this.source;
    const sourceFormat = (_sourceRt$colorBuffer = sourceRt == null ? void 0 : sourceRt.colorBuffer.format) != null ? _sourceRt$colorBuffer : this.device.backBufferFormat;
    if (this.shouldReallocate(this.colorRenderTarget, sourceRt == null ? void 0 : sourceRt.colorBuffer, sourceFormat)) {
      this.releaseRenderTarget(this.colorRenderTarget);
      this.colorRenderTarget = this.allocateRenderTarget(this.colorRenderTarget, sourceRt, device, sourceFormat);
    }
    const colorBuffer = this.colorRenderTarget.colorBuffer;
    device.scope.resolve(_colorUniformName).setValue(colorBuffer);
  }
  execute() {
    const device = this.device;
    const sourceRt = this.source;
    const colorBuffer = this.colorRenderTarget.colorBuffer;
    if (device.isWebGPU) {
      device.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);
      device.mipmapRenderer.generate(this.colorRenderTarget.colorBuffer.impl);
    } else {
      device.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);
      device.activeTexture(device.maxCombinedTextures - 1);
      device.bindTexture(colorBuffer);
      device.gl.generateMipmap(colorBuffer.impl._glTarget);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/render-pass-depth-grab.js
var _depthUniformName = "uSceneDepthMap";
var RenderPassDepthGrab = class extends RenderPass {
  constructor(device, camera) {
    super(device);
    this.depthRenderTarget = null;
    this.camera = null;
    this.camera = camera;
  }
  destroy() {
    super.destroy();
    this.releaseRenderTarget(this.depthRenderTarget);
  }
  shouldReallocate(targetRT, sourceTexture) {
    const width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
    const height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
    return !targetRT || width !== targetRT.width || height !== targetRT.height;
  }
  allocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth) {
    const texture = new Texture(device, {
      name: _depthUniformName,
      format,
      width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
      height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
    if (renderTarget) {
      renderTarget.destroyFrameBuffers();
      if (isDepth) {
        renderTarget._depthBuffer = texture;
      } else {
        renderTarget._colorBuffer = texture;
        renderTarget._colorBuffers = [texture];
      }
    } else {
      renderTarget = new RenderTarget({
        name: "DepthGrabRT",
        colorBuffer: isDepth ? null : texture,
        depthBuffer: isDepth ? texture : null,
        depth: !isDepth,
        stencil: device.supportsStencil,
        autoResolve: false
      });
    }
    return renderTarget;
  }
  releaseRenderTarget(rt) {
    if (rt) {
      rt.destroyTextureBuffers();
      rt.destroy();
    }
  }
  before() {
    var _camera$renderTarget, _camera$renderTarget$, _camera$renderTarget2, _camera$renderTarget3;
    const camera = this.camera;
    const device = this.device;
    const destinationRt = (_camera$renderTarget = camera == null ? void 0 : camera.renderTarget) != null ? _camera$renderTarget : device.backBuffer;
    let useDepthBuffer = true;
    let format = destinationRt.stencil ? PIXELFORMAT_DEPTHSTENCIL : PIXELFORMAT_DEPTH;
    if (device.isWebGPU) {
      const numSamples = destinationRt.samples;
      if (numSamples > 1) {
        format = PIXELFORMAT_R32F;
        useDepthBuffer = false;
      }
    }
    const sourceTexture = (_camera$renderTarget$ = (_camera$renderTarget2 = camera.renderTarget) == null ? void 0 : _camera$renderTarget2.depthBuffer) != null ? _camera$renderTarget$ : (_camera$renderTarget3 = camera.renderTarget) == null ? void 0 : _camera$renderTarget3.colorBuffer;
    if (this.shouldReallocate(this.depthRenderTarget, sourceTexture)) {
      this.releaseRenderTarget(this.depthRenderTarget);
      this.depthRenderTarget = this.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, format, useDepthBuffer);
    }
    const colorBuffer = useDepthBuffer ? this.depthRenderTarget.depthBuffer : this.depthRenderTarget.colorBuffer;
    device.scope.resolve(_depthUniformName).setValue(colorBuffer);
  }
  execute() {
    const device = this.device;
    if (device.isWebGL2 && device.renderTarget.samples > 1) {
      const src = device.renderTarget.impl._glFrameBuffer;
      const dest = this.depthRenderTarget;
      device.renderTarget = dest;
      device.updateBegin();
      this.depthRenderTarget.impl.internalResolve(device, src, dest.impl._glFrameBuffer, this.depthRenderTarget, device.gl.DEPTH_BUFFER_BIT);
    } else {
      device.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/camera.js
var _deviceCoord = new Vec3();
var _halfSize2 = new Vec3();
var _point = new Vec3();
var _invViewProjMat = new Mat4();
var _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
var Camera = class _Camera {
  constructor() {
    this.shaderPassInfo = null;
    this.renderPassColorGrab = null;
    this.renderPassDepthGrab = null;
    this.renderingParams = null;
    this.renderPasses = [];
    this.jitter = 0;
    this._aspectRatio = 16 / 9;
    this._aspectRatioMode = ASPECT_AUTO;
    this._calculateProjection = null;
    this._calculateTransform = null;
    this._clearColor = new Color(0.75, 0.75, 0.75, 1);
    this._clearColorBuffer = true;
    this._clearDepth = 1;
    this._clearDepthBuffer = true;
    this._clearStencil = 0;
    this._clearStencilBuffer = true;
    this._cullFaces = true;
    this._farClip = 1e3;
    this._flipFaces = false;
    this._fov = 45;
    this._frustumCulling = true;
    this._horizontalFov = false;
    this._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];
    this._layersSet = new Set(this._layers);
    this._nearClip = 0.1;
    this._node = null;
    this._orthoHeight = 10;
    this._projection = PROJECTION_PERSPECTIVE;
    this._rect = new Vec4(0, 0, 1, 1);
    this._renderTarget = null;
    this._scissorRect = new Vec4(0, 0, 1, 1);
    this._scissorRectClear = false;
    this._aperture = 16;
    this._shutter = 1 / 1e3;
    this._sensitivity = 1e3;
    this._projMat = new Mat4();
    this._projMatDirty = true;
    this._projMatSkybox = new Mat4();
    this._viewMat = new Mat4();
    this._viewMatDirty = true;
    this._viewProjMat = new Mat4();
    this._viewProjMatDirty = true;
    this._shaderMatricesVersion = 0;
    this._viewProjInverse = new Mat4();
    this._viewProjCurrent = null;
    this._viewProjPrevious = new Mat4();
    this._jitters = [0, 0, 0, 0];
    this.frustum = new Frustum();
    this._xr = null;
    this._xrProperties = {
      horizontalFov: this._horizontalFov,
      fov: this._fov,
      aspectRatio: this._aspectRatio,
      farClip: this._farClip,
      nearClip: this._nearClip
    };
  }
  destroy() {
    var _this$renderPassColor, _this$renderPassDepth;
    (_this$renderPassColor = this.renderPassColorGrab) == null || _this$renderPassColor.destroy();
    this.renderPassColorGrab = null;
    (_this$renderPassDepth = this.renderPassDepthGrab) == null || _this$renderPassDepth.destroy();
    this.renderPassDepthGrab = null;
    this.renderPasses.length = 0;
  }
  _storeShaderMatrices(viewProjMat2, jitterX, jitterY, renderVersion) {
    if (this._shaderMatricesVersion !== renderVersion) {
      var _this$_viewProjCurren, _this$_viewProjCurren2;
      this._shaderMatricesVersion = renderVersion;
      this._viewProjPrevious.copy((_this$_viewProjCurren = this._viewProjCurrent) != null ? _this$_viewProjCurren : viewProjMat2);
      (_this$_viewProjCurren2 = this._viewProjCurrent) != null ? _this$_viewProjCurren2 : this._viewProjCurrent = new Mat4();
      this._viewProjCurrent.copy(viewProjMat2);
      this._viewProjInverse.invert(viewProjMat2);
      this._jitters[2] = this._jitters[0];
      this._jitters[3] = this._jitters[1];
      this._jitters[0] = jitterX;
      this._jitters[1] = jitterY;
    }
  }
  get fullSizeClearRect() {
    const rect = this._scissorRectClear ? this.scissorRect : this._rect;
    return rect.x === 0 && rect.y === 0 && rect.z === 1 && rect.w === 1;
  }
  set aspectRatio(newValue) {
    if (this._aspectRatio !== newValue) {
      this._aspectRatio = newValue;
      this._projMatDirty = true;
    }
  }
  get aspectRatio() {
    var _this$xr;
    return (_this$xr = this.xr) != null && _this$xr.active ? this._xrProperties.aspectRatio : this._aspectRatio;
  }
  set aspectRatioMode(newValue) {
    if (this._aspectRatioMode !== newValue) {
      this._aspectRatioMode = newValue;
      this._projMatDirty = true;
    }
  }
  get aspectRatioMode() {
    return this._aspectRatioMode;
  }
  set calculateProjection(newValue) {
    this._calculateProjection = newValue;
    this._projMatDirty = true;
  }
  get calculateProjection() {
    return this._calculateProjection;
  }
  set calculateTransform(newValue) {
    this._calculateTransform = newValue;
  }
  get calculateTransform() {
    return this._calculateTransform;
  }
  set clearColor(newValue) {
    this._clearColor.copy(newValue);
  }
  get clearColor() {
    return this._clearColor;
  }
  set clearColorBuffer(newValue) {
    this._clearColorBuffer = newValue;
  }
  get clearColorBuffer() {
    return this._clearColorBuffer;
  }
  set clearDepth(newValue) {
    this._clearDepth = newValue;
  }
  get clearDepth() {
    return this._clearDepth;
  }
  set clearDepthBuffer(newValue) {
    this._clearDepthBuffer = newValue;
  }
  get clearDepthBuffer() {
    return this._clearDepthBuffer;
  }
  set clearStencil(newValue) {
    this._clearStencil = newValue;
  }
  get clearStencil() {
    return this._clearStencil;
  }
  set clearStencilBuffer(newValue) {
    this._clearStencilBuffer = newValue;
  }
  get clearStencilBuffer() {
    return this._clearStencilBuffer;
  }
  set cullFaces(newValue) {
    this._cullFaces = newValue;
  }
  get cullFaces() {
    return this._cullFaces;
  }
  set farClip(newValue) {
    if (this._farClip !== newValue) {
      this._farClip = newValue;
      this._projMatDirty = true;
    }
  }
  get farClip() {
    var _this$xr2;
    return (_this$xr2 = this.xr) != null && _this$xr2.active ? this._xrProperties.farClip : this._farClip;
  }
  set flipFaces(newValue) {
    this._flipFaces = newValue;
  }
  get flipFaces() {
    return this._flipFaces;
  }
  set fov(newValue) {
    if (this._fov !== newValue) {
      this._fov = newValue;
      this._projMatDirty = true;
    }
  }
  get fov() {
    var _this$xr3;
    return (_this$xr3 = this.xr) != null && _this$xr3.active ? this._xrProperties.fov : this._fov;
  }
  set frustumCulling(newValue) {
    this._frustumCulling = newValue;
  }
  get frustumCulling() {
    return this._frustumCulling;
  }
  set horizontalFov(newValue) {
    if (this._horizontalFov !== newValue) {
      this._horizontalFov = newValue;
      this._projMatDirty = true;
    }
  }
  get horizontalFov() {
    var _this$xr4;
    return (_this$xr4 = this.xr) != null && _this$xr4.active ? this._xrProperties.horizontalFov : this._horizontalFov;
  }
  set layers(newValue) {
    this._layers = newValue.slice(0);
    this._layersSet = new Set(this._layers);
  }
  get layers() {
    return this._layers;
  }
  get layersSet() {
    return this._layersSet;
  }
  set nearClip(newValue) {
    if (this._nearClip !== newValue) {
      this._nearClip = newValue;
      this._projMatDirty = true;
    }
  }
  get nearClip() {
    var _this$xr5;
    return (_this$xr5 = this.xr) != null && _this$xr5.active ? this._xrProperties.nearClip : this._nearClip;
  }
  set node(newValue) {
    this._node = newValue;
  }
  get node() {
    return this._node;
  }
  set orthoHeight(newValue) {
    if (this._orthoHeight !== newValue) {
      this._orthoHeight = newValue;
      this._projMatDirty = true;
    }
  }
  get orthoHeight() {
    return this._orthoHeight;
  }
  set projection(newValue) {
    if (this._projection !== newValue) {
      this._projection = newValue;
      this._projMatDirty = true;
    }
  }
  get projection() {
    return this._projection;
  }
  get projectionMatrix() {
    this._evaluateProjectionMatrix();
    return this._projMat;
  }
  set rect(newValue) {
    this._rect.copy(newValue);
  }
  get rect() {
    return this._rect;
  }
  set renderTarget(newValue) {
    this._renderTarget = newValue;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  set scissorRect(newValue) {
    this._scissorRect.copy(newValue);
  }
  get scissorRect() {
    return this._scissorRect;
  }
  get viewMatrix() {
    if (this._viewMatDirty) {
      const wtm = this._node.getWorldTransform();
      this._viewMat.copy(wtm).invert();
      this._viewMatDirty = false;
    }
    return this._viewMat;
  }
  set aperture(newValue) {
    this._aperture = newValue;
  }
  get aperture() {
    return this._aperture;
  }
  set sensitivity(newValue) {
    this._sensitivity = newValue;
  }
  get sensitivity() {
    return this._sensitivity;
  }
  set shutter(newValue) {
    this._shutter = newValue;
  }
  get shutter() {
    return this._shutter;
  }
  set xr(newValue) {
    if (this._xr !== newValue) {
      this._xr = newValue;
      this._projMatDirty = true;
    }
  }
  get xr() {
    return this._xr;
  }
  clone() {
    return new _Camera().copy(this);
  }
  copy(other) {
    this._aspectRatio = other._aspectRatio;
    this._farClip = other._farClip;
    this._fov = other._fov;
    this._horizontalFov = other._horizontalFov;
    this._nearClip = other._nearClip;
    this._xrProperties.aspectRatio = other._xrProperties.aspectRatio;
    this._xrProperties.farClip = other._xrProperties.farClip;
    this._xrProperties.fov = other._xrProperties.fov;
    this._xrProperties.horizontalFov = other._xrProperties.horizontalFov;
    this._xrProperties.nearClip = other._xrProperties.nearClip;
    this.aspectRatioMode = other.aspectRatioMode;
    this.calculateProjection = other.calculateProjection;
    this.calculateTransform = other.calculateTransform;
    this.clearColor = other.clearColor;
    this.clearColorBuffer = other.clearColorBuffer;
    this.clearDepth = other.clearDepth;
    this.clearDepthBuffer = other.clearDepthBuffer;
    this.clearStencil = other.clearStencil;
    this.clearStencilBuffer = other.clearStencilBuffer;
    this.cullFaces = other.cullFaces;
    this.flipFaces = other.flipFaces;
    this.frustumCulling = other.frustumCulling;
    this.layers = other.layers;
    this.orthoHeight = other.orthoHeight;
    this.projection = other.projection;
    this.rect = other.rect;
    this.renderTarget = other.renderTarget;
    this.scissorRect = other.scissorRect;
    this.aperture = other.aperture;
    this.shutter = other.shutter;
    this.sensitivity = other.sensitivity;
    this.shaderPassInfo = other.shaderPassInfo;
    this.jitter = other.jitter;
    this._projMatDirty = true;
    return this;
  }
  _enableRenderPassColorGrab(device, enable) {
    if (enable) {
      if (!this.renderPassColorGrab) {
        this.renderPassColorGrab = new RenderPassColorGrab(device);
      }
    } else {
      var _this$renderPassColor2;
      (_this$renderPassColor2 = this.renderPassColorGrab) == null || _this$renderPassColor2.destroy();
      this.renderPassColorGrab = null;
    }
  }
  _enableRenderPassDepthGrab(device, renderer, enable) {
    if (enable) {
      if (!this.renderPassDepthGrab) {
        this.renderPassDepthGrab = new RenderPassDepthGrab(device, this);
      }
    } else {
      var _this$renderPassDepth2;
      (_this$renderPassDepth2 = this.renderPassDepthGrab) == null || _this$renderPassDepth2.destroy();
      this.renderPassDepthGrab = null;
    }
  }
  _updateViewProjMat() {
    if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
      this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);
      this._viewProjMatDirty = false;
    }
  }
  worldToScreen(worldCoord, cw, ch, screenCoord = new Vec3()) {
    this._updateViewProjMat();
    this._viewProjMat.transformPoint(worldCoord, screenCoord);
    const vpm = this._viewProjMat.data;
    const w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
    screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
    screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
    return screenCoord;
  }
  screenToWorld(x2, y2, z2, cw, ch, worldCoord = new Vec3()) {
    const range = this.farClip - this.nearClip;
    _deviceCoord.set(x2 / cw, (ch - y2) / ch, z2 / range);
    _deviceCoord.mulScalar(2);
    _deviceCoord.sub(Vec3.ONE);
    if (this._projection === PROJECTION_PERSPECTIVE) {
      Mat4._getPerspectiveHalfSize(_halfSize2, this.fov, this.aspectRatio, this.nearClip, this.horizontalFov);
      _halfSize2.x *= _deviceCoord.x;
      _halfSize2.y *= _deviceCoord.y;
      const invView = this._node.getWorldTransform();
      _halfSize2.z = -this.nearClip;
      invView.transformPoint(_halfSize2, _point);
      const cameraPos = this._node.getPosition();
      worldCoord.sub2(_point, cameraPos);
      worldCoord.normalize();
      worldCoord.mulScalar(z2);
      worldCoord.add(cameraPos);
    } else {
      this._updateViewProjMat();
      _invViewProjMat.copy(this._viewProjMat).invert();
      _invViewProjMat.transformPoint(_deviceCoord, worldCoord);
    }
    return worldCoord;
  }
  _evaluateProjectionMatrix() {
    if (this._projMatDirty) {
      if (this._projection === PROJECTION_PERSPECTIVE) {
        this._projMat.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip, this.horizontalFov);
        this._projMatSkybox.copy(this._projMat);
      } else {
        const y2 = this._orthoHeight;
        const x2 = y2 * this.aspectRatio;
        this._projMat.setOrtho(-x2, x2, -y2, y2, this.nearClip, this.farClip);
        this._projMatSkybox.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip);
      }
      this._projMatDirty = false;
    }
  }
  getProjectionMatrixSkybox() {
    this._evaluateProjectionMatrix();
    return this._projMatSkybox;
  }
  getExposure() {
    const ev100 = Math.log2(this._aperture * this._aperture / this._shutter * 100 / this._sensitivity);
    return 1 / (Math.pow(2, ev100) * 1.2);
  }
  getScreenSize(sphere) {
    if (this._projection === PROJECTION_PERSPECTIVE) {
      const distance = this._node.getPosition().distance(sphere.center);
      if (distance < sphere.radius) {
        return 1;
      }
      const viewAngle = Math.asin(sphere.radius / distance);
      const sphereViewHeight = Math.tan(viewAngle);
      const screenViewHeight = Math.tan(this.fov / 2 * math.DEG_TO_RAD);
      return Math.min(sphereViewHeight / screenViewHeight, 1);
    }
    return math.clamp(sphere.radius / this._orthoHeight, 0, 1);
  }
  getFrustumCorners(near = this.nearClip, far = this.farClip) {
    const fov = this.fov * Math.PI / 180;
    let y2 = this._projection === PROJECTION_PERSPECTIVE ? Math.tan(fov / 2) * near : this._orthoHeight;
    let x2 = y2 * this.aspectRatio;
    const points = _frustumPoints;
    points[0].x = x2;
    points[0].y = -y2;
    points[0].z = -near;
    points[1].x = x2;
    points[1].y = y2;
    points[1].z = -near;
    points[2].x = -x2;
    points[2].y = y2;
    points[2].z = -near;
    points[3].x = -x2;
    points[3].y = -y2;
    points[3].z = -near;
    if (this._projection === PROJECTION_PERSPECTIVE) {
      y2 = Math.tan(fov / 2) * far;
      x2 = y2 * this.aspectRatio;
    }
    points[4].x = x2;
    points[4].y = -y2;
    points[4].z = -far;
    points[5].x = x2;
    points[5].y = y2;
    points[5].z = -far;
    points[6].x = -x2;
    points[6].y = y2;
    points[6].z = -far;
    points[7].x = -x2;
    points[7].y = -y2;
    points[7].z = -far;
    return points;
  }
  setXrProperties(properties3) {
    Object.assign(this._xrProperties, properties3);
    this._projMatDirty = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graph-node.js
var scaleCompensatePosTransform = new Mat4();
var scaleCompensatePos = new Vec3();
var scaleCompensateRot = new Quat();
var scaleCompensateRot2 = new Quat();
var scaleCompensateScale = new Vec3();
var scaleCompensateScaleForParent = new Vec3();
var tmpMat42 = new Mat4();
var tmpQuat = new Quat();
var position = new Vec3();
var invParentWtm = new Mat4();
var rotation = new Quat();
var invParentRot = new Quat();
var matrix = new Mat4();
var target = new Vec3();
var up = new Vec3();
function createTest(attr, value) {
  if (attr instanceof Function) {
    return attr;
  }
  return (node) => {
    let x2 = node[attr];
    if (x2 instanceof Function) {
      x2 = x2();
    }
    return x2 === value;
  };
}
function findNode(node, test) {
  if (test(node)) {
    return node;
  }
  const children = node._children;
  const len = children.length;
  for (let i = 0; i < len; ++i) {
    const result = findNode(children[i], test);
    if (result) {
      return result;
    }
  }
  return null;
}
var GraphNode = class extends EventHandler {
  constructor(name = "Untitled") {
    super();
    this.name = void 0;
    this.tags = new Tags(this);
    this.localPosition = new Vec3();
    this.localRotation = new Quat();
    this.localScale = new Vec3(1, 1, 1);
    this.localEulerAngles = new Vec3();
    this.position = new Vec3();
    this.rotation = new Quat();
    this.eulerAngles = new Vec3();
    this._scale = null;
    this.localTransform = new Mat4();
    this._dirtyLocal = false;
    this._aabbVer = 0;
    this._frozen = false;
    this.worldTransform = new Mat4();
    this._dirtyWorld = false;
    this._worldScaleSign = 0;
    this._normalMatrix = new Mat3();
    this._dirtyNormal = true;
    this._right = null;
    this._up = null;
    this._forward = null;
    this._parent = null;
    this._children = [];
    this._graphDepth = 0;
    this._enabled = true;
    this._enabledInHierarchy = false;
    this.scaleCompensation = false;
    this.name = name;
  }
  get right() {
    if (!this._right) {
      this._right = new Vec3();
    }
    return this.getWorldTransform().getX(this._right).normalize();
  }
  get up() {
    if (!this._up) {
      this._up = new Vec3();
    }
    return this.getWorldTransform().getY(this._up).normalize();
  }
  get forward() {
    if (!this._forward) {
      this._forward = new Vec3();
    }
    return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
  }
  get normalMatrix() {
    const normalMat = this._normalMatrix;
    if (this._dirtyNormal) {
      normalMat.invertMat4(this.getWorldTransform()).transpose();
      this._dirtyNormal = false;
    }
    return normalMat;
  }
  set enabled(enabled) {
    if (this._enabled !== enabled) {
      var _this$_parent;
      this._enabled = enabled;
      if (enabled && (_this$_parent = this._parent) != null && _this$_parent.enabled || !enabled) {
        this._notifyHierarchyStateChanged(this, enabled);
      }
    }
  }
  get enabled() {
    return this._enabled && this._enabledInHierarchy;
  }
  get parent() {
    return this._parent;
  }
  get path() {
    let node = this._parent;
    if (!node) {
      return "";
    }
    let result = this.name;
    while (node && node._parent) {
      result = `${node.name}/${result}`;
      node = node._parent;
    }
    return result;
  }
  get root() {
    let result = this;
    while (result._parent) {
      result = result._parent;
    }
    return result;
  }
  get children() {
    return this._children;
  }
  get graphDepth() {
    return this._graphDepth;
  }
  _notifyHierarchyStateChanged(node, enabled) {
    node._onHierarchyStateChanged(enabled);
    const c2 = node._children;
    for (let i = 0, len = c2.length; i < len; i++) {
      if (c2[i]._enabled) {
        this._notifyHierarchyStateChanged(c2[i], enabled);
      }
    }
  }
  _onHierarchyStateChanged(enabled) {
    this._enabledInHierarchy = enabled;
    if (enabled && !this._frozen) {
      this._unfreezeParentToRoot();
    }
  }
  _cloneInternal(clone) {
    clone.name = this.name;
    const tags = this.tags._list;
    clone.tags.clear();
    for (let i = 0; i < tags.length; i++) {
      clone.tags.add(tags[i]);
    }
    clone.localPosition.copy(this.localPosition);
    clone.localRotation.copy(this.localRotation);
    clone.localScale.copy(this.localScale);
    clone.localEulerAngles.copy(this.localEulerAngles);
    clone.position.copy(this.position);
    clone.rotation.copy(this.rotation);
    clone.eulerAngles.copy(this.eulerAngles);
    clone.localTransform.copy(this.localTransform);
    clone._dirtyLocal = this._dirtyLocal;
    clone.worldTransform.copy(this.worldTransform);
    clone._dirtyWorld = this._dirtyWorld;
    clone._dirtyNormal = this._dirtyNormal;
    clone._aabbVer = this._aabbVer + 1;
    clone._enabled = this._enabled;
    clone.scaleCompensation = this.scaleCompensation;
    clone._enabledInHierarchy = false;
  }
  clone() {
    const clone = new this.constructor();
    this._cloneInternal(clone);
    return clone;
  }
  copy(source) {
    source._cloneInternal(this);
    return this;
  }
  destroy() {
    this.remove();
    const children = this._children;
    while (children.length) {
      const child = children.pop();
      child._parent = null;
      child.destroy();
    }
    this.fire("destroy", this);
    this.off();
  }
  find(attr, value) {
    const results = [];
    const test = createTest(attr, value);
    this.forEach((node) => {
      if (test(node)) {
        results.push(node);
      }
    });
    return results;
  }
  findOne(attr, value) {
    const test = createTest(attr, value);
    return findNode(this, test);
  }
  findByTag() {
    const query = arguments;
    const results = [];
    const queryNode = (node, checkNode) => {
      if (checkNode && node.tags.has(...query)) {
        results.push(node);
      }
      for (let i = 0; i < node._children.length; i++) {
        queryNode(node._children[i], true);
      }
    };
    queryNode(this, false);
    return results;
  }
  findByName(name) {
    return this.findOne("name", name);
  }
  findByPath(path2) {
    const parts = Array.isArray(path2) ? path2 : path2.split("/");
    let result = this;
    for (let i = 0, imax = parts.length; i < imax; ++i) {
      result = result.children.find((c2) => c2.name === parts[i]);
      if (!result) {
        return null;
      }
    }
    return result;
  }
  forEach(callback, thisArg) {
    callback.call(thisArg, this);
    const children = this._children;
    const len = children.length;
    for (let i = 0; i < len; ++i) {
      children[i].forEach(callback, thisArg);
    }
  }
  isDescendantOf(node) {
    let parent = this._parent;
    while (parent) {
      if (parent === node) {
        return true;
      }
      parent = parent._parent;
    }
    return false;
  }
  isAncestorOf(node) {
    return node.isDescendantOf(this);
  }
  getEulerAngles() {
    this.getWorldTransform().getEulerAngles(this.eulerAngles);
    return this.eulerAngles;
  }
  getLocalEulerAngles() {
    this.localRotation.getEulerAngles(this.localEulerAngles);
    return this.localEulerAngles;
  }
  getLocalPosition() {
    return this.localPosition;
  }
  getLocalRotation() {
    return this.localRotation;
  }
  getLocalScale() {
    return this.localScale;
  }
  getLocalTransform() {
    if (this._dirtyLocal) {
      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
      this._dirtyLocal = false;
    }
    return this.localTransform;
  }
  getPosition() {
    this.getWorldTransform().getTranslation(this.position);
    return this.position;
  }
  getRotation() {
    this.rotation.setFromMat4(this.getWorldTransform());
    return this.rotation;
  }
  getScale() {
    if (!this._scale) {
      this._scale = new Vec3();
    }
    return this.getWorldTransform().getScale(this._scale);
  }
  getWorldTransform() {
    if (!this._dirtyLocal && !this._dirtyWorld) {
      return this.worldTransform;
    }
    if (this._parent) {
      this._parent.getWorldTransform();
    }
    this._sync();
    return this.worldTransform;
  }
  get worldScaleSign() {
    if (this._worldScaleSign === 0) {
      this._worldScaleSign = this.getWorldTransform().scaleSign;
    }
    return this._worldScaleSign;
  }
  remove() {
    var _this$_parent2;
    (_this$_parent2 = this._parent) == null || _this$_parent2.removeChild(this);
  }
  reparent(parent, index) {
    this.remove();
    if (parent) {
      if (index >= 0) {
        parent.insertChild(this, index);
      } else {
        parent.addChild(this);
      }
    }
  }
  setLocalEulerAngles(x2, y2, z2) {
    this.localRotation.setFromEulerAngles(x2, y2, z2);
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  setLocalPosition(x2, y2, z2) {
    if (x2 instanceof Vec3) {
      this.localPosition.copy(x2);
    } else {
      this.localPosition.set(x2, y2, z2);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  setLocalRotation(x2, y2, z2, w) {
    if (x2 instanceof Quat) {
      this.localRotation.copy(x2);
    } else {
      this.localRotation.set(x2, y2, z2, w);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  setLocalScale(x2, y2, z2) {
    if (x2 instanceof Vec3) {
      this.localScale.copy(x2);
    } else {
      this.localScale.set(x2, y2, z2);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  _dirtifyLocal() {
    if (!this._dirtyLocal) {
      this._dirtyLocal = true;
      if (!this._dirtyWorld) {
        this._dirtifyWorld();
      }
    }
  }
  _unfreezeParentToRoot() {
    let p = this._parent;
    while (p) {
      p._frozen = false;
      p = p._parent;
    }
  }
  _dirtifyWorld() {
    if (!this._dirtyWorld) {
      this._unfreezeParentToRoot();
    }
    this._dirtifyWorldInternal();
  }
  _dirtifyWorldInternal() {
    if (!this._dirtyWorld) {
      this._frozen = false;
      this._dirtyWorld = true;
      for (let i = 0; i < this._children.length; i++) {
        if (!this._children[i]._dirtyWorld) {
          this._children[i]._dirtifyWorldInternal();
        }
      }
    }
    this._dirtyNormal = true;
    this._worldScaleSign = 0;
    this._aabbVer++;
  }
  setPosition(x2, y2, z2) {
    if (x2 instanceof Vec3) {
      position.copy(x2);
    } else {
      position.set(x2, y2, z2);
    }
    if (this._parent === null) {
      this.localPosition.copy(position);
    } else {
      invParentWtm.copy(this._parent.getWorldTransform()).invert();
      invParentWtm.transformPoint(position, this.localPosition);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  setRotation(x2, y2, z2, w) {
    if (x2 instanceof Quat) {
      rotation.copy(x2);
    } else {
      rotation.set(x2, y2, z2, w);
    }
    if (this._parent === null) {
      this.localRotation.copy(rotation);
    } else {
      const parentRot = this._parent.getRotation();
      invParentRot.copy(parentRot).invert();
      this.localRotation.copy(invParentRot).mul(rotation);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  setPositionAndRotation(position3, rotation2) {
    if (this._parent === null) {
      this.localPosition.copy(position3);
      this.localRotation.copy(rotation2);
    } else {
      const parentWtm = this._parent.getWorldTransform();
      invParentWtm.copy(parentWtm).invert();
      invParentWtm.transformPoint(position3, this.localPosition);
      this.localRotation.setFromMat4(invParentWtm).mul(rotation2);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  setEulerAngles(x2, y2, z2) {
    this.localRotation.setFromEulerAngles(x2, y2, z2);
    if (this._parent !== null) {
      const parentRot = this._parent.getRotation();
      invParentRot.copy(parentRot).invert();
      this.localRotation.mul2(invParentRot, this.localRotation);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  addChild(node) {
    this._prepareInsertChild(node);
    this._children.push(node);
    this._onInsertChild(node);
  }
  addChildAndSaveTransform(node) {
    const wPos = node.getPosition();
    const wRot = node.getRotation();
    this._prepareInsertChild(node);
    node.setPosition(tmpMat42.copy(this.worldTransform).invert().transformPoint(wPos));
    node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));
    this._children.push(node);
    this._onInsertChild(node);
  }
  insertChild(node, index) {
    this._prepareInsertChild(node);
    this._children.splice(index, 0, node);
    this._onInsertChild(node);
  }
  _prepareInsertChild(node) {
    node.remove();
  }
  _fireOnHierarchy(name, nameHierarchy, parent) {
    this.fire(name, parent);
    for (let i = 0; i < this._children.length; i++) {
      this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);
    }
  }
  _onInsertChild(node) {
    node._parent = this;
    const enabledInHierarchy = node._enabled && this.enabled;
    if (node._enabledInHierarchy !== enabledInHierarchy) {
      node._enabledInHierarchy = enabledInHierarchy;
      node._notifyHierarchyStateChanged(node, enabledInHierarchy);
    }
    node._updateGraphDepth();
    node._dirtifyWorld();
    if (this._frozen) {
      node._unfreezeParentToRoot();
    }
    node._fireOnHierarchy("insert", "inserthierarchy", this);
    if (this.fire) this.fire("childinsert", node);
  }
  _updateGraphDepth() {
    this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;
    for (let i = 0, len = this._children.length; i < len; i++) {
      this._children[i]._updateGraphDepth();
    }
  }
  removeChild(child) {
    const index = this._children.indexOf(child);
    if (index === -1) {
      return;
    }
    this._children.splice(index, 1);
    child._parent = null;
    child._fireOnHierarchy("remove", "removehierarchy", this);
    this.fire("childremove", child);
  }
  _sync() {
    if (this._dirtyLocal) {
      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
      this._dirtyLocal = false;
    }
    if (this._dirtyWorld) {
      if (this._parent === null) {
        this.worldTransform.copy(this.localTransform);
      } else {
        if (this.scaleCompensation) {
          let parentWorldScale;
          const parent = this._parent;
          let scale2 = this.localScale;
          let parentToUseScaleFrom = parent;
          if (parentToUseScaleFrom) {
            while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
              parentToUseScaleFrom = parentToUseScaleFrom._parent;
            }
            if (parentToUseScaleFrom) {
              parentToUseScaleFrom = parentToUseScaleFrom._parent;
              if (parentToUseScaleFrom) {
                parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
                scaleCompensateScale.mul2(parentWorldScale, this.localScale);
                scale2 = scaleCompensateScale;
              }
            }
          }
          scaleCompensateRot2.setFromMat4(parent.worldTransform);
          scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
          let tmatrix = parent.worldTransform;
          if (parent.scaleCompensation) {
            scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
            scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
            tmatrix = scaleCompensatePosTransform;
          }
          tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
          this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale2);
        } else {
          this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
        }
      }
      this._dirtyWorld = false;
    }
  }
  syncHierarchy() {
    if (!this._enabled) {
      return;
    }
    if (this._frozen) {
      return;
    }
    this._frozen = true;
    if (this._dirtyLocal || this._dirtyWorld) {
      this._sync();
    }
    const children = this._children;
    for (let i = 0, len = children.length; i < len; i++) {
      children[i].syncHierarchy();
    }
  }
  lookAt(x2, y2, z2, ux = 0, uy = 1, uz = 0) {
    if (x2 instanceof Vec3) {
      target.copy(x2);
      if (y2 instanceof Vec3) {
        up.copy(y2);
      } else {
        up.copy(Vec3.UP);
      }
    } else if (z2 === void 0) {
      return;
    } else {
      target.set(x2, y2, z2);
      up.set(ux, uy, uz);
    }
    matrix.setLookAt(this.getPosition(), target, up);
    rotation.setFromMat4(matrix);
    this.setRotation(rotation);
  }
  translate(x2, y2, z2) {
    if (x2 instanceof Vec3) {
      position.copy(x2);
    } else {
      position.set(x2, y2, z2);
    }
    position.add(this.getPosition());
    this.setPosition(position);
  }
  translateLocal(x2, y2, z2) {
    if (x2 instanceof Vec3) {
      position.copy(x2);
    } else {
      position.set(x2, y2, z2);
    }
    this.localRotation.transformVector(position, position);
    this.localPosition.add(position);
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  rotate(x2, y2, z2) {
    rotation.setFromEulerAngles(x2, y2, z2);
    if (this._parent === null) {
      this.localRotation.mul2(rotation, this.localRotation);
    } else {
      const rot = this.getRotation();
      const parentRot = this._parent.getRotation();
      invParentRot.copy(parentRot).invert();
      rotation.mul2(invParentRot, rotation);
      this.localRotation.mul2(rotation, rot);
    }
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  rotateLocal(x2, y2, z2) {
    rotation.setFromEulerAngles(x2, y2, z2);
    this.localRotation.mul(rotation);
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/light-camera.js
var _viewMat = new Mat4();
var _viewProjMat = new Mat4();
var _viewportMatrix = new Mat4();
var LightCamera = class _LightCamera {
  static create(name, lightType, face) {
    const camera = new Camera();
    camera.node = new GraphNode(name);
    camera.aspectRatio = 1;
    camera.aspectRatioMode = ASPECT_MANUAL;
    camera._scissorRectClear = true;
    switch (lightType) {
      case LIGHTTYPE_OMNI:
        camera.node.setRotation(_LightCamera.pointLightRotations[face]);
        camera.fov = 90;
        camera.projection = PROJECTION_PERSPECTIVE;
        break;
      case LIGHTTYPE_SPOT:
        camera.projection = PROJECTION_PERSPECTIVE;
        break;
      case LIGHTTYPE_DIRECTIONAL:
        camera.projection = PROJECTION_ORTHOGRAPHIC;
        break;
    }
    return camera;
  }
  static evalSpotCookieMatrix(light) {
    let cookieCamera = _LightCamera._spotCookieCamera;
    if (!cookieCamera) {
      cookieCamera = _LightCamera.create("SpotCookieCamera", LIGHTTYPE_SPOT);
      _LightCamera._spotCookieCamera = cookieCamera;
    }
    cookieCamera.fov = light._outerConeAngle * 2;
    const cookieNode = cookieCamera._node;
    cookieNode.setPosition(light._node.getPosition());
    cookieNode.setRotation(light._node.getRotation());
    cookieNode.rotateLocal(-90, 0, 0);
    _viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();
    _viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);
    const cookieMatrix = light.cookieMatrix;
    const rectViewport = light.atlasViewport;
    _viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
    cookieMatrix.mul2(_viewportMatrix, _viewProjMat);
    return cookieMatrix;
  }
};
LightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];
LightCamera._spotCookieCamera = null;

// ../node_modules/playcanvas/build/playcanvas/src/scene/lighting/lights-buffer.js
var epsilon = 1e-6;
var tempVec3 = new Vec3();
var tempAreaLightSizes = new Float32Array(6);
var areaHalfAxisWidth = new Vec3(-0.5, 0, 0);
var areaHalfAxisHeight = new Vec3(0, 0, 0.5);
var TextureIndex8 = {
  FLAGS: 0,
  COLOR_A: 1,
  COLOR_B: 2,
  SPOT_ANGLES: 3,
  SHADOW_BIAS: 4,
  COOKIE_A: 5,
  COOKIE_B: 6,
  COUNT: 7
};
var TextureIndexFloat = {
  POSITION_RANGE: 0,
  SPOT_DIRECTION: 1,
  PROJ_MAT_0: 2,
  ATLAS_VIEWPORT: 2,
  PROJ_MAT_1: 3,
  PROJ_MAT_2: 4,
  PROJ_MAT_3: 5,
  AREA_DATA_WIDTH: 6,
  AREA_DATA_HEIGHT: 7,
  COUNT: 8
};
var _defines;
var LightsBuffer = class {
  static getShaderDefines() {
    const buildShaderDefines = (object, prefix) => {
      return Object.keys(object).map((key) => `#define ${prefix}${key} ${object[key]}`).join("\n");
    };
    if (!_defines) {
      _defines = `

								${buildShaderDefines(TextureIndex8, "CLUSTER_TEXTURE_8_")}
								${buildShaderDefines(TextureIndexFloat, "CLUSTER_TEXTURE_F_")}
						`;
    }
    return _defines;
  }
  constructor(device) {
    this.areaLightsEnabled = false;
    this.device = device;
    this.cookiesEnabled = false;
    this.shadowsEnabled = false;
    this.areaLightsEnabled = false;
    this.maxLights = 255;
    const pixelsPerLight8 = TextureIndex8.COUNT;
    this.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);
    this.lightsTexture8 = this.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_RGBA8, "LightsTexture8");
    this._lightsTexture8Id = this.device.scope.resolve("lightsTexture8");
    const pixelsPerLightFloat = TextureIndexFloat.COUNT;
    this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);
    this.lightsTextureFloat = this.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, "LightsTextureFloat");
    this._lightsTextureFloatId = this.device.scope.resolve("lightsTextureFloat");
    this.invMaxColorValue = 0;
    this.invMaxAttenuation = 0;
    this.boundsMin = new Vec3();
    this.boundsDelta = new Vec3();
  }
  destroy() {
    var _this$lightsTexture, _this$lightsTextureFl;
    (_this$lightsTexture = this.lightsTexture8) == null || _this$lightsTexture.destroy();
    this.lightsTexture8 = null;
    (_this$lightsTextureFl = this.lightsTextureFloat) == null || _this$lightsTextureFl.destroy();
    this.lightsTextureFloat = null;
  }
  createTexture(device, width, height, format, name) {
    const tex = new Texture(device, {
      name,
      width,
      height,
      mipmaps: false,
      format,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      type: TEXTURETYPE_DEFAULT,
      magFilter: FILTER_NEAREST,
      minFilter: FILTER_NEAREST,
      anisotropy: 1
    });
    return tex;
  }
  setCompressionRanges(maxAttenuation, maxColorValue) {
    this.invMaxColorValue = 1 / maxColorValue;
    this.invMaxAttenuation = 1 / maxAttenuation;
  }
  setBounds(min, delta) {
    this.boundsMin.copy(min);
    this.boundsDelta.copy(delta);
  }
  uploadTextures() {
    this.lightsTextureFloat.lock().set(this.lightsFloat);
    this.lightsTextureFloat.unlock();
    this.lightsTexture8.lock().set(this.lights8);
    this.lightsTexture8.unlock();
  }
  updateUniforms() {
    this._lightsTexture8Id.setValue(this.lightsTexture8);
    this._lightsTextureFloatId.setValue(this.lightsTextureFloat);
  }
  getSpotDirection(direction, spot) {
    const mat2 = spot._node.getWorldTransform();
    mat2.getY(direction).mulScalar(-1);
    direction.normalize();
  }
  getLightAreaSizes(light) {
    const mat2 = light._node.getWorldTransform();
    mat2.transformVector(areaHalfAxisWidth, tempVec3);
    tempAreaLightSizes[0] = tempVec3.x;
    tempAreaLightSizes[1] = tempVec3.y;
    tempAreaLightSizes[2] = tempVec3.z;
    mat2.transformVector(areaHalfAxisHeight, tempVec3);
    tempAreaLightSizes[3] = tempVec3.x;
    tempAreaLightSizes[4] = tempVec3.y;
    tempAreaLightSizes[5] = tempVec3.z;
    return tempAreaLightSizes;
  }
  addLightDataFlags(data8, index, light, isSpot, castShadows, shadowIntensity) {
    data8[index + 0] = isSpot ? 255 : 0;
    data8[index + 1] = this.areaLightsEnabled ? light._shape * 64 : 0;
    data8[index + 2] = light._falloffMode * 255;
    data8[index + 3] = castShadows ? shadowIntensity * 255 : 0;
  }
  addLightDataColor(data8, index, light, isCookie) {
    const invMaxColorValue = this.invMaxColorValue;
    const color = light._colorLinear;
    FloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);
    FloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);
    FloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);
    data8[index + 6] = isCookie ? 255 : 0;
    const isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);
    const isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);
    data8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;
  }
  addLightDataSpotAngles(data8, index, light) {
    FloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon) + 0.5, data8, index + 0, 2);
    FloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon) + 0.5, data8, index + 2, 2);
  }
  addLightDataShadowBias(data8, index, light) {
    const lightRenderData = light.getRenderData(null, 0);
    const biases = light._getUniformBiasValues(lightRenderData);
    FloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);
    FloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);
  }
  addLightDataCookies(data8, index, light) {
    const isRgb = light._cookieChannel === "rgb";
    data8[index + 0] = Math.floor(light.cookieIntensity * 255);
    data8[index + 1] = isRgb ? 255 : 0;
    if (!isRgb) {
      const channel = light._cookieChannel;
      data8[index + 4] = channel === "rrr" ? 255 : 0;
      data8[index + 5] = channel === "ggg" ? 255 : 0;
      data8[index + 6] = channel === "bbb" ? 255 : 0;
      data8[index + 7] = channel === "aaa" ? 255 : 0;
    }
  }
  addLightData(light, lightIndex) {
    const isSpot = light._type === LIGHTTYPE_SPOT;
    const hasAtlasViewport = light.atlasViewportAllocated;
    const isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;
    const isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;
    const castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;
    const pos = light._node.getPosition();
    let lightProjectionMatrix = null;
    let atlasViewport = null;
    if (isSpot) {
      if (castShadows) {
        const lightRenderData = light.getRenderData(null, 0);
        lightProjectionMatrix = lightRenderData.shadowMatrix;
      } else if (isCookie) {
        lightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);
      }
    } else {
      if (castShadows || isCookie) {
        atlasViewport = light.atlasViewport;
      }
    }
    const data8 = this.lights8;
    const data8Start = lightIndex * this.lightsTexture8.width * 4;
    this.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows, light.shadowIntensity);
    this.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, isCookie);
    if (isSpot) {
      this.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);
    }
    if (light.castShadows) {
      this.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);
    }
    if (isCookie) {
      this.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);
    }
    const dataFloat = this.lightsFloat;
    const dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;
    dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;
    dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;
    dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;
    dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;
    if (isSpot) {
      this.getSpotDirection(tempVec3, light);
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3.x;
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3.y;
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3.z;
    }
    if (lightProjectionMatrix) {
      const matData = lightProjectionMatrix.data;
      for (let m = 0; m < 16; m++) {
        dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];
      }
    }
    if (atlasViewport) {
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;
    }
    if (isArea) {
      const areaSizes = this.getLightAreaSizes(light);
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];
      dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/lighting/world-clusters.js
var tempVec32 = new Vec3();
var tempMin3 = new Vec3();
var tempMax3 = new Vec3();
var tempBox = new BoundingBox();
var epsilon2 = 1e-6;
var ClusterLight = class {
  constructor() {
    this.light = null;
    this.min = new Vec3();
    this.max = new Vec3();
  }
};
var WorldClusters = class {
  constructor(device) {
    this.clusterTexture = void 0;
    this.device = device;
    this.name = "Untitled";
    this.reportCount = 0;
    this.boundsMin = new Vec3();
    this.boundsMax = new Vec3();
    this.boundsDelta = new Vec3();
    this._cells = new Vec3(1, 1, 1);
    this._cellsLimit = new Vec3();
    this.cells = this._cells;
    this.maxCellLightCount = 4;
    this._maxAttenuation = 0;
    this._maxColorValue = 0;
    this._usedLights = [];
    this._usedLights.push(new ClusterLight());
    this.lightsBuffer = new LightsBuffer(device);
    this.registerUniforms(device);
  }
  set maxCellLightCount(count) {
    if (count !== this._maxCellLightCount) {
      this._maxCellLightCount = count;
      this._cellsDirty = true;
    }
  }
  get maxCellLightCount() {
    return this._maxCellLightCount;
  }
  set cells(value) {
    tempVec32.copy(value).floor();
    if (!this._cells.equals(tempVec32)) {
      this._cells.copy(tempVec32);
      this._cellsLimit.copy(tempVec32).sub(Vec3.ONE);
      this._cellsDirty = true;
    }
  }
  get cells() {
    return this._cells;
  }
  destroy() {
    this.lightsBuffer.destroy();
    this.releaseClusterTexture();
  }
  releaseClusterTexture() {
    if (this.clusterTexture) {
      this.clusterTexture.destroy();
      this.clusterTexture = null;
    }
  }
  registerUniforms(device) {
    this._clusterSkipId = device.scope.resolve("clusterSkip");
    this._clusterMaxCellsId = device.scope.resolve("clusterMaxCells");
    this._clusterWorldTextureId = device.scope.resolve("clusterWorldTexture");
    this._clusterTextureSizeId = device.scope.resolve("clusterTextureSize");
    this._clusterTextureSizeData = new Float32Array(3);
    this._clusterBoundsMinId = device.scope.resolve("clusterBoundsMin");
    this._clusterBoundsMinData = new Float32Array(3);
    this._clusterBoundsDeltaId = device.scope.resolve("clusterBoundsDelta");
    this._clusterBoundsDeltaData = new Float32Array(3);
    this._clusterCellsCountByBoundsSizeId = device.scope.resolve("clusterCellsCountByBoundsSize");
    this._clusterCellsCountByBoundsSizeData = new Float32Array(3);
    this._clusterCellsDotId = device.scope.resolve("clusterCellsDot");
    this._clusterCellsDotData = new Float32Array(3);
    this._clusterCellsMaxId = device.scope.resolve("clusterCellsMax");
    this._clusterCellsMaxData = new Float32Array(3);
    this._clusterCompressionLimit0Id = device.scope.resolve("clusterCompressionLimit0");
    this._clusterCompressionLimit0Data = new Float32Array(2);
  }
  updateParams(lightingParams) {
    if (lightingParams) {
      this.cells = lightingParams.cells;
      this.maxCellLightCount = lightingParams.maxLightsPerCell;
      this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;
      this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;
      this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;
    }
  }
  updateCells() {
    if (this._cellsDirty) {
      this._cellsDirty = false;
      const cx = this._cells.x;
      const cy = this._cells.y;
      const cz = this._cells.z;
      const numCells = cx * cy * cz;
      const totalPixels = this.maxCellLightCount * numCells;
      let width = Math.ceil(Math.sqrt(totalPixels));
      width = math.roundUp(width, this.maxCellLightCount);
      const height = Math.ceil(totalPixels / width);
      this._clusterCellsMaxData[0] = cx;
      this._clusterCellsMaxData[1] = cy;
      this._clusterCellsMaxData[2] = cz;
      this._clusterCellsDotData[0] = this.maxCellLightCount;
      this._clusterCellsDotData[1] = cx * cz * this.maxCellLightCount;
      this._clusterCellsDotData[2] = cx * this.maxCellLightCount;
      this.clusters = new Uint8ClampedArray(totalPixels);
      this.counts = new Int32Array(numCells);
      this._clusterTextureSizeData[0] = width;
      this._clusterTextureSizeData[1] = 1 / width;
      this._clusterTextureSizeData[2] = 1 / height;
      this.releaseClusterTexture();
      this.clusterTexture = this.lightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8, "ClusterTexture");
    }
  }
  uploadTextures() {
    this.clusterTexture.lock().set(this.clusters);
    this.clusterTexture.unlock();
    this.lightsBuffer.uploadTextures();
  }
  updateUniforms() {
    this._clusterSkipId.setValue(this._usedLights.length > 1 ? 0 : 1);
    this.lightsBuffer.updateUniforms();
    this._clusterWorldTextureId.setValue(this.clusterTexture);
    this._clusterMaxCellsId.setValue(this.maxCellLightCount);
    const boundsDelta = this.boundsDelta;
    this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;
    this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;
    this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;
    this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);
    this._clusterBoundsMinData[0] = this.boundsMin.x;
    this._clusterBoundsMinData[1] = this.boundsMin.y;
    this._clusterBoundsMinData[2] = this.boundsMin.z;
    this._clusterBoundsDeltaData[0] = boundsDelta.x;
    this._clusterBoundsDeltaData[1] = boundsDelta.y;
    this._clusterBoundsDeltaData[2] = boundsDelta.z;
    this._clusterCompressionLimit0Data[0] = this._maxAttenuation;
    this._clusterCompressionLimit0Data[1] = this._maxColorValue;
    this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);
    this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);
    this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);
    this._clusterCellsDotId.setValue(this._clusterCellsDotData);
    this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);
    this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);
  }
  evalLightCellMinMax(clusteredLight, min, max) {
    min.copy(clusteredLight.min);
    min.sub(this.boundsMin);
    min.div(this.boundsDelta);
    min.mul2(min, this.cells);
    min.floor();
    max.copy(clusteredLight.max);
    max.sub(this.boundsMin);
    max.div(this.boundsDelta);
    max.mul2(max, this.cells);
    max.ceil();
    min.max(Vec3.ZERO);
    max.min(this._cellsLimit);
  }
  collectLights(lights2) {
    const maxLights = this.lightsBuffer.maxLights;
    const usedLights = this._usedLights;
    let lightIndex = 1;
    lights2.forEach((light) => {
      const runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));
      const zeroAngleSpotlight = light.type === LIGHTTYPE_SPOT && light._outerConeAngle === 0;
      if (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight && !zeroAngleSpotlight) {
        if (lightIndex < maxLights) {
          let clusteredLight;
          if (lightIndex < usedLights.length) {
            clusteredLight = usedLights[lightIndex];
          } else {
            clusteredLight = new ClusterLight();
            usedLights.push(clusteredLight);
          }
          clusteredLight.light = light;
          light.getBoundingBox(tempBox);
          clusteredLight.min.copy(tempBox.getMin());
          clusteredLight.max.copy(tempBox.getMax());
          lightIndex++;
        }
      }
    });
    usedLights.length = lightIndex;
  }
  evaluateBounds() {
    const usedLights = this._usedLights;
    const min = this.boundsMin;
    const max = this.boundsMax;
    if (usedLights.length > 1) {
      min.copy(usedLights[1].min);
      max.copy(usedLights[1].max);
      for (let i = 2; i < usedLights.length; i++) {
        min.min(usedLights[i].min);
        max.max(usedLights[i].max);
      }
    } else {
      min.set(0, 0, 0);
      max.set(1, 1, 1);
    }
    this.boundsDelta.sub2(max, min);
    this.lightsBuffer.setBounds(min, this.boundsDelta);
  }
  evaluateCompressionLimits() {
    let maxAttenuation = 0;
    let maxColorValue = 0;
    const usedLights = this._usedLights;
    for (let i = 1; i < usedLights.length; i++) {
      const light = usedLights[i].light;
      maxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);
      const color = light._colorLinear;
      maxColorValue = Math.max(color[0], maxColorValue);
      maxColorValue = Math.max(color[1], maxColorValue);
      maxColorValue = Math.max(color[2], maxColorValue);
    }
    this._maxAttenuation = maxAttenuation + epsilon2;
    this._maxColorValue = maxColorValue + epsilon2;
    this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);
  }
  updateClusters(lightingParams) {
    this.counts.fill(0);
    this.clusters.fill(0);
    this.lightsBuffer.areaLightsEnabled = lightingParams ? lightingParams.areaLightsEnabled : false;
    const divX = this._cells.x;
    const divZ = this._cells.z;
    const counts = this.counts;
    const limit = this._maxCellLightCount;
    const clusters = this.clusters;
    const pixelsPerCellCount = this.maxCellLightCount;
    const usedLights = this._usedLights;
    for (let i = 1; i < usedLights.length; i++) {
      const clusteredLight = usedLights[i];
      const light = clusteredLight.light;
      this.lightsBuffer.addLightData(light, i);
      this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);
      const xStart = tempMin3.x;
      const xEnd = tempMax3.x;
      const yStart = tempMin3.y;
      const yEnd = tempMax3.y;
      const zStart = tempMin3.z;
      const zEnd = tempMax3.z;
      for (let x2 = xStart; x2 <= xEnd; x2++) {
        for (let z2 = zStart; z2 <= zEnd; z2++) {
          for (let y2 = yStart; y2 <= yEnd; y2++) {
            const clusterIndex = x2 + divX * (z2 + y2 * divZ);
            const count = counts[clusterIndex];
            if (count < limit) {
              clusters[pixelsPerCellCount * clusterIndex + count] = i;
              counts[clusterIndex] = count + 1;
            }
          }
        }
      }
    }
  }
  update(lights2, lightingParams = null) {
    this.updateParams(lightingParams);
    this.updateCells();
    this.collectLights(lights2);
    this.evaluateBounds();
    this.evaluateCompressionLimits();
    this.updateClusters(lightingParams);
    this.uploadTextures();
  }
  activate() {
    this.updateUniforms();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/math/blue-noise.js
var base64String = "muPIHORMLNDCz4DxVR/ZvYfAUVEFR47KRIC4nwAAAAAP7WxlhD6Ci+2HCe7BF8jRAPZwdH2UPpI5PdLCJdkvG4UTaNDJ/0crAzne71GCrb4kbdMjjCEGzdX6fNxDMLJq5xkeoIVTdfiZkodEeArmZmp/FQzFjD4x8iOW7Dg64n+3mWqyEwLxXT8zoJXfbw8QJKDCaarUYyTlMzNFHbgUe9IQV7g4YOgtSKpIFZJ0qERm7u4PpmiF89ktHWCywaGmD6h+hfh2/Zd8KYlKqqo4Cem4T42bT/Z9FpCQF1hhSjfBzZ5XFn/y3jegWC6u86KuELRundQS/1Rp+XuKKGIgRv3CvP5y749yqLlFO495JOT3+f2CXgd71npU0/KjjpkZucbJ5m78IVyuSrSozc9jgBUhDrz0hFsyb7LFUH9//wJbBgLdNWJZObfKxrNt8TliLA9w9sXFv6g26iXpf6r/BqcAusj/QzGBZuoUGeEtw8BCXCZ3jUiw4hvM18ZVqlUD3C40LAFXW6FRjuAZGRNstb0/qVk4skwyT+MHrvRorI4rKHVMWZmKyAkzL/78u/9pMQuX14pZN50b2PHn6fRxeaCQLsfT4dpvIkWWFuFVENZIh+8xgR6lU+85W0PPdAu1j99kcCG40JBQa4JMyRzq6qriOBLtqF87vpCJan0WEduVr/mOYkS00urVA0mA6M3031+GmGmW48PaJDYOEIb3bIXWPaLoAOEinX1TN3+/vwhG6nqJu0TdHpedS7QsGZIoxH3nQYYjQP1jmbahlbNngw5ogsGk1y50XZyUmQBY+/JBJ3Unu4dApm+WmPwHPU9gLb+4mHh4BiY6M86pq+WeTyWdI3s0CXPEtHGXZ8zMZgUoyRomBi1VdazzuN+WOmQ9Pa0Z0tlNopUi8AJ4x2Xn4mmOKEbXLxlbVsWu8XhuDGYFOGCRVdSqDPXrHU5SDdUlti3k5///SBwzTMwK3L4a1H7w4lnpEas6////AfX8asyIBfeFXVJ3tgvxQ/blZuUKyIODIfr/UzdWNu7pciLBpdZRZ4pIfZ1R6szq+XNxkGG///8EZFpu7VHAhFWqHEOrB9unw+YQa5o8/9IR/V5/zq+986rJSyfgJKt2u9hxU1wzyQWPjJGvzG9+eWWxGFOHVKqI4jBQALwZZswesnvZ2UmmkEXdiRpz8B+oWE7PY70ZTMndisYSXg2TqoI+3y9BxbnY2Y4EfbdcRhAvG59NqDENNYbxKvK5HJfPG5M+Wi2AcpLVJrD6caiEOzgSoVNSgQK8fm2M3zGcF4xtClv/8Hs9oD7C3jitTATYNQxmKqKf1LhIxzf1bmfiNn7UKFmcJu4sLqVLwxGSue3taBEyknkw5hXTsUCvqmmL/f8n/w0giR7Hu/9EHvpkz3yuu64TioMkzdTJ30i0+hFnQqW1+v9mMwq+z9qGX0UFu9MomvVG2xod6vc12AAAAACq7sGa5qptFR0jF3nQt/D+7PibKYahaxP3hEixPbGi9nwNf2LAa7LkEZRKxzXeCD64Xpii5n+8Kpg8eHIv7AWXZltgMoGltmoJ0XGdOCL8WkzphvR9N2o3ARSZ42l5e5Pe4B58MCRlP3EKv+mcloknH+fto5BWsmEutW6KvjOVsznFCktkSczVk4aGvj9VXlRcLeDoKG8RkBgdcNG2bf8HUL4MT2DM+ar7NImJhKpxakX4Vk0CnP+/XNhl5UsP0lXgeZXPoDBMSW5An+DXlTCO5FQGwSPYwHLKYVIimEdAoVe49rQLaaNcye5LxU2/c5TijTgJtD5eQQIe1snxauj5jZsxJBUJdoP/zqpjqv8qBruoPsVsP8N44PCUW5Dd0DzqjSS/Dl5mI9cn1w2ndN/0KAEm1QAAAACwu6KM/083IBbH5bPa/9oHUwcU8I9v3j6/v18QYammrf+P6VL///8BrpuM3fOLCxaLNOFNF1zPbPYTP65ni6njft4eVcyrVXRQFrs52tr35StiSp55edVDCBC0H5rIfac6nzUwxQSt7y15QoKb+5zebEQUmVbrPjXuUa19Ey7sqXMiSUKHaw72PJKDdrutJoQr3u6lEYJ8K0MakWKj9zjTFi4X94TsKYco0GrLeB60M6D8M/80rhXUW8iMequg8y5F838WI0+gp3GBN5Kj/xIOxTWQuUaPV/LwvARr1VH93BFgGZR1MFW0Ua30GbYmdnAgo9VWy8SQtpDUgGE2r2zq2eTEMCL7sMKmE1hchVhuF/TCq9iXKEm86kzOf3Rp9ZnCxbpDUj+FKNxVyXe6pVZkRXv/m95SnB/EB8aME29N85MtAcDoXWlor8De2Q5Dg1tar+8wgiZufbMam81j//ASUohoR/zSh2KG4bvT6mkIPz6C5/98DC3LaWlaEZ1zA5JORZRu6J/a0GY285sEYzw71YqOT1ihAG0z5SDt1xNiDQWZdFpndArp6xWhqSDkRb4kSJEHb9liPvw7uLV/6i5MVf//A9Qjr8xkAEUh+KDI+zdtJ68d6MBOktg1iyp/SCq8O9f5pbamn1VVVQPRTWqNBvhQKa07s6P0lc9Luu/3gw4HeyOUfz8MxMwV4UQhua+t9cr4bz/nIB2wnDSK1K7I94M+s6C84htaX/CNlMQUSs2KJO+yaebfTbkNX5yWcqEJevo0vbKUiETuFXiL019A3E+lmsyZMwXrXLLiQAZ5t9+jI3JobhJTMiDH5ZOQ+8Jau5555NMjHSscP9qCVaa40doh+1a3Ukf6jqBmLddgh79/fwTfCyqiuldNkUoy+nUp+4nerwg0OjtGv2x485PJOJvUEokNhYIdWjpx7BWk0VZGWOp3jSFTJ2bnu6KCduZtG/UcBC9RZ3W/jMSfSMw4Etr/DoD/XYP2V5Ovw+YoM3F5g2dGLdvuG6ZkVGLE6Dk5Zr+sdSyGliJP1y2OFf/KFO0RWO+3gsGhesTnfZVpTd8/HwgO216gwaqo+vY3TljfJWowY+i0p0Os4SLn/1wLqDHMlszggmT/D8MRFzs+pLv6LNJSsNZ/r41mWi/rF6ZcKp/yzJdK0VU44hskq3RGpgO6mIpJDsf/mZkFrz0yYOMLbuaj/wp1v7JMFM5eqvBhmTd7U8frQAtHtys4zgpjZmzUhOVTfNNLifElGXADlqHGKrkBT/nYwX8ZRm3RjvyPvjKyEqEGKUpVnvOGx+NKPHiWM//ZDpDVGvvrjmk8RPF/wiYZD3+Us8YCXjrVOfjdd1UPAfjLp8jgSn4me7DPTpz1Ggy9XL80guFO7ECT10AvILKfD18Qx+KY/f8aRqu0oOO8hfKRFZa9PUJwCsp6VdZz6LFkm2b9Pl2LIifCwzRy7TpdG2uAtOxP2OemY26bJMa9ZGSLIRlMsgpDpnDJwd0oa5pQ13x1hrHf52HpulUWonGWsfXZbSQYKu9bnEN76ciQih0opN3deDVrbrxorfVlnCmL1R9zq3ePGWIv21c7pW8kEiFTM5JX8dAw867s/60cf79/BH+MDFCZBHlz1L+qGOJf/1txhhmrf3//As+RIJwevDb+fgNXVeHw67QptZegayhrEwr5Gy+EPo1RLaMtPbqOZYoVzXzwzjMFWZxyUG9YUIf6////AQWy84iAygLk9COtXt92+0mT/xg0zMzMBeLkb8y9SL2TDXgSX422hDgpGNLJyuPioA+YJ91G8znrpNqHkwYyscaJDEc9Vc+j4cXle3hvcd2JqDQH2lBZxDn6mUTs0b75raMvbs727codX01Anj8f3wir9P2xQaQ22v/TxCMglKDFoTjaP01XTLgxnTvPv02JgEUrW6UDgOnobFpLdvKdlypgIzPcq14fgXU5tvVW0FEs7VRlsG1IyA69fN4n+awHhT34cE+xUvdj86C8LgAsFheTjI9Ht9EyYAAAAAAVBVKRx2wLgUTI0/2QfyJo2riRw3JDqzEShmx/Lifo6mRkQVbS7X53t+EvKxcXogtdts31e9MRHdcHgsA8rt4/mt2unlzQ/wsU8Gu7+W6Oj7eD8EQdDp5XlCsVaS/AV/t5ZpPOHR3rGpyAJe9IPV+xMrBL1Oz/8MQhFs31h0N1cVnq371uqIJYHyafKH1jteAK3VpMXBcuC+yt0ZeKyRUY4QhdrJJ4tJ1wg3Hu6kDsbovxupTMkGdRrm8oZSoYPbJ+PwH/xotgTdkA1205vUEfnqkI04T/fnnd1fiZW5AwNcggd7fi4j5zasmcntZexIxqFZQMzMJpfndmI5jn17cgn5EV5t9XN0C///8Q9wlJpMGXdoiaMTG2sVyHQsn8mWRISCLNG777S0OuDRP2GlLcJ2UeOg7Fo8hTNPeJ//iTJhyqxhKRUntdXOihq2wfKfH///8B0GGrwT+fSOQRdctKxjjGCSS11d6BlQ9BDfE0J6Z25FaNTKGpFKNCMr2G/041KpWwBLVe1k08vncseQbKZdXi8x1t9XA45U/Wd43D9wAh3Tal0aiLVzGPusOZ1F+W3TWoqlX/A95+dNef11TsuGful+ctGssldk3fqpfqh+43XTxL42+leSHoF/dWHYGX6maqUEuLX7UB+r/6Llr4LKocbVIeu+hB9QTPfz9fCP8RyWmX4SmbhMFsNtCijV7lVcwejLKlvl0GfCndnWV7/39VBrtTRuUx92oke3GBgKkC5fdGK0YvNK+xenKaDmsHDjNFUM3NMz3ZiXXFuLgojosPVCDEl2W5BjX3Ms+j0GSqACHmh0+RPWyuNm/Qe8vFf9AW7N1uRaxWirrUytqEJnJ4/Flm8hSoiZ2NQBsS6w/yQlC4gCaFo8q4nyY6AFdo4hiwhBXzbNKKvZvktCjSCukRR/BbYVbNwZi2Yh3hGodEacLW8qijiWJODf0P2bhfaiPspPT4lYJBgi/KfcFwCfvyUIgkJOv///8CG/JEepRBLaMFE+2TgrqsJXOVOWHt6g/bFwVLLMVBsMR50dis/39/AlBX+/rMTJkUQrnlxpR2iu0Tp8tATkRYGmDIrcAiRP8PjoWIlb7/0ecTdSCE9Y58+a+n/FovJQTVF4F2jAxMZhTgrM/KVS5BQu6bVbkWY5HXnxRshks3urDdW4RkWp4M4TeLmFK5KF/uHkkiO5Kv96RioH984v/CSDBnG+BwlnU9B+o7Y+0X0Nob+0pLsStxjvPXMy2eCpzhOWV4XbObBHN4UE2sLQ/DIqXhOzxVf38GlTi6aG7EnePO7TRJm9yOfUUcqq1I2iQHrVDqn3TUNRi/lMw8KbMW/3/nqCz/Ef8PoW5Qxcz2yHR/f78EPB2Stbd+ZFmfNTUYILzsb9YNhpaHcaymYrBiNHmFE3Y4ccYJ25Prqm7zHobGHED8/93ZNlWro9vcKivGZs31UiK1k5zjUhexUgbqJb+fUTjxce/7Zly8a5KMC1fX5nfjPgibdvzbXV1jRT2asXvmSAusaLdq1TSIJ8fXINk5AtT34EWPAsfP9IFQqM5K11O6saoHJA==";
var data = null;
var initData = () => {
  if (!data) {
    const binaryString = atob(base64String);
    data = Uint8Array.from(binaryString, (char) => char.charCodeAt(0));
  }
};
var blueNoiseData = () => {
  initData();
  return data;
};
var BlueNoise = class {
  constructor(seed = 0) {
    this.seed = 0;
    this.seed = seed * 4;
    initData();
  }
  _next() {
    this.seed = (this.seed + 4) % data.length;
  }
  value() {
    this._next();
    return data[this.seed] / 255;
  }
  vec4(dest = new Vec4()) {
    this._next();
    return dest.set(data[this.seed], data[this.seed + 1], data[this.seed + 2], data[this.seed + 3]).mulScalar(1 / 255);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/light-cube.js
var lightCubeDir = [new Vec3(-1, 0, 0), new Vec3(1, 0, 0), new Vec3(0, -1, 0), new Vec3(0, 1, 0), new Vec3(0, 0, -1), new Vec3(0, 0, 1)];
var LightCube = class {
  constructor() {
    this.colors = new Float32Array(6 * 3);
  }
  update(ambientLight, lights2) {
    const colors = this.colors;
    const {
      r,
      g,
      b
    } = ambientLight;
    for (let j = 0; j < 6; j++) {
      colors[j * 3] = r;
      colors[j * 3 + 1] = g;
      colors[j * 3 + 2] = b;
    }
    for (let j = 0; j < lights2.length; j++) {
      const light = lights2[j];
      if (light._type === LIGHTTYPE_DIRECTIONAL) {
        for (let c2 = 0; c2 < 6; c2++) {
          const weight = Math.max(lightCubeDir[c2].dot(light._direction), 0) * light._intensity;
          const lightColor = light._color;
          colors[c2 * 3] += lightColor.r * weight;
          colors[c2 * 3 + 1] += lightColor.g * weight;
          colors[c2 * 3 + 2] += lightColor.b * weight;
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/noise-textures.js
var createTexture = (device, namePrefix, size, data2) => {
  const texture = new Texture(device, {
    name: `${namePrefix}${size}`,
    width: size,
    height: size,
    format: PIXELFORMAT_RGBA8,
    addressU: ADDRESS_REPEAT,
    addressV: ADDRESS_REPEAT,
    type: TEXTURETYPE_DEFAULT,
    magFilter: FILTER_NEAREST,
    minFilter: FILTER_NEAREST,
    anisotropy: 1,
    mipmaps: false
  });
  texture.lock().set(data2);
  texture.unlock();
  return texture;
};
var deviceCacheBlueNoise = new DeviceCache();
var getBlueNoiseTexture = (device) => {
  return deviceCacheBlueNoise.get(device, () => {
    const data2 = blueNoiseData();
    const size = Math.sqrt(data2.length / 4);
    return createTexture(device, "BlueNoise", size, data2);
  });
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-map.js
var ShadowMap = class _ShadowMap {
  constructor(texture, targets) {
    this.texture = texture;
    this.cached = false;
    this.renderTargets = targets;
  }
  destroy() {
    if (this.texture) {
      this.texture.destroy();
      this.texture = null;
    }
    const targets = this.renderTargets;
    for (let i = 0; i < targets.length; i++) {
      targets[i].destroy();
    }
    this.renderTargets.length = 0;
  }
  static getShadowFormat(device, shadowType) {
    if (shadowType === SHADOW_VSM32) {
      return PIXELFORMAT_RGBA32F;
    } else if (shadowType === SHADOW_VSM16) {
      return PIXELFORMAT_RGBA16F;
    } else if (shadowType === SHADOW_PCF5) {
      return PIXELFORMAT_DEPTH;
    } else if (shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3) {
      return PIXELFORMAT_DEPTH;
    } else if (shadowType === SHADOW_PCSS) {
      return PIXELFORMAT_R32F;
    }
    return PIXELFORMAT_RGBA8;
  }
  static getShadowFiltering(device, shadowType) {
    if (shadowType === SHADOW_VSM32) {
      return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
    }
    return FILTER_LINEAR;
  }
  static create(device, light) {
    let shadowMap = null;
    if (light._type === LIGHTTYPE_OMNI) {
      shadowMap = this.createCubemap(device, light._shadowResolution, light._shadowType);
    } else {
      shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
    }
    return shadowMap;
  }
  static createAtlas(device, resolution, shadowType) {
    const shadowMap = this.create2dMap(device, resolution, shadowType);
    const targets = shadowMap.renderTargets;
    const rt = targets[0];
    for (let i = 0; i < 5; i++) {
      targets.push(rt);
    }
    return shadowMap;
  }
  static create2dMap(device, size, shadowType) {
    const format = this.getShadowFormat(device, shadowType);
    const filter = this.getShadowFiltering(device, shadowType);
    const texture = new Texture(device, {
      format,
      width: size,
      height: size,
      mipmaps: false,
      minFilter: filter,
      magFilter: filter,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name: "ShadowMap2D"
    });
    let target2 = null;
    if (shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3) {
      texture.compareOnRead = true;
      texture.compareFunc = FUNC_LESS;
      target2 = new RenderTarget({
        depthBuffer: texture
      });
    } else {
      target2 = new RenderTarget({
        colorBuffer: texture,
        depth: true
      });
    }
    if (device.isWebGPU) {
      target2.flipY = true;
    }
    return new _ShadowMap(texture, [target2]);
  }
  static createCubemap(device, size, shadowType) {
    const format = shadowType === SHADOW_PCSS ? PIXELFORMAT_R32F : PIXELFORMAT_RGBA8;
    const cubemap = new Texture(device, {
      format,
      width: size,
      height: size,
      cubemap: true,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name: "ShadowMapCube"
    });
    const targets = [];
    for (let i = 0; i < 6; i++) {
      const target2 = new RenderTarget({
        colorBuffer: cubemap,
        face: i,
        depth: true
      });
      targets.push(target2);
    }
    return new _ShadowMap(cubemap, targets);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/lighting/light-texture-atlas.js
var _tempArray = [];
var _tempArray2 = [];
var _viewport = new Vec4();
var _scissor = new Vec4();
var Slot = class {
  constructor(rect) {
    this.size = Math.floor(rect.w * 1024);
    this.used = false;
    this.lightId = -1;
    this.rect = rect;
  }
};
var LightTextureAtlas = class {
  constructor(device) {
    this.device = device;
    this.version = 1;
    this.shadowAtlasResolution = 2048;
    this.shadowAtlas = null;
    this.shadowEdgePixels = 3;
    this.cookieAtlasResolution = 4;
    this.cookieAtlas = new Texture(this.device, {
      name: "CookieAtlas",
      width: this.cookieAtlasResolution,
      height: this.cookieAtlasResolution,
      format: PIXELFORMAT_RGBA8,
      cubemap: false,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
    this.cookieRenderTarget = new RenderTarget({
      colorBuffer: this.cookieAtlas,
      depth: false,
      flipY: true
    });
    this.slots = [];
    this.atlasSplit = [];
    this.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];
    this.scissorVec = new Vec4();
    this.allocateShadowAtlas(1);
    this.allocateCookieAtlas(1);
    this.allocateUniforms();
  }
  destroy() {
    this.destroyShadowAtlas();
    this.destroyCookieAtlas();
  }
  destroyShadowAtlas() {
    var _this$shadowAtlas;
    (_this$shadowAtlas = this.shadowAtlas) == null || _this$shadowAtlas.destroy();
    this.shadowAtlas = null;
  }
  destroyCookieAtlas() {
    var _this$cookieAtlas, _this$cookieRenderTar;
    (_this$cookieAtlas = this.cookieAtlas) == null || _this$cookieAtlas.destroy();
    this.cookieAtlas = null;
    (_this$cookieRenderTar = this.cookieRenderTarget) == null || _this$cookieRenderTar.destroy();
    this.cookieRenderTarget = null;
  }
  allocateShadowAtlas(resolution) {
    if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {
      this.version++;
      this.destroyShadowAtlas();
      this.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, SHADOW_PCF3);
      this.shadowAtlas.cached = true;
      const scissorOffset = 4 / this.shadowAtlasResolution;
      this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);
    }
  }
  allocateCookieAtlas(resolution) {
    if (this.cookieAtlas.width !== resolution) {
      this.cookieRenderTarget.resize(resolution, resolution);
      this.version++;
    }
  }
  allocateUniforms() {
    this._shadowAtlasTextureId = this.device.scope.resolve("shadowAtlasTexture");
    this._shadowAtlasParamsId = this.device.scope.resolve("shadowAtlasParams");
    this._shadowAtlasParams = new Float32Array(2);
    this._cookieAtlasTextureId = this.device.scope.resolve("cookieAtlasTexture");
  }
  updateUniforms() {
    const rt = this.shadowAtlas.renderTargets[0];
    const shadowBuffer = rt.depthBuffer;
    this._shadowAtlasTextureId.setValue(shadowBuffer);
    this._shadowAtlasParams[0] = this.shadowAtlasResolution;
    this._shadowAtlasParams[1] = this.shadowEdgePixels;
    this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);
    this._cookieAtlasTextureId.setValue(this.cookieAtlas);
  }
  subdivide(numLights, lightingParams) {
    let atlasSplit = lightingParams.atlasSplit;
    if (!atlasSplit) {
      const gridSize = Math.ceil(Math.sqrt(numLights));
      atlasSplit = _tempArray2;
      atlasSplit[0] = gridSize;
      atlasSplit.length = 1;
    }
    const arraysEqual2 = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);
    if (!arraysEqual2(atlasSplit, this.atlasSplit)) {
      this.version++;
      this.slots.length = 0;
      this.atlasSplit.length = 0;
      this.atlasSplit.push(...atlasSplit);
      const splitCount = this.atlasSplit[0];
      if (splitCount > 1) {
        const invSize = 1 / splitCount;
        for (let i = 0; i < splitCount; i++) {
          for (let j = 0; j < splitCount; j++) {
            const rect = new Vec4(i * invSize, j * invSize, invSize, invSize);
            const nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];
            if (nextLevelSplit > 1) {
              for (let x2 = 0; x2 < nextLevelSplit; x2++) {
                for (let y2 = 0; y2 < nextLevelSplit; y2++) {
                  const invSizeNext = invSize / nextLevelSplit;
                  const rectNext = new Vec4(rect.x + x2 * invSizeNext, rect.y + y2 * invSizeNext, invSizeNext, invSizeNext);
                  this.slots.push(new Slot(rectNext));
                }
              }
            } else {
              this.slots.push(new Slot(rect));
            }
          }
        }
      } else {
        this.slots.push(new Slot(new Vec4(0, 0, 1, 1)));
      }
      this.slots.sort((a, b) => {
        return b.size - a.size;
      });
    }
  }
  collectLights(localLights, lightingParams) {
    const cookiesEnabled = lightingParams.cookiesEnabled;
    const shadowsEnabled = lightingParams.shadowsEnabled;
    let needsShadowAtlas = false;
    let needsCookieAtlas = false;
    const lights2 = _tempArray;
    lights2.length = 0;
    const processLights = (list) => {
      for (let i = 0; i < list.length; i++) {
        const light = list[i];
        if (light.visibleThisFrame) {
          const lightShadow = shadowsEnabled && light.castShadows;
          const lightCookie = cookiesEnabled && !!light.cookie;
          needsShadowAtlas || (needsShadowAtlas = lightShadow);
          needsCookieAtlas || (needsCookieAtlas = lightCookie);
          if (lightShadow || lightCookie) {
            lights2.push(light);
          }
        }
      }
    };
    if (cookiesEnabled || shadowsEnabled) {
      processLights(localLights);
    }
    lights2.sort((a, b) => {
      return b.maxScreenSize - a.maxScreenSize;
    });
    if (needsShadowAtlas) {
      this.allocateShadowAtlas(this.shadowAtlasResolution);
    }
    if (needsCookieAtlas) {
      this.allocateCookieAtlas(this.cookieAtlasResolution);
    }
    if (needsShadowAtlas || needsCookieAtlas) {
      this.subdivide(lights2.length, lightingParams);
    }
    return lights2;
  }
  setupSlot(light, rect) {
    light.atlasViewport.copy(rect);
    const faceCount = light.numShadowFaces;
    for (let face = 0; face < faceCount; face++) {
      if (light.castShadows || light._cookie) {
        _viewport.copy(rect);
        _scissor.copy(rect);
        if (light._type === LIGHTTYPE_SPOT) {
          _viewport.add(this.scissorVec);
        }
        if (light._type === LIGHTTYPE_OMNI) {
          const smallSize = _viewport.z / 3;
          const offset = this.cubeSlotsOffsets[face];
          _viewport.x += smallSize * offset.x;
          _viewport.y += smallSize * offset.y;
          _viewport.z = smallSize;
          _viewport.w = smallSize;
          _scissor.copy(_viewport);
        }
        if (light.castShadows) {
          const lightRenderData = light.getRenderData(null, face);
          lightRenderData.shadowViewport.copy(_viewport);
          lightRenderData.shadowScissor.copy(_scissor);
        }
      }
    }
  }
  assignSlot(light, slotIndex, slotReassigned) {
    light.atlasViewportAllocated = true;
    const slot = this.slots[slotIndex];
    slot.lightId = light.id;
    slot.used = true;
    if (slotReassigned) {
      light.atlasSlotUpdated = true;
      light.atlasVersion = this.version;
      light.atlasSlotIndex = slotIndex;
    }
  }
  update(localLights, lightingParams) {
    this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;
    this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;
    const lights2 = this.collectLights(localLights, lightingParams);
    if (lights2.length > 0) {
      const slots = this.slots;
      for (let i = 0; i < slots.length; i++) {
        slots[i].used = false;
      }
      const assignCount = Math.min(lights2.length, slots.length);
      for (let i = 0; i < assignCount; i++) {
        const light = lights2[i];
        if (light.castShadows) {
          light._shadowMap = this.shadowAtlas;
        }
        const previousSlot = slots[light.atlasSlotIndex];
        if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {
          const _previousSlot = slots[light.atlasSlotIndex];
          if (_previousSlot.size === slots[i].size && !_previousSlot.used) {
            this.assignSlot(light, light.atlasSlotIndex, false);
          }
        }
      }
      let usedCount = 0;
      for (let i = 0; i < assignCount; i++) {
        while (usedCount < slots.length && slots[usedCount].used) {
          usedCount++;
        }
        const light = lights2[i];
        if (!light.atlasViewportAllocated) {
          this.assignSlot(light, usedCount, true);
        }
        const slot = slots[light.atlasSlotIndex];
        this.setupSlot(light, slot.rect);
      }
    }
    this.updateUniforms();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/material.js
var blendModes = [];
blendModes[BLEND_SUBTRACTIVE] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_REVERSE_SUBTRACT
};
blendModes[BLEND_NONE] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ZERO,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_NORMAL] = {
  src: BLENDMODE_SRC_ALPHA,
  dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
  op: BLENDEQUATION_ADD,
  alphaSrc: BLENDMODE_ONE
};
blendModes[BLEND_PREMULTIPLIED] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_ADDITIVE] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_ADDITIVEALPHA] = {
  src: BLENDMODE_SRC_ALPHA,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_MULTIPLICATIVE2X] = {
  src: BLENDMODE_DST_COLOR,
  dst: BLENDMODE_SRC_COLOR,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_SCREEN] = {
  src: BLENDMODE_ONE_MINUS_DST_COLOR,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_MULTIPLICATIVE] = {
  src: BLENDMODE_DST_COLOR,
  dst: BLENDMODE_ZERO,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_MIN] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_MIN
};
blendModes[BLEND_MAX] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_MAX
};
var id11 = 0;
var Material = class _Material {
  constructor() {
    this.meshInstances = [];
    this.name = "Untitled";
    this.userId = "";
    this.id = id11++;
    this.variants = /* @__PURE__ */ new Map();
    this.defines = /* @__PURE__ */ new Map();
    this._definesDirty = false;
    this.parameters = {};
    this.alphaTest = 0;
    this.alphaToCoverage = false;
    this._blendState = new BlendState();
    this._depthState = new DepthState();
    this.cull = CULLFACE_BACK;
    this.stencilFront = null;
    this.stencilBack = null;
    this._shaderVersion = 0;
    this._scene = null;
    this.dirty = true;
    if (new.target === _Material) ;
  }
  set depthBias(value) {
    this._depthState.depthBias = value;
  }
  get depthBias() {
    return this._depthState.depthBias;
  }
  set slopeDepthBias(value) {
    this._depthState.depthBiasSlope = value;
  }
  get slopeDepthBias() {
    return this._depthState.depthBiasSlope;
  }
  set redWrite(value) {
    this._blendState.redWrite = value;
  }
  get redWrite() {
    return this._blendState.redWrite;
  }
  set greenWrite(value) {
    this._blendState.greenWrite = value;
  }
  get greenWrite() {
    return this._blendState.greenWrite;
  }
  set blueWrite(value) {
    this._blendState.blueWrite = value;
  }
  get blueWrite() {
    return this._blendState.blueWrite;
  }
  set alphaWrite(value) {
    this._blendState.alphaWrite = value;
  }
  get alphaWrite() {
    return this._blendState.alphaWrite;
  }
  get transparent() {
    return this._blendState.blend;
  }
  _updateTransparency() {
    const transparent = this.transparent;
    const meshInstances = this.meshInstances;
    for (let i = 0; i < meshInstances.length; i++) {
      meshInstances[i].transparent = transparent;
    }
  }
  set blendState(value) {
    this._blendState.copy(value);
    this._updateTransparency();
  }
  get blendState() {
    return this._blendState;
  }
  set blendType(type) {
    var _blendMode$alphaOp, _blendMode$alphaSrc, _blendMode$alphaDst;
    const blendMode = blendModes[type];
    this._blendState.setColorBlend(blendMode.op, blendMode.src, blendMode.dst);
    this._blendState.setAlphaBlend((_blendMode$alphaOp = blendMode.alphaOp) != null ? _blendMode$alphaOp : blendMode.op, (_blendMode$alphaSrc = blendMode.alphaSrc) != null ? _blendMode$alphaSrc : blendMode.src, (_blendMode$alphaDst = blendMode.alphaDst) != null ? _blendMode$alphaDst : blendMode.dst);
    const blend = type !== BLEND_NONE;
    if (this._blendState.blend !== blend) {
      this._blendState.blend = blend;
      this._updateTransparency();
    }
    this._updateMeshInstanceKeys();
  }
  get blendType() {
    if (!this.transparent) {
      return BLEND_NONE;
    }
    const {
      colorOp,
      colorSrcFactor,
      colorDstFactor,
      alphaOp,
      alphaSrcFactor,
      alphaDstFactor
    } = this._blendState;
    for (let i = 0; i < blendModes.length; i++) {
      const blendMode = blendModes[i];
      if (blendMode.src === colorSrcFactor && blendMode.dst === colorDstFactor && blendMode.op === colorOp && blendMode.src === alphaSrcFactor && blendMode.dst === alphaDstFactor && blendMode.op === alphaOp) {
        return i;
      }
    }
    return BLEND_NORMAL;
  }
  set depthState(value) {
    this._depthState.copy(value);
  }
  get depthState() {
    return this._depthState;
  }
  set depthTest(value) {
    this._depthState.test = value;
  }
  get depthTest() {
    return this._depthState.test;
  }
  set depthFunc(value) {
    this._depthState.func = value;
  }
  get depthFunc() {
    return this._depthState.func;
  }
  set depthWrite(value) {
    this._depthState.write = value;
  }
  get depthWrite() {
    return this._depthState.write;
  }
  copy(source) {
    var _source$stencilFront;
    this.name = source.name;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this._blendState.copy(source._blendState);
    this._depthState.copy(source._depthState);
    this.cull = source.cull;
    this.stencilFront = (_source$stencilFront = source.stencilFront) == null ? void 0 : _source$stencilFront.clone();
    if (source.stencilBack) {
      this.stencilBack = source.stencilFront === source.stencilBack ? this.stencilFront : source.stencilBack.clone();
    }
    this.clearParameters();
    for (const name in source.parameters) {
      if (source.parameters.hasOwnProperty(name)) {
        this._setParameterSimple(name, source.parameters[name].data);
      }
    }
    this.defines.clear();
    source.defines.forEach((define) => this.defines.add(define));
    return this;
  }
  clone() {
    const clone = new this.constructor();
    return clone.copy(this);
  }
  _updateMeshInstanceKeys() {
    const meshInstances = this.meshInstances;
    for (let i = 0; i < meshInstances.length; i++) {
      meshInstances[i].updateKey();
    }
  }
  updateUniforms(device, scene) {
  }
  getShaderVariant(params) {
  }
  update() {
    if (this._definesDirty) {
      this._definesDirty = false;
      this.clearVariants();
    }
    this.dirty = true;
  }
  clearParameters() {
    this.parameters = {};
  }
  getParameters() {
    return this.parameters;
  }
  clearVariants() {
    this.variants.clear();
    const meshInstances = this.meshInstances;
    const count = meshInstances.length;
    for (let i = 0; i < count; i++) {
      meshInstances[i].clearShaders();
    }
  }
  getParameter(name) {
    return this.parameters[name];
  }
  _setParameterSimple(name, data2) {
    const param = this.parameters[name];
    if (param) {
      param.data = data2;
    } else {
      this.parameters[name] = {
        scopeId: null,
        data: data2
      };
    }
  }
  setParameter(name, data2) {
    if (data2 === void 0 && typeof name === "object") {
      const uniformObject = name;
      if (uniformObject.length) {
        for (let i = 0; i < uniformObject.length; i++) {
          this.setParameter(uniformObject[i]);
        }
        return;
      }
      name = uniformObject.name;
      data2 = uniformObject.value;
    }
    this._setParameterSimple(name, data2);
  }
  deleteParameter(name) {
    if (this.parameters[name]) {
      delete this.parameters[name];
    }
  }
  setParameters(device, names) {
    const parameters = this.parameters;
    if (names === void 0) names = parameters;
    for (const paramName in names) {
      const parameter = parameters[paramName];
      if (parameter) {
        if (!parameter.scopeId) {
          parameter.scopeId = device.scope.resolve(paramName);
        }
        parameter.scopeId.setValue(parameter.data);
      }
    }
  }
  setDefine(name, value) {
    let modified = false;
    const {
      defines
    } = this;
    if (value !== void 0 && value !== false) {
      modified = !defines.has(name) || defines.get(name) !== value;
      defines.set(name, value);
    } else {
      modified = defines.has(name);
      defines.delete(name);
    }
    this._definesDirty || (this._definesDirty = modified);
  }
  getDefine(name) {
    return this.defines.has(name);
  }
  destroy() {
    this.variants.clear();
    for (let i = 0; i < this.meshInstances.length; i++) {
      const meshInstance = this.meshInstances[i];
      meshInstance.clearShaders();
      meshInstance._material = null;
      if (meshInstance.mesh) {
        const defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);
        if (this !== defaultMaterial) {
          meshInstance.material = defaultMaterial;
        }
      }
    }
    this.meshInstances.length = 0;
  }
  addMeshInstanceRef(meshInstance) {
    this.meshInstances.push(meshInstance);
  }
  removeMeshInstanceRef(meshInstance) {
    const meshInstances = this.meshInstances;
    const i = meshInstances.indexOf(meshInstance);
    if (i !== -1) {
      meshInstances.splice(i, 1);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-map-cache.js
var ShadowMapCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.clear();
    this.cache = null;
  }
  clear() {
    this.cache.forEach((shadowMaps) => {
      shadowMaps.forEach((shadowMap) => {
        shadowMap.destroy();
      });
    });
    this.cache.clear();
  }
  getKey(light) {
    const isCubeMap = light._type === LIGHTTYPE_OMNI;
    const shadowType = light._shadowType;
    const resolution = light._shadowResolution;
    return `${isCubeMap}-${shadowType}-${resolution}`;
  }
  get(device, light) {
    const key = this.getKey(light);
    const shadowMaps = this.cache.get(key);
    if (shadowMaps && shadowMaps.length) {
      return shadowMaps.pop();
    }
    const shadowMap = ShadowMap.create(device, light);
    shadowMap.cached = true;
    return shadowMap;
  }
  add(light, shadowMap) {
    const key = this.getKey(light);
    const shadowMaps = this.cache.get(key);
    if (shadowMaps) {
      shadowMaps.push(shadowMap);
    } else {
      this.cache.set(key, [shadowMap]);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-shadow-local-non-clustered.js
var RenderPassShadowLocalNonClustered = class extends RenderPass {
  constructor(device, shadowRenderer, light, face, applyVsm) {
    super(device);
    this.requiresCubemaps = false;
    this.shadowRenderer = shadowRenderer;
    this.light = light;
    this.face = face;
    this.applyVsm = applyVsm;
    this.shadowCamera = shadowRenderer.prepareFace(light, null, face);
    shadowRenderer.setupRenderPass(this, this.shadowCamera, true);
  }
  execute() {
    this.shadowRenderer.renderFace(this.light, null, this.face, false);
  }
  after() {
    if (this.applyVsm) {
      this.shadowRenderer.renderVsm(this.light, this.shadowCamera);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-renderer-local.js
var ShadowRendererLocal = class {
  constructor(renderer, shadowRenderer) {
    this.shadowLights = [];
    this.renderer = void 0;
    this.shadowRenderer = void 0;
    this.device = void 0;
    this.renderer = renderer;
    this.shadowRenderer = shadowRenderer;
    this.device = renderer.device;
  }
  cull(light, comp, casters = null) {
    const isClustered = this.renderer.scene.clusteredLightingEnabled;
    light.visibleThisFrame = true;
    if (!isClustered) {
      if (!light._shadowMap) {
        light._shadowMap = ShadowMap.create(this.device, light);
      }
    }
    const type = light._type;
    const faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;
    for (let face = 0; face < faceCount; face++) {
      const lightRenderData = light.getRenderData(null, face);
      const shadowCam = lightRenderData.shadowCamera;
      shadowCam.nearClip = light.attenuationEnd / 1e3;
      shadowCam.farClip = light.attenuationEnd;
      lightRenderData.depthRangeCompensation = shadowCam.farClip - shadowCam.nearClip;
      const shadowCamNode = shadowCam._node;
      const lightNode = light._node;
      shadowCamNode.setPosition(lightNode.getPosition());
      if (type === LIGHTTYPE_SPOT) {
        shadowCam.fov = light._outerConeAngle * 2;
        shadowCamNode.setRotation(lightNode.getRotation());
        shadowCamNode.rotateLocal(-90, 0, 0);
      } else if (type === LIGHTTYPE_OMNI) {
        if (isClustered) {
          const tileSize = this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;
          const texelSize = 2 / tileSize;
          const filterSize = texelSize * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
          shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
        } else {
          shadowCam.fov = 90;
        }
      }
      this.renderer.updateCameraFrustum(shadowCam);
      this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
    }
  }
  prepareLights(shadowLights, lights2) {
    let shadowCamera;
    for (let i = 0; i < lights2.length; i++) {
      const light = lights2[i];
      if (this.shadowRenderer.needsShadowRendering(light) && light.atlasViewportAllocated) {
        shadowLights.push(light);
        for (let face = 0; face < light.numShadowFaces; face++) {
          shadowCamera = this.shadowRenderer.prepareFace(light, null, face);
        }
      }
    }
    return shadowCamera;
  }
  buildNonClusteredRenderPasses(frameGraph, localLights) {
    for (let i = 0; i < localLights.length; i++) {
      const light = localLights[i];
      if (this.shadowRenderer.needsShadowRendering(light)) {
        const applyVsm = light._type === LIGHTTYPE_SPOT;
        const faceCount = light.numShadowFaces;
        for (let face = 0; face < faceCount; face++) {
          const renderPass = new RenderPassShadowLocalNonClustered(this.device, this.shadowRenderer, light, face, applyVsm);
          frameGraph.addRenderPass(renderPass);
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-shadow-directional.js
var RenderPassShadowDirectional = class extends RenderPass {
  constructor(device, shadowRenderer, light, camera, allCascadesRendering) {
    super(device);
    this.shadowRenderer = shadowRenderer;
    this.light = light;
    this.camera = camera;
    this.allCascadesRendering = allCascadesRendering;
  }
  execute() {
    const {
      light,
      camera,
      shadowRenderer,
      allCascadesRendering
    } = this;
    const faceCount = light.numShadowFaces;
    const shadowUpdateOverrides = light.shadowUpdateOverrides;
    for (let face = 0; face < faceCount; face++) {
      if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) !== SHADOWUPDATE_NONE) {
        shadowRenderer.renderFace(light, camera, face, !allCascadesRendering);
      }
      if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_THISFRAME) {
        shadowUpdateOverrides[face] = SHADOWUPDATE_NONE;
      }
    }
  }
  after() {
    this.shadowRenderer.renderVsm(this.light, this.camera);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-renderer-directional.js
var visibleSceneAabb = new BoundingBox();
var center = new Vec3();
var shadowCamView = new Mat4();
var aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
var _depthRange = {
  min: 0,
  max: 0
};
function getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {
  aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;
  aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;
  aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;
  aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;
  aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;
  aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;
  let minz = 9999999999;
  let maxz = -9999999999;
  for (let i = 0; i < 8; ++i) {
    cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);
    const z2 = aabbPoints[i].z;
    if (z2 < minz) minz = z2;
    if (z2 > maxz) maxz = z2;
  }
  _depthRange.min = minz;
  _depthRange.max = maxz;
  return _depthRange;
}
var ShadowRendererDirectional = class {
  constructor(renderer, shadowRenderer) {
    this.renderer = void 0;
    this.shadowRenderer = void 0;
    this.device = void 0;
    this.renderer = renderer;
    this.shadowRenderer = shadowRenderer;
    this.device = renderer.device;
  }
  cull(light, comp, camera, casters = null) {
    light.visibleThisFrame = true;
    if (!light._shadowMap) {
      light._shadowMap = ShadowMap.create(this.device, light);
    }
    const nearDist = camera._nearClip;
    this.generateSplitDistances(light, nearDist, Math.min(camera._farClip, light.shadowDistance));
    const shadowUpdateOverrides = light.shadowUpdateOverrides;
    for (let cascade = 0; cascade < light.numCascades; cascade++) {
      if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[cascade]) === SHADOWUPDATE_NONE) {
        break;
      }
      const lightRenderData = light.getRenderData(camera, cascade);
      const shadowCam = lightRenderData.shadowCamera;
      shadowCam.renderTarget = light._shadowMap.renderTargets[0];
      lightRenderData.shadowViewport.copy(light.cascades[cascade]);
      lightRenderData.shadowScissor.copy(light.cascades[cascade]);
      const shadowCamNode = shadowCam._node;
      const lightNode = light._node;
      shadowCamNode.setPosition(lightNode.getPosition());
      shadowCamNode.setRotation(lightNode.getRotation());
      shadowCamNode.rotateLocal(-90, 0, 0);
      const frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];
      const frustumFarDist = light._shadowCascadeDistances[cascade];
      const frustumPoints = camera.getFrustumCorners(frustumNearDist, frustumFarDist);
      center.set(0, 0, 0);
      const cameraWorldMat = camera.node.getWorldTransform();
      for (let i = 0; i < 8; i++) {
        cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);
        center.add(frustumPoints[i]);
      }
      center.mulScalar(1 / 8);
      let radius = 0;
      for (let i = 0; i < 8; i++) {
        const dist = frustumPoints[i].sub(center).length();
        if (dist > radius) {
          radius = dist;
        }
      }
      const right = shadowCamNode.right;
      const up2 = shadowCamNode.up;
      const lightDir = shadowCamNode.forward;
      const sizeRatio = 0.25 * light._shadowResolution / radius;
      const x2 = Math.ceil(center.dot(up2) * sizeRatio) / sizeRatio;
      const y2 = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;
      const scaledUp = up2.mulScalar(x2);
      const scaledRight = right.mulScalar(y2);
      const dot = center.dot(lightDir);
      const scaledDir = lightDir.mulScalar(dot);
      center.add2(scaledUp, scaledRight).add(scaledDir);
      shadowCamNode.setPosition(center);
      shadowCamNode.translateLocal(0, 0, 1e6);
      shadowCam.nearClip = 0.01;
      shadowCam.farClip = 2e6;
      shadowCam.orthoHeight = radius;
      this.renderer.updateCameraFrustum(shadowCam);
      this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
      let emptyAabb = true;
      const visibleCasters = lightRenderData.visibleCasters;
      for (let i = 0; i < visibleCasters.length; i++) {
        const meshInstance = visibleCasters[i];
        if (emptyAabb) {
          emptyAabb = false;
          visibleSceneAabb.copy(meshInstance.aabb);
        } else {
          visibleSceneAabb.add(meshInstance.aabb);
        }
      }
      shadowCamView.copy(shadowCamNode.getWorldTransform()).invert();
      const depthRange = getDepthRange(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
      shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);
      shadowCam.farClip = depthRange.max - depthRange.min + 0.2;
      lightRenderData.depthRangeCompensation = shadowCam.farClip;
      lightRenderData.projectionCompensation = radius;
    }
  }
  generateSplitDistances(light, nearDist, farDist) {
    light._shadowCascadeDistances.fill(farDist);
    for (let i = 1; i < light.numCascades; i++) {
      const fraction = i / light.numCascades;
      const linearDist = nearDist + (farDist - nearDist) * fraction;
      const logDist = nearDist * (farDist / nearDist) ** fraction;
      const dist = math.lerp(linearDist, logDist, light.cascadeDistribution);
      light._shadowCascadeDistances[i - 1] = dist;
    }
  }
  getLightRenderPass(light, camera) {
    let renderPass = null;
    if (this.shadowRenderer.needsShadowRendering(light)) {
      const faceCount = light.numShadowFaces;
      const shadowUpdateOverrides = light.shadowUpdateOverrides;
      let allCascadesRendering = true;
      let shadowCamera;
      for (let face = 0; face < faceCount; face++) {
        if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_NONE) {
          allCascadesRendering = false;
        }
        shadowCamera = this.shadowRenderer.prepareFace(light, camera, face);
      }
      renderPass = new RenderPassShadowDirectional(this.device, this.shadowRenderer, light, camera, allCascadesRendering);
      this.shadowRenderer.setupRenderPass(renderPass, shadowCamera, allCascadesRendering);
    }
    return renderPass;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-pass.js
var shaderPassDeviceCache = new DeviceCache();
var ShaderPassInfo = class {
  constructor(name, index, options2 = {}) {
    this.index = void 0;
    this.name = void 0;
    this.shaderDefines = void 0;
    this.name = name;
    this.index = index;
    Object.assign(this, options2);
    this.shaderDefines = this.buildShaderDefines();
  }
  buildShaderDefines() {
    let keyword;
    if (this.isShadow) {
      keyword = "SHADOW";
    } else if (this.isForward) {
      keyword = "FORWARD";
    } else if (this.index === SHADER_DEPTH) {
      keyword = "DEPTH";
    } else if (this.index === SHADER_PICK) {
      keyword = "PICK";
    }
    const define1 = keyword ? `#define ${keyword}_PASS
` : "";
    const define2 = `#define ${this.name.toUpperCase()}_PASS
`;
    return define1 + define2;
  }
};
var ShaderPass = class _ShaderPass {
  constructor() {
    this.passesNamed = /* @__PURE__ */ new Map();
    this.passesIndexed = [];
    this.nextIndex = 0;
    const add = (name, index, options2) => {
      this.allocate(name, options2);
    };
    add("forward", SHADER_FORWARD, {
      isForward: true
    });
    add("prepass");
    add("depth");
    add("pick");
    add("shadow");
  }
  static get(device) {
    return shaderPassDeviceCache.get(device, () => {
      return new _ShaderPass();
    });
  }
  allocate(name, options2) {
    let info = this.passesNamed.get(name);
    if (info === void 0) {
      info = new ShaderPassInfo(name, this.nextIndex, options2);
      this.passesNamed.set(info.name, info);
      this.passesIndexed[info.index] = info;
      this.nextIndex++;
    }
    return info;
  }
  getByIndex(index) {
    const info = this.passesIndexed[index];
    return info;
  }
  getByName(name) {
    return this.passesNamed.get(name);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/rendering-params.js
var RenderingParams = class {
  constructor() {
    this._gammaCorrection = GAMMA_SRGB;
    this._toneMapping = TONEMAP_LINEAR;
    this._srgbRenderTarget = false;
    this._hash = void 0;
  }
  get hash() {
    if (this._hash === void 0) {
      const key = `${this.gammaCorrection}_${this.toneMapping}_${this.srgbRenderTarget}`;
      this._hash = hashCode(key);
    }
    return this._hash;
  }
  markDirty() {
    this._hash = void 0;
  }
  set gammaCorrection(value) {
    if (this._gammaCorrection !== value) {
      this._gammaCorrection = value;
      this.markDirty();
    }
  }
  get gammaCorrection() {
    return this._gammaCorrection;
  }
  set toneMapping(value) {
    if (this._toneMapping !== value) {
      this._toneMapping = value;
      this.markDirty();
    }
  }
  get toneMapping() {
    return this._toneMapping;
  }
  set srgbRenderTarget(value) {
    if (this._srgbRenderTarget !== value) {
      this._srgbRenderTarget = value;
      this.markDirty();
    }
  }
  get srgbRenderTarget() {
    return this._srgbRenderTarget;
  }
  get shaderOutputGamma() {
    const gammaOutput = this._gammaCorrection === GAMMA_SRGB && !this._srgbRenderTarget;
    return gammaOutput ? GAMMA_SRGB : GAMMA_NONE;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-renderer.js
var tempSet = /* @__PURE__ */ new Set();
var shadowCamView2 = new Mat4();
var shadowCamViewProj = new Mat4();
var pixelOffset = new Float32Array(2);
var blurScissorRect = new Vec4(1, 1, 0, 0);
var viewportMatrix = new Mat4();
function gauss(x2, sigma) {
  return Math.exp(-(x2 * x2) / (2 * sigma * sigma));
}
function gaussWeights(kernelSize) {
  const sigma = (kernelSize - 1) / (2 * 3);
  const halfWidth = (kernelSize - 1) * 0.5;
  const values = new Array(kernelSize);
  let sum = 0;
  for (let i = 0; i < kernelSize; ++i) {
    values[i] = gauss(i - halfWidth, sigma);
    sum += values[i];
  }
  for (let i = 0; i < kernelSize; ++i) {
    values[i] /= sum;
  }
  return values;
}
var ShadowRenderer = class _ShadowRenderer {
  constructor(renderer, lightTextureAtlas) {
    this.shadowPassCache = [];
    this.device = renderer.device;
    this.renderer = renderer;
    this.lightTextureAtlas = lightTextureAtlas;
    const scope = this.device.scope;
    this.sourceId = scope.resolve("source");
    this.pixelOffsetId = scope.resolve("pixelOffset");
    this.weightId = scope.resolve("weight[0]");
    this.blurVsmShaderCode = [shaderChunks.blurVSMPS, `#define GAUSS
${shaderChunks.blurVSMPS}`];
    const packed = "#define PACKED\n";
    this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
    this.blurVsmShader = [{}, {}];
    this.blurPackedVsmShader = [{}, {}];
    this.blurVsmWeights = {};
    this.shadowMapLightRadiusId = scope.resolve("light_radius");
    this.viewUniformFormat = null;
    this.viewBindGroupFormat = null;
    this.blendStateWrite = new BlendState();
    this.blendStateNoWrite = new BlendState();
    this.blendStateNoWrite.setColorWrite(false, false, false, false);
    this.shadowRenderingParams = new RenderingParams();
  }
  static createShadowCamera(device, shadowType, type, face) {
    const shadowCam = LightCamera.create("ShadowCamera", type, face);
    if (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {
      shadowCam.clearColor = new Color(0, 0, 0, 0);
    } else {
      shadowCam.clearColor = new Color(1, 1, 1, 1);
    }
    shadowCam.clearDepthBuffer = true;
    shadowCam.clearStencilBuffer = false;
    return shadowCam;
  }
  static setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {
    let hwPcf = shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3;
    if (type === LIGHTTYPE_OMNI && !isClustered) {
      hwPcf = false;
    }
    shadowCam.clearColorBuffer = !hwPcf;
  }
  _cullShadowCastersInternal(meshInstances, visible, camera) {
    const numInstances = meshInstances.length;
    for (let i = 0; i < numInstances; i++) {
      const meshInstance = meshInstances[i];
      if (meshInstance.castShadow) {
        if (!meshInstance.cull || meshInstance._isVisible(camera)) {
          meshInstance.visibleThisFrame = true;
          visible.push(meshInstance);
        }
      }
    }
  }
  cullShadowCasters(comp, light, visible, camera, casters) {
    visible.length = 0;
    if (casters) {
      this._cullShadowCastersInternal(casters, visible, camera);
    } else {
      const layers = comp.layerList;
      const len = layers.length;
      for (let i = 0; i < len; i++) {
        const layer = layers[i];
        if (layer._lightsSet.has(light)) {
          if (!tempSet.has(layer)) {
            tempSet.add(layer);
            this._cullShadowCastersInternal(layer.shadowCasters, visible, camera);
          }
        }
      }
      tempSet.clear();
    }
    visible.sort(this.renderer.sortCompareDepth);
  }
  setupRenderState(device, light) {
    const isClustered = this.renderer.scene.clusteredLightingEnabled;
    const useShadowSampler = isClustered ? light._isPcf : light._isPcf && light._type !== LIGHTTYPE_OMNI;
    device.setBlendState(useShadowSampler ? this.blendStateNoWrite : this.blendStateWrite);
    device.setDepthState(light.shadowDepthState);
    device.setStencilState(null, null);
  }
  dispatchUniforms(light, shadowCam, lightRenderData, face) {
    const shadowCamNode = shadowCam._node;
    if (light._type !== LIGHTTYPE_DIRECTIONAL) {
      this.renderer.dispatchViewPos(shadowCamNode.getPosition());
      this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
    }
    shadowCamView2.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
    shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView2);
    const rectViewport = lightRenderData.shadowViewport;
    shadowCam.rect = rectViewport;
    shadowCam.scissorRect = lightRenderData.shadowScissor;
    viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
    lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);
    if (light._type === LIGHTTYPE_DIRECTIONAL) {
      light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);
    }
  }
  getShadowPass(light) {
    var _this$shadowPassCache;
    const lightType = light._type;
    const shadowType = light._shadowType;
    let shadowPassInfo = (_this$shadowPassCache = this.shadowPassCache[lightType]) == null ? void 0 : _this$shadowPassCache[shadowType];
    if (!shadowPassInfo) {
      const shadowPassName = `ShadowPass_${lightType}_${shadowType}`;
      shadowPassInfo = ShaderPass.get(this.device).allocate(shadowPassName, {
        isShadow: true,
        lightType,
        shadowType
      });
      if (!this.shadowPassCache[lightType]) {
        this.shadowPassCache[lightType] = [];
      }
      this.shadowPassCache[lightType][shadowType] = shadowPassInfo;
    }
    return shadowPassInfo.index;
  }
  submitCasters(visibleCasters, light) {
    const device = this.device;
    const renderer = this.renderer;
    const scene = renderer.scene;
    const passFlags = 1 << SHADER_SHADOW;
    const shadowPass = this.getShadowPass(light);
    const renderParams = this.shadowRenderingParams;
    const count = visibleCasters.length;
    for (let i = 0; i < count; i++) {
      const meshInstance = visibleCasters[i];
      const mesh = meshInstance.mesh;
      meshInstance.ensureMaterial(device);
      const material = meshInstance.material;
      renderer.setBaseConstants(device, material);
      renderer.setSkinning(device, meshInstance);
      if (material.dirty) {
        material.updateUniforms(device, scene);
        material.dirty = false;
      }
      if (material.chunks) {
        renderer.setupCullMode(true, 1, meshInstance);
        material.setParameters(device);
        meshInstance.setParameters(device, passFlags);
      }
      const shaderInstance = meshInstance.getShaderInstance(shadowPass, 0, scene, renderParams, this.viewUniformFormat, this.viewBindGroupFormat);
      const shadowShader = shaderInstance.shader;
      meshInstance._key[SORTKEY_DEPTH] = shadowShader.id;
      device.setShader(shadowShader);
      renderer.setVertexBuffers(device, mesh);
      renderer.setMorphing(device, meshInstance.morphInstance);
      this.renderer.setupMeshUniformBuffers(shaderInstance, meshInstance);
      const style = meshInstance.renderStyle;
      device.setIndexBuffer(mesh.indexBuffer[style]);
      renderer.drawInstance(device, meshInstance, mesh, style);
      renderer._shadowDrawCalls++;
    }
  }
  needsShadowRendering(light) {
    const needs = light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame;
    if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {
      light.shadowUpdateMode = SHADOWUPDATE_NONE;
    }
    if (needs) {
      this.renderer._shadowMapUpdates += light.numShadowFaces;
    }
    return needs;
  }
  getLightRenderData(light, camera, face) {
    return light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);
  }
  setupRenderPass(renderPass, shadowCamera, clearRenderTarget) {
    const rt = shadowCamera.renderTarget;
    renderPass.init(rt);
    renderPass.depthStencilOps.clearDepthValue = 1;
    renderPass.depthStencilOps.clearDepth = clearRenderTarget;
    if (rt.depthBuffer) {
      renderPass.depthStencilOps.storeDepth = true;
    } else {
      renderPass.colorOps.clearValue.copy(shadowCamera.clearColor);
      renderPass.colorOps.clear = clearRenderTarget;
      renderPass.depthStencilOps.storeDepth = false;
    }
    renderPass.requiresCubemaps = false;
  }
  prepareFace(light, camera, face) {
    const type = light._type;
    const shadowType = light._shadowType;
    const isClustered = this.renderer.scene.clusteredLightingEnabled;
    const lightRenderData = this.getLightRenderData(light, camera, face);
    const shadowCam = lightRenderData.shadowCamera;
    _ShadowRenderer.setShadowCameraSettings(shadowCam, this.device, shadowType, type, isClustered);
    const renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;
    shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];
    return shadowCam;
  }
  renderFace(light, camera, face, clear, insideRenderPass = true) {
    const device = this.device;
    const lightRenderData = this.getLightRenderData(light, camera, face);
    const shadowCam = lightRenderData.shadowCamera;
    this.dispatchUniforms(light, shadowCam, lightRenderData, face);
    const rt = shadowCam.renderTarget;
    const renderer = this.renderer;
    renderer.setCameraUniforms(shadowCam, rt);
    if (device.supportsUniformBuffers) {
      renderer.setupViewUniformBuffers(lightRenderData.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, 1);
    }
    if (insideRenderPass) {
      renderer.setupViewport(shadowCam, rt);
      if (clear) {
        renderer.clear(shadowCam);
      }
    } else {
      renderer.clearView(shadowCam, rt, true, false);
    }
    this.setupRenderState(device, light);
    this.submitCasters(lightRenderData.visibleCasters, light);
  }
  render(light, camera, insideRenderPass = true) {
    if (this.needsShadowRendering(light)) {
      const faceCount = light.numShadowFaces;
      for (let face = 0; face < faceCount; face++) {
        this.prepareFace(light, camera, face);
        this.renderFace(light, camera, face, true, insideRenderPass);
      }
      this.renderVsm(light, camera);
    }
  }
  renderVsm(light, camera) {
    if (light._isVsm && light._vsmBlurSize > 1) {
      const isClustered = this.renderer.scene.clusteredLightingEnabled;
      if (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {
        this.applyVsmBlur(light, camera);
      }
    }
  }
  getVsmBlurShader(isVsm8, blurMode, filterSize) {
    let blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];
    if (!blurShader) {
      this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
      const blurVS = shaderChunks.fullscreenQuadVS;
      let blurFS = `#define SAMPLES ${filterSize}
`;
      if (isVsm8) {
        blurFS += this.blurPackedVsmShaderCode[blurMode];
      } else {
        blurFS += this.blurVsmShaderCode[blurMode];
      }
      const blurShaderName = `blurVsm${blurMode}${filterSize}${isVsm8}`;
      blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);
      if (isVsm8) {
        this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
      } else {
        this.blurVsmShader[blurMode][filterSize] = blurShader;
      }
    }
    return blurShader;
  }
  applyVsmBlur(light, camera) {
    const device = this.device;
    device.setBlendState(BlendState.NOBLEND);
    const lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);
    const shadowCam = lightRenderData.shadowCamera;
    const origShadowMap = shadowCam.renderTarget;
    const tempShadowMap = this.renderer.shadowMapCache.get(device, light);
    const tempRt = tempShadowMap.renderTargets[0];
    const isVsm8 = light._shadowType === SHADOW_VSM8;
    const blurMode = light.vsmBlurMode;
    const filterSize = light._vsmBlurSize;
    const blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);
    blurScissorRect.z = light._shadowResolution - 2;
    blurScissorRect.w = blurScissorRect.z;
    this.sourceId.setValue(origShadowMap.colorBuffer);
    pixelOffset[0] = 1 / light._shadowResolution;
    pixelOffset[1] = 0;
    this.pixelOffsetId.setValue(pixelOffset);
    if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
    drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
    this.sourceId.setValue(tempRt.colorBuffer);
    pixelOffset[1] = pixelOffset[0];
    pixelOffset[0] = 0;
    this.pixelOffsetId.setValue(pixelOffset);
    drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
    this.renderer.shadowMapCache.add(light, tempShadowMap);
  }
  initViewBindGroupFormat() {
    if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
      this.viewUniformFormat = new UniformBufferFormat(this.device, [new UniformFormat("matrix_viewProjection", UNIFORMTYPE_MAT4)]);
      this.viewBindGroupFormat = new BindGroupFormat(this.device, [new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)]);
    }
  }
  frameUpdate() {
    this.initViewBindGroupFormat();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/world-clusters-allocator.js
var tempClusterArray = [];
var WorldClustersAllocator = class {
  constructor(graphicsDevice) {
    this._empty = null;
    this._allocated = [];
    this._clusters = /* @__PURE__ */ new Map();
    this.device = graphicsDevice;
  }
  destroy() {
    if (this._empty) {
      this._empty.destroy();
      this._empty = null;
    }
    this._allocated.forEach((cluster) => {
      cluster.destroy();
    });
    this._allocated.length = 0;
  }
  get count() {
    return this._allocated.length;
  }
  get empty() {
    if (!this._empty) {
      const empty = new WorldClusters(this.device);
      empty.name = "ClusterEmpty";
      empty.update([]);
      this._empty = empty;
    }
    return this._empty;
  }
  assign(renderPasses) {
    const empty = this.empty;
    tempClusterArray.push(...this._allocated);
    this._allocated.length = 0;
    this._clusters.clear();
    const passCount = renderPasses.length;
    for (let p = 0; p < passCount; p++) {
      const renderPass = renderPasses[p];
      const renderActions = renderPass.renderActions;
      if (renderActions) {
        const count = renderActions.length;
        for (let i = 0; i < count; i++) {
          const ra = renderActions[i];
          ra.lightClusters = null;
          const layer = ra.layer;
          if (layer.hasClusteredLights && layer.meshInstances.length) {
            const hash = layer.getLightIdHash();
            const existingRenderAction = this._clusters.get(hash);
            let clusters = existingRenderAction == null ? void 0 : existingRenderAction.lightClusters;
            if (!clusters) {
              var _tempClusterArray$pop;
              clusters = (_tempClusterArray$pop = tempClusterArray.pop()) != null ? _tempClusterArray$pop : new WorldClusters(this.device);
              this._allocated.push(clusters);
              this._clusters.set(hash, ra);
            }
            ra.lightClusters = clusters;
          }
          if (!ra.lightClusters) {
            ra.lightClusters = empty;
          }
        }
      }
    }
    tempClusterArray.forEach((item) => item.destroy());
    tempClusterArray.length = 0;
  }
  update(renderPasses, lighting) {
    this.assign(renderPasses);
    this._clusters.forEach((renderAction) => {
      const layer = renderAction.layer;
      const cluster = renderAction.lightClusters;
      cluster.update(layer.clusteredLightsSet, lighting);
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-cookie-renderer.js
var textureBlitVertexShader = `
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
		#ifndef WEBGPU
			uv0.y = 1.0 - uv0.y;
		#endif
	}`;
var textureBlitFragmentShader = `
	varying vec2 uv0;
	uniform sampler2D blitTexture;
	void main(void) {
		gl_FragColor = texture2D(blitTexture, uv0);
	}`;
var textureCubeBlitFragmentShader = `
	varying vec2 uv0;
	uniform samplerCube blitTexture;
	uniform mat4 invViewProj;
	void main(void) {
		vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);
		vec4 worldPos = invViewProj * projPos;
		gl_FragColor = textureCube(blitTexture, worldPos.xyz);
	}`;
var _viewport2 = new Vec4();
var _invViewProjMatrices = [];
var RenderPassCookieRenderer = class _RenderPassCookieRenderer extends RenderPass {
  constructor(device, cubeSlotsOffsets) {
    super(device);
    this._quadRenderer2D = null;
    this._quadRendererCube = null;
    this._filteredLights = [];
    this._cubeSlotsOffsets = cubeSlotsOffsets;
    this.requiresCubemaps = false;
    this.blitTextureId = device.scope.resolve("blitTexture");
    this.invViewProjId = device.scope.resolve("invViewProj");
  }
  destroy() {
    var _this$_quadRenderer2D, _this$_quadRendererCu;
    (_this$_quadRenderer2D = this._quadRenderer2D) == null || _this$_quadRenderer2D.destroy();
    this._quadRenderer2D = null;
    (_this$_quadRendererCu = this._quadRendererCube) == null || _this$_quadRendererCu.destroy();
    this._quadRendererCube = null;
  }
  static create(renderTarget, cubeSlotsOffsets) {
    const renderPass = new _RenderPassCookieRenderer(renderTarget.device, cubeSlotsOffsets);
    renderPass.init(renderTarget);
    renderPass.colorOps.clear = false;
    renderPass.depthStencilOps.clearDepth = false;
    return renderPass;
  }
  update(lights2) {
    const filteredLights = this._filteredLights;
    this.filter(lights2, filteredLights);
    this.executeEnabled = filteredLights.length > 0;
  }
  filter(lights2, filteredLights) {
    for (let i = 0; i < lights2.length; i++) {
      const light = lights2[i];
      if (light._type === LIGHTTYPE_DIRECTIONAL) {
        continue;
      }
      if (!light.atlasViewportAllocated) {
        continue;
      }
      if (!light.atlasSlotUpdated) {
        continue;
      }
      if (light.enabled && light.cookie && light.visibleThisFrame) {
        filteredLights.push(light);
      }
    }
  }
  initInvViewProjMatrices() {
    if (!_invViewProjMatrices.length) {
      for (let face = 0; face < 6; face++) {
        const camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);
        const projMat = camera.projectionMatrix;
        const viewMat2 = camera.node.getLocalTransform().clone().invert();
        _invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat2).invert();
      }
    }
  }
  get quadRenderer2D() {
    if (!this._quadRenderer2D) {
      const shader = createShaderFromCode(this.device, textureBlitVertexShader, textureBlitFragmentShader, "cookieRenderer2d");
      this._quadRenderer2D = new QuadRender(shader);
    }
    return this._quadRenderer2D;
  }
  get quadRendererCube() {
    if (!this._quadRendererCube) {
      const shader = createShaderFromCode(this.device, textureBlitVertexShader, textureCubeBlitFragmentShader, "cookieRendererCube");
      this._quadRendererCube = new QuadRender(shader);
    }
    return this._quadRendererCube;
  }
  execute() {
    const device = this.device;
    device.setBlendState(BlendState.NOBLEND);
    device.setCullMode(CULLFACE_NONE);
    device.setDepthState(DepthState.NODEPTH);
    device.setStencilState();
    const renderTargetWidth = this.renderTarget.colorBuffer.width;
    const cubeSlotsOffsets = this._cubeSlotsOffsets;
    const filteredLights = this._filteredLights;
    for (let i = 0; i < filteredLights.length; i++) {
      const light = filteredLights[i];
      const faceCount = light.numShadowFaces;
      const quad = faceCount > 1 ? this.quadRendererCube : this.quadRenderer2D;
      if (faceCount > 1) {
        this.initInvViewProjMatrices();
      }
      this.blitTextureId.setValue(light.cookie);
      for (let face = 0; face < faceCount; face++) {
        _viewport2.copy(light.atlasViewport);
        if (faceCount > 1) {
          const smallSize = _viewport2.z / 3;
          const offset = cubeSlotsOffsets[face];
          _viewport2.x += smallSize * offset.x;
          _viewport2.y += smallSize * offset.y;
          _viewport2.z = smallSize;
          _viewport2.w = smallSize;
          this.invViewProjId.setValue(_invViewProjMatrices[face].data);
        }
        _viewport2.mulScalar(renderTargetWidth);
        quad.render(_viewport2);
      }
    }
    filteredLights.length = 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-shadow-local-clustered.js
var RenderPassShadowLocalClustered = class extends RenderPass {
  constructor(device, shadowRenderer, shadowRendererLocal) {
    super(device);
    this.requiresCubemaps = false;
    this.shadowRenderer = shadowRenderer;
    this.shadowRendererLocal = shadowRendererLocal;
  }
  update(localLights) {
    const shadowLights = this.shadowRendererLocal.shadowLights;
    const shadowCamera = this.shadowRendererLocal.prepareLights(shadowLights, localLights);
    const count = shadowLights.length;
    this.enabled = count > 0;
    if (count) {
      this.shadowRenderer.setupRenderPass(this, shadowCamera, false);
    }
  }
  execute() {
    const shadowLights = this.shadowRendererLocal.shadowLights;
    const count = shadowLights.length;
    for (let i = 0; i < count; i++) {
      const light = shadowLights[i];
      for (let face = 0; face < light.numShadowFaces; face++) {
        this.shadowRenderer.renderFace(light, null, face, true);
      }
    }
    shadowLights.length = 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-update-clustered.js
var RenderPassUpdateClustered = class extends RenderPass {
  constructor(device, renderer, shadowRenderer, shadowRendererLocal, lightTextureAtlas) {
    super(device);
    this.renderer = renderer;
    this.frameGraph = null;
    this.cookiesRenderPass = RenderPassCookieRenderer.create(lightTextureAtlas.cookieRenderTarget, lightTextureAtlas.cubeSlotsOffsets);
    this.beforePasses.push(this.cookiesRenderPass);
    this.shadowRenderPass = new RenderPassShadowLocalClustered(device, shadowRenderer, shadowRendererLocal);
    this.beforePasses.push(this.shadowRenderPass);
  }
  update(frameGraph, shadowsEnabled, cookiesEnabled, lights2, localLights) {
    this.frameGraph = frameGraph;
    this.cookiesRenderPass.enabled = cookiesEnabled;
    if (cookiesEnabled) {
      this.cookiesRenderPass.update(lights2);
    }
    this.shadowRenderPass.enabled = shadowsEnabled;
    if (shadowsEnabled) {
      this.shadowRenderPass.update(localLights);
    }
  }
  destroy() {
    this.cookiesRenderPass.destroy();
    this.cookiesRenderPass = null;
  }
  execute() {
    const {
      renderer
    } = this;
    const {
      scene
    } = renderer;
    renderer.worldClustersAllocator.update(this.frameGraph.renderPasses, scene.lighting);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/renderer.js
var _skinUpdateIndex = 0;
var viewProjMat = new Mat4();
var viewInvMat = new Mat4();
var viewMat = new Mat4();
var viewMat3 = new Mat3();
var tempSphere = new BoundingSphere();
var _flipYMat = new Mat4().setScale(1, -1, 1);
var _tempLightSet = /* @__PURE__ */ new Set();
var _tempLayerSet = /* @__PURE__ */ new Set();
var _dynamicBindGroup2 = new DynamicBindGroup();
var _fixProjRangeMat = new Mat4().set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1]);
var _haltonSequence = [new Vec2(0.5, 0.333333), new Vec2(0.25, 0.666667), new Vec2(0.75, 0.111111), new Vec2(0.125, 0.444444), new Vec2(0.625, 0.777778), new Vec2(0.375, 0.222222), new Vec2(0.875, 0.555556), new Vec2(0.0625, 0.888889), new Vec2(0.5625, 0.037037), new Vec2(0.3125, 0.37037), new Vec2(0.8125, 0.703704), new Vec2(0.1875, 0.148148), new Vec2(0.6875, 0.481481), new Vec2(0.4375, 0.814815), new Vec2(0.9375, 0.259259), new Vec2(0.03125, 0.592593)];
var _tempProjMat0 = new Mat4();
var _tempProjMat1 = new Mat4();
var _tempProjMat2 = new Mat4();
var _tempProjMat3 = new Mat4();
var _tempProjMat4 = new Mat4();
var _tempProjMat5 = new Mat4();
var _tempSet = /* @__PURE__ */ new Set();
var _tempMeshInstances = [];
var _tempMeshInstancesSkinned = [];
var Renderer = class {
  constructor(graphicsDevice) {
    this.clustersDebugRendered = false;
    this.processingMeshInstances = /* @__PURE__ */ new Set();
    this.worldClustersAllocator = void 0;
    this.lights = [];
    this.localLights = [];
    this.cameraDirShadowLights = /* @__PURE__ */ new Map();
    this.dirLightShadows = /* @__PURE__ */ new Map();
    this.blueNoise = new BlueNoise(123);
    this.device = graphicsDevice;
    this.scene = null;
    this.worldClustersAllocator = new WorldClustersAllocator(graphicsDevice);
    this.lightTextureAtlas = new LightTextureAtlas(graphicsDevice);
    this.shadowMapCache = new ShadowMapCache();
    this.shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);
    this._shadowRendererLocal = new ShadowRendererLocal(this, this.shadowRenderer);
    this._shadowRendererDirectional = new ShadowRendererDirectional(this, this.shadowRenderer);
    this._renderPassUpdateClustered = new RenderPassUpdateClustered(this.device, this, this.shadowRenderer, this._shadowRendererLocal, this.lightTextureAtlas);
    this.viewUniformFormat = null;
    this.viewBindGroupFormat = null;
    this._skinTime = 0;
    this._morphTime = 0;
    this._cullTime = 0;
    this._shadowMapTime = 0;
    this._lightClustersTime = 0;
    this._layerCompositionUpdateTime = 0;
    this._shadowDrawCalls = 0;
    this._skinDrawCalls = 0;
    this._instancedDrawCalls = 0;
    this._shadowMapUpdates = 0;
    this._numDrawCallsCulled = 0;
    this._camerasRendered = 0;
    this._lightClusters = 0;
    const scope = graphicsDevice.scope;
    this.boneTextureId = scope.resolve("texture_poseMap");
    this.boneTextureSizeId = scope.resolve("texture_poseMapSize");
    this.modelMatrixId = scope.resolve("matrix_model");
    this.normalMatrixId = scope.resolve("matrix_normal");
    this.viewInvId = scope.resolve("matrix_viewInverse");
    this.viewPos = new Float32Array(3);
    this.viewPosId = scope.resolve("view_position");
    this.projId = scope.resolve("matrix_projection");
    this.projSkyboxId = scope.resolve("matrix_projectionSkybox");
    this.viewId = scope.resolve("matrix_view");
    this.viewId3 = scope.resolve("matrix_view3");
    this.viewProjId = scope.resolve("matrix_viewProjection");
    this.flipYId = scope.resolve("projectionFlipY");
    this.tbnBasis = scope.resolve("tbnBasis");
    this.nearClipId = scope.resolve("camera_near");
    this.farClipId = scope.resolve("camera_far");
    this.cameraParams = new Float32Array(4);
    this.cameraParamsId = scope.resolve("camera_params");
    this.viewIndexId = scope.resolve("view_index");
    this.blueNoiseJitterVersion = 0;
    this.blueNoiseJitterVec = new Vec4();
    this.blueNoiseJitterData = new Float32Array(4);
    this.blueNoiseJitterId = scope.resolve("blueNoiseJitter");
    this.blueNoiseTextureId = scope.resolve("blueNoiseTex32");
    this.alphaTestId = scope.resolve("alpha_ref");
    this.opacityMapId = scope.resolve("texture_opacityMap");
    this.exposureId = scope.resolve("exposure");
    this.twoSidedLightingNegScaleFactorId = scope.resolve("twoSidedLightingNegScaleFactor");
    this.twoSidedLightingNegScaleFactorId.setValue(0);
    this.morphPositionTex = scope.resolve("morphPositionTex");
    this.morphNormalTex = scope.resolve("morphNormalTex");
    this.morphTexParams = scope.resolve("morph_tex_params");
    this.lightCube = new LightCube();
    this.constantLightCube = scope.resolve("lightCube[0]");
  }
  destroy() {
    this.shadowRenderer = null;
    this._shadowRendererLocal = null;
    this._shadowRendererDirectional = null;
    this.shadowMapCache.destroy();
    this.shadowMapCache = null;
    this._renderPassUpdateClustered.destroy();
    this._renderPassUpdateClustered = null;
    this.lightTextureAtlas.destroy();
    this.lightTextureAtlas = null;
  }
  sortCompare(drawCallA, drawCallB) {
    if (drawCallA.layer === drawCallB.layer) {
      if (drawCallA.drawOrder && drawCallB.drawOrder) {
        return drawCallA.drawOrder - drawCallB.drawOrder;
      } else if (drawCallA.zdist && drawCallB.zdist) {
        return drawCallB.zdist - drawCallA.zdist;
      } else if (drawCallA.zdist2 && drawCallB.zdist2) {
        return drawCallA.zdist2 - drawCallB.zdist2;
      }
    }
    return drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];
  }
  sortCompareMesh(drawCallA, drawCallB) {
    if (drawCallA.layer === drawCallB.layer) {
      if (drawCallA.drawOrder && drawCallB.drawOrder) {
        return drawCallA.drawOrder - drawCallB.drawOrder;
      } else if (drawCallA.zdist && drawCallB.zdist) {
        return drawCallB.zdist - drawCallA.zdist;
      }
    }
    const keyA = drawCallA._key[SORTKEY_FORWARD];
    const keyB = drawCallB._key[SORTKEY_FORWARD];
    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
      return drawCallB.mesh.id - drawCallA.mesh.id;
    }
    return keyB - keyA;
  }
  sortCompareDepth(drawCallA, drawCallB) {
    const keyA = drawCallA._key[SORTKEY_DEPTH];
    const keyB = drawCallB._key[SORTKEY_DEPTH];
    if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
      return drawCallB.mesh.id - drawCallA.mesh.id;
    }
    return keyB - keyA;
  }
  setupViewport(camera, renderTarget) {
    const device = this.device;
    const pixelWidth = renderTarget ? renderTarget.width : device.width;
    const pixelHeight = renderTarget ? renderTarget.height : device.height;
    const rect = camera.rect;
    let x2 = Math.floor(rect.x * pixelWidth);
    let y2 = Math.floor(rect.y * pixelHeight);
    let w = Math.floor(rect.z * pixelWidth);
    let h2 = Math.floor(rect.w * pixelHeight);
    device.setViewport(x2, y2, w, h2);
    if (camera._scissorRectClear) {
      const scissorRect = camera.scissorRect;
      x2 = Math.floor(scissorRect.x * pixelWidth);
      y2 = Math.floor(scissorRect.y * pixelHeight);
      w = Math.floor(scissorRect.z * pixelWidth);
      h2 = Math.floor(scissorRect.w * pixelHeight);
    }
    device.setScissor(x2, y2, w, h2);
  }
  setCameraUniforms(camera, target2) {
    const flipY = target2 == null ? void 0 : target2.flipY;
    let viewCount = 1;
    if (camera.xr && camera.xr.session) {
      var _camera$_node;
      const transform = ((_camera$_node = camera._node) == null || (_camera$_node = _camera$_node.parent) == null ? void 0 : _camera$_node.getWorldTransform()) || null;
      const views = camera.xr.views;
      viewCount = views.list.length;
      for (let v = 0; v < viewCount; v++) {
        const view = views.list[v];
        view.updateTransforms(transform);
        camera.frustum.setFromMat4(view.projViewOffMat);
      }
    } else {
      let projMat = camera.projectionMatrix;
      if (camera.calculateProjection) {
        camera.calculateProjection(projMat, VIEW_CENTER);
      }
      let projMatSkybox = camera.getProjectionMatrixSkybox();
      if (flipY) {
        projMat = _tempProjMat0.mul2(_flipYMat, projMat);
        projMatSkybox = _tempProjMat1.mul2(_flipYMat, projMatSkybox);
      }
      if (this.device.isWebGPU) {
        projMat = _tempProjMat2.mul2(_fixProjRangeMat, projMat);
        projMatSkybox = _tempProjMat3.mul2(_fixProjRangeMat, projMatSkybox);
      }
      const {
        jitter
      } = camera;
      let jitterX = 0;
      let jitterY = 0;
      if (jitter > 0) {
        const targetWidth = target2 ? target2.width : this.device.width;
        const targetHeight = target2 ? target2.height : this.device.height;
        const offset = _haltonSequence[this.device.renderVersion % _haltonSequence.length];
        jitterX = jitter * (offset.x * 2 - 1) / targetWidth;
        jitterY = jitter * (offset.y * 2 - 1) / targetHeight;
        projMat = _tempProjMat4.copy(projMat);
        projMat.data[8] = jitterX;
        projMat.data[9] = jitterY;
        projMatSkybox = _tempProjMat5.copy(projMatSkybox);
        projMatSkybox.data[8] = jitterX;
        projMatSkybox.data[9] = jitterY;
        if (this.blueNoiseJitterVersion !== this.device.renderVersion) {
          this.blueNoiseJitterVersion = this.device.renderVersion;
          this.blueNoise.vec4(this.blueNoiseJitterVec);
        }
      }
      const jitterVec = jitter > 0 ? this.blueNoiseJitterVec : Vec4.ZERO;
      this.blueNoiseJitterData[0] = jitterVec.x;
      this.blueNoiseJitterData[1] = jitterVec.y;
      this.blueNoiseJitterData[2] = jitterVec.z;
      this.blueNoiseJitterData[3] = jitterVec.w;
      this.blueNoiseJitterId.setValue(this.blueNoiseJitterData);
      this.projId.setValue(projMat.data);
      this.projSkyboxId.setValue(projMatSkybox.data);
      if (camera.calculateTransform) {
        camera.calculateTransform(viewInvMat, VIEW_CENTER);
      } else {
        const pos = camera._node.getPosition();
        const rot = camera._node.getRotation();
        viewInvMat.setTRS(pos, rot, Vec3.ONE);
      }
      this.viewInvId.setValue(viewInvMat.data);
      viewMat.copy(viewInvMat).invert();
      this.viewId.setValue(viewMat.data);
      viewMat3.setFromMat4(viewMat);
      this.viewId3.setValue(viewMat3.data);
      viewProjMat.mul2(projMat, viewMat);
      this.viewProjId.setValue(viewProjMat.data);
      camera._storeShaderMatrices(viewProjMat, jitterX, jitterY, this.device.renderVersion);
      this.flipYId.setValue(flipY ? -1 : 1);
      this.dispatchViewPos(camera._node.getPosition());
      camera.frustum.setFromMat4(viewProjMat);
    }
    this.tbnBasis.setValue(flipY ? -1 : 1);
    const n = camera._nearClip;
    const f = camera._farClip;
    this.nearClipId.setValue(n);
    this.farClipId.setValue(f);
    this.cameraParams[0] = 1 / f;
    this.cameraParams[1] = f;
    this.cameraParams[2] = n;
    this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
    this.cameraParamsId.setValue(this.cameraParams);
    this.exposureId.setValue(this.scene.physicalUnits ? camera.getExposure() : this.scene.exposure);
    return viewCount;
  }
  clear(camera, clearColor, clearDepth, clearStencil) {
    const flags = ((clearColor != null ? clearColor : camera._clearColorBuffer) ? CLEARFLAG_COLOR : 0) | ((clearDepth != null ? clearDepth : camera._clearDepthBuffer) ? CLEARFLAG_DEPTH : 0) | ((clearStencil != null ? clearStencil : camera._clearStencilBuffer) ? CLEARFLAG_STENCIL : 0);
    if (flags) {
      const device = this.device;
      device.clear({
        color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
        depth: camera._clearDepth,
        stencil: camera._clearStencil,
        flags
      });
    }
  }
  setCamera(camera, target2, clear, renderAction = null) {
    this.setCameraUniforms(camera, target2);
    this.clearView(camera, target2, clear, false);
  }
  clearView(camera, target2, clear, forceWrite) {
    const device = this.device;
    device.setRenderTarget(target2);
    device.updateBegin();
    if (forceWrite) {
      device.setColorWrite(true, true, true, true);
      device.setDepthWrite(true);
    }
    this.setupViewport(camera, target2);
    if (clear) {
      const options2 = camera._clearOptions;
      device.clear(options2 ? options2 : {
        color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
        depth: camera._clearDepth,
        flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
        stencil: camera._clearStencil
      });
    }
  }
  setupCullMode(cullFaces, flipFactor, drawCall) {
    const material = drawCall.material;
    let mode = CULLFACE_NONE;
    if (cullFaces) {
      let flipFaces = 1;
      if (material.cull === CULLFACE_FRONT || material.cull === CULLFACE_BACK) {
        flipFaces = flipFactor * drawCall.flipFacesFactor * drawCall.node.worldScaleSign;
      }
      if (flipFaces < 0) {
        mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
      } else {
        mode = material.cull;
      }
    }
    this.device.setCullMode(mode);
    if (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {
      this.twoSidedLightingNegScaleFactorId.setValue(drawCall.node.worldScaleSign);
    }
  }
  updateCameraFrustum(camera) {
    if (camera.xr && camera.xr.views.list.length) {
      const view = camera.xr.views.list[0];
      viewProjMat.mul2(view.projMat, view.viewOffMat);
      camera.frustum.setFromMat4(viewProjMat);
      return;
    }
    const projMat = camera.projectionMatrix;
    if (camera.calculateProjection) {
      camera.calculateProjection(projMat, VIEW_CENTER);
    }
    if (camera.calculateTransform) {
      camera.calculateTransform(viewInvMat, VIEW_CENTER);
    } else {
      const pos = camera._node.getPosition();
      const rot = camera._node.getRotation();
      viewInvMat.setTRS(pos, rot, Vec3.ONE);
      this.viewInvId.setValue(viewInvMat.data);
    }
    viewMat.copy(viewInvMat).invert();
    viewProjMat.mul2(projMat, viewMat);
    camera.frustum.setFromMat4(viewProjMat);
  }
  setBaseConstants(device, material) {
    device.setCullMode(material.cull);
    if (material.opacityMap) {
      this.opacityMapId.setValue(material.opacityMap);
    }
    if (material.opacityMap || material.alphaTest > 0) {
      this.alphaTestId.setValue(material.alphaTest);
    }
  }
  updateCpuSkinMatrices(drawCalls) {
    _skinUpdateIndex++;
    const drawCallsCount = drawCalls.length;
    if (drawCallsCount === 0) return;
    for (let i = 0; i < drawCallsCount; i++) {
      const si = drawCalls[i].skinInstance;
      if (si) {
        si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);
        si._dirty = true;
      }
    }
  }
  updateGpuSkinMatrices(drawCalls) {
    for (const drawCall of drawCalls) {
      const skin = drawCall.skinInstance;
      if (skin && skin._dirty) {
        skin.updateMatrixPalette(drawCall.node, _skinUpdateIndex);
        skin._dirty = false;
      }
    }
  }
  updateMorphing(drawCalls) {
    for (const drawCall of drawCalls) {
      const morphInst = drawCall.morphInstance;
      if (morphInst && morphInst._dirty) {
        morphInst.update();
      }
    }
  }
  updateGSplats(drawCalls) {
    for (const drawCall of drawCalls) {
      var _drawCall$gsplatInsta;
      (_drawCall$gsplatInsta = drawCall.gsplatInstance) == null || _drawCall$gsplatInsta.update();
    }
  }
  gpuUpdate(drawCalls) {
    this.updateGpuSkinMatrices(drawCalls);
    this.updateMorphing(drawCalls);
    this.updateGSplats(drawCalls);
  }
  setVertexBuffers(device, mesh) {
    device.setVertexBuffer(mesh.vertexBuffer);
  }
  setMorphing(device, morphInstance) {
    if (morphInstance) {
      morphInstance.prepareRendering(device);
      device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
      this.morphPositionTex.setValue(morphInstance.texturePositions);
      this.morphNormalTex.setValue(morphInstance.textureNormals);
      this.morphTexParams.setValue(morphInstance._textureParams);
    }
  }
  setSkinning(device, meshInstance) {
    const skinInstance = meshInstance.skinInstance;
    if (skinInstance) {
      this._skinDrawCalls++;
      const boneTexture = skinInstance.boneTexture;
      this.boneTextureId.setValue(boneTexture);
      this.boneTextureSizeId.setValue(skinInstance.boneTextureSize);
    }
  }
  dispatchViewPos(position3) {
    const vp = this.viewPos;
    vp[0] = position3.x;
    vp[1] = position3.y;
    vp[2] = position3.z;
    this.viewPosId.setValue(vp);
  }
  initViewBindGroupFormat(isClustered) {
    if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
      const uniforms = [new UniformFormat("matrix_viewProjection", UNIFORMTYPE_MAT4), new UniformFormat("cubeMapRotationMatrix", UNIFORMTYPE_MAT3), new UniformFormat("view_position", UNIFORMTYPE_VEC3), new UniformFormat("skyboxIntensity", UNIFORMTYPE_FLOAT), new UniformFormat("exposure", UNIFORMTYPE_FLOAT), new UniformFormat("textureBias", UNIFORMTYPE_FLOAT)];
      if (isClustered) {
        uniforms.push(...[new UniformFormat("clusterCellsCountByBoundsSize", UNIFORMTYPE_VEC3), new UniformFormat("clusterTextureSize", UNIFORMTYPE_VEC3), new UniformFormat("clusterBoundsMin", UNIFORMTYPE_VEC3), new UniformFormat("clusterBoundsDelta", UNIFORMTYPE_VEC3), new UniformFormat("clusterCellsDot", UNIFORMTYPE_VEC3), new UniformFormat("clusterCellsMax", UNIFORMTYPE_VEC3), new UniformFormat("clusterCompressionLimit0", UNIFORMTYPE_VEC2), new UniformFormat("shadowAtlasParams", UNIFORMTYPE_VEC2), new UniformFormat("clusterMaxCells", UNIFORMTYPE_INT), new UniformFormat("clusterSkip", UNIFORMTYPE_FLOAT)]);
      }
      this.viewUniformFormat = new UniformBufferFormat(this.device, uniforms);
      const formats = [new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT), new BindTextureFormat("lightsTextureFloat", SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT), new BindTextureFormat("lightsTexture8", SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT), new BindTextureFormat("shadowAtlasTexture", SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_DEPTH), new BindTextureFormat("cookieAtlasTexture", SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT), new BindTextureFormat("areaLightsLutTex1", SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT), new BindTextureFormat("areaLightsLutTex2", SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT)];
      if (isClustered) {
        formats.push(...[new BindTextureFormat("clusterWorldTexture", SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT)]);
      }
      this.viewBindGroupFormat = new BindGroupFormat(this.device, formats);
    }
  }
  setupViewUniformBuffers(viewBindGroups, viewUniformFormat, viewBindGroupFormat, viewCount) {
    const device = this.device;
    while (viewBindGroups.length < viewCount) {
      const ub = new UniformBuffer(device, viewUniformFormat, false);
      const bg = new BindGroup(device, viewBindGroupFormat, ub);
      viewBindGroups.push(bg);
    }
    const viewBindGroup = viewBindGroups[0];
    viewBindGroup.defaultUniformBuffer.update();
    viewBindGroup.update();
    device.setBindGroup(BINDGROUP_VIEW, viewBindGroup);
  }
  setupMeshUniformBuffers(shaderInstance, meshInstance) {
    const device = this.device;
    if (device.supportsUniformBuffers) {
      this.modelMatrixId.setValue(meshInstance.node.worldTransform.data);
      this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
      const meshBindGroup = shaderInstance.getBindGroup(device);
      meshBindGroup.update();
      device.setBindGroup(BINDGROUP_MESH, meshBindGroup);
      const meshUniformBuffer = shaderInstance.getUniformBuffer(device);
      meshUniformBuffer.update(_dynamicBindGroup2);
      device.setBindGroup(BINDGROUP_MESH_UB, _dynamicBindGroup2.bindGroup, _dynamicBindGroup2.offsets);
    }
  }
  drawInstance(device, meshInstance, mesh, style, normal) {
    const modelMatrix = meshInstance.node.worldTransform;
    this.modelMatrixId.setValue(modelMatrix.data);
    if (normal) {
      this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
    }
    const instancingData = meshInstance.instancingData;
    if (instancingData) {
      if (instancingData.count > 0) {
        this._instancedDrawCalls++;
        device.setVertexBuffer(instancingData.vertexBuffer);
        device.draw(mesh.primitive[style], instancingData.count);
      } else {
        device.clearVertexBuffer();
      }
    } else {
      device.draw(mesh.primitive[style]);
    }
  }
  drawInstance2(device, meshInstance, mesh, style) {
    const instancingData = meshInstance.instancingData;
    if (instancingData) {
      if (instancingData.count > 0) {
        this._instancedDrawCalls++;
        device.draw(mesh.primitive[style], instancingData.count, true);
      } else {
        device.clearVertexBuffer();
      }
    } else {
      device.draw(mesh.primitive[style], void 0, true);
    }
  }
  cull(camera, drawCalls, culledInstances) {
    const opaque = culledInstances.opaque;
    opaque.length = 0;
    const transparent = culledInstances.transparent;
    transparent.length = 0;
    const doCull = camera.frustumCulling;
    const count = drawCalls.length;
    for (let i = 0; i < count; i++) {
      const drawCall = drawCalls[i];
      if (drawCall.visible) {
        const visible = !doCull || !drawCall.cull || drawCall._isVisible(camera);
        if (visible) {
          drawCall.visibleThisFrame = true;
          const bucket = drawCall.transparent ? transparent : opaque;
          bucket.push(drawCall);
          if (drawCall.skinInstance || drawCall.morphInstance || drawCall.gsplatInstance) {
            this.processingMeshInstances.add(drawCall);
            if (drawCall.gsplatInstance) {
              drawCall.gsplatInstance.cameras.push(camera);
            }
          }
        }
      }
    }
  }
  collectLights(comp) {
    this.lights.length = 0;
    this.localLights.length = 0;
    const stats = this.scene._stats;
    const count = comp.layerList.length;
    for (let i = 0; i < count; i++) {
      const layer = comp.layerList[i];
      if (!_tempLayerSet.has(layer)) {
        _tempLayerSet.add(layer);
        const lights2 = layer._lights;
        for (let j = 0; j < lights2.length; j++) {
          const light = lights2[j];
          if (!_tempLightSet.has(light)) {
            _tempLightSet.add(light);
            this.lights.push(light);
            if (light._type !== LIGHTTYPE_DIRECTIONAL) {
              this.localLights.push(light);
            }
          }
        }
      }
    }
    stats.lights = this.lights.length;
    _tempLightSet.clear();
    _tempLayerSet.clear();
  }
  cullLights(camera, lights2) {
    const clusteredLightingEnabled = this.scene.clusteredLightingEnabled;
    const physicalUnits = this.scene.physicalUnits;
    for (let i = 0; i < lights2.length; i++) {
      const light = lights2[i];
      if (light.enabled) {
        if (light._type !== LIGHTTYPE_DIRECTIONAL) {
          light.getBoundingSphere(tempSphere);
          if (camera.frustum.containsSphere(tempSphere)) {
            light.visibleThisFrame = true;
            light.usePhysicalUnits = physicalUnits;
            const screenSize = camera.getScreenSize(tempSphere);
            light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);
          } else {
            if (!clusteredLightingEnabled) {
              if (light.castShadows && !light.shadowMap) {
                light.visibleThisFrame = true;
              }
            }
          }
        } else {
          light.usePhysicalUnits = this.scene.physicalUnits;
        }
      }
    }
  }
  cullShadowmaps(comp) {
    const isClustered = this.scene.clusteredLightingEnabled;
    for (let i = 0; i < this.localLights.length; i++) {
      const light = this.localLights[i];
      if (light._type !== LIGHTTYPE_DIRECTIONAL) {
        if (isClustered) {
          if (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {
            light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
          }
        } else {
          if (light.shadowUpdateMode === SHADOWUPDATE_NONE && light.castShadows) {
            if (!light.getRenderData(null, 0).shadowCamera.renderTarget) {
              light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
            }
          }
        }
        if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
          this._shadowRendererLocal.cull(light, comp);
        }
      }
    }
    this.cameraDirShadowLights.clear();
    const cameras = comp.cameras;
    for (let i = 0; i < cameras.length; i++) {
      const cameraComponent = cameras[i];
      if (cameraComponent.enabled) {
        const camera = cameraComponent.camera;
        let lightList;
        const cameraLayers = camera.layers;
        for (let l = 0; l < cameraLayers.length; l++) {
          const cameraLayer = comp.getLayerById(cameraLayers[l]);
          if (cameraLayer) {
            const layerDirLights = cameraLayer.splitLights[LIGHTTYPE_DIRECTIONAL];
            for (let j = 0; j < layerDirLights.length; j++) {
              const light = layerDirLights[j];
              if (light.castShadows && !_tempSet.has(light)) {
                var _lightList;
                _tempSet.add(light);
                lightList = (_lightList = lightList) != null ? _lightList : [];
                lightList.push(light);
                this._shadowRendererDirectional.cull(light, comp, camera);
              }
            }
          }
        }
        if (lightList) {
          this.cameraDirShadowLights.set(camera, lightList);
        }
        _tempSet.clear();
      }
    }
  }
  cullComposition(comp) {
    this.processingMeshInstances.clear();
    const numCameras = comp.cameras.length;
    this._camerasRendered += numCameras;
    for (let i = 0; i < numCameras; i++) {
      const camera = comp.cameras[i];
      camera.onPreCull == null || camera.onPreCull();
      const renderTarget = camera.renderTarget;
      camera.frameUpdate(renderTarget);
      this.updateCameraFrustum(camera.camera);
      const layerIds = camera.layers;
      for (let j = 0; j < layerIds.length; j++) {
        const layer = comp.getLayerById(layerIds[j]);
        if (layer && layer.enabled) {
          this.cullLights(camera.camera, layer._lights);
          const culledInstances = layer.getCulledInstances(camera.camera);
          this.cull(camera.camera, layer.meshInstances, culledInstances);
        }
      }
      camera.onPostCull == null || camera.onPostCull();
    }
    if (this.scene.clusteredLightingEnabled) {
      this.updateLightTextureAtlas();
    }
    this.cullShadowmaps(comp);
  }
  updateShaders(drawCalls, onlyLitShaders) {
    const count = drawCalls.length;
    for (let i = 0; i < count; i++) {
      const mat2 = drawCalls[i].material;
      if (mat2) {
        if (!_tempSet.has(mat2)) {
          _tempSet.add(mat2);
          if (mat2.getShaderVariant !== Material.prototype.getShaderVariant) {
            if (onlyLitShaders) {
              if (!mat2.useLighting || mat2.emitter && !mat2.emitter.lighting) {
                continue;
              }
            }
            mat2.clearVariants();
          }
        }
      }
    }
    _tempSet.clear();
  }
  updateFrameUniforms() {
    this.blueNoiseTextureId.setValue(getBlueNoiseTexture(this.device));
  }
  beginFrame(comp) {
    const scene = this.scene;
    const updateShaders = scene.updateShaders;
    const layers = comp.layerList;
    const layerCount = layers.length;
    for (let i = 0; i < layerCount; i++) {
      const layer = layers[i];
      const meshInstances = layer.meshInstances;
      const count = meshInstances.length;
      for (let j = 0; j < count; j++) {
        const meshInst = meshInstances[j];
        meshInst.visibleThisFrame = false;
        if (updateShaders) {
          _tempMeshInstances.push(meshInst);
        }
        if (meshInst.skinInstance) {
          _tempMeshInstancesSkinned.push(meshInst);
        }
      }
    }
    if (updateShaders) {
      const onlyLitShaders = !scene.updateShaders;
      this.updateShaders(_tempMeshInstances, onlyLitShaders);
      scene.updateShaders = false;
      scene._shaderVersion++;
    }
    this.updateFrameUniforms();
    this.updateCpuSkinMatrices(_tempMeshInstancesSkinned);
    _tempMeshInstances.length = 0;
    _tempMeshInstancesSkinned.length = 0;
    const lights2 = this.lights;
    const lightCount = lights2.length;
    for (let i = 0; i < lightCount; i++) {
      lights2[i].beginFrame();
    }
  }
  updateLightTextureAtlas() {
    this.lightTextureAtlas.update(this.localLights, this.scene.lighting);
  }
  updateLayerComposition(comp) {
    const len = comp.layerList.length;
    const scene = this.scene;
    const shaderVersion = scene._shaderVersion;
    for (let i = 0; i < len; i++) {
      const layer = comp.layerList[i];
      layer._shaderVersion = shaderVersion;
    }
    comp._update();
  }
  frameUpdate() {
    this.clustersDebugRendered = false;
    this.initViewBindGroupFormat(this.scene.clusteredLightingEnabled);
    this.dirLightShadows.clear();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/composition/render-action.js
var RenderAction = class {
  constructor() {
    this.layer = null;
    this.transparent = false;
    this.camera = null;
    this.renderTarget = null;
    this.lightClusters = null;
    this.clearColor = false;
    this.clearDepth = false;
    this.clearStencil = false;
    this.triggerPostprocess = false;
    this.firstCameraUse = false;
    this.lastCameraUse = false;
    this.viewBindGroups = [];
    this.useCameraPasses = false;
  }
  destroy() {
    this.viewBindGroups.forEach((bg) => {
      bg.defaultUniformBuffer.destroy();
      bg.destroy();
    });
    this.viewBindGroups.length = 0;
  }
  setupClears(camera, layer) {
    this.clearColor = (camera == null ? void 0 : camera.clearColorBuffer) || layer.clearColorBuffer;
    this.clearDepth = (camera == null ? void 0 : camera.clearDepthBuffer) || layer.clearDepthBuffer;
    this.clearStencil = (camera == null ? void 0 : camera.clearStencilBuffer) || layer.clearStencilBuffer;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-forward.js
var RenderPassForward = class extends RenderPass {
  constructor(device, layerComposition, scene, renderer) {
    super(device);
    this.layerComposition = void 0;
    this.scene = void 0;
    this.renderer = void 0;
    this.renderActions = [];
    this.noDepthClear = false;
    this.layerComposition = layerComposition;
    this.scene = scene;
    this.renderer = renderer;
  }
  addRenderAction(renderAction) {
    this.renderActions.push(renderAction);
  }
  addLayer(cameraComponent, layer, transparent, autoClears = true) {
    const ra = new RenderAction();
    ra.renderTarget = this.renderTarget;
    ra.camera = cameraComponent;
    ra.layer = layer;
    ra.transparent = transparent;
    if (autoClears) {
      const firstRa = this.renderActions.length === 0;
      ra.setupClears(firstRa ? cameraComponent : void 0, layer);
    }
    this.addRenderAction(ra);
  }
  addLayers(composition, cameraComponent, startIndex, firstLayerClears, lastLayerId, lastLayerIsTransparent = true) {
    const {
      layerList,
      subLayerEnabled,
      subLayerList
    } = composition;
    let clearRenderTarget = firstLayerClears;
    let index = startIndex;
    while (index < layerList.length) {
      const layer = layerList[index];
      const isTransparent = subLayerList[index];
      const enabled = layer.enabled && subLayerEnabled[index];
      const renderedbyCamera = cameraComponent.camera.layersSet.has(layer.id);
      if (enabled && renderedbyCamera) {
        this.addLayer(cameraComponent, layer, isTransparent, clearRenderTarget);
        clearRenderTarget = false;
      }
      index++;
      if (layer.id === lastLayerId && isTransparent === lastLayerIsTransparent) {
        break;
      }
    }
    return index;
  }
  updateDirectionalShadows() {
    const {
      renderer,
      renderActions
    } = this;
    for (let i = 0; i < renderActions.length; i++) {
      const renderAction = renderActions[i];
      const cameraComp = renderAction.camera;
      const camera = cameraComp.camera;
      const shadowDirLights = this.renderer.cameraDirShadowLights.get(camera);
      if (shadowDirLights) {
        for (let l = 0; l < shadowDirLights.length; l++) {
          const light = shadowDirLights[l];
          if (renderer.dirLightShadows.get(light) !== camera) {
            renderer.dirLightShadows.set(light, camera);
            const shadowPass = renderer._shadowRendererDirectional.getLightRenderPass(light, camera);
            if (shadowPass) {
              this.beforePasses.push(shadowPass);
            }
          }
        }
      }
    }
  }
  updateClears() {
    const renderAction = this.renderActions[0];
    if (renderAction) {
      const cameraComponent = renderAction.camera;
      const camera = cameraComponent.camera;
      const fullSizeClearRect = camera.fullSizeClearRect;
      this.setClearColor(fullSizeClearRect && renderAction.clearColor ? camera.clearColor : void 0);
      this.setClearDepth(fullSizeClearRect && renderAction.clearDepth && !this.noDepthClear ? camera.clearDepth : void 0);
      this.setClearStencil(fullSizeClearRect && renderAction.clearStencil ? camera.clearStencil : void 0);
    }
  }
  frameUpdate() {
    super.frameUpdate();
    this.updateDirectionalShadows();
    this.updateClears();
  }
  before() {
    const {
      renderActions
    } = this;
    for (let i = 0; i < renderActions.length; i++) {
      const ra = renderActions[i];
      if (ra.firstCameraUse) {
        ra.camera.onPreRender == null || ra.camera.onPreRender();
      }
    }
  }
  execute() {
    const {
      layerComposition,
      renderActions
    } = this;
    for (let i = 0; i < renderActions.length; i++) {
      const ra = renderActions[i];
      if (layerComposition.isEnabled(ra.layer, ra.transparent)) {
        this.renderRenderAction(ra, i === 0);
      }
    }
  }
  after() {
    for (let i = 0; i < this.renderActions.length; i++) {
      const ra = this.renderActions[i];
      if (ra.lastCameraUse) {
        ra.camera.onPostRender == null || ra.camera.onPostRender();
      }
    }
    this.beforePasses.length = 0;
  }
  renderRenderAction(renderAction, firstRenderAction) {
    const {
      renderer
    } = this;
    const device = renderer.device;
    const {
      layer,
      transparent,
      camera
    } = renderAction;
    if (camera) {
      var _camera$camera$shader, _camera$camera$shader2, _renderAction$renderT;
      const options2 = {
        lightClusters: renderAction.lightClusters
      };
      const shaderPass = (_camera$camera$shader = (_camera$camera$shader2 = camera.camera.shaderPassInfo) == null ? void 0 : _camera$camera$shader2.index) != null ? _camera$camera$shader : SHADER_FORWARD;
      if (!firstRenderAction || !camera.camera.fullSizeClearRect) {
        options2.clearColor = renderAction.clearColor;
        options2.clearDepth = renderAction.clearDepth;
        options2.clearStencil = renderAction.clearStencil;
      }
      const renderTarget = (_renderAction$renderT = renderAction.renderTarget) != null ? _renderAction$renderT : device.backBuffer;
      renderer.renderForwardLayer(camera.camera, renderTarget, layer, transparent, shaderPass, renderAction.viewBindGroups, options2);
      device.setBlendState(BlendState.NOBLEND);
      device.setStencilState(null, null);
      device.setAlphaToCoverage(false);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-postprocessing.js
var RenderPassPostprocessing = class extends RenderPass {
  constructor(device, renderer, renderAction) {
    super(device);
    this.renderer = renderer;
    this.renderAction = renderAction;
    this.requiresCubemaps = false;
  }
  execute() {
    const renderAction = this.renderAction;
    const camera = renderAction.camera;
    camera.onPostprocessing();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/renderer/forward-renderer.js
var _noLights = [[], [], []];
var tmpColor = new Color();
var _drawCallList = {
  drawCalls: [],
  shaderInstances: [],
  isNewMaterial: [],
  lightMaskChanged: [],
  clear: function() {
    this.drawCalls.length = 0;
    this.shaderInstances.length = 0;
    this.isNewMaterial.length = 0;
    this.lightMaskChanged.length = 0;
  }
};
function vogelDiskPrecalculationSamples(numSamples) {
  const samples = [];
  for (let i = 0; i < numSamples; ++i) {
    const r = Math.sqrt(i + 0.5) / Math.sqrt(numSamples);
    samples.push(r);
  }
  return samples;
}
function vogelSpherePrecalculationSamples(numSamples) {
  const samples = [];
  for (let i = 0; i < numSamples; i++) {
    const weight = i / numSamples;
    const radius = Math.sqrt(1 - weight * weight);
    samples.push(radius);
  }
  return samples;
}
var ForwardRenderer = class extends Renderer {
  constructor(graphicsDevice) {
    super(graphicsDevice);
    const device = this.device;
    this._forwardDrawCalls = 0;
    this._materialSwitches = 0;
    this._depthMapTime = 0;
    this._forwardTime = 0;
    this._sortTime = 0;
    const scope = device.scope;
    this.fogColorId = scope.resolve("fog_color");
    this.fogStartId = scope.resolve("fog_start");
    this.fogEndId = scope.resolve("fog_end");
    this.fogDensityId = scope.resolve("fog_density");
    this.ambientId = scope.resolve("light_globalAmbient");
    this.skyboxIntensityId = scope.resolve("skyboxIntensity");
    this.cubeMapRotationMatrixId = scope.resolve("cubeMapRotationMatrix");
    this.pcssDiskSamplesId = scope.resolve("pcssDiskSamples[0]");
    this.pcssSphereSamplesId = scope.resolve("pcssSphereSamples[0]");
    this.lightColorId = [];
    this.lightDir = [];
    this.lightDirId = [];
    this.lightShadowMapId = [];
    this.lightShadowMatrixId = [];
    this.lightShadowParamsId = [];
    this.lightShadowIntensity = [];
    this.lightRadiusId = [];
    this.lightPos = [];
    this.lightPosId = [];
    this.lightWidth = [];
    this.lightWidthId = [];
    this.lightHeight = [];
    this.lightHeightId = [];
    this.lightInAngleId = [];
    this.lightOutAngleId = [];
    this.lightCookieId = [];
    this.lightCookieIntId = [];
    this.lightCookieMatrixId = [];
    this.lightCookieOffsetId = [];
    this.lightShadowSearchAreaId = [];
    this.lightCameraParamsId = [];
    this.shadowMatrixPaletteId = [];
    this.shadowCascadeDistancesId = [];
    this.shadowCascadeCountId = [];
    this.screenSizeId = scope.resolve("uScreenSize");
    this._screenSize = new Float32Array(4);
    this.fogColor = new Float32Array(3);
    this.ambientColor = new Float32Array(3);
    this.pcssDiskSamples = vogelDiskPrecalculationSamples(16);
    this.pcssSphereSamples = vogelSpherePrecalculationSamples(16);
  }
  destroy() {
    super.destroy();
  }
  dispatchGlobalLights(scene) {
    const ambientUniform = this.ambientColor;
    tmpColor.linear(scene.ambientLight);
    ambientUniform[0] = tmpColor.r;
    ambientUniform[1] = tmpColor.g;
    ambientUniform[2] = tmpColor.b;
    if (scene.physicalUnits) {
      for (let i = 0; i < 3; i++) {
        ambientUniform[i] *= scene.ambientLuminance;
      }
    }
    this.ambientId.setValue(ambientUniform);
    this.skyboxIntensityId.setValue(scene.physicalUnits ? scene.skyboxLuminance : scene.skyboxIntensity);
    this.cubeMapRotationMatrixId.setValue(scene._skyboxRotationMat3.data);
  }
  _resolveLight(scope, i) {
    const light = `light${i}`;
    this.lightColorId[i] = scope.resolve(`${light}_color`);
    this.lightDir[i] = new Float32Array(3);
    this.lightDirId[i] = scope.resolve(`${light}_direction`);
    this.lightShadowMapId[i] = scope.resolve(`${light}_shadowMap`);
    this.lightShadowMatrixId[i] = scope.resolve(`${light}_shadowMatrix`);
    this.lightShadowParamsId[i] = scope.resolve(`${light}_shadowParams`);
    this.lightShadowIntensity[i] = scope.resolve(`${light}_shadowIntensity`);
    this.lightShadowSearchAreaId[i] = scope.resolve(`${light}_shadowSearchArea`);
    this.lightRadiusId[i] = scope.resolve(`${light}_radius`);
    this.lightPos[i] = new Float32Array(3);
    this.lightPosId[i] = scope.resolve(`${light}_position`);
    this.lightWidth[i] = new Float32Array(3);
    this.lightWidthId[i] = scope.resolve(`${light}_halfWidth`);
    this.lightHeight[i] = new Float32Array(3);
    this.lightHeightId[i] = scope.resolve(`${light}_halfHeight`);
    this.lightInAngleId[i] = scope.resolve(`${light}_innerConeAngle`);
    this.lightOutAngleId[i] = scope.resolve(`${light}_outerConeAngle`);
    this.lightCookieId[i] = scope.resolve(`${light}_cookie`);
    this.lightCookieIntId[i] = scope.resolve(`${light}_cookieIntensity`);
    this.lightCookieMatrixId[i] = scope.resolve(`${light}_cookieMatrix`);
    this.lightCookieOffsetId[i] = scope.resolve(`${light}_cookieOffset`);
    this.lightCameraParamsId[i] = scope.resolve(`${light}_cameraParams`);
    this.shadowMatrixPaletteId[i] = scope.resolve(`${light}_shadowMatrixPalette[0]`);
    this.shadowCascadeDistancesId[i] = scope.resolve(`${light}_shadowCascadeDistances[0]`);
    this.shadowCascadeCountId[i] = scope.resolve(`${light}_shadowCascadeCount`);
  }
  setLTCDirectionalLight(wtm, cnt, dir, campos, far) {
    this.lightPos[cnt][0] = campos.x - dir.x * far;
    this.lightPos[cnt][1] = campos.y - dir.y * far;
    this.lightPos[cnt][2] = campos.z - dir.z * far;
    this.lightPosId[cnt].setValue(this.lightPos[cnt]);
    const hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
    this.lightWidth[cnt][0] = hWidth.x * far;
    this.lightWidth[cnt][1] = hWidth.y * far;
    this.lightWidth[cnt][2] = hWidth.z * far;
    this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
    const hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
    this.lightHeight[cnt][0] = hHeight.x * far;
    this.lightHeight[cnt][1] = hHeight.y * far;
    this.lightHeight[cnt][2] = hHeight.z * far;
    this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
  }
  dispatchDirectLights(dirs, mask, camera) {
    let cnt = 0;
    const scope = this.device.scope;
    for (let i = 0; i < dirs.length; i++) {
      if (!(dirs[i].mask & mask)) continue;
      const directional = dirs[i];
      const wtm = directional._node.getWorldTransform();
      if (!this.lightColorId[cnt]) {
        this._resolveLight(scope, cnt);
      }
      this.lightColorId[cnt].setValue(directional._colorLinear);
      wtm.getY(directional._direction).mulScalar(-1);
      directional._direction.normalize();
      this.lightDir[cnt][0] = directional._direction.x;
      this.lightDir[cnt][1] = directional._direction.y;
      this.lightDir[cnt][2] = directional._direction.z;
      this.lightDirId[cnt].setValue(this.lightDir[cnt]);
      if (directional.shape !== LIGHTSHAPE_PUNCTUAL) {
        this.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);
      }
      if (directional.castShadows) {
        const lightRenderData = directional.getRenderData(camera, 0);
        const biases = directional._getUniformBiasValues(lightRenderData);
        this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
        this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
        this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);
        this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);
        this.shadowCascadeCountId[cnt].setValue(directional.numCascades);
        this.lightShadowIntensity[cnt].setValue(directional.shadowIntensity);
        const projectionCompensation = 50 / lightRenderData.projectionCompensation;
        const shadowRT = lightRenderData.shadowCamera.renderTarget;
        if (shadowRT) {
          const pixelsPerMeter = directional.penumbraSize / shadowRT.width;
          this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter * projectionCompensation);
        }
        const cameraParams = directional._shadowCameraParams;
        cameraParams.length = 4;
        cameraParams[0] = lightRenderData.depthRangeCompensation;
        cameraParams[1] = lightRenderData.shadowCamera._farClip;
        cameraParams[2] = lightRenderData.shadowCamera._nearClip;
        cameraParams[3] = 1;
        this.lightCameraParamsId[cnt].setValue(cameraParams);
        const params = directional._shadowRenderParams;
        params.length = 4;
        params[0] = directional._shadowResolution;
        params[1] = biases.normalBias;
        params[2] = biases.bias;
        params[3] = 0;
        this.lightShadowParamsId[cnt].setValue(params);
      }
      cnt++;
    }
    return cnt;
  }
  setLTCPositionalLight(wtm, cnt) {
    const hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
    this.lightWidth[cnt][0] = hWidth.x;
    this.lightWidth[cnt][1] = hWidth.y;
    this.lightWidth[cnt][2] = hWidth.z;
    this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
    const hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
    this.lightHeight[cnt][0] = hHeight.x;
    this.lightHeight[cnt][1] = hHeight.y;
    this.lightHeight[cnt][2] = hHeight.z;
    this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
  }
  dispatchOmniLight(scope, omni, cnt) {
    const wtm = omni._node.getWorldTransform();
    if (!this.lightColorId[cnt]) {
      this._resolveLight(scope, cnt);
    }
    this.lightRadiusId[cnt].setValue(omni.attenuationEnd);
    this.lightColorId[cnt].setValue(omni._colorLinear);
    wtm.getTranslation(omni._position);
    this.lightPos[cnt][0] = omni._position.x;
    this.lightPos[cnt][1] = omni._position.y;
    this.lightPos[cnt][2] = omni._position.z;
    this.lightPosId[cnt].setValue(this.lightPos[cnt]);
    if (omni.shape !== LIGHTSHAPE_PUNCTUAL) {
      this.setLTCPositionalLight(wtm, cnt);
    }
    if (omni.castShadows) {
      const lightRenderData = omni.getRenderData(null, 0);
      this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
      const biases = omni._getUniformBiasValues(lightRenderData);
      const params = omni._shadowRenderParams;
      params.length = 4;
      params[0] = omni._shadowResolution;
      params[1] = biases.normalBias;
      params[2] = biases.bias;
      params[3] = 1 / omni.attenuationEnd;
      this.lightShadowParamsId[cnt].setValue(params);
      this.lightShadowIntensity[cnt].setValue(omni.shadowIntensity);
      const pixelsPerMeter = omni.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
      this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter);
      const cameraParams = omni._shadowCameraParams;
      cameraParams.length = 4;
      cameraParams[0] = lightRenderData.depthRangeCompensation;
      cameraParams[1] = lightRenderData.shadowCamera._farClip;
      cameraParams[2] = lightRenderData.shadowCamera._nearClip;
      cameraParams[3] = 0;
      this.lightCameraParamsId[cnt].setValue(cameraParams);
    }
    if (omni._cookie) {
      this.lightCookieId[cnt].setValue(omni._cookie);
      this.lightShadowMatrixId[cnt].setValue(wtm.data);
      this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);
    }
  }
  dispatchSpotLight(scope, spot, cnt) {
    const wtm = spot._node.getWorldTransform();
    if (!this.lightColorId[cnt]) {
      this._resolveLight(scope, cnt);
    }
    this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
    this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
    this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
    this.lightColorId[cnt].setValue(spot._colorLinear);
    wtm.getTranslation(spot._position);
    this.lightPos[cnt][0] = spot._position.x;
    this.lightPos[cnt][1] = spot._position.y;
    this.lightPos[cnt][2] = spot._position.z;
    this.lightPosId[cnt].setValue(this.lightPos[cnt]);
    if (spot.shape !== LIGHTSHAPE_PUNCTUAL) {
      this.setLTCPositionalLight(wtm, cnt);
    }
    wtm.getY(spot._direction).mulScalar(-1);
    spot._direction.normalize();
    this.lightDir[cnt][0] = spot._direction.x;
    this.lightDir[cnt][1] = spot._direction.y;
    this.lightDir[cnt][2] = spot._direction.z;
    this.lightDirId[cnt].setValue(this.lightDir[cnt]);
    if (spot.castShadows) {
      const lightRenderData = spot.getRenderData(null, 0);
      this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
      this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
      const biases = spot._getUniformBiasValues(lightRenderData);
      const params = spot._shadowRenderParams;
      params.length = 4;
      params[0] = spot._shadowResolution;
      params[1] = biases.normalBias;
      params[2] = biases.bias;
      params[3] = 1 / spot.attenuationEnd;
      this.lightShadowParamsId[cnt].setValue(params);
      this.lightShadowIntensity[cnt].setValue(spot.shadowIntensity);
      const pixelsPerMeter = spot.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
      const fov = lightRenderData.shadowCamera._fov * Math.PI / 180;
      const fovRatio = 1 / Math.tan(fov / 2);
      this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter * fovRatio);
      const cameraParams = spot._shadowCameraParams;
      cameraParams.length = 4;
      cameraParams[0] = lightRenderData.depthRangeCompensation;
      cameraParams[1] = lightRenderData.shadowCamera._farClip;
      cameraParams[2] = lightRenderData.shadowCamera._nearClip;
      cameraParams[3] = 0;
      this.lightCameraParamsId[cnt].setValue(cameraParams);
    }
    if (spot._cookie) {
      if (!spot.castShadows) {
        const cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);
        this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);
      }
      this.lightCookieId[cnt].setValue(spot._cookie);
      this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);
      if (spot._cookieTransform) {
        spot._cookieTransformUniform[0] = spot._cookieTransform.x;
        spot._cookieTransformUniform[1] = spot._cookieTransform.y;
        spot._cookieTransformUniform[2] = spot._cookieTransform.z;
        spot._cookieTransformUniform[3] = spot._cookieTransform.w;
        this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
        spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
        spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
        this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
      }
    }
  }
  dispatchLocalLights(sortedLights, mask, usedDirLights) {
    let cnt = usedDirLights;
    const scope = this.device.scope;
    const omnis = sortedLights[LIGHTTYPE_OMNI];
    const numOmnis = omnis.length;
    for (let i = 0; i < numOmnis; i++) {
      const omni = omnis[i];
      if (!(omni.mask & mask)) continue;
      this.dispatchOmniLight(scope, omni, cnt);
      cnt++;
    }
    const spts = sortedLights[LIGHTTYPE_SPOT];
    const numSpts = spts.length;
    for (let i = 0; i < numSpts; i++) {
      const spot = spts[i];
      if (!(spot.mask & mask)) continue;
      this.dispatchSpotLight(scope, spot, cnt);
      cnt++;
    }
  }
  renderForwardPrepareMaterials(camera, renderTarget, drawCalls, sortedLights, layer, pass) {
    var _camera$renderingPara, _renderTarget$isColor, _layer$getLightHash;
    const renderParams = (_camera$renderingPara = camera.renderingParams) != null ? _camera$renderingPara : this.scene.rendering;
    renderParams.srgbRenderTarget = (_renderTarget$isColor = renderTarget == null ? void 0 : renderTarget.isColorBufferSrgb(0)) != null ? _renderTarget$isColor : false;
    const addCall = (drawCall, shaderInstance, isNewMaterial, lightMaskChanged) => {
      _drawCallList.drawCalls.push(drawCall);
      _drawCallList.shaderInstances.push(shaderInstance);
      _drawCallList.isNewMaterial.push(isNewMaterial);
      _drawCallList.lightMaskChanged.push(lightMaskChanged);
    };
    _drawCallList.clear();
    const device = this.device;
    const scene = this.scene;
    const clusteredLightingEnabled = scene.clusteredLightingEnabled;
    const lightHash = (_layer$getLightHash = layer == null ? void 0 : layer.getLightHash(clusteredLightingEnabled)) != null ? _layer$getLightHash : 0;
    let prevMaterial = null, prevObjDefs, prevLightMask;
    const drawCallsCount = drawCalls.length;
    for (let i = 0; i < drawCallsCount; i++) {
      const drawCall = drawCalls[i];
      drawCall.ensureMaterial(device);
      const material = drawCall.material;
      const objDefs = drawCall._shaderDefs;
      const lightMask = drawCall.mask;
      if (material && material === prevMaterial && objDefs !== prevObjDefs) {
        prevMaterial = null;
      }
      if (material !== prevMaterial) {
        this._materialSwitches++;
        material._scene = scene;
        if (material.dirty) {
          material.updateUniforms(device, scene);
          material.dirty = false;
        }
      }
      const shaderInstance = drawCall.getShaderInstance(pass, lightHash, scene, renderParams, this.viewUniformFormat, this.viewBindGroupFormat, sortedLights);
      addCall(drawCall, shaderInstance, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);
      prevMaterial = material;
      prevObjDefs = objDefs;
      prevLightMask = lightMask;
    }
    return _drawCallList;
  }
  renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces) {
    const device = this.device;
    const scene = this.scene;
    const passFlag = 1 << pass;
    const flipFactor = flipFaces ? -1 : 1;
    const clusteredLightingEnabled = scene.clusteredLightingEnabled;
    const preparedCallsCount = preparedCalls.drawCalls.length;
    for (let i = 0; i < preparedCallsCount; i++) {
      var _drawCall$stencilFron, _drawCall$stencilBack;
      const drawCall = preparedCalls.drawCalls[i];
      const newMaterial = preparedCalls.isNewMaterial[i];
      const lightMaskChanged = preparedCalls.lightMaskChanged[i];
      const shaderInstance = preparedCalls.shaderInstances[i];
      const material = drawCall.material;
      const lightMask = drawCall.mask;
      if (newMaterial) {
        const asyncCompile = false;
        device.setShader(shaderInstance.shader, asyncCompile);
        material.setParameters(device);
        if (lightMaskChanged) {
          const usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], lightMask, camera);
          if (!clusteredLightingEnabled) {
            this.dispatchLocalLights(sortedLights, lightMask, usedDirLights);
          }
        }
        this.alphaTestId.setValue(material.alphaTest);
        device.setBlendState(material.blendState);
        device.setDepthState(material.depthState);
        device.setAlphaToCoverage(material.alphaToCoverage);
      }
      this.setupCullMode(camera._cullFaces, flipFactor, drawCall);
      const stencilFront = (_drawCall$stencilFron = drawCall.stencilFront) != null ? _drawCall$stencilFron : material.stencilFront;
      const stencilBack = (_drawCall$stencilBack = drawCall.stencilBack) != null ? _drawCall$stencilBack : material.stencilBack;
      device.setStencilState(stencilFront, stencilBack);
      drawCall.setParameters(device, passFlag);
      device.scope.resolve("meshInstanceId").setValue(drawCall.id);
      const mesh = drawCall.mesh;
      this.setVertexBuffers(device, mesh);
      this.setMorphing(device, drawCall.morphInstance);
      this.setSkinning(device, drawCall);
      this.setupMeshUniformBuffers(shaderInstance, drawCall);
      const style = drawCall.renderStyle;
      device.setIndexBuffer(mesh.indexBuffer[style]);
      drawCallback == null || drawCallback(drawCall, i);
      if (camera.xr && camera.xr.session && camera.xr.views.list.length) {
        const views = camera.xr.views;
        for (let v = 0; v < views.list.length; v++) {
          const view = views.list[v];
          device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
          this.projId.setValue(view.projMat.data);
          this.projSkyboxId.setValue(view.projMat.data);
          this.viewId.setValue(view.viewOffMat.data);
          this.viewInvId.setValue(view.viewInvOffMat.data);
          this.viewId3.setValue(view.viewMat3.data);
          this.viewProjId.setValue(view.projViewOffMat.data);
          this.viewPosId.setValue(view.positionData);
          this.viewIndexId.setValue(v);
          if (v === 0) {
            this.drawInstance(device, drawCall, mesh, style, true);
          } else {
            this.drawInstance2(device, drawCall, mesh, style);
          }
          this._forwardDrawCalls++;
        }
      } else {
        this.drawInstance(device, drawCall, mesh, style, true);
        this._forwardDrawCalls++;
      }
      if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {
        material.setParameters(device, drawCall.parameters);
      }
    }
  }
  renderForward(camera, renderTarget, allDrawCalls, sortedLights, pass, drawCallback, layer, flipFaces) {
    const preparedCalls = this.renderForwardPrepareMaterials(camera, renderTarget, allDrawCalls, sortedLights, layer, pass);
    this.renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces);
    _drawCallList.clear();
  }
  renderForwardLayer(camera, renderTarget, layer, transparent, shaderPass, viewBindGroups, options2 = {}) {
    var _options$clearColor, _options$clearDepth, _options$clearStencil;
    const {
      scene,
      device
    } = this;
    const clusteredLightingEnabled = scene.clusteredLightingEnabled;
    this.setupViewport(camera, renderTarget);
    let visible, splitLights;
    if (layer) {
      layer.sortVisible(camera, transparent);
      const culledInstances = layer.getCulledInstances(camera);
      visible = transparent ? culledInstances.transparent : culledInstances.opaque;
      scene.immediate.onPreRenderLayer(layer, visible, transparent);
      if (layer.requiresLightCube) {
        this.lightCube.update(scene.ambientLight, layer._lights);
        this.constantLightCube.setValue(this.lightCube.colors);
      }
      splitLights = layer.splitLights;
    } else {
      var _options$splitLights;
      visible = options2.meshInstances;
      splitLights = (_options$splitLights = options2.splitLights) != null ? _options$splitLights : _noLights;
    }
    if (clusteredLightingEnabled) {
      var _options$lightCluster;
      const lightClusters = (_options$lightCluster = options2.lightClusters) != null ? _options$lightCluster : this.worldClustersAllocator.empty;
      lightClusters.activate();
      if (layer) {
        if (!this.clustersDebugRendered && scene.lighting.debugLayer === layer.id) {
          this.clustersDebugRendered = true;
        }
      }
    }
    scene._activeCamera = camera;
    const viewCount = this.setCameraUniforms(camera, renderTarget);
    if (device.supportsUniformBuffers) {
      this.setupViewUniformBuffers(viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, viewCount);
    }
    const clearColor = (_options$clearColor = options2.clearColor) != null ? _options$clearColor : false;
    const clearDepth = (_options$clearDepth = options2.clearDepth) != null ? _options$clearDepth : false;
    const clearStencil = (_options$clearStencil = options2.clearStencil) != null ? _options$clearStencil : false;
    if (clearColor || clearDepth || clearStencil) {
      this.clear(camera, clearColor, clearDepth, clearStencil);
    }
    const flipFaces = !!(camera._flipFaces ^ (renderTarget == null ? void 0 : renderTarget.flipY));
    const forwardDrawCalls = this._forwardDrawCalls;
    this.renderForward(camera, renderTarget, visible, splitLights, shaderPass, null, layer, flipFaces);
    if (layer) {
      layer._forwardDrawCalls += this._forwardDrawCalls - forwardDrawCalls;
    }
  }
  setSceneConstants() {
    const scene = this.scene;
    this.dispatchGlobalLights(scene);
    if (scene.fog !== FOG_NONE) {
      tmpColor.linear(scene.fogColor);
      const fogUniform = this.fogColor;
      fogUniform[0] = tmpColor.r;
      fogUniform[1] = tmpColor.g;
      fogUniform[2] = tmpColor.b;
      this.fogColorId.setValue(fogUniform);
      if (scene.fog === FOG_LINEAR) {
        this.fogStartId.setValue(scene.fogStart);
        this.fogEndId.setValue(scene.fogEnd);
      } else {
        this.fogDensityId.setValue(scene.fogDensity);
      }
    }
    const device = this.device;
    this._screenSize[0] = device.width;
    this._screenSize[1] = device.height;
    this._screenSize[2] = 1 / device.width;
    this._screenSize[3] = 1 / device.height;
    this.screenSizeId.setValue(this._screenSize);
    this.pcssDiskSamplesId.setValue(this.pcssDiskSamples);
    this.pcssSphereSamplesId.setValue(this.pcssSphereSamples);
  }
  buildFrameGraph(frameGraph, layerComposition) {
    const scene = this.scene;
    frameGraph.reset();
    if (scene.clusteredLightingEnabled) {
      const {
        shadowsEnabled,
        cookiesEnabled
      } = scene.lighting;
      this._renderPassUpdateClustered.update(frameGraph, shadowsEnabled, cookiesEnabled, this.lights, this.localLights);
      frameGraph.addRenderPass(this._renderPassUpdateClustered);
    } else {
      this._shadowRendererLocal.buildNonClusteredRenderPasses(frameGraph, this.localLights);
    }
    let startIndex = 0;
    let newStart = true;
    let renderTarget = null;
    const renderActions = layerComposition._renderActions;
    for (let i = startIndex; i < renderActions.length; i++) {
      const renderAction = renderActions[i];
      const {
        layer,
        camera
      } = renderAction;
      if (renderAction.useCameraPasses) {
        camera.camera.renderPasses.forEach((renderPass) => {
          frameGraph.addRenderPass(renderPass);
        });
      } else {
        const isDepthLayer = layer.id === LAYERID_DEPTH;
        const isGrabPass = isDepthLayer && (camera.renderSceneColorMap || camera.renderSceneDepthMap);
        if (newStart) {
          newStart = false;
          startIndex = i;
          renderTarget = renderAction.renderTarget;
        }
        const nextRenderAction = renderActions[i + 1];
        const isNextLayerDepth = nextRenderAction ? nextRenderAction.layer.id === LAYERID_DEPTH : false;
        const isNextLayerGrabPass = isNextLayerDepth && (camera.renderSceneColorMap || camera.renderSceneDepthMap);
        const nextNeedDirShadows = nextRenderAction ? nextRenderAction.firstCameraUse && this.cameraDirShadowLights.has(nextRenderAction.camera.camera) : false;
        if (!nextRenderAction || nextRenderAction.renderTarget !== renderTarget || nextNeedDirShadows || isNextLayerGrabPass || isGrabPass) {
          const isDepthOnly = isDepthLayer && startIndex === i;
          if (!isDepthOnly) {
            this.addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, i);
          }
          if (isDepthLayer) {
            if (camera.renderSceneColorMap) {
              const colorGrabPass = camera.camera.renderPassColorGrab;
              colorGrabPass.source = camera.renderTarget;
              frameGraph.addRenderPass(colorGrabPass);
            }
            if (camera.renderSceneDepthMap) {
              frameGraph.addRenderPass(camera.camera.renderPassDepthGrab);
            }
          }
          if (renderAction.triggerPostprocess && camera != null && camera.onPostprocessing) {
            const renderPass = new RenderPassPostprocessing(this.device, this, renderAction);
            frameGraph.addRenderPass(renderPass);
          }
          newStart = true;
        }
      }
    }
  }
  addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, endIndex) {
    const renderPass = new RenderPassForward(this.device, layerComposition, this.scene, this);
    renderPass.init(renderTarget);
    const renderActions = layerComposition._renderActions;
    for (let i = startIndex; i <= endIndex; i++) {
      renderPass.addRenderAction(renderActions[i]);
    }
    frameGraph.addRenderPass(renderPass);
  }
  update(comp) {
    this.frameUpdate();
    this.shadowRenderer.frameUpdate();
    this.scene._updateSkyMesh();
    this.updateLayerComposition(comp);
    this.collectLights(comp);
    this.beginFrame(comp);
    this.setSceneConstants();
    this.cullComposition(comp);
    this.gpuUpdate(this.processingMeshInstances);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/layer.js
var layerCounter = 0;
var lightKeys = [];
var _tempMaterials = /* @__PURE__ */ new Set();
function sortManual(drawCallA, drawCallB) {
  return drawCallA.drawOrder - drawCallB.drawOrder;
}
function sortMaterialMesh(drawCallA, drawCallB) {
  const keyA = drawCallA._key[SORTKEY_FORWARD];
  const keyB = drawCallB._key[SORTKEY_FORWARD];
  if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
    return drawCallB.mesh.id - drawCallA.mesh.id;
  }
  return keyB - keyA;
}
function sortBackToFront(drawCallA, drawCallB) {
  return drawCallB.zdist - drawCallA.zdist;
}
function sortFrontToBack(drawCallA, drawCallB) {
  return drawCallA.zdist - drawCallB.zdist;
}
var sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];
var CulledInstances = class {
  constructor() {
    this.opaque = [];
    this.transparent = [];
  }
};
var Layer = class {
  constructor(options2 = {}) {
    var _options$enabled, _options$opaqueSortMo, _options$transparentS;
    this.meshInstances = [];
    this.meshInstancesSet = /* @__PURE__ */ new Set();
    this.shadowCasters = [];
    this.shadowCastersSet = /* @__PURE__ */ new Set();
    this._visibleInstances = /* @__PURE__ */ new WeakMap();
    this._lights = [];
    this._lightsSet = /* @__PURE__ */ new Set();
    this._clusteredLightsSet = /* @__PURE__ */ new Set();
    this._splitLights = [[], [], []];
    this._splitLightsDirty = true;
    this.requiresLightCube = false;
    this.cameras = [];
    this.camerasSet = /* @__PURE__ */ new Set();
    this._dirtyComposition = false;
    if (options2.id !== void 0) {
      this.id = options2.id;
      layerCounter = Math.max(this.id + 1, layerCounter);
    } else {
      this.id = layerCounter++;
    }
    this.name = options2.name;
    this._enabled = (_options$enabled = options2.enabled) != null ? _options$enabled : true;
    this._refCounter = this._enabled ? 1 : 0;
    this.opaqueSortMode = (_options$opaqueSortMo = options2.opaqueSortMode) != null ? _options$opaqueSortMo : SORTMODE_MATERIALMESH;
    this.transparentSortMode = (_options$transparentS = options2.transparentSortMode) != null ? _options$transparentS : SORTMODE_BACK2FRONT;
    if (options2.renderTarget) {
      this.renderTarget = options2.renderTarget;
    }
    this._clearColorBuffer = !!options2.clearColorBuffer;
    this._clearDepthBuffer = !!options2.clearDepthBuffer;
    this._clearStencilBuffer = !!options2.clearStencilBuffer;
    this.onEnable = options2.onEnable;
    this.onDisable = options2.onDisable;
    if (this._enabled && this.onEnable) {
      this.onEnable();
    }
    this.customSortCallback = null;
    this.customCalculateSortValues = null;
    this._lightHash = 0;
    this._lightHashDirty = false;
    this._lightIdHash = 0;
    this._lightIdHashDirty = false;
    this._shaderVersion = -1;
  }
  set enabled(val) {
    if (val !== this._enabled) {
      this._dirtyComposition = true;
      this._enabled = val;
      if (val) {
        this.incrementCounter();
        if (this.onEnable) this.onEnable();
      } else {
        this.decrementCounter();
        if (this.onDisable) this.onDisable();
      }
    }
  }
  get enabled() {
    return this._enabled;
  }
  set clearColorBuffer(val) {
    this._clearColorBuffer = val;
    this._dirtyComposition = true;
  }
  get clearColorBuffer() {
    return this._clearColorBuffer;
  }
  set clearDepthBuffer(val) {
    this._clearDepthBuffer = val;
    this._dirtyComposition = true;
  }
  get clearDepthBuffer() {
    return this._clearDepthBuffer;
  }
  set clearStencilBuffer(val) {
    this._clearStencilBuffer = val;
    this._dirtyComposition = true;
  }
  get clearStencilBuffer() {
    return this._clearStencilBuffer;
  }
  get hasClusteredLights() {
    return this._clusteredLightsSet.size > 0;
  }
  get clusteredLightsSet() {
    return this._clusteredLightsSet;
  }
  incrementCounter() {
    if (this._refCounter === 0) {
      this._enabled = true;
      if (this.onEnable) this.onEnable();
    }
    this._refCounter++;
  }
  decrementCounter() {
    if (this._refCounter === 1) {
      this._enabled = false;
      if (this.onDisable) this.onDisable();
    } else if (this._refCounter === 0) {
      return;
    }
    this._refCounter--;
  }
  addMeshInstances(meshInstances, skipShadowCasters) {
    const destMeshInstances = this.meshInstances;
    const destMeshInstancesSet = this.meshInstancesSet;
    for (let i = 0; i < meshInstances.length; i++) {
      const mi = meshInstances[i];
      if (!destMeshInstancesSet.has(mi)) {
        destMeshInstances.push(mi);
        destMeshInstancesSet.add(mi);
        _tempMaterials.add(mi.material);
      }
    }
    if (!skipShadowCasters) {
      this.addShadowCasters(meshInstances);
    }
    if (_tempMaterials.size > 0) {
      const sceneShaderVer = this._shaderVersion;
      _tempMaterials.forEach((mat2) => {
        if (sceneShaderVer >= 0 && mat2._shaderVersion !== sceneShaderVer) {
          if (mat2.getShaderVariant !== Material.prototype.getShaderVariant) {
            mat2.clearVariants();
          }
          mat2._shaderVersion = sceneShaderVer;
        }
      });
      _tempMaterials.clear();
    }
  }
  removeMeshInstances(meshInstances, skipShadowCasters) {
    const destMeshInstances = this.meshInstances;
    const destMeshInstancesSet = this.meshInstancesSet;
    for (let i = 0; i < meshInstances.length; i++) {
      const mi = meshInstances[i];
      if (destMeshInstancesSet.has(mi)) {
        destMeshInstancesSet.delete(mi);
        const j = destMeshInstances.indexOf(mi);
        if (j >= 0) {
          destMeshInstances.splice(j, 1);
        }
      }
    }
    if (!skipShadowCasters) {
      this.removeShadowCasters(meshInstances);
    }
  }
  addShadowCasters(meshInstances) {
    const shadowCasters = this.shadowCasters;
    const shadowCastersSet = this.shadowCastersSet;
    for (let i = 0; i < meshInstances.length; i++) {
      const mi = meshInstances[i];
      if (mi.castShadow && !shadowCastersSet.has(mi)) {
        shadowCastersSet.add(mi);
        shadowCasters.push(mi);
      }
    }
  }
  removeShadowCasters(meshInstances) {
    const shadowCasters = this.shadowCasters;
    const shadowCastersSet = this.shadowCastersSet;
    for (let i = 0; i < meshInstances.length; i++) {
      const mi = meshInstances[i];
      if (shadowCastersSet.has(mi)) {
        shadowCastersSet.delete(mi);
        const j = shadowCasters.indexOf(mi);
        if (j >= 0) {
          shadowCasters.splice(j, 1);
        }
      }
    }
  }
  clearMeshInstances(skipShadowCasters = false) {
    this.meshInstances.length = 0;
    this.meshInstancesSet.clear();
    if (!skipShadowCasters) {
      this.shadowCasters.length = 0;
      this.shadowCastersSet.clear();
    }
  }
  markLightsDirty() {
    this._lightHashDirty = true;
    this._lightIdHashDirty = true;
    this._splitLightsDirty = true;
  }
  addLight(light) {
    const l = light.light;
    if (!this._lightsSet.has(l)) {
      this._lightsSet.add(l);
      this._lights.push(l);
      this.markLightsDirty();
    }
    if (l.type !== LIGHTTYPE_DIRECTIONAL) {
      this._clusteredLightsSet.add(l);
    }
  }
  removeLight(light) {
    const l = light.light;
    if (this._lightsSet.has(l)) {
      this._lightsSet.delete(l);
      this._lights.splice(this._lights.indexOf(l), 1);
      this.markLightsDirty();
    }
    if (l.type !== LIGHTTYPE_DIRECTIONAL) {
      this._clusteredLightsSet.delete(l);
    }
  }
  clearLights() {
    this._lightsSet.forEach((light) => light.removeLayer(this));
    this._lightsSet.clear();
    this._clusteredLightsSet.clear();
    this._lights.length = 0;
    this.markLightsDirty();
  }
  get splitLights() {
    if (this._splitLightsDirty) {
      this._splitLightsDirty = false;
      const splitLights = this._splitLights;
      for (let i = 0; i < splitLights.length; i++) {
        splitLights[i].length = 0;
      }
      const lights2 = this._lights;
      for (let i = 0; i < lights2.length; i++) {
        const light = lights2[i];
        if (light.enabled) {
          splitLights[light._type].push(light);
        }
      }
      for (let i = 0; i < splitLights.length; i++) {
        splitLights[i].sort((a, b) => a.key - b.key);
      }
    }
    return this._splitLights;
  }
  evaluateLightHash(localLights, directionalLights, useIds) {
    let hash = 0;
    const lights2 = this._lights;
    for (let i = 0; i < lights2.length; i++) {
      const isLocalLight = lights2[i].type !== LIGHTTYPE_DIRECTIONAL;
      if (localLights && isLocalLight || directionalLights && !isLocalLight) {
        lightKeys.push(useIds ? lights2[i].id : lights2[i].key);
      }
    }
    if (lightKeys.length > 0) {
      lightKeys.sort();
      hash = hash32Fnv1a(lightKeys);
      lightKeys.length = 0;
    }
    return hash;
  }
  getLightHash(isClustered) {
    if (this._lightHashDirty) {
      this._lightHashDirty = false;
      this._lightHash = this.evaluateLightHash(!isClustered, true, false);
    }
    return this._lightHash;
  }
  getLightIdHash() {
    if (this._lightIdHashDirty) {
      this._lightIdHashDirty = false;
      this._lightIdHash = this.evaluateLightHash(true, false, true);
    }
    return this._lightIdHash;
  }
  addCamera(camera) {
    if (!this.camerasSet.has(camera.camera)) {
      this.camerasSet.add(camera.camera);
      this.cameras.push(camera);
      this._dirtyComposition = true;
    }
  }
  removeCamera(camera) {
    if (this.camerasSet.has(camera.camera)) {
      this.camerasSet.delete(camera.camera);
      const index = this.cameras.indexOf(camera);
      this.cameras.splice(index, 1);
      this._dirtyComposition = true;
    }
  }
  clearCameras() {
    this.cameras.length = 0;
    this.camerasSet.clear();
    this._dirtyComposition = true;
  }
  _calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {
    for (let i = 0; i < drawCallsCount; i++) {
      const drawCall = drawCalls[i];
      if (drawCall.layer <= LAYER_FX) continue;
      if (drawCall.calculateSortDistance) {
        drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
        continue;
      }
      const meshPos = drawCall.aabb.center;
      const tempx = meshPos.x - camPos.x;
      const tempy = meshPos.y - camPos.y;
      const tempz = meshPos.z - camPos.z;
      drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
    }
  }
  getCulledInstances(camera) {
    let instances = this._visibleInstances.get(camera);
    if (!instances) {
      instances = new CulledInstances();
      this._visibleInstances.set(camera, instances);
    }
    return instances;
  }
  sortVisible(camera, transparent) {
    const sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
    if (sortMode === SORTMODE_NONE) {
      return;
    }
    const culledInstances = this.getCulledInstances(camera);
    const instances = transparent ? culledInstances.transparent : culledInstances.opaque;
    const cameraNode = camera.node;
    if (sortMode === SORTMODE_CUSTOM) {
      const sortPos = cameraNode.getPosition();
      const sortDir = cameraNode.forward;
      if (this.customCalculateSortValues) {
        this.customCalculateSortValues(instances, instances.length, sortPos, sortDir);
      }
      if (this.customSortCallback) {
        instances.sort(this.customSortCallback);
      }
    } else {
      if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
        const sortPos = cameraNode.getPosition();
        const sortDir = cameraNode.forward;
        this._calculateSortDistances(instances, instances.length, sortPos, sortDir);
      }
      instances.sort(sortCallbacks[sortMode]);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/sort.js
var cmpPriority = (a, b) => a.priority - b.priority;
var sortPriority = (arr) => arr.sort(cmpPriority);

// ../node_modules/playcanvas/build/playcanvas/src/scene/composition/layer-composition.js
var LayerComposition = class extends EventHandler {
  constructor(name = "Untitled") {
    super();
    this.layerList = [];
    this.layerIdMap = /* @__PURE__ */ new Map();
    this.layerNameMap = /* @__PURE__ */ new Map();
    this.layerOpaqueIndexMap = /* @__PURE__ */ new Map();
    this.layerTransparentIndexMap = /* @__PURE__ */ new Map();
    this.subLayerList = [];
    this.subLayerEnabled = [];
    this.cameras = [];
    this._renderActions = [];
    this._dirty = false;
    this.name = name;
    this._opaqueOrder = {};
    this._transparentOrder = {};
  }
  destroy() {
    this.destroyRenderActions();
  }
  destroyRenderActions() {
    this._renderActions.forEach((ra) => ra.destroy());
    this._renderActions.length = 0;
  }
  _update() {
    const len = this.layerList.length;
    if (!this._dirty) {
      for (let i = 0; i < len; i++) {
        if (this.layerList[i]._dirtyComposition) {
          this._dirty = true;
          break;
        }
      }
    }
    if (this._dirty) {
      this._dirty = false;
      this.cameras.length = 0;
      for (let i = 0; i < len; i++) {
        const layer = this.layerList[i];
        layer._dirtyComposition = false;
        for (let j = 0; j < layer.cameras.length; j++) {
          const camera = layer.cameras[j];
          const index = this.cameras.indexOf(camera);
          if (index < 0) {
            this.cameras.push(camera);
          }
        }
      }
      if (this.cameras.length > 1) {
        sortPriority(this.cameras);
      }
      let renderActionCount = 0;
      this.destroyRenderActions();
      for (let i = 0; i < this.cameras.length; i++) {
        const camera = this.cameras[i];
        if (camera.camera.renderPasses.length > 0) {
          this.addDummyRenderAction(renderActionCount, camera);
          renderActionCount++;
          continue;
        }
        let cameraFirstRenderAction = true;
        const cameraFirstRenderActionIndex = renderActionCount;
        let lastRenderAction = null;
        let postProcessMarked = false;
        for (let j = 0; j < len; j++) {
          const layer = this.layerList[j];
          const isLayerEnabled = layer.enabled && this.subLayerEnabled[j];
          if (isLayerEnabled) {
            if (layer.cameras.length > 0) {
              if (camera.layers.indexOf(layer.id) >= 0) {
                if (!postProcessMarked && layer.id === camera.disablePostEffectsLayer) {
                  postProcessMarked = true;
                  if (lastRenderAction) {
                    lastRenderAction.triggerPostprocess = true;
                  }
                }
                const isTransparent = this.subLayerList[j];
                lastRenderAction = this.addRenderAction(renderActionCount, layer, isTransparent, camera, cameraFirstRenderAction, postProcessMarked);
                renderActionCount++;
                cameraFirstRenderAction = false;
              }
            }
          }
        }
        if (cameraFirstRenderActionIndex < renderActionCount) {
          lastRenderAction.lastCameraUse = true;
        }
        if (!postProcessMarked && lastRenderAction) {
          lastRenderAction.triggerPostprocess = true;
        }
        if (camera.renderTarget && camera.postEffectsEnabled) {
          this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, camera);
        }
      }
      this._logRenderActions();
    }
  }
  getNextRenderAction(renderActionIndex) {
    const renderAction = new RenderAction();
    this._renderActions.push(renderAction);
    return renderAction;
  }
  addDummyRenderAction(renderActionIndex, camera) {
    const renderAction = this.getNextRenderAction(renderActionIndex);
    renderAction.camera = camera;
    renderAction.useCameraPasses = true;
  }
  addRenderAction(renderActionIndex, layer, isTransparent, camera, cameraFirstRenderAction, postProcessMarked) {
    let rt = layer.id !== LAYERID_DEPTH ? camera.renderTarget : null;
    let used = false;
    const renderActions = this._renderActions;
    for (let i = renderActionIndex - 1; i >= 0; i--) {
      if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {
        used = true;
        break;
      }
    }
    if (postProcessMarked && camera.postEffectsEnabled) {
      rt = null;
    }
    const renderAction = this.getNextRenderAction(renderActionIndex);
    renderAction.triggerPostprocess = false;
    renderAction.layer = layer;
    renderAction.transparent = isTransparent;
    renderAction.camera = camera;
    renderAction.renderTarget = rt;
    renderAction.firstCameraUse = cameraFirstRenderAction;
    renderAction.lastCameraUse = false;
    const needsCameraClear = cameraFirstRenderAction || !used;
    const needsLayerClear = layer.clearColorBuffer || layer.clearDepthBuffer || layer.clearStencilBuffer;
    if (needsCameraClear || needsLayerClear) {
      renderAction.setupClears(needsCameraClear ? camera : void 0, layer);
    }
    return renderAction;
  }
  propagateRenderTarget(startIndex, fromCamera) {
    for (let a = startIndex; a >= 0; a--) {
      const ra = this._renderActions[a];
      const layer = ra.layer;
      if (ra.renderTarget && layer.id !== LAYERID_DEPTH) {
        break;
      }
      if (layer.id === LAYERID_DEPTH) {
        continue;
      }
      if (ra.useCameraPasses) {
        break;
      }
      const thisCamera = ra == null ? void 0 : ra.camera.camera;
      if (thisCamera) {
        if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {
          break;
        }
      }
      ra.renderTarget = fromCamera.renderTarget;
    }
  }
  _logRenderActions() {
  }
  _isLayerAdded(layer) {
    const found = this.layerIdMap.get(layer.id) === layer;
    return found;
  }
  _isSublayerAdded(layer, transparent) {
    const map = transparent ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
    if (map.get(layer) !== void 0) {
      return true;
    }
    return false;
  }
  push(layer) {
    if (this._isLayerAdded(layer)) return;
    this.layerList.push(layer);
    this.layerList.push(layer);
    this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
    this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
    this.subLayerEnabled.push(true);
    this.subLayerEnabled.push(true);
    this._updateLayerMaps();
    this._dirty = true;
    this.fire("add", layer);
  }
  insert(layer, index) {
    if (this._isLayerAdded(layer)) return;
    this.layerList.splice(index, 0, layer, layer);
    this.subLayerList.splice(index, 0, false, true);
    const count = this.layerList.length;
    this._updateOpaqueOrder(index, count - 1);
    this._updateTransparentOrder(index, count - 1);
    this.subLayerEnabled.splice(index, 0, true, true);
    this._updateLayerMaps();
    this._dirty = true;
    this.fire("add", layer);
  }
  remove(layer) {
    let id13 = this.layerList.indexOf(layer);
    delete this._opaqueOrder[id13];
    delete this._transparentOrder[id13];
    while (id13 >= 0) {
      this.layerList.splice(id13, 1);
      this.subLayerList.splice(id13, 1);
      this.subLayerEnabled.splice(id13, 1);
      id13 = this.layerList.indexOf(layer);
      this._dirty = true;
      this.fire("remove", layer);
    }
    const count = this.layerList.length;
    this._updateOpaqueOrder(0, count - 1);
    this._updateTransparentOrder(0, count - 1);
    this._updateLayerMaps();
  }
  pushOpaque(layer) {
    if (this._isSublayerAdded(layer, false)) return;
    this.layerList.push(layer);
    this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
    this.subLayerEnabled.push(true);
    this._updateLayerMaps();
    this._dirty = true;
    this.fire("add", layer);
  }
  insertOpaque(layer, index) {
    if (this._isSublayerAdded(layer, false)) return;
    this.layerList.splice(index, 0, layer);
    this.subLayerList.splice(index, 0, false);
    const count = this.subLayerList.length;
    this._updateOpaqueOrder(index, count - 1);
    this.subLayerEnabled.splice(index, 0, true);
    this._updateLayerMaps();
    this._dirty = true;
    this.fire("add", layer);
  }
  removeOpaque(layer) {
    for (let i = 0, len = this.layerList.length; i < len; i++) {
      if (this.layerList[i] === layer && !this.subLayerList[i]) {
        this.layerList.splice(i, 1);
        this.subLayerList.splice(i, 1);
        len--;
        this._updateOpaqueOrder(i, len - 1);
        this.subLayerEnabled.splice(i, 1);
        this._dirty = true;
        if (this.layerList.indexOf(layer) < 0) {
          this.fire("remove", layer);
        }
        break;
      }
    }
    this._updateLayerMaps();
  }
  pushTransparent(layer) {
    if (this._isSublayerAdded(layer, true)) return;
    this.layerList.push(layer);
    this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
    this.subLayerEnabled.push(true);
    this._updateLayerMaps();
    this._dirty = true;
    this.fire("add", layer);
  }
  insertTransparent(layer, index) {
    if (this._isSublayerAdded(layer, true)) return;
    this.layerList.splice(index, 0, layer);
    this.subLayerList.splice(index, 0, true);
    const count = this.subLayerList.length;
    this._updateTransparentOrder(index, count - 1);
    this.subLayerEnabled.splice(index, 0, true);
    this._updateLayerMaps();
    this._dirty = true;
    this.fire("add", layer);
  }
  removeTransparent(layer) {
    for (let i = 0, len = this.layerList.length; i < len; i++) {
      if (this.layerList[i] === layer && this.subLayerList[i]) {
        this.layerList.splice(i, 1);
        this.subLayerList.splice(i, 1);
        len--;
        this._updateTransparentOrder(i, len - 1);
        this.subLayerEnabled.splice(i, 1);
        this._dirty = true;
        if (this.layerList.indexOf(layer) < 0) {
          this.fire("remove", layer);
        }
        break;
      }
    }
    this._updateLayerMaps();
  }
  getOpaqueIndex(layer) {
    var _this$layerOpaqueInde;
    return (_this$layerOpaqueInde = this.layerOpaqueIndexMap.get(layer)) != null ? _this$layerOpaqueInde : -1;
  }
  getTransparentIndex(layer) {
    var _this$layerTransparen;
    return (_this$layerTransparen = this.layerTransparentIndexMap.get(layer)) != null ? _this$layerTransparen : -1;
  }
  isEnabled(layer, transparent) {
    const index = transparent ? this.getTransparentIndex(layer) : this.getOpaqueIndex(layer);
    return this.subLayerEnabled[index];
  }
  _updateLayerMaps() {
    this.layerIdMap.clear();
    this.layerNameMap.clear();
    this.layerOpaqueIndexMap.clear();
    this.layerTransparentIndexMap.clear();
    for (let i = 0; i < this.layerList.length; i++) {
      const layer = this.layerList[i];
      this.layerIdMap.set(layer.id, layer);
      this.layerNameMap.set(layer.name, layer);
      const subLayerIndexMap = this.subLayerList[i] ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
      subLayerIndexMap.set(layer, i);
    }
  }
  getLayerById(id13) {
    var _this$layerIdMap$get;
    return (_this$layerIdMap$get = this.layerIdMap.get(id13)) != null ? _this$layerIdMap$get : null;
  }
  getLayerByName(name) {
    var _this$layerNameMap$ge;
    return (_this$layerNameMap$ge = this.layerNameMap.get(name)) != null ? _this$layerNameMap$ge : null;
  }
  _updateOpaqueOrder(startIndex, endIndex) {
    for (let i = startIndex; i <= endIndex; i++) {
      if (this.subLayerList[i] === false) {
        this._opaqueOrder[this.layerList[i].id] = i;
      }
    }
  }
  _updateTransparentOrder(startIndex, endIndex) {
    for (let i = startIndex; i <= endIndex; i++) {
      if (this.subLayerList[i] === true) {
        this._transparentOrder[this.layerList[i].id] = i;
      }
    }
  }
  _sortLayersDescending(layersA, layersB, order) {
    let topLayerA = -1;
    let topLayerB = -1;
    for (let i = 0, len = layersA.length; i < len; i++) {
      const id13 = layersA[i];
      if (order.hasOwnProperty(id13)) {
        topLayerA = Math.max(topLayerA, order[id13]);
      }
    }
    for (let i = 0, len = layersB.length; i < len; i++) {
      const id13 = layersB[i];
      if (order.hasOwnProperty(id13)) {
        topLayerB = Math.max(topLayerB, order[id13]);
      }
    }
    if (topLayerA === -1 && topLayerB !== -1) {
      return 1;
    } else if (topLayerB === -1 && topLayerA !== -1) {
      return -1;
    }
    return topLayerB - topLayerA;
  }
  sortTransparentLayers(layersA, layersB) {
    return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
  }
  sortOpaqueLayers(layersA, layersB) {
    return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/light.js
var tmpVec = new Vec3();
var tmpBiases = {
  bias: 0,
  normalBias: 0
};
var tmpColor2 = new Color();
var chanId = {
  r: 0,
  g: 1,
  b: 2,
  a: 3
};
var lightTypes = {
  "directional": LIGHTTYPE_DIRECTIONAL,
  "omni": LIGHTTYPE_OMNI,
  "point": LIGHTTYPE_OMNI,
  "spot": LIGHTTYPE_SPOT
};
var directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];
var id12 = 0;
var LightRenderData = class {
  constructor(device, camera, face, light) {
    this.light = light;
    this.camera = camera;
    this.shadowCamera = ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);
    this.shadowMatrix = new Mat4();
    this.shadowViewport = new Vec4(0, 0, 1, 1);
    this.shadowScissor = new Vec4(0, 0, 1, 1);
    this.depthRangeCompensation = 0;
    this.projectionCompensation = 0;
    this.face = face;
    this.visibleCasters = [];
    this.viewBindGroups = [];
  }
  destroy() {
    this.viewBindGroups.forEach((bg) => {
      bg.defaultUniformBuffer.destroy();
      bg.destroy();
    });
    this.viewBindGroups.length = 0;
  }
  get shadowBuffer() {
    const rt = this.shadowCamera.renderTarget;
    if (rt) {
      const light = this.light;
      if (light._type === LIGHTTYPE_OMNI) {
        return rt.colorBuffer;
      }
      return light._isPcf ? rt.depthBuffer : rt.colorBuffer;
    }
    return null;
  }
};
var Light = class _Light {
  constructor(graphicsDevice, clusteredLighting) {
    this.layers = /* @__PURE__ */ new Set();
    this.clusteredLighting = void 0;
    this.shadowDepthState = DepthState.DEFAULT.clone();
    this.device = graphicsDevice;
    this.clusteredLighting = clusteredLighting;
    this.id = id12++;
    this._type = LIGHTTYPE_DIRECTIONAL;
    this._color = new Color(0.8, 0.8, 0.8);
    this._intensity = 1;
    this._affectSpecularity = true;
    this._luminance = 0;
    this._castShadows = false;
    this._enabled = false;
    this._mask = MASK_AFFECT_DYNAMIC;
    this.isStatic = false;
    this.key = 0;
    this.bakeDir = true;
    this.bakeNumSamples = 1;
    this.bakeArea = 0;
    this.attenuationStart = 10;
    this.attenuationEnd = 10;
    this._falloffMode = LIGHTFALLOFF_LINEAR;
    this._shadowType = SHADOW_PCF3;
    this._vsmBlurSize = 11;
    this.vsmBlurMode = BLUR_GAUSSIAN;
    this.vsmBias = 0.01 * 0.25;
    this._cookie = null;
    this.cookieIntensity = 1;
    this._cookieFalloff = true;
    this._cookieChannel = "rgb";
    this._cookieTransform = null;
    this._cookieTransformUniform = new Float32Array(4);
    this._cookieOffset = null;
    this._cookieOffsetUniform = new Float32Array(2);
    this._cookieTransformSet = false;
    this._cookieOffsetSet = false;
    this._innerConeAngle = 40;
    this._outerConeAngle = 45;
    this.cascades = null;
    this._shadowMatrixPalette = null;
    this._shadowCascadeDistances = null;
    this.numCascades = 1;
    this.cascadeDistribution = 0.5;
    this._shape = LIGHTSHAPE_PUNCTUAL;
    this._colorLinear = new Float32Array(3);
    this._updateLinearColor();
    this._position = new Vec3(0, 0, 0);
    this._direction = new Vec3(0, 0, 0);
    this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
    this._updateOuterAngle(this._outerConeAngle);
    this._usePhysicalUnits = void 0;
    this._shadowMap = null;
    this._shadowRenderParams = [];
    this._shadowCameraParams = [];
    this.shadowDistance = 40;
    this._shadowResolution = 1024;
    this._shadowBias = -5e-4;
    this.shadowIntensity = 1;
    this._normalOffsetBias = 0;
    this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
    this.shadowUpdateOverrides = null;
    this._penumbraSize = 1;
    this._isVsm = false;
    this._isPcf = true;
    this._cookieMatrix = null;
    this._atlasViewport = null;
    this.atlasViewportAllocated = false;
    this.atlasVersion = 0;
    this.atlasSlotIndex = 0;
    this.atlasSlotUpdated = false;
    this._node = null;
    this._renderData = [];
    this.visibleThisFrame = false;
    this.maxScreenSize = 0;
    this._updateShadowBias();
  }
  destroy() {
    this._destroyShadowMap();
    this.releaseRenderData();
    this._renderData = null;
  }
  releaseRenderData() {
    if (this._renderData) {
      for (let i = 0; i < this._renderData.length; i++) {
        this._renderData[i].destroy();
      }
      this._renderData.length = 0;
    }
  }
  addLayer(layer) {
    this.layers.add(layer);
  }
  removeLayer(layer) {
    this.layers.delete(layer);
  }
  set shadowBias(value) {
    if (this._shadowBias !== value) {
      this._shadowBias = value;
      this._updateShadowBias();
    }
  }
  get shadowBias() {
    return this._shadowBias;
  }
  set numCascades(value) {
    if (!this.cascades || this.numCascades !== value) {
      this.cascades = directionalCascades[value - 1];
      this._shadowMatrixPalette = new Float32Array(4 * 16);
      this._shadowCascadeDistances = new Float32Array(4);
      this._destroyShadowMap();
      this.updateKey();
    }
  }
  get numCascades() {
    return this.cascades.length;
  }
  set shadowMap(shadowMap) {
    if (this._shadowMap !== shadowMap) {
      this._destroyShadowMap();
      this._shadowMap = shadowMap;
    }
  }
  get shadowMap() {
    return this._shadowMap;
  }
  set mask(value) {
    if (this._mask !== value) {
      this._mask = value;
      this.updateKey();
    }
  }
  get mask() {
    return this._mask;
  }
  get numShadowFaces() {
    const type = this._type;
    if (type === LIGHTTYPE_DIRECTIONAL) {
      return this.numCascades;
    } else if (type === LIGHTTYPE_OMNI) {
      return 6;
    }
    return 1;
  }
  set type(value) {
    if (this._type === value) {
      return;
    }
    this._type = value;
    this._destroyShadowMap();
    this._updateShadowBias();
    this.updateKey();
    const stype = this._shadowType;
    this._shadowType = null;
    this.shadowUpdateOverrides = null;
    this.shadowType = stype;
  }
  get type() {
    return this._type;
  }
  set shape(value) {
    if (this._shape === value) {
      return;
    }
    this._shape = value;
    this._destroyShadowMap();
    this.updateKey();
    const stype = this._shadowType;
    this._shadowType = null;
    this.shadowType = stype;
  }
  get shape() {
    return this._shape;
  }
  set usePhysicalUnits(value) {
    if (this._usePhysicalUnits !== value) {
      this._usePhysicalUnits = value;
      this._updateLinearColor();
    }
  }
  get usePhysicalUnits() {
    return this._usePhysicalUnits;
  }
  set shadowType(value) {
    if (this._shadowType === value) {
      return;
    }
    const device = this.device;
    if (this._type === LIGHTTYPE_OMNI && value !== SHADOW_PCF3 && value !== SHADOW_PCSS) {
      value = SHADOW_PCF3;
    }
    if (value === SHADOW_VSM32 && (!device.textureFloatRenderable || !device.textureFloatFilterable)) {
      value = SHADOW_VSM16;
    }
    if (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) {
      value = SHADOW_VSM8;
    }
    this._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;
    this._isPcf = value === SHADOW_PCF1 || value === SHADOW_PCF3 || value === SHADOW_PCF5;
    this._shadowType = value;
    this._destroyShadowMap();
    this.updateKey();
  }
  get shadowType() {
    return this._shadowType;
  }
  set enabled(value) {
    if (this._enabled !== value) {
      this._enabled = value;
      this.layersDirty();
    }
  }
  get enabled() {
    return this._enabled;
  }
  set castShadows(value) {
    if (this._castShadows !== value) {
      this._castShadows = value;
      this._destroyShadowMap();
      this.layersDirty();
      this.updateKey();
    }
  }
  get castShadows() {
    return this._castShadows && this._mask !== MASK_BAKE && this._mask !== 0;
  }
  get bakeShadows() {
    return this._castShadows && this._mask === MASK_BAKE;
  }
  set shadowResolution(value) {
    if (this._shadowResolution !== value) {
      if (this._type === LIGHTTYPE_OMNI) {
        value = Math.min(value, this.device.maxCubeMapSize);
      } else {
        value = Math.min(value, this.device.maxTextureSize);
      }
      this._shadowResolution = value;
      this._destroyShadowMap();
    }
  }
  get shadowResolution() {
    return this._shadowResolution;
  }
  set vsmBlurSize(value) {
    if (this._vsmBlurSize === value) {
      return;
    }
    if (value % 2 === 0) value++;
    this._vsmBlurSize = value;
  }
  get vsmBlurSize() {
    return this._vsmBlurSize;
  }
  set normalOffsetBias(value) {
    if (this._normalOffsetBias === value) {
      return;
    }
    if (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {
      this.updateKey();
    }
    this._normalOffsetBias = value;
  }
  get normalOffsetBias() {
    return this._normalOffsetBias;
  }
  set falloffMode(value) {
    if (this._falloffMode === value) {
      return;
    }
    this._falloffMode = value;
    this.updateKey();
  }
  get falloffMode() {
    return this._falloffMode;
  }
  set innerConeAngle(value) {
    if (this._innerConeAngle === value) {
      return;
    }
    this._innerConeAngle = value;
    this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
    if (this._usePhysicalUnits) {
      this._updateLinearColor();
    }
  }
  get innerConeAngle() {
    return this._innerConeAngle;
  }
  set outerConeAngle(value) {
    if (this._outerConeAngle === value) {
      return;
    }
    this._outerConeAngle = value;
    this._updateOuterAngle(value);
    if (this._usePhysicalUnits) {
      this._updateLinearColor();
    }
  }
  get outerConeAngle() {
    return this._outerConeAngle;
  }
  set penumbraSize(value) {
    this._penumbraSize = value;
  }
  get penumbraSize() {
    return this._penumbraSize;
  }
  _updateOuterAngle(angle) {
    const radAngle = angle * Math.PI / 180;
    this._outerConeAngleCos = Math.cos(radAngle);
    this._outerConeAngleSin = Math.sin(radAngle);
  }
  set intensity(value) {
    if (this._intensity !== value) {
      this._intensity = value;
      this._updateLinearColor();
    }
  }
  get intensity() {
    return this._intensity;
  }
  set affectSpecularity(value) {
    if (this._type === LIGHTTYPE_DIRECTIONAL) {
      this._affectSpecularity = value;
      this.updateKey();
    }
  }
  get affectSpecularity() {
    return this._affectSpecularity;
  }
  set luminance(value) {
    if (this._luminance !== value) {
      this._luminance = value;
      this._updateLinearColor();
    }
  }
  get luminance() {
    return this._luminance;
  }
  get cookieMatrix() {
    if (!this._cookieMatrix) {
      this._cookieMatrix = new Mat4();
    }
    return this._cookieMatrix;
  }
  get atlasViewport() {
    if (!this._atlasViewport) {
      this._atlasViewport = new Vec4(0, 0, 1, 1);
    }
    return this._atlasViewport;
  }
  set cookie(value) {
    if (this._cookie === value) {
      return;
    }
    this._cookie = value;
    this.updateKey();
  }
  get cookie() {
    return this._cookie;
  }
  set cookieFalloff(value) {
    if (this._cookieFalloff === value) {
      return;
    }
    this._cookieFalloff = value;
    this.updateKey();
  }
  get cookieFalloff() {
    return this._cookieFalloff;
  }
  set cookieChannel(value) {
    if (this._cookieChannel === value) {
      return;
    }
    if (value.length < 3) {
      const chr = value.charAt(value.length - 1);
      const addLen = 3 - value.length;
      for (let i = 0; i < addLen; i++) {
        value += chr;
      }
    }
    this._cookieChannel = value;
    this.updateKey();
  }
  get cookieChannel() {
    return this._cookieChannel;
  }
  set cookieTransform(value) {
    if (this._cookieTransform === value) {
      return;
    }
    this._cookieTransform = value;
    this._cookieTransformSet = !!value;
    if (value && !this._cookieOffset) {
      this.cookieOffset = new Vec2();
      this._cookieOffsetSet = false;
    }
    this.updateKey();
  }
  get cookieTransform() {
    return this._cookieTransform;
  }
  set cookieOffset(value) {
    if (this._cookieOffset === value) {
      return;
    }
    const xformNew = !!(this._cookieTransformSet || value);
    if (xformNew && !value && this._cookieOffset) {
      this._cookieOffset.set(0, 0);
    } else {
      this._cookieOffset = value;
    }
    this._cookieOffsetSet = !!value;
    if (value && !this._cookieTransform) {
      this.cookieTransform = new Vec4(1, 1, 0, 0);
      this._cookieTransformSet = false;
    }
    this.updateKey();
  }
  get cookieOffset() {
    return this._cookieOffset;
  }
  beginFrame() {
    this.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;
    this.maxScreenSize = 0;
    this.atlasViewportAllocated = false;
    this.atlasSlotUpdated = false;
  }
  _destroyShadowMap() {
    this.releaseRenderData();
    if (this._shadowMap) {
      if (!this._shadowMap.cached) {
        this._shadowMap.destroy();
      }
      this._shadowMap = null;
    }
    if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
      this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
    }
    if (this.shadowUpdateOverrides) {
      for (let i = 0; i < this.shadowUpdateOverrides.length; i++) {
        if (this.shadowUpdateOverrides[i] === SHADOWUPDATE_NONE) {
          this.shadowUpdateOverrides[i] = SHADOWUPDATE_THISFRAME;
        }
      }
    }
  }
  getRenderData(camera, face) {
    for (let i = 0; i < this._renderData.length; i++) {
      const current = this._renderData[i];
      if (current.camera === camera && current.face === face) {
        return current;
      }
    }
    const rd = new LightRenderData(this.device, camera, face, this);
    this._renderData.push(rd);
    return rd;
  }
  clone() {
    const clone = new _Light(this.device, this.clusteredLighting);
    clone.type = this._type;
    clone.setColor(this._color);
    clone.intensity = this._intensity;
    clone.affectSpecularity = this._affectSpecularity;
    clone.luminance = this._luminance;
    clone.castShadows = this.castShadows;
    clone._enabled = this._enabled;
    clone.attenuationStart = this.attenuationStart;
    clone.attenuationEnd = this.attenuationEnd;
    clone.falloffMode = this._falloffMode;
    clone.shadowType = this._shadowType;
    clone.vsmBlurSize = this._vsmBlurSize;
    clone.vsmBlurMode = this.vsmBlurMode;
    clone.vsmBias = this.vsmBias;
    clone.penumbraSize = this.penumbraSize;
    clone.shadowUpdateMode = this.shadowUpdateMode;
    clone.mask = this.mask;
    if (this.shadowUpdateOverrides) {
      clone.shadowUpdateOverrides = this.shadowUpdateOverrides.slice();
    }
    clone.innerConeAngle = this._innerConeAngle;
    clone.outerConeAngle = this._outerConeAngle;
    clone.numCascades = this.numCascades;
    clone.cascadeDistribution = this.cascadeDistribution;
    clone.shape = this._shape;
    clone.shadowDepthState.copy(this.shadowDepthState);
    clone.shadowBias = this.shadowBias;
    clone.normalOffsetBias = this._normalOffsetBias;
    clone.shadowResolution = this._shadowResolution;
    clone.shadowDistance = this.shadowDistance;
    clone.shadowIntensity = this.shadowIntensity;
    return clone;
  }
  static getLightUnitConversion(type, outerAngle = Math.PI / 4, innerAngle = 0) {
    switch (type) {
      case LIGHTTYPE_SPOT: {
        const falloffEnd = Math.cos(outerAngle);
        const falloffStart = Math.cos(innerAngle);
        return 2 * Math.PI * (1 - falloffStart + (falloffStart - falloffEnd) / 2);
      }
      case LIGHTTYPE_OMNI:
        return 4 * Math.PI;
      case LIGHTTYPE_DIRECTIONAL:
        return 1;
    }
  }
  _getUniformBiasValues(lightRenderData) {
    const farClip = lightRenderData.shadowCamera._farClip;
    switch (this._type) {
      case LIGHTTYPE_OMNI:
        tmpBiases.bias = this.shadowBias;
        tmpBiases.normalBias = this._normalOffsetBias;
        break;
      case LIGHTTYPE_SPOT:
        if (this._isVsm) {
          tmpBiases.bias = -1e-5 * 20;
        } else {
          tmpBiases.bias = this.shadowBias * 20;
        }
        tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7) : this._normalOffsetBias;
        break;
      case LIGHTTYPE_DIRECTIONAL:
        if (this._isVsm) {
          tmpBiases.bias = -1e-5 * 20;
        } else {
          tmpBiases.bias = this.shadowBias / farClip * 100;
        }
        tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7) : this._normalOffsetBias;
        break;
    }
    return tmpBiases;
  }
  getColor() {
    return this._color;
  }
  getBoundingSphere(sphere) {
    if (this._type === LIGHTTYPE_SPOT) {
      const size = this.attenuationEnd;
      const angle = this._outerConeAngle;
      const cosAngle = this._outerConeAngleCos;
      const node = this._node;
      tmpVec.copy(node.up);
      if (angle > 45) {
        sphere.radius = size * this._outerConeAngleSin;
        tmpVec.mulScalar(-size * cosAngle);
      } else {
        sphere.radius = size / (2 * cosAngle);
        tmpVec.mulScalar(-sphere.radius);
      }
      sphere.center.add2(node.getPosition(), tmpVec);
    } else if (this._type === LIGHTTYPE_OMNI) {
      sphere.center = this._node.getPosition();
      sphere.radius = this.attenuationEnd;
    }
  }
  getBoundingBox(box) {
    if (this._type === LIGHTTYPE_SPOT) {
      const range = this.attenuationEnd;
      const angle = this._outerConeAngle;
      const node = this._node;
      const scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);
      box.center.set(0, -range * 0.5, 0);
      box.halfExtents.set(scl, range * 0.5, scl);
      box.setFromTransformedAabb(box, node.getWorldTransform(), true);
    } else if (this._type === LIGHTTYPE_OMNI) {
      box.center.copy(this._node.getPosition());
      box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
    }
  }
  _updateShadowBias() {
    if (this._type === LIGHTTYPE_OMNI && !this.clusteredLighting) {
      this.shadowDepthState.depthBias = 0;
      this.shadowDepthState.depthBiasSlope = 0;
    } else {
      const bias = this.shadowBias * -1e3;
      this.shadowDepthState.depthBias = bias;
      this.shadowDepthState.depthBiasSlope = bias;
    }
  }
  _updateLinearColor() {
    let intensity = this._intensity;
    if (this._usePhysicalUnits) {
      intensity = this._luminance / _Light.getLightUnitConversion(this._type, this._outerConeAngle * math.DEG_TO_RAD, this._innerConeAngle * math.DEG_TO_RAD);
    }
    const color = this._color;
    const colorLinear = this._colorLinear;
    if (intensity >= 1) {
      tmpColor2.linear(color).mulScalar(intensity);
    } else {
      tmpColor2.copy(color).mulScalar(intensity).linear();
    }
    colorLinear[0] = tmpColor2.r;
    colorLinear[1] = tmpColor2.g;
    colorLinear[2] = tmpColor2.b;
  }
  setColor() {
    if (arguments.length === 1) {
      this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);
    } else if (arguments.length === 3) {
      this._color.set(arguments[0], arguments[1], arguments[2]);
    }
    this._updateLinearColor();
  }
  layersDirty() {
    this.layers.forEach((layer) => {
      layer.markLightsDirty();
    });
  }
  updateKey() {
    let key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8 | (this.affectSpecularity ? 1 : 0) << 7 | this.mask << 6;
    if (this._cookieChannel.length === 3) {
      key |= chanId[this._cookieChannel.charAt(1)] << 16;
      key |= chanId[this._cookieChannel.charAt(2)] << 14;
    }
    if (key !== this.key) {
      this.layersDirty();
    }
    this.key = key;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/lighting/lighting-params.js
var LightingParams = class {
  constructor(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {
    this._areaLightsEnabled = false;
    this._cells = new Vec3(10, 3, 10);
    this._maxLightsPerCell = 255;
    this._shadowsEnabled = true;
    this._shadowType = SHADOW_PCF3;
    this._shadowAtlasResolution = 2048;
    this._cookiesEnabled = false;
    this._cookieAtlasResolution = 2048;
    this.debugLayer = void 0;
    this.atlasSplit = null;
    this._supportsAreaLights = supportsAreaLights;
    this._maxTextureSize = maxTextureSize;
    this._dirtyLightsFnc = dirtyLightsFnc;
  }
  applySettings(render) {
    var _render$lightingShado, _render$lightingCooki, _render$lightingAreaL, _render$lightingShado2, _render$lightingCooki2, _render$lightingMaxLi, _render$lightingShado3;
    this.shadowsEnabled = (_render$lightingShado = render.lightingShadowsEnabled) != null ? _render$lightingShado : this.shadowsEnabled;
    this.cookiesEnabled = (_render$lightingCooki = render.lightingCookiesEnabled) != null ? _render$lightingCooki : this.cookiesEnabled;
    this.areaLightsEnabled = (_render$lightingAreaL = render.lightingAreaLightsEnabled) != null ? _render$lightingAreaL : this.areaLightsEnabled;
    this.shadowAtlasResolution = (_render$lightingShado2 = render.lightingShadowAtlasResolution) != null ? _render$lightingShado2 : this.shadowAtlasResolution;
    this.cookieAtlasResolution = (_render$lightingCooki2 = render.lightingCookieAtlasResolution) != null ? _render$lightingCooki2 : this.cookieAtlasResolution;
    this.maxLightsPerCell = (_render$lightingMaxLi = render.lightingMaxLightsPerCell) != null ? _render$lightingMaxLi : this.maxLightsPerCell;
    this.shadowType = (_render$lightingShado3 = render.lightingShadowType) != null ? _render$lightingShado3 : this.shadowType;
    if (render.lightingCells) {
      this.cell = new Vec3(render.lightingCells);
    }
  }
  set cells(value) {
    this._cells.copy(value);
  }
  get cells() {
    return this._cells;
  }
  set maxLightsPerCell(value) {
    this._maxLightsPerCell = math.clamp(value, 1, 255);
  }
  get maxLightsPerCell() {
    return this._maxLightsPerCell;
  }
  set cookieAtlasResolution(value) {
    this._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
  }
  get cookieAtlasResolution() {
    return this._cookieAtlasResolution;
  }
  set shadowAtlasResolution(value) {
    this._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
  }
  get shadowAtlasResolution() {
    return this._shadowAtlasResolution;
  }
  set shadowType(value) {
    if (this._shadowType !== value) {
      this._shadowType = value;
      this._dirtyLightsFnc();
    }
  }
  get shadowType() {
    return this._shadowType;
  }
  set cookiesEnabled(value) {
    if (this._cookiesEnabled !== value) {
      this._cookiesEnabled = value;
      this._dirtyLightsFnc();
    }
  }
  get cookiesEnabled() {
    return this._cookiesEnabled;
  }
  set areaLightsEnabled(value) {
    if (this._supportsAreaLights) {
      if (this._areaLightsEnabled !== value) {
        this._areaLightsEnabled = value;
        this._dirtyLightsFnc();
      }
    }
  }
  get areaLightsEnabled() {
    return this._areaLightsEnabled;
  }
  set shadowsEnabled(value) {
    if (this._shadowsEnabled !== value) {
      this._shadowsEnabled = value;
      this._dirtyLightsFnc();
    }
  }
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/morph-instance.js
var textureMorphVertexShader = `
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
	}
	`;
var blendStateAdditive = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);
var MorphInstance = class _MorphInstance {
  constructor(morph) {
    this.shaderCache = [];
    this.morph = morph;
    morph.incRefCount();
    this.device = morph.device;
    this._weights = [];
    this._weightMap = /* @__PURE__ */ new Map();
    for (let v = 0; v < morph._targets.length; v++) {
      const target2 = morph._targets[v];
      if (target2.name) {
        this._weightMap.set(target2.name, v);
      }
      this.setWeight(v, target2.defaultWeight);
    }
    this._activeTargets = [];
    this.maxSubmitCount = this.device.maxTextures;
    this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
    const createRT = (name, textureVar) => {
      this[textureVar] = morph._createTexture(name, morph._renderTextureFormat);
      return new RenderTarget({
        colorBuffer: this[textureVar],
        depth: false
      });
    };
    if (morph.morphPositions) {
      this.rtPositions = createRT("MorphRTPos", "texturePositions");
    }
    if (morph.morphNormals) {
      this.rtNormals = createRT("MorphRTNrm", "textureNormals");
    }
    this._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight]);
    const halfSize = morph.aabb.halfExtents;
    this._aabbSize = new Float32Array([halfSize.x * 4, halfSize.y * 4, halfSize.z * 4]);
    const min = morph.aabb.getMin();
    this._aabbMin = new Float32Array([min.x * 2, min.y * 2, min.z * 2]);
    this._aabbNrmSize = new Float32Array([2, 2, 2]);
    this._aabbNrmMin = new Float32Array([-1, -1, -1]);
    this.aabbSizeId = this.device.scope.resolve("aabbSize");
    this.aabbMinId = this.device.scope.resolve("aabbMin");
    for (let i = 0; i < this.maxSubmitCount; i++) {
      this[`morphBlendTex${i}`] = this.device.scope.resolve(`morphBlendTex${i}`);
    }
    this.morphFactor = this.device.scope.resolve("morphFactor[0]");
    this.zeroTextures = false;
  }
  destroy() {
    this.shader = null;
    const morph = this.morph;
    if (morph) {
      this.morph = null;
      morph.decRefCount();
      if (morph.refCount < 1) {
        morph.destroy();
      }
    }
    if (this.rtPositions) {
      this.rtPositions.destroy();
      this.rtPositions = null;
    }
    if (this.texturePositions) {
      this.texturePositions.destroy();
      this.texturePositions = null;
    }
    if (this.rtNormals) {
      this.rtNormals.destroy();
      this.rtNormals = null;
    }
    if (this.textureNormals) {
      this.textureNormals.destroy();
      this.textureNormals = null;
    }
  }
  clone() {
    return new _MorphInstance(this.morph);
  }
  _getWeightIndex(key) {
    if (typeof key === "string") {
      const index = this._weightMap.get(key);
      return index;
    }
    return key;
  }
  getWeight(key) {
    const index = this._getWeightIndex(key);
    return this._weights[index];
  }
  setWeight(key, weight) {
    const index = this._getWeightIndex(key);
    this._weights[index] = weight;
    this._dirty = true;
  }
  _getFragmentShader(numTextures) {
    let textureDecl = "";
    let addingCode = "";
    for (let i = 0; i < numTextures; i++) {
      textureDecl += `uniform highp sampler2D morphBlendTex${i};`;
      addingCode += `color.xyz += morphFactor[${i}] * texture2D(morphBlendTex${i}, uv0).xyz;`;
    }
    return `

						varying vec2 uv0;
						${this.morph.intRenderFormat ? "#define MORPH_INT" : ""}
						${numTextures > 0 ? `uniform highp float morphFactor[${numTextures}];` : ""}
						${textureDecl}

						#ifdef MORPH_INT
								uniform vec3 aabbSize;
								uniform vec3 aabbMin;
						#endif

						void main (void) {
								highp vec4 color = vec4(0, 0, 0, 1);

								${addingCode}

								#ifdef MORPH_INT
										color.xyz = (color.xyz - aabbMin) / aabbSize * 65535.0;
										gl_FragColor = uvec4(color);
								#else
										gl_FragColor = color;
								#endif
						}
				`;
  }
  _getShader(count) {
    let shader = this.shaderCache[count];
    if (!shader) {
      const fs3 = this._getFragmentShader(count);
      const outputType = this.morph.intRenderFormat ? "uvec4" : "vec4";
      shader = createShaderFromCode(this.device, textureMorphVertexShader, fs3, `textureMorph${count}`, void 0, {
        fragmentOutputTypes: [outputType]
      });
      this.shaderCache[count] = shader;
    }
    return shader;
  }
  _updateTextureRenderTarget(renderTarget, srcTextureName, isPos) {
    const device = this.device;
    const submitBatch = (usedCount2, blending2) => {
      this.morphFactor.setValue(this._shaderMorphWeights);
      device.setBlendState(blending2 ? blendStateAdditive : BlendState.NOBLEND);
      const shader = this._getShader(usedCount2);
      drawQuadWithShader(device, renderTarget, shader);
    };
    this.setAabbUniforms(isPos);
    let usedCount = 0;
    let blending = false;
    const count = this._activeTargets.length;
    for (let i = 0; i < count; i++) {
      const activeTarget = this._activeTargets[i];
      const tex = activeTarget.target[srcTextureName];
      if (tex) {
        this[`morphBlendTex${usedCount}`].setValue(tex);
        this._shaderMorphWeights[usedCount] = activeTarget.weight;
        usedCount++;
        if (usedCount >= this.maxSubmitCount) {
          submitBatch(usedCount, blending);
          usedCount = 0;
          blending = true;
        }
      }
    }
    if (usedCount > 0 || count === 0 && !this.zeroTextures) {
      submitBatch(usedCount, blending);
    }
  }
  _updateTextureMorph() {
    this.device;
    if (this._activeTargets.length > 0 || !this.zeroTextures) {
      if (this.rtPositions) {
        this._updateTextureRenderTarget(this.rtPositions, "texturePositions", true);
      }
      if (this.rtNormals) {
        this._updateTextureRenderTarget(this.rtNormals, "textureNormals", false);
      }
      this.zeroTextures = this._activeTargets.length === 0;
    }
  }
  setAabbUniforms(isPos = true) {
    this.aabbSizeId.setValue(isPos ? this._aabbSize : this._aabbNrmSize);
    this.aabbMinId.setValue(isPos ? this._aabbMin : this._aabbNrmMin);
  }
  prepareRendering(device) {
    this.setAabbUniforms();
  }
  update() {
    this._dirty = false;
    const targets = this.morph._targets;
    let activeCount = 0;
    const epsilon3 = 1e-5;
    for (let i = 0; i < targets.length; i++) {
      const absWeight = Math.abs(this.getWeight(i));
      if (absWeight > epsilon3) {
        if (this._activeTargets.length <= activeCount) {
          this._activeTargets[activeCount] = {};
        }
        const activeTarget = this._activeTargets[activeCount++];
        activeTarget.absWeight = absWeight;
        activeTarget.weight = this.getWeight(i);
        activeTarget.target = targets[i];
      }
    }
    this._activeTargets.length = activeCount;
    if (this.morph.intRenderFormat) {
      if (this._activeTargets.length > this.maxSubmitCount) {
        this._activeTargets.sort((l, r) => {
          return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;
        });
        this._activeTargets.length = this.maxSubmitCount;
      }
    }
    this._updateTextureMorph();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/model.js
var Model = class _Model {
  constructor() {
    this.graph = null;
    this.meshInstances = [];
    this.skinInstances = [];
    this.morphInstances = [];
    this.cameras = [];
    this.lights = [];
    this._shadersVersion = 0;
    this._immutable = false;
  }
  getGraph() {
    return this.graph;
  }
  setGraph(graph) {
    this.graph = graph;
  }
  getCameras() {
    return this.cameras;
  }
  setCameras(cameras) {
    this.cameras = cameras;
  }
  getLights() {
    return this.lights;
  }
  setLights(lights2) {
    this.lights = lights2;
  }
  getMaterials() {
    const materials = [];
    for (let i = 0; i < this.meshInstances.length; i++) {
      const meshInstance = this.meshInstances[i];
      if (materials.indexOf(meshInstance.material) === -1) {
        materials.push(meshInstance.material);
      }
    }
    return materials;
  }
  clone() {
    const srcNodes = [];
    const cloneNodes = [];
    const _duplicate = function _duplicate2(node) {
      const newNode = node.clone();
      srcNodes.push(node);
      cloneNodes.push(newNode);
      for (let idx = 0; idx < node._children.length; idx++) {
        newNode.addChild(_duplicate2(node._children[idx]));
      }
      return newNode;
    };
    const cloneGraph = _duplicate(this.graph);
    const cloneMeshInstances = [];
    const cloneSkinInstances = [];
    const cloneMorphInstances = [];
    for (let i = 0; i < this.skinInstances.length; i++) {
      const skin = this.skinInstances[i].skin;
      const cloneSkinInstance = new SkinInstance(skin);
      const bones = [];
      for (let j = 0; j < skin.boneNames.length; j++) {
        const boneName = skin.boneNames[j];
        const bone = cloneGraph.findByName(boneName);
        bones.push(bone);
      }
      cloneSkinInstance.bones = bones;
      cloneSkinInstances.push(cloneSkinInstance);
    }
    for (let i = 0; i < this.morphInstances.length; i++) {
      const morph = this.morphInstances[i].morph;
      const cloneMorphInstance = new MorphInstance(morph);
      cloneMorphInstances.push(cloneMorphInstance);
    }
    for (let i = 0; i < this.meshInstances.length; i++) {
      const meshInstance = this.meshInstances[i];
      const nodeIndex = srcNodes.indexOf(meshInstance.node);
      const cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);
      if (meshInstance.skinInstance) {
        const skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
        cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
      }
      if (meshInstance.morphInstance) {
        const morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
        cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
      }
      cloneMeshInstances.push(cloneMeshInstance);
    }
    const clone = new _Model();
    clone.graph = cloneGraph;
    clone.meshInstances = cloneMeshInstances;
    clone.skinInstances = cloneSkinInstances;
    clone.morphInstances = cloneMorphInstances;
    clone.getGraph().syncHierarchy();
    return clone;
  }
  destroy() {
    const meshInstances = this.meshInstances;
    for (let i = 0; i < meshInstances.length; i++) {
      meshInstances[i].destroy();
    }
    this.meshInstances.length = 0;
  }
  generateWireframe() {
    MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/morph.js
var Morph = class extends RefCountedObject {
  constructor(targets, graphicsDevice, {
    preferHighPrecision = false
  } = {}) {
    var _this$_renderTextureF;
    super();
    this._aabb = void 0;
    this.preferHighPrecision = void 0;
    this.device = graphicsDevice;
    this.preferHighPrecision = preferHighPrecision;
    this._targets = targets.slice();
    const device = this.device;
    const renderableHalf = device.textureHalfFloatRenderable ? PIXELFORMAT_RGBA16F : void 0;
    const renderableFloat = device.textureFloatRenderable ? PIXELFORMAT_RGBA32F : void 0;
    this._renderTextureFormat = this.preferHighPrecision ? renderableFloat != null ? renderableFloat : renderableHalf : renderableHalf != null ? renderableHalf : renderableFloat;
    this._renderTextureFormat = (_this$_renderTextureF = this._renderTextureFormat) != null ? _this$_renderTextureF : PIXELFORMAT_RGBA16U;
    this.intRenderFormat = isIntegerPixelFormat(this._renderTextureFormat);
    this._textureFormat = this.preferHighPrecision ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;
    this._init();
    this._updateMorphFlags();
  }
  get aabb() {
    if (!this._aabb) {
      const min = new Vec3();
      const max = new Vec3();
      for (let i = 0; i < this._targets.length; i++) {
        const targetAabb = this._targets[i].aabb;
        min.min(targetAabb.getMin());
        max.max(targetAabb.getMax());
      }
      this._aabb = new BoundingBox();
      this._aabb.setMinMax(min, max);
    }
    return this._aabb;
  }
  get morphPositions() {
    return this._morphPositions;
  }
  get morphNormals() {
    return this._morphNormals;
  }
  _init() {
    this._initTextureBased();
    for (let i = 0; i < this._targets.length; i++) {
      this._targets[i]._postInit();
    }
  }
  _findSparseSet(deltaArrays, ids3, usedDataIndices) {
    let freeIndex = 1;
    const dataCount = deltaArrays[0].length;
    for (let v = 0; v < dataCount; v += 3) {
      let vertexUsed = false;
      for (let i = 0; i < deltaArrays.length; i++) {
        const data2 = deltaArrays[i];
        if (data2[v] !== 0 || data2[v + 1] !== 0 || data2[v + 2] !== 0) {
          vertexUsed = true;
          break;
        }
      }
      if (vertexUsed) {
        ids3.push(freeIndex);
        usedDataIndices.push(v / 3);
        freeIndex++;
      } else {
        ids3.push(0);
      }
    }
    return freeIndex;
  }
  _initTextureBased() {
    const deltaArrays = [], deltaInfos = [];
    for (let i = 0; i < this._targets.length; i++) {
      const target2 = this._targets[i];
      if (target2.options.deltaPositions) {
        deltaArrays.push(target2.options.deltaPositions);
        deltaInfos.push({
          target: target2,
          name: "texturePositions"
        });
      }
      if (target2.options.deltaNormals) {
        deltaArrays.push(target2.options.deltaNormals);
        deltaInfos.push({
          target: target2,
          name: "textureNormals"
        });
      }
    }
    const ids3 = [], usedDataIndices = [];
    const freeIndex = this._findSparseSet(deltaArrays, ids3, usedDataIndices);
    const maxTextureSize = this.device.maxTextureSize;
    let morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
    morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
    const morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);
    if (morphTextureHeight > maxTextureSize) {
      return false;
    }
    this.morphTextureWidth = morphTextureWidth;
    this.morphTextureHeight = morphTextureHeight;
    let halfFloat = false;
    let numComponents = 3;
    const float2Half = FloatPacking.float2Half;
    if (this._textureFormat === PIXELFORMAT_RGBA16F) {
      halfFloat = true;
      numComponents = 4;
    }
    const textures = [];
    for (let i = 0; i < deltaArrays.length; i++) {
      textures.push(this._createTexture("MorphTarget", this._textureFormat));
    }
    for (let i = 0; i < deltaArrays.length; i++) {
      const data2 = deltaArrays[i];
      const texture = textures[i];
      const textureData = texture.lock();
      if (halfFloat) {
        for (let v = 0; v < usedDataIndices.length; v++) {
          const index = usedDataIndices[v] * 3;
          const dstIndex = v * numComponents + numComponents;
          textureData[dstIndex] = float2Half(data2[index]);
          textureData[dstIndex + 1] = float2Half(data2[index + 1]);
          textureData[dstIndex + 2] = float2Half(data2[index + 2]);
        }
      } else {
        for (let v = 0; v < usedDataIndices.length; v++) {
          const index = usedDataIndices[v] * 3;
          const dstIndex = v * numComponents + numComponents;
          textureData[dstIndex] = data2[index];
          textureData[dstIndex + 1] = data2[index + 1];
          textureData[dstIndex + 2] = data2[index + 2];
        }
      }
      texture.unlock();
      const target2 = deltaInfos[i].target;
      target2._setTexture(deltaInfos[i].name, texture);
    }
    const formatDesc = [{
      semantic: SEMANTIC_ATTR15,
      components: 1,
      type: TYPE_UINT32,
      asInt: true
    }];
    this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc, ids3.length), ids3.length, {
      data: new Uint32Array(ids3)
    });
    return true;
  }
  destroy() {
    var _this$vertexBufferIds;
    (_this$vertexBufferIds = this.vertexBufferIds) == null || _this$vertexBufferIds.destroy();
    this.vertexBufferIds = null;
    for (let i = 0; i < this._targets.length; i++) {
      this._targets[i].destroy();
    }
    this._targets.length = 0;
  }
  get targets() {
    return this._targets;
  }
  _updateMorphFlags() {
    this._morphPositions = false;
    this._morphNormals = false;
    for (let i = 0; i < this._targets.length; i++) {
      const target2 = this._targets[i];
      if (target2.morphPositions) {
        this._morphPositions = true;
      }
      if (target2.morphNormals) {
        this._morphNormals = true;
      }
    }
  }
  _createTexture(name, format) {
    return new Texture(this.device, {
      width: this.morphTextureWidth,
      height: this.morphTextureHeight,
      format,
      cubemap: false,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/morph-target.js
var MorphTarget = class _MorphTarget {
  constructor(options2) {
    this.used = false;
    this.options = options2;
    this._name = options2.name;
    this._defaultWeight = options2.defaultWeight || 0;
    this._aabb = options2.aabb;
    this.deltaPositions = options2.deltaPositions;
  }
  destroy() {
    var _this$texturePosition, _this$textureNormals;
    (_this$texturePosition = this.texturePositions) == null || _this$texturePosition.destroy();
    this.texturePositions = null;
    (_this$textureNormals = this.textureNormals) == null || _this$textureNormals.destroy();
    this.textureNormals = null;
  }
  get name() {
    return this._name;
  }
  get defaultWeight() {
    return this._defaultWeight;
  }
  get aabb() {
    if (!this._aabb) {
      this._aabb = new BoundingBox();
      if (this.deltaPositions) {
        this._aabb.compute(this.deltaPositions);
      }
    }
    return this._aabb;
  }
  get morphPositions() {
    return !!this.texturePositions;
  }
  get morphNormals() {
    return !!this.textureNormals;
  }
  clone() {
    return new _MorphTarget(this.options);
  }
  _postInit() {
    if (!this.options.preserveData) {
      this.options = null;
    }
    this.used = true;
  }
  _setTexture(name, texture) {
    this[name] = texture;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/particle-system/cpu-updater.js
var nonUniformScale;
var uniformScale = 1;
var particleTexChannels = 4;
var rotMat = new Mat4();
var rotMatInv = new Mat4();
var randomPosTformed = new Vec3();
var randomPos = new Vec3();
var rndFactor3Vec = new Vec3();
var particlePosPrev = new Vec3();
var velocityVec = new Vec3();
var localVelocityVec = new Vec3();
var velocityVec2 = new Vec3();
var localVelocityVec2 = new Vec3();
var radialVelocityVec = new Vec3();
var particlePos = new Vec3();
var particleFinalPos = new Vec3();
var moveDirVec = new Vec3();
var tmpVec32 = new Vec3();
function frac(f) {
  return f - Math.floor(f);
}
function saturate(x2) {
  return Math.max(Math.min(x2, 1), 0);
}
function glMod(x2, y2) {
  return x2 - y2 * Math.floor(x2 / y2);
}
function encodeFloatRGBA(v) {
  let encX = frac(v);
  let encY = frac(255 * v);
  let encZ = frac(65025 * v);
  let encW = frac(160581375 * v);
  encX -= encY / 255;
  encY -= encZ / 255;
  encZ -= encW / 255;
  encW -= encW / 255;
  return [encX, encY, encZ, encW];
}
function encodeFloatRG(v) {
  let encX = frac(v);
  let encY = frac(255 * v);
  encX -= encY / 255;
  encY -= encY / 255;
  return [encX, encY];
}
var ParticleCPUUpdater = class {
  constructor(emitter) {
    this._emitter = emitter;
  }
  calcSpawnPosition(particleTex, spawnMatrix2, extentsInnerRatioUniform2, emitterPos, i) {
    const emitter = this._emitter;
    const rX = Math.random();
    const rY = Math.random();
    const rZ = Math.random();
    const rW = Math.random();
    if (emitter.useCpu) {
      particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels] = rX;
      particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels] = rY;
      particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels] = rZ;
    }
    randomPos.x = rX - 0.5;
    randomPos.y = rY - 0.5;
    randomPos.z = rZ - 0.5;
    if (emitter.emitterShape === EMITTERSHAPE_BOX) {
      const max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
      const edgeX = max + (0.5 - max) * extentsInnerRatioUniform2[0];
      const edgeY = max + (0.5 - max) * extentsInnerRatioUniform2[1];
      const edgeZ = max + (0.5 - max) * extentsInnerRatioUniform2[2];
      randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
      randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
      randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
      if (!emitter.localSpace) {
        randomPosTformed.copy(emitterPos).add(spawnMatrix2.transformPoint(randomPos));
      } else {
        randomPosTformed.copy(spawnMatrix2.transformPoint(randomPos));
      }
    } else {
      randomPos.normalize();
      const spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
      const r = rW * (1 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
      if (!emitter.localSpace) {
        randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));
      } else {
        randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));
      }
    }
    const particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
    let startSpawnTime = -particleRate * i;
    if (emitter.pack8) {
      const packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
      const packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
      const packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
      let packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
      packA = packA % (Math.PI * 2) / (Math.PI * 2);
      const rg0 = encodeFloatRG(packX);
      particleTex[i * particleTexChannels] = rg0[0];
      particleTex[i * particleTexChannels + 1] = rg0[1];
      const ba0 = encodeFloatRG(packY);
      particleTex[i * particleTexChannels + 2] = ba0[0];
      particleTex[i * particleTexChannels + 3] = ba0[1];
      const rg1 = encodeFloatRG(packZ);
      particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels] = rg1[0];
      particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels] = rg1[1];
      const ba1 = encodeFloatRG(packA);
      particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels] = ba1[0];
      particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = ba1[1];
      const a2 = 1;
      particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 2] = a2;
      const maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1) * Math.max(emitter.rate, emitter.rate2));
      const maxPosLife = emitter.lifetime + 1;
      startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
      const rgba3 = encodeFloatRGBA(startSpawnTime);
      particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[0];
      particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[1];
      particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[2];
      particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[3];
    } else {
      particleTex[i * particleTexChannels] = randomPosTformed.x;
      particleTex[i * particleTexChannels + 1] = randomPosTformed.y;
      particleTex[i * particleTexChannels + 2] = randomPosTformed.z;
      particleTex[i * particleTexChannels + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
      particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = startSpawnTime;
    }
  }
  update(data2, vbToSort, particleTex, spawnMatrix2, extentsInnerRatioUniform2, emitterPos, delta, isOnStop) {
    let a, b, c2;
    const emitter = this._emitter;
    if (emitter.meshInstance.node) {
      const fullMat = emitter.meshInstance.node.worldTransform;
      for (let j = 0; j < 12; j++) {
        rotMat.data[j] = fullMat.data[j];
      }
      rotMatInv.copy(rotMat);
      rotMatInv.invert();
      nonUniformScale = emitter.meshInstance.node.localScale;
      uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
    }
    emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
    const posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
    const vertSize = !emitter.useMesh ? 15 : 17;
    let cf, cc;
    let rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
    const precision1 = emitter.precision - 1;
    for (let i = 0; i < emitter.numParticles; i++) {
      const id13 = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
      const rndFactor = particleTex[id13 * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels];
      rndFactor3Vec.x = rndFactor;
      rndFactor3Vec.y = particleTex[id13 * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels];
      rndFactor3Vec.z = particleTex[id13 * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels];
      const particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
      const particleLifetime = emitter.lifetime;
      let life = particleTex[id13 * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] + delta;
      const nlife = saturate(life / particleLifetime);
      let scale3 = 0;
      let alphaDiv = 0;
      const angle = 0;
      const respawn = life - delta <= 0 || life >= particleLifetime;
      if (respawn) {
        this.calcSpawnPosition(particleTex, spawnMatrix2, extentsInnerRatioUniform2, emitterPos, id13);
      }
      let particleEnabled = life > 0 && life < particleLifetime;
      if (particleEnabled) {
        c2 = nlife * precision1;
        cf = Math.floor(c2);
        cc = Math.ceil(c2);
        c2 %= 1;
        a = emitter.qRotSpeed[cf];
        b = emitter.qRotSpeed[cc];
        rotSpeed = a + (b - a) * c2;
        a = emitter.qRotSpeed2[cf];
        b = emitter.qRotSpeed2[cc];
        rotSpeed2 = a + (b - a) * c2;
        a = emitter.qScale[cf];
        b = emitter.qScale[cc];
        scale3 = a + (b - a) * c2;
        a = emitter.qScale2[cf];
        b = emitter.qScale2[cc];
        scale2 = a + (b - a) * c2;
        a = emitter.qAlpha[cf];
        b = emitter.qAlpha[cc];
        alpha = a + (b - a) * c2;
        a = emitter.qAlpha2[cf];
        b = emitter.qAlpha2[cc];
        alpha2 = a + (b - a) * c2;
        a = emitter.qRadialSpeed[cf];
        b = emitter.qRadialSpeed[cc];
        radialSpeed = a + (b - a) * c2;
        a = emitter.qRadialSpeed2[cf];
        b = emitter.qRadialSpeed2[cc];
        radialSpeed2 = a + (b - a) * c2;
        radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100 % 1);
        particlePosPrev.x = particleTex[id13 * particleTexChannels];
        particlePosPrev.y = particleTex[id13 * particleTexChannels + 1];
        particlePosPrev.z = particleTex[id13 * particleTexChannels + 2];
        if (!emitter.localSpace) {
          radialVelocityVec.copy(particlePosPrev).sub(emitterPos);
        } else {
          radialVelocityVec.copy(particlePosPrev);
        }
        radialVelocityVec.normalize().mulScalar(radialSpeed);
        cf *= 3;
        cc *= 3;
        a = emitter.qLocalVelocity[cf];
        b = emitter.qLocalVelocity[cc];
        localVelocityVec.x = a + (b - a) * c2;
        a = emitter.qLocalVelocity[cf + 1];
        b = emitter.qLocalVelocity[cc + 1];
        localVelocityVec.y = a + (b - a) * c2;
        a = emitter.qLocalVelocity[cf + 2];
        b = emitter.qLocalVelocity[cc + 2];
        localVelocityVec.z = a + (b - a) * c2;
        a = emitter.qLocalVelocity2[cf];
        b = emitter.qLocalVelocity2[cc];
        localVelocityVec2.x = a + (b - a) * c2;
        a = emitter.qLocalVelocity2[cf + 1];
        b = emitter.qLocalVelocity2[cc + 1];
        localVelocityVec2.y = a + (b - a) * c2;
        a = emitter.qLocalVelocity2[cf + 2];
        b = emitter.qLocalVelocity2[cc + 2];
        localVelocityVec2.z = a + (b - a) * c2;
        a = emitter.qVelocity[cf];
        b = emitter.qVelocity[cc];
        velocityVec.x = a + (b - a) * c2;
        a = emitter.qVelocity[cf + 1];
        b = emitter.qVelocity[cc + 1];
        velocityVec.y = a + (b - a) * c2;
        a = emitter.qVelocity[cf + 2];
        b = emitter.qVelocity[cc + 2];
        velocityVec.z = a + (b - a) * c2;
        a = emitter.qVelocity2[cf];
        b = emitter.qVelocity2[cc];
        velocityVec2.x = a + (b - a) * c2;
        a = emitter.qVelocity2[cf + 1];
        b = emitter.qVelocity2[cc + 1];
        velocityVec2.y = a + (b - a) * c2;
        a = emitter.qVelocity2[cf + 2];
        b = emitter.qVelocity2[cc + 2];
        velocityVec2.z = a + (b - a) * c2;
        localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
        localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
        localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;
        if (emitter.initialVelocity > 0) {
          if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
            randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();
            localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));
          } else {
            localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));
          }
        }
        velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
        velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
        velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
        rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
        scale3 = (scale3 + (scale2 - scale3) * (rndFactor * 1e4 % 1)) * uniformScale;
        alphaDiv = (alpha2 - alpha) * (rndFactor * 1e3 % 1);
        if (emitter.meshInstance.node) {
          if (!emitter.localSpace) {
            rotMat.transformPoint(localVelocityVec, localVelocityVec);
          } else {
            localVelocityVec.x /= nonUniformScale.x;
            localVelocityVec.y /= nonUniformScale.y;
            localVelocityVec.z /= nonUniformScale.z;
          }
        }
        if (!emitter.localSpace) {
          localVelocityVec.add(velocityVec.mul(nonUniformScale));
          localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
        } else {
          rotMatInv.transformPoint(velocityVec, velocityVec);
          localVelocityVec.add(velocityVec).add(radialVelocityVec);
        }
        moveDirVec.copy(localVelocityVec);
        particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));
        particleFinalPos.copy(particlePos);
        particleTex[id13 * particleTexChannels] = particleFinalPos.x;
        particleTex[id13 * particleTexChannels + 1] = particleFinalPos.y;
        particleTex[id13 * particleTexChannels + 2] = particleFinalPos.z;
        particleTex[id13 * particleTexChannels + 3] += rotSpeed * delta;
        if (emitter.wrap && emitter.wrapBounds) {
          if (!emitter.localSpace) {
            particleFinalPos.sub(emitterPos);
          }
          particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
          particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
          particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
          if (!emitter.localSpace) {
            particleFinalPos.add(emitterPos);
          }
        }
        if (emitter.sort > 0) {
          if (emitter.sort === 1) {
            tmpVec32.copy(particleFinalPos).sub(posCam);
            emitter.particleDistance[id13] = -(tmpVec32.x * tmpVec32.x + tmpVec32.y * tmpVec32.y + tmpVec32.z * tmpVec32.z);
          } else if (emitter.sort === 2) {
            emitter.particleDistance[id13] = life;
          } else if (emitter.sort === 3) {
            emitter.particleDistance[id13] = -life;
          }
        }
      }
      if (isOnStop) {
        if (life < 0) {
          particleTex[id13 * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = -1;
        }
      } else {
        if (life >= particleLifetime) {
          life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
          particleTex[id13 * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = emitter.loop ? 1 : -1;
        }
        if (life < 0 && emitter.loop) {
          particleTex[id13 * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = 1;
        }
      }
      if (particleTex[id13 * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] < 0) {
        particleEnabled = false;
      }
      particleTex[id13 * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = life;
      for (let v = 0; v < emitter.numParticleVerts; v++) {
        const vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
        let quadX = emitter.vbCPU[vbOffset];
        let quadY = emitter.vbCPU[vbOffset + 1];
        let quadZ = emitter.vbCPU[vbOffset + 2];
        if (!particleEnabled) {
          quadX = quadY = quadZ = 0;
        }
        const w = i * emitter.numParticleVerts * vertSize + v * vertSize;
        data2[w] = particleFinalPos.x;
        data2[w + 1] = particleFinalPos.y;
        data2[w + 2] = particleFinalPos.z;
        data2[w + 3] = nlife;
        data2[w + 4] = emitter.alignToMotion ? angle : particleTex[id13 * particleTexChannels + 3];
        data2[w + 5] = scale3;
        data2[w + 6] = alphaDiv;
        data2[w + 7] = moveDirVec.x;
        data2[w + 8] = quadX;
        data2[w + 9] = quadY;
        data2[w + 10] = quadZ;
        data2[w + 11] = moveDirVec.y;
        data2[w + 12] = id13;
        data2[w + 13] = moveDirVec.z;
        data2[w + 14] = emitter.vbCPU[vbOffset + 3];
        if (emitter.useMesh) {
          data2[w + 15] = emitter.vbCPU[vbOffset + 4];
          data2[w + 16] = emitter.vbCPU[vbOffset + 5];
        }
      }
    }
    if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
      const vbStride = emitter.useMesh ? 6 : 4;
      const particleDistance = emitter.particleDistance;
      for (let i = 0; i < emitter.numParticles; i++) {
        vbToSort[i][0] = i;
        vbToSort[i][1] = particleDistance[Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * vbStride + 3])];
      }
      emitter.vbOld.set(emitter.vbCPU);
      vbToSort.sort((p12, p22) => {
        return p12[1] - p22[1];
      });
      for (let i = 0; i < emitter.numParticles; i++) {
        const src = vbToSort[i][0] * emitter.numParticleVerts * vbStride;
        const dest = i * emitter.numParticleVerts * vbStride;
        for (let j = 0; j < emitter.numParticleVerts * vbStride; j++) {
          emitter.vbCPU[dest + j] = emitter.vbOld[src + j];
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/particle-system/gpu-updater.js
var spawnMatrix3 = new Mat3();
var emitterMatrix3 = new Mat3();
var emitterMatrix3Inv = new Mat3();
var ParticleGPUUpdater = class {
  constructor(emitter, gd) {
    this._emitter = emitter;
    this.frameRandomUniform = new Float32Array(3);
    this.emitterPosUniform = new Float32Array(3);
    this.emitterScaleUniform = new Float32Array([1, 1, 1]);
    this.worldBoundsMulUniform = new Float32Array(3);
    this.worldBoundsAddUniform = new Float32Array(3);
    this.inBoundsSizeUniform = new Float32Array(3);
    this.inBoundsCenterUniform = new Float32Array(3);
    this.constantParticleTexIN = gd.scope.resolve("particleTexIN");
    this.constantParticleTexOUT = gd.scope.resolve("particleTexOUT");
    this.constantEmitterPos = gd.scope.resolve("emitterPos");
    this.constantEmitterScale = gd.scope.resolve("emitterScale");
    this.constantSpawnBounds = gd.scope.resolve("spawnBounds");
    this.constantSpawnPosInnerRatio = gd.scope.resolve("spawnPosInnerRatio");
    this.constantSpawnBoundsSphere = gd.scope.resolve("spawnBoundsSphere");
    this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve("spawnBoundsSphereInnerRatio");
    this.constantInitialVelocity = gd.scope.resolve("initialVelocity");
    this.constantFrameRandom = gd.scope.resolve("frameRandom");
    this.constantDelta = gd.scope.resolve("delta");
    this.constantRate = gd.scope.resolve("rate");
    this.constantRateDiv = gd.scope.resolve("rateDiv");
    this.constantLifetime = gd.scope.resolve("lifetime");
    this.constantGraphSampleSize = gd.scope.resolve("graphSampleSize");
    this.constantGraphNumSamples = gd.scope.resolve("graphNumSamples");
    this.constantInternalTex0 = gd.scope.resolve("internalTex0");
    this.constantInternalTex1 = gd.scope.resolve("internalTex1");
    this.constantInternalTex2 = gd.scope.resolve("internalTex2");
    this.constantInternalTex3 = gd.scope.resolve("internalTex3");
    this.constantEmitterMatrix = gd.scope.resolve("emitterMatrix");
    this.constantEmitterMatrixInv = gd.scope.resolve("emitterMatrixInv");
    this.constantNumParticles = gd.scope.resolve("numParticles");
    this.constantNumParticlesPot = gd.scope.resolve("numParticlesPot");
    this.constantLocalVelocityDivMult = gd.scope.resolve("localVelocityDivMult");
    this.constantVelocityDivMult = gd.scope.resolve("velocityDivMult");
    this.constantRotSpeedDivMult = gd.scope.resolve("rotSpeedDivMult");
    this.constantSeed = gd.scope.resolve("seed");
    this.constantStartAngle = gd.scope.resolve("startAngle");
    this.constantStartAngle2 = gd.scope.resolve("startAngle2");
    this.constantOutBoundsMul = gd.scope.resolve("outBoundsMul");
    this.constantOutBoundsAdd = gd.scope.resolve("outBoundsAdd");
    this.constantInBoundsSize = gd.scope.resolve("inBoundsSize");
    this.constantInBoundsCenter = gd.scope.resolve("inBoundsCenter");
    this.constantMaxVel = gd.scope.resolve("maxVel");
    this.constantFaceTangent = gd.scope.resolve("faceTangent");
    this.constantFaceBinorm = gd.scope.resolve("faceBinorm");
  }
  _setInputBounds() {
    this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
    this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
    this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
    this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
    this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
    this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
    this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
    this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
  }
  randomize() {
    this.frameRandomUniform[0] = Math.random();
    this.frameRandomUniform[1] = Math.random();
    this.frameRandomUniform[2] = Math.random();
  }
  update(device, spawnMatrix2, extentsInnerRatioUniform2, delta, isOnStop) {
    const emitter = this._emitter;
    device.setBlendState(BlendState.NOBLEND);
    device.setDepthState(DepthState.NODEPTH);
    device.setCullMode(CULLFACE_NONE);
    this.randomize();
    this.constantGraphSampleSize.setValue(1 / emitter.precision);
    this.constantGraphNumSamples.setValue(emitter.precision);
    this.constantNumParticles.setValue(emitter.numParticles);
    this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
    this.constantInternalTex0.setValue(emitter.internalTex0);
    this.constantInternalTex1.setValue(emitter.internalTex1);
    this.constantInternalTex2.setValue(emitter.internalTex2);
    this.constantInternalTex3.setValue(emitter.internalTex3);
    const node = emitter.meshInstance.node;
    const emitterScale = node === null ? Vec3.ONE : node.localScale;
    if (emitter.pack8) {
      this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
      this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
      this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
      this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
      this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
      this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
      this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
      this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);
      this._setInputBounds();
      let maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
      maxVel = Math.max(maxVel, 1);
      this.constantMaxVel.setValue(maxVel);
    }
    const emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();
    const emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();
    if (emitter.emitterShape === EMITTERSHAPE_BOX) {
      spawnMatrix3.setFromMat4(spawnMatrix2);
      this.constantSpawnBounds.setValue(spawnMatrix3.data);
      this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform2);
    } else {
      this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
      this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
    }
    this.constantInitialVelocity.setValue(emitter.initialVelocity);
    emitterMatrix3.setFromMat4(emitterMatrix);
    emitterMatrix3Inv.invertMat4(emitterMatrix);
    this.emitterPosUniform[0] = emitterPos.x;
    this.emitterPosUniform[1] = emitterPos.y;
    this.emitterPosUniform[2] = emitterPos.z;
    this.constantEmitterPos.setValue(this.emitterPosUniform);
    this.constantFrameRandom.setValue(this.frameRandomUniform);
    this.constantDelta.setValue(delta);
    this.constantRate.setValue(emitter.rate);
    this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
    this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
    this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
    this.constantSeed.setValue(emitter.seed);
    this.constantLifetime.setValue(emitter.lifetime);
    this.emitterScaleUniform[0] = emitterScale.x;
    this.emitterScaleUniform[1] = emitterScale.y;
    this.emitterScaleUniform[2] = emitterScale.z;
    this.constantEmitterScale.setValue(this.emitterScaleUniform);
    this.constantEmitterMatrix.setValue(emitterMatrix3.data);
    this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
    this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
    this.constantVelocityDivMult.setValue(emitter.velocityUMax);
    this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
    let texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
    texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
    const texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
    this.constantParticleTexIN.setValue(texIN);
    drawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);
    emitter.material.setParameter("particleTexOUT", texIN);
    emitter.material.setParameter("particleTexIN", texOUT);
    emitter.beenReset = false;
    emitter.swapTex = !emitter.swapTex;
    emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
    emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
    if (emitter.pack8) {
      this._setInputBounds();
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/particle.js
var ShaderGeneratorParticle = class extends ShaderGenerator {
  generateKey(options2) {
    let key = "particle";
    for (const prop in options2) {
      if (options2.hasOwnProperty(prop)) {
        key += options2[prop];
      }
    }
    return key;
  }
  _animTex(options2) {
    let vshader = "";
    vshader += options2.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;
    vshader += shaderChunks.particleAnimTexVS;
    return vshader;
  }
  createShaderDefinition(device, options2) {
    const executionDefine = `#define PARTICLE_${options2.useCpu ? "CPU" : "GPU"}
`;
    let fshader = `#define PARTICLE
${executionDefine}`;
    let vshader = `#define VERTEXSHADER
${executionDefine}`;
    if (options2.mesh) vshader += "#define USE_MESH\n";
    if (options2.localSpace) vshader += "#define LOCAL_SPACE\n";
    if (options2.screenSpace) vshader += "#define SCREEN_SPACE\n";
    if (options2.animTex) vshader += "\nuniform vec2 animTexTilesParams;\n";
    if (options2.animTex) vshader += "\nuniform vec4 animTexParams;\n";
    if (options2.animTex) vshader += "\nuniform vec2 animTexIndexParams;\n";
    if (options2.normal === 2) vshader += "\nvarying mat3 ParticleMat;\n";
    if (options2.normal === 1) vshader += "\nvarying vec3 Normal;\n";
    if (options2.soft) vshader += "\nvarying float vDepth;\n";
    const faceVS = options2.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;
    if (!options2.useCpu) {
      vshader += shaderChunks.particle_initVS;
      vshader += options2.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;
      if (options2.soft > 0) vshader += shaderChunks.screenDepthPS;
      vshader += shaderChunks.particleVS;
      if (options2.localSpace) vshader += shaderChunks.particle_localShiftVS;
      if (options2.animTex) vshader += this._animTex(options2);
      if (options2.wrap) vshader += shaderChunks.particle_wrapVS;
      if (options2.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
      vshader += options2.mesh ? shaderChunks.particle_meshVS : faceVS;
      if (options2.normal === 1) vshader += shaderChunks.particle_normalVS;
      if (options2.normal === 2) vshader += shaderChunks.particle_TBNVS;
      if (options2.stretch > 0) vshader += shaderChunks.particle_stretchVS;
      vshader += shaderChunks.particle_endVS;
      if (options2.soft > 0) vshader += shaderChunks.particle_softVS;
    } else {
      if (options2.soft > 0) vshader += shaderChunks.screenDepthPS;
      vshader += shaderChunks.particle_cpuVS;
      if (options2.localSpace) vshader += shaderChunks.particle_localShiftVS;
      if (options2.animTex) vshader += this._animTex(options2);
      if (options2.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
      vshader += options2.mesh ? shaderChunks.particle_meshVS : faceVS;
      if (options2.normal === 1) vshader += shaderChunks.particle_normalVS;
      if (options2.normal === 2) vshader += shaderChunks.particle_TBNVS;
      if (options2.stretch > 0) vshader += shaderChunks.particle_stretchVS;
      vshader += shaderChunks.particle_cpu_endVS;
      if (options2.soft > 0) vshader += shaderChunks.particle_softVS;
    }
    vshader += "}\n";
    if (options2.normal > 0) {
      if (options2.normal === 1) {
        fshader += "\nvarying vec3 Normal;\n";
      } else if (options2.normal === 2) {
        fshader += "\nvarying mat3 ParticleMat;\n";
      }
      fshader += "\nuniform vec3 lightCube[6];\n";
    }
    if (options2.soft) fshader += "\nvarying float vDepth;\n";
    fshader += shaderChunks.decodePS;
    fshader += ShaderGenerator.gammaCode(options2.gamma);
    fshader += ShaderGenerator.tonemapCode(options2.toneMap);
    fshader += ShaderGenerator.fogCode(options2.fog);
    if (options2.normal === 2) fshader += "\nuniform sampler2D normalMap;\n";
    if (options2.soft > 0) fshader += shaderChunks.screenDepthPS;
    fshader += shaderChunks.particlePS;
    if (options2.soft > 0) fshader += shaderChunks.particle_softPS;
    if (options2.normal === 1) fshader += "\nvec3 normal = Normal;\n";
    if (options2.normal === 2) fshader += shaderChunks.particle_normalMapPS;
    if (options2.normal > 0) fshader += options2.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;
    if (options2.normal > 0) fshader += shaderChunks.particle_lightingPS;
    if (options2.blend === BLEND_NORMAL) {
      fshader += shaderChunks.particle_blendNormalPS;
    } else if (options2.blend === BLEND_ADDITIVE) {
      fshader += shaderChunks.particle_blendAddPS;
    } else if (options2.blend === BLEND_MULTIPLICATIVE) {
      fshader += shaderChunks.particle_blendMultiplyPS;
    }
    fshader += shaderChunks.particle_endPS;
    return ShaderUtils.createDefinition(device, {
      name: "ParticleShader",
      vertexCode: vshader,
      fragmentCode: fshader
    });
  }
};
var particle = new ShaderGeneratorParticle();

// ../node_modules/playcanvas/build/playcanvas/src/scene/particle-system/particle-material.js
var ParticleMaterial = class extends Material {
  constructor(emitter) {
    super();
    this.emitter = null;
    this.emitter = emitter;
  }
  getShaderVariant(params) {
    var _renderParams$shaderO, _renderParams$toneMap;
    const {
      device,
      scene,
      renderParams
    } = params;
    const {
      emitter
    } = this;
    const options2 = {
      defines: this.defines,
      pass: SHADER_FORWARD,
      useCpu: this.emitter.useCpu,
      normal: emitter.lighting ? emitter.normalMap !== null ? 2 : 1 : 0,
      halflambert: this.emitter.halfLambert,
      stretch: this.emitter.stretch,
      alignToMotion: this.emitter.alignToMotion,
      soft: this.emitter.depthSoftening,
      mesh: this.emitter.useMesh,
      gamma: (_renderParams$shaderO = renderParams == null ? void 0 : renderParams.shaderOutputGamma) != null ? _renderParams$shaderO : GAMMA_NONE,
      toneMap: (_renderParams$toneMap = renderParams == null ? void 0 : renderParams.toneMapping) != null ? _renderParams$toneMap : TONEMAP_LINEAR,
      fog: scene && !this.emitter.noFog ? scene.fog : "none",
      wrap: this.emitter.wrap && this.emitter.wrapBounds,
      localSpace: this.emitter.localSpace,
      screenSpace: emitter.inTools ? false : this.emitter.screenSpace,
      blend: this.blendType,
      animTex: this.emitter._isAnimated(),
      animTexLoop: this.emitter.animLoop,
      pack8: this.emitter.pack8,
      customFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN
    };
    const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
    const library = getProgramLibrary(device);
    library.register("particle", particle);
    return library.getProgram("particle", options2, processingOptions, this.userId);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/particle-system/particle-emitter.js
var particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];
function _createTexture(device, width, height, pixelData, format = PIXELFORMAT_RGBA32F, mult8Bit, filter) {
  let mipFilter = FILTER_NEAREST;
  if (filter && (format === PIXELFORMAT_RGBA8 || format === PIXELFORMAT_SRGBA8)) {
    mipFilter = FILTER_LINEAR;
  }
  const texture = new Texture(device, {
    width,
    height,
    format,
    cubemap: false,
    mipmaps: false,
    minFilter: mipFilter,
    magFilter: mipFilter,
    addressU: ADDRESS_CLAMP_TO_EDGE,
    addressV: ADDRESS_CLAMP_TO_EDGE,
    name: "ParticleSystemTexture"
  });
  const pixels = texture.lock();
  if (format === PIXELFORMAT_RGBA8 || format === PIXELFORMAT_SRGBA8) {
    const temp = new Uint8Array(pixelData.length);
    for (let i = 0; i < pixelData.length; i++) {
      temp[i] = pixelData[i] * mult8Bit * 255;
    }
    pixelData = temp;
  }
  pixels.set(pixelData);
  texture.unlock();
  return texture;
}
function saturate2(x2) {
  return Math.max(Math.min(x2, 1), 0);
}
var default0Curve = new Curve([0, 0, 1, 0]);
var default1Curve = new Curve([0, 1, 1, 1]);
var default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
var default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
var particleTexHeight = 2;
var particleTexChannels2 = 4;
var extentsInnerRatioUniform = new Float32Array(3);
var spawnMatrix = new Mat4();
var tmpVec33 = new Vec3();
var bMin = new Vec3();
var bMax = new Vec3();
var setPropertyTarget;
var setPropertyOptions;
function setProperty(pName, defaultVal) {
  if (setPropertyOptions[pName] !== void 0 && setPropertyOptions[pName] !== null) {
    setPropertyTarget[pName] = setPropertyOptions[pName];
  } else {
    setPropertyTarget[pName] = defaultVal;
  }
}
function pack3NFloats(a, b, c2) {
  const packed = a * 255 << 16 | b * 255 << 8 | c2 * 255;
  return packed / (1 << 24);
}
function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
  const num = qXYZ.length / 3;
  const colors = new Array(num * 4);
  for (let i = 0; i < num; i++) {
    colors[i * 4] = qXYZ[i * 3];
    colors[i * 4 + 1] = qXYZ[i * 3 + 1];
    colors[i * 4 + 2] = qXYZ[i * 3 + 2];
    colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
  }
  return colors;
}
function packTextureRGBA(qRGB, qA) {
  const colors = new Array(qA.length * 4);
  for (let i = 0; i < qA.length; i++) {
    colors[i * 4] = qRGB[i * 3];
    colors[i * 4 + 1] = qRGB[i * 3 + 1];
    colors[i * 4 + 2] = qRGB[i * 3 + 2];
    colors[i * 4 + 3] = qA[i];
  }
  return colors;
}
function packTexture5Floats(qA, qB, qC, qD, qE) {
  const colors = new Array(qA.length * 4);
  for (let i = 0; i < qA.length; i++) {
    colors[i * 4] = qA[i];
    colors[i * 4 + 1] = qB[i];
    colors[i * 4 + 2] = 0;
    colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
  }
  return colors;
}
function packTexture2Floats(qA, qB) {
  const colors = new Array(qA.length * 4);
  for (let i = 0; i < qA.length; i++) {
    colors[i * 4] = qA[i];
    colors[i * 4 + 1] = qB[i];
    colors[i * 4 + 2] = 0;
    colors[i * 4 + 3] = 0;
  }
  return colors;
}
function calcEndTime(emitter) {
  const interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
  return Date.now() + interval * 1e3;
}
function subGraph(A, B) {
  const r = new Float32Array(A.length);
  for (let i = 0; i < A.length; i++) {
    r[i] = A[i] - B[i];
  }
  return r;
}
function maxUnsignedGraphValue(A, outUMax) {
  const chans = outUMax.length;
  const values = A.length / chans;
  for (let i = 0; i < values; i++) {
    for (let j = 0; j < chans; j++) {
      const a = Math.abs(A[i * chans + j]);
      outUMax[j] = Math.max(outUMax[j], a);
    }
  }
}
function normalizeGraph(A, uMax) {
  const chans = uMax.length;
  const values = A.length / chans;
  for (let i = 0; i < values; i++) {
    for (let j = 0; j < chans; j++) {
      A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];
      A[i * chans + j] *= 0.5;
      A[i * chans + j] += 0.5;
    }
  }
}
function divGraphFrom2Curves(curve1, curve2, outUMax) {
  const sub = subGraph(curve2, curve1);
  maxUnsignedGraphValue(sub, outUMax);
  normalizeGraph(sub, outUMax);
  return sub;
}
var particleEmitterDeviceCache = new DeviceCache();
var ParticleEmitter = class {
  constructor(graphicsDevice, options2) {
    this.material = null;
    this.internalTex0 = null;
    this.internalTex1 = null;
    this.internalTex2 = null;
    this.colorParam = null;
    this.graphicsDevice = graphicsDevice;
    const gd = graphicsDevice;
    const precision = 32;
    this.precision = precision;
    this._addTimeTime = 0;
    setPropertyTarget = this;
    setPropertyOptions = options2;
    setProperty("numParticles", 1);
    if (this.numParticles > graphicsDevice.maxTextureSize) {
      this.numParticles = graphicsDevice.maxTextureSize;
    }
    setProperty("rate", 1);
    setProperty("rate2", this.rate);
    setProperty("lifetime", 50);
    setProperty("emitterExtents", new Vec3(0, 0, 0));
    setProperty("emitterExtentsInner", new Vec3(0, 0, 0));
    setProperty("emitterRadius", 0);
    setProperty("emitterRadiusInner", 0);
    setProperty("emitterShape", EMITTERSHAPE_BOX);
    setProperty("initialVelocity", 1);
    setProperty("wrap", false);
    setProperty("localSpace", false);
    setProperty("screenSpace", false);
    setProperty("wrapBounds", null);
    setProperty("colorMap", this.defaultParamTexture);
    setProperty("normalMap", null);
    setProperty("loop", true);
    setProperty("preWarm", false);
    setProperty("sort", PARTICLESORT_NONE);
    setProperty("mode", PARTICLEMODE_GPU);
    setProperty("scene", null);
    setProperty("lighting", false);
    setProperty("halfLambert", false);
    setProperty("intensity", 1);
    setProperty("stretch", 0);
    setProperty("alignToMotion", false);
    setProperty("depthSoftening", 0);
    setProperty("mesh", null);
    setProperty("particleNormal", new Vec3(0, 1, 0));
    setProperty("orientation", PARTICLEORIENTATION_SCREEN);
    setProperty("depthWrite", false);
    setProperty("noFog", false);
    setProperty("blendType", BLEND_NORMAL);
    setProperty("node", null);
    setProperty("startAngle", 0);
    setProperty("startAngle2", this.startAngle);
    setProperty("animTilesX", 1);
    setProperty("animTilesY", 1);
    setProperty("animStartFrame", 0);
    setProperty("animNumFrames", 1);
    setProperty("animNumAnimations", 1);
    setProperty("animIndex", 0);
    setProperty("randomizeAnimIndex", false);
    setProperty("animSpeed", 1);
    setProperty("animLoop", true);
    this._gpuUpdater = new ParticleGPUUpdater(this, gd);
    this._cpuUpdater = new ParticleCPUUpdater(this);
    this.emitterPosUniform = new Float32Array(3);
    this.wrapBoundsUniform = new Float32Array(3);
    this.emitterScaleUniform = new Float32Array([1, 1, 1]);
    setProperty("colorGraph", default1Curve3);
    setProperty("colorGraph2", this.colorGraph);
    setProperty("scaleGraph", default1Curve);
    setProperty("scaleGraph2", this.scaleGraph);
    setProperty("alphaGraph", default1Curve);
    setProperty("alphaGraph2", this.alphaGraph);
    setProperty("localVelocityGraph", default0Curve3);
    setProperty("localVelocityGraph2", this.localVelocityGraph);
    setProperty("velocityGraph", default0Curve3);
    setProperty("velocityGraph2", this.velocityGraph);
    setProperty("rotationSpeedGraph", default0Curve);
    setProperty("rotationSpeedGraph2", this.rotationSpeedGraph);
    setProperty("radialSpeedGraph", default0Curve);
    setProperty("radialSpeedGraph2", this.radialSpeedGraph);
    this.animTilesParams = new Float32Array(2);
    this.animParams = new Float32Array(4);
    this.animIndexParams = new Float32Array(2);
    this.vbToSort = null;
    this.vbOld = null;
    this.particleDistance = null;
    this.camera = null;
    this.swapTex = false;
    this.useMesh = true;
    this.useCpu = !graphicsDevice.supportsGpuParticles;
    this.pack8 = true;
    this.localBounds = new BoundingBox();
    this.worldBoundsNoTrail = new BoundingBox();
    this.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];
    this.worldBounds = new BoundingBox();
    this.worldBoundsSize = new Vec3();
    this.prevWorldBoundsSize = new Vec3();
    this.prevWorldBoundsCenter = new Vec3();
    this.prevEmitterExtents = this.emitterExtents;
    this.prevEmitterRadius = this.emitterRadius;
    this.worldBoundsMul = new Vec3();
    this.worldBoundsAdd = new Vec3();
    this.timeToSwitchBounds = 0;
    this.shaderParticleUpdateRespawn = null;
    this.shaderParticleUpdateNoRespawn = null;
    this.shaderParticleUpdateOnStop = null;
    this.numParticleVerts = 0;
    this.numParticleIndices = 0;
    this.material = null;
    this.meshInstance = null;
    this.drawOrder = 0;
    this.seed = Math.random();
    this.fixedTimeStep = 1 / 60;
    this.maxSubSteps = 10;
    this.simTime = 0;
    this.simTimeTotal = 0;
    this.beenReset = false;
    this._layer = null;
    this.rebuild();
  }
  get defaultParamTexture() {
    return particleEmitterDeviceCache.get(this.graphicsDevice, () => {
      const resolution = 16;
      const centerPoint = resolution * 0.5 + 0.5;
      const dtex = new Float32Array(resolution * resolution * 4);
      for (let y2 = 0; y2 < resolution; y2++) {
        for (let x2 = 0; x2 < resolution; x2++) {
          const xgrad = x2 + 1 - centerPoint;
          const ygrad = y2 + 1 - centerPoint;
          const c2 = saturate2(1 - saturate2(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
          const p = y2 * resolution + x2;
          dtex[p * 4] = 1;
          dtex[p * 4 + 1] = 1;
          dtex[p * 4 + 2] = 1;
          dtex[p * 4 + 3] = c2;
        }
      }
      const texture = _createTexture(this.graphicsDevice, resolution, resolution, dtex, PIXELFORMAT_SRGBA8, 1, true);
      texture.minFilter = FILTER_LINEAR;
      texture.magFilter = FILTER_LINEAR;
      return texture;
    });
  }
  onChangeCamera() {
    this.resetMaterial();
  }
  calculateBoundsMad() {
    this.worldBoundsMul.x = 1 / this.worldBoundsSize.x;
    this.worldBoundsMul.y = 1 / this.worldBoundsSize.y;
    this.worldBoundsMul.z = 1 / this.worldBoundsSize.z;
    this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);
    this.worldBoundsAdd.x += 0.5;
    this.worldBoundsAdd.y += 0.5;
    this.worldBoundsAdd.z += 0.5;
  }
  calculateWorldBounds() {
    if (!this.node) return;
    this.prevWorldBoundsSize.copy(this.worldBoundsSize);
    this.prevWorldBoundsCenter.copy(this.worldBounds.center);
    if (!this.useCpu) {
      let recalculateLocalBounds = false;
      if (this.emitterShape === EMITTERSHAPE_BOX) {
        recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
      } else {
        recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
      }
      if (recalculateLocalBounds) {
        this.calculateLocalBounds();
      }
    }
    const nodeWT = this.node.getWorldTransform();
    if (this.localSpace) {
      this.worldBoundsNoTrail.copy(this.localBounds);
    } else {
      this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
    }
    this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
    this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
    const now2 = this.simTimeTotal;
    if (now2 >= this.timeToSwitchBounds) {
      this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
      this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
      this.timeToSwitchBounds = now2 + this.lifetime;
    }
    this.worldBounds.copy(this.worldBoundsTrail[0]);
    this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
    if (this.localSpace) {
      this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
      this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
    } else {
      this.meshInstance.aabb.copy(this.worldBounds);
      this.meshInstance.mesh.aabb.copy(this.worldBounds);
    }
    this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
    if (this.pack8) this.calculateBoundsMad();
  }
  resetWorldBounds() {
    if (!this.node) return;
    this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
    this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
    this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
    this.worldBounds.copy(this.worldBoundsTrail[0]);
    this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
    this.prevWorldBoundsSize.copy(this.worldBoundsSize);
    this.prevWorldBoundsCenter.copy(this.worldBounds.center);
    this.simTimeTotal = 0;
    this.timeToSwitchBounds = 0;
  }
  calculateLocalBounds() {
    let minx = Number.MAX_VALUE;
    let miny = Number.MAX_VALUE;
    let minz = Number.MAX_VALUE;
    let maxx = -Number.MAX_VALUE;
    let maxy = -Number.MAX_VALUE;
    let maxz = -Number.MAX_VALUE;
    let maxR = 0;
    let maxScale = 0;
    const stepWeight = this.lifetime / this.precision;
    const wVels = [this.qVelocity, this.qVelocity2];
    const lVels = [this.qLocalVelocity, this.qLocalVelocity2];
    const accumX = [0, 0];
    const accumY = [0, 0];
    const accumZ = [0, 0];
    const accumR = [0, 0];
    const accumW = [0, 0];
    let x2, y2, z2;
    for (let i = 0; i < this.precision + 1; i++) {
      const index = Math.min(i, this.precision - 1);
      for (let j = 0; j < 2; j++) {
        x2 = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
        y2 = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
        z2 = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
        minx = Math.min(x2, minx);
        miny = Math.min(y2, miny);
        minz = Math.min(z2, minz);
        maxx = Math.max(x2, maxx);
        maxy = Math.max(y2, maxy);
        maxz = Math.max(z2, maxz);
        accumX[j] = x2;
        accumY[j] = y2;
        accumZ[j] = z2;
      }
      for (let j = 0; j < 2; j++) {
        accumW[j] += stepWeight * Math.sqrt(wVels[j][index * 3 + 0] * wVels[j][index * 3 + 0] + wVels[j][index * 3 + 1] * wVels[j][index * 3 + 1] + wVels[j][index * 3 + 2] * wVels[j][index * 3 + 2]);
      }
      accumR[0] += this.qRadialSpeed[index] * stepWeight;
      accumR[1] += this.qRadialSpeed2[index] * stepWeight;
      maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
      maxScale = Math.max(maxScale, this.qScale[index]);
    }
    if (this.emitterShape === EMITTERSHAPE_BOX) {
      x2 = this.emitterExtents.x * 0.5;
      y2 = this.emitterExtents.y * 0.5;
      z2 = this.emitterExtents.z * 0.5;
    } else {
      x2 = this.emitterRadius;
      y2 = this.emitterRadius;
      z2 = this.emitterRadius;
    }
    const w = Math.max(accumW[0], accumW[1]);
    bMin.x = minx - maxScale - x2 - maxR - w;
    bMin.y = miny - maxScale - y2 - maxR - w;
    bMin.z = minz - maxScale - z2 - maxR - w;
    bMax.x = maxx + maxScale + x2 + maxR + w;
    bMax.y = maxy + maxScale + y2 + maxR + w;
    bMax.z = maxz + maxScale + z2 + maxR + w;
    this.localBounds.setMinMax(bMin, bMax);
  }
  rebuild() {
    const gd = this.graphicsDevice;
    if (this.colorMap === null) this.colorMap = this.defaultParamTexture;
    this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
    this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles;
    this._destroyResources();
    this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
    particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
    this.useMesh = !!this.mesh;
    this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
    this.rebuildGraphs();
    this.calculateLocalBounds();
    this.resetWorldBounds();
    if (this.node) {
      this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
      this.worldBoundsTrail[0].copy(this.worldBounds);
      this.worldBoundsTrail[1].copy(this.worldBounds);
      this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
      this.prevWorldBoundsSize.copy(this.worldBoundsSize);
      this.prevWorldBoundsCenter.copy(this.worldBounds.center);
      if (this.pack8) this.calculateBoundsMad();
    }
    this.vbToSort = new Array(this.numParticles);
    for (let iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];
    this.particleDistance = new Float32Array(this.numParticles);
    this._gpuUpdater.randomize();
    this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels2);
    const emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();
    if (this.emitterShape === EMITTERSHAPE_BOX) {
      if (this.node === null || this.localSpace) {
        spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
      } else {
        spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec33.copy(this.spawnBounds).mul(this.node.localScale));
      }
      extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
      extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
      extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
    }
    for (let i = 0; i < this.numParticles; i++) {
      this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);
      if (this.useCpu) this.particleTex[i * particleTexChannels2 + 3 + this.numParticlesPot * 2 * particleTexChannels2] = 1;
    }
    this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels2);
    for (let i = 0; i < this.particleTexStart.length; i++) {
      this.particleTexStart[i] = this.particleTex[i];
    }
    if (!this.useCpu) {
      if (this.pack8) {
        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_RGBA8, 1, false);
      } else {
        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
      }
      this.rtParticleTexIN = new RenderTarget({
        colorBuffer: this.particleTexIN,
        depth: false
      });
      this.rtParticleTexOUT = new RenderTarget({
        colorBuffer: this.particleTexOUT,
        depth: false
      });
      this.swapTex = false;
    }
    const shaderCodeStart = (this.localSpace ? "#define LOCAL_SPACE\n" : "") + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;
    const shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;
    const shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;
    const shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;
    const params = `Shape:${this.emitterShape}-Pack:${this.pack8}-Local:${this.localSpace}`;
    this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, `ParticleUpdateRespawn-${params}`);
    this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, `ParticleUpdateNoRespawn-${params}`);
    this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, `ParticleUpdateStop-${params}`);
    this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
    this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
    this._allocate(this.numParticles);
    const mesh = new Mesh(gd);
    mesh.vertexBuffer = this.vertexBuffer;
    mesh.indexBuffer[0] = this.indexBuffer;
    mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
    mesh.primitive[0].indexed = true;
    this.material = this._createMaterial();
    this.resetMaterial();
    const wasVisible = this.meshInstance ? this.meshInstance.visible : true;
    this.meshInstance = new MeshInstance(mesh, this.material, this.node);
    this.meshInstance.pick = false;
    this.meshInstance.updateKey();
    this.meshInstance.cull = true;
    if (this.localSpace) {
      this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
    } else {
      this.meshInstance.aabb.copy(this.worldBounds);
    }
    this.meshInstance._updateAabb = false;
    this.meshInstance.visible = wasVisible;
    this._setMaterialTextures();
    this.resetTime();
    this.addTime(0, false);
    if (this.preWarm) this.prewarm(this.lifetime);
  }
  _isAnimated() {
    return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);
  }
  rebuildGraphs() {
    const precision = this.precision;
    const gd = this.graphicsDevice;
    this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
    this.qVelocity = this.velocityGraph.quantize(precision);
    this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);
    this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
    this.qScale = this.scaleGraph.quantize(precision);
    this.qAlpha = this.alphaGraph.quantize(precision);
    this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);
    this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
    this.qVelocity2 = this.velocityGraph2.quantize(precision);
    this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);
    this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
    this.qScale2 = this.scaleGraph2.quantize(precision);
    this.qAlpha2 = this.alphaGraph2.quantize(precision);
    this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);
    for (let i = 0; i < precision; i++) {
      this.qRotSpeed[i] *= math.DEG_TO_RAD;
      this.qRotSpeed2[i] *= math.DEG_TO_RAD;
    }
    this.localVelocityUMax = new Float32Array(3);
    this.velocityUMax = new Float32Array(3);
    this.colorUMax = new Float32Array(3);
    this.rotSpeedUMax = [0];
    this.scaleUMax = [0];
    this.alphaUMax = [0];
    this.radialSpeedUMax = [0];
    this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
    this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
    this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
    this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
    this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
    this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
    this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);
    if (this.pack8) {
      const umax = [0, 0, 0];
      maxUnsignedGraphValue(this.qVelocity, umax);
      const umax2 = [0, 0, 0];
      maxUnsignedGraphValue(this.qVelocity2, umax2);
      const lumax = [0, 0, 0];
      maxUnsignedGraphValue(this.qLocalVelocity, lumax);
      const lumax2 = [0, 0, 0];
      maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
      const rumax = [0];
      maxUnsignedGraphValue(this.qRadialSpeed, rumax);
      const rumax2 = [0];
      maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
      let maxVel = Math.max(umax[0], umax2[0]);
      maxVel = Math.max(maxVel, umax[1]);
      maxVel = Math.max(maxVel, umax2[1]);
      maxVel = Math.max(maxVel, umax[2]);
      maxVel = Math.max(maxVel, umax2[2]);
      let lmaxVel = Math.max(lumax[0], lumax2[0]);
      lmaxVel = Math.max(lmaxVel, lumax[1]);
      lmaxVel = Math.max(lmaxVel, lumax2[1]);
      lmaxVel = Math.max(lmaxVel, lumax[2]);
      lmaxVel = Math.max(lmaxVel, lumax2[2]);
      const maxRad = Math.max(rumax[0], rumax2[0]);
      this.maxVel = maxVel + lmaxVel + maxRad;
    }
    if (!this.useCpu) {
      this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
      this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
      this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
      this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
    }
    this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_SRGBA8, 1, true);
  }
  _setMaterialTextures() {
    if (this.colorMap) {
      this.material.setParameter("colorMap", this.colorMap);
      if (this.lighting && this.normalMap) {
        this.material.setParameter("normalMap", this.normalMap);
      }
    }
  }
  _createMaterial() {
    const material = new ParticleMaterial(this);
    material.name = `EmitterMaterial:${this.node.name}`;
    material.cull = CULLFACE_NONE;
    material.alphaWrite = false;
    material.blendType = this.blendType;
    material.depthWrite = this.depthWrite;
    return material;
  }
  resetMaterial() {
    const material = this.material;
    material.setParameter("stretch", this.stretch);
    if (this._isAnimated()) {
      material.setParameter("animTexTilesParams", this.animTilesParams);
      material.setParameter("animTexParams", this.animParams);
      material.setParameter("animTexIndexParams", this.animIndexParams);
    }
    material.setParameter("colorMult", this.intensity);
    if (!this.useCpu) {
      material.setParameter("internalTex0", this.internalTex0);
      material.setParameter("internalTex1", this.internalTex1);
      material.setParameter("internalTex2", this.internalTex2);
      material.setParameter("internalTex3", this.internalTex3);
    }
    material.setParameter("colorParam", this.colorParam);
    material.setParameter("numParticles", this.numParticles);
    material.setParameter("numParticlesPot", this.numParticlesPot);
    material.setParameter("lifetime", this.lifetime);
    material.setParameter("rate", this.rate);
    material.setParameter("rateDiv", this.rate2 - this.rate);
    material.setParameter("seed", this.seed);
    material.setParameter("scaleDivMult", this.scaleUMax[0]);
    material.setParameter("alphaDivMult", this.alphaUMax[0]);
    material.setParameter("radialSpeedDivMult", this.radialSpeedUMax[0]);
    material.setParameter("graphNumSamples", this.precision);
    material.setParameter("graphSampleSize", 1 / this.precision);
    material.setParameter("emitterScale", new Float32Array([1, 1, 1]));
    if (this.pack8) {
      this._gpuUpdater._setInputBounds();
      material.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform);
      material.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform);
      material.setParameter("maxVel", this.maxVel);
    }
    if (this.wrap && this.wrapBounds) {
      this.wrapBoundsUniform[0] = this.wrapBounds.x;
      this.wrapBoundsUniform[1] = this.wrapBounds.y;
      this.wrapBoundsUniform[2] = this.wrapBounds.z;
      material.setParameter("wrapBounds", this.wrapBoundsUniform);
    }
    this._setMaterialTextures();
    if (this.depthSoftening > 0) {
      material.setParameter("softening", 1 / (this.depthSoftening * this.depthSoftening * 100));
    }
    if (this.stretch > 0) material.cull = CULLFACE_NONE;
    this._compParticleFaceParams();
  }
  _compParticleFaceParams() {
    let tangent, binormal;
    if (this.orientation === PARTICLEORIENTATION_SCREEN) {
      tangent = new Float32Array([1, 0, 0]);
      binormal = new Float32Array([0, 0, 1]);
    } else {
      let n;
      if (this.orientation === PARTICLEORIENTATION_WORLD) {
        n = this.particleNormal.normalize();
      } else {
        const emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();
        n = emitterMat.transformVector(this.particleNormal).normalize();
      }
      const t = new Vec3(1, 0, 0);
      if (Math.abs(t.dot(n)) === 1) {
        t.set(0, 0, 1);
      }
      const b = new Vec3().cross(n, t).normalize();
      t.cross(b, n).normalize();
      tangent = new Float32Array([t.x, t.y, t.z]);
      binormal = new Float32Array([b.x, b.y, b.z]);
    }
    this.material.setParameter("faceTangent", tangent);
    this.material.setParameter("faceBinorm", binormal);
  }
  _allocate(numParticles) {
    const psysVertCount = numParticles * this.numParticleVerts;
    const psysIndexCount = numParticles * this.numParticleIndices;
    if (this.vertexBuffer === void 0 || this.vertexBuffer.getNumVertices() !== psysVertCount) {
      const elements = [];
      if (!this.useCpu) {
        elements.push({
          semantic: SEMANTIC_ATTR0,
          components: 4,
          type: TYPE_FLOAT32
        });
        if (this.useMesh) {
          elements.push({
            semantic: SEMANTIC_ATTR1,
            components: 2,
            type: TYPE_FLOAT32
          });
        }
      } else {
        elements.push({
          semantic: SEMANTIC_ATTR0,
          components: 4,
          type: TYPE_FLOAT32
        }, {
          semantic: SEMANTIC_ATTR1,
          components: 4,
          type: TYPE_FLOAT32
        }, {
          semantic: SEMANTIC_ATTR2,
          components: 4,
          type: TYPE_FLOAT32
        }, {
          semantic: SEMANTIC_ATTR3,
          components: 1,
          type: TYPE_FLOAT32
        }, {
          semantic: SEMANTIC_ATTR4,
          components: this.useMesh ? 4 : 2,
          type: TYPE_FLOAT32
        });
      }
      const vertexFormat = new VertexFormat(this.graphicsDevice, elements);
      this.vertexBuffer = new VertexBuffer(this.graphicsDevice, vertexFormat, psysVertCount, {
        usage: BUFFER_DYNAMIC
      });
      this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT32, psysIndexCount);
      const data2 = new Float32Array(this.vertexBuffer.lock());
      let meshData, stride, texCoordOffset;
      if (this.useMesh) {
        meshData = new Float32Array(this.mesh.vertexBuffer.lock());
        stride = meshData.length / this.mesh.vertexBuffer.numVertices;
        for (let elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {
          if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
            texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
            break;
          }
        }
      }
      for (let i = 0; i < psysVertCount; i++) {
        const id13 = Math.floor(i / this.numParticleVerts);
        if (!this.useMesh) {
          const vertID = i % 4;
          data2[i * 4] = particleVerts[vertID][0];
          data2[i * 4 + 1] = particleVerts[vertID][1];
          data2[i * 4 + 2] = 0;
          data2[i * 4 + 3] = id13;
        } else {
          const vert = i % this.numParticleVerts;
          data2[i * 6] = meshData[vert * stride];
          data2[i * 6 + 1] = meshData[vert * stride + 1];
          data2[i * 6 + 2] = meshData[vert * stride + 2];
          data2[i * 6 + 3] = id13;
          data2[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
          data2[i * 6 + 5] = 1 - meshData[vert * stride + texCoordOffset + 1];
        }
      }
      if (this.useCpu) {
        this.vbCPU = new Float32Array(data2);
        this.vbOld = new Float32Array(this.vbCPU.length);
      }
      this.vertexBuffer.unlock();
      if (this.useMesh) {
        this.mesh.vertexBuffer.unlock();
      }
      let dst = 0;
      const indices = new Uint32Array(this.indexBuffer.lock());
      if (this.useMesh) {
        const ib = this.mesh.indexBuffer[0];
        meshData = new typedArrayIndexFormats[ib.format](ib.lock());
      }
      for (let i = 0; i < numParticles; i++) {
        if (!this.useMesh) {
          const baseIndex = i * 4;
          indices[dst++] = baseIndex;
          indices[dst++] = baseIndex + 1;
          indices[dst++] = baseIndex + 2;
          indices[dst++] = baseIndex;
          indices[dst++] = baseIndex + 2;
          indices[dst++] = baseIndex + 3;
        } else {
          for (let j = 0; j < this.numParticleIndices; j++) {
            indices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;
          }
        }
      }
      this.indexBuffer.unlock();
      if (this.useMesh) this.mesh.indexBuffer[0].unlock();
    }
  }
  reset() {
    this.beenReset = true;
    this.seed = Math.random();
    this.material.setParameter("seed", this.seed);
    if (this.useCpu) {
      for (let i = 0; i < this.particleTexStart.length; i++) {
        this.particleTex[i] = this.particleTexStart[i];
      }
    } else {
      this._setMaterialTextures();
    }
    this.resetWorldBounds();
    this.resetTime();
    const origLoop = this.loop;
    this.loop = true;
    this.addTime(0, false);
    this.loop = origLoop;
    if (this.preWarm) {
      this.prewarm(this.lifetime);
    }
  }
  prewarm(time) {
    const lifetimeFraction = time / this.lifetime;
    const iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
    const stepDelta = time / iterations;
    for (let i = 0; i < iterations; i++) {
      this.addTime(stepDelta, false);
    }
  }
  resetTime() {
    this.endTime = calcEndTime(this);
  }
  finishFrame() {
    if (this.useCpu) this.vertexBuffer.unlock();
  }
  addTime(delta, isOnStop) {
    const device = this.graphicsDevice;
    this.simTimeTotal += delta;
    this.calculateWorldBounds();
    if (this._isAnimated()) {
      const tilesParams = this.animTilesParams;
      tilesParams[0] = 1 / this.animTilesX;
      tilesParams[1] = 1 / this.animTilesY;
      const params = this.animParams;
      params[0] = this.animStartFrame;
      params[1] = this.animNumFrames * this.animSpeed;
      params[2] = this.animNumFrames - 1;
      params[3] = this.animNumAnimations - 1;
      const animIndexParams = this.animIndexParams;
      animIndexParams[0] = this.animIndex;
      animIndexParams[1] = this.randomizeAnimIndex;
    }
    if (this.scene) {
      if (this.camera !== this.scene._activeCamera) {
        this.camera = this.scene._activeCamera;
        this.onChangeCamera();
      }
    }
    if (this.emitterShape === EMITTERSHAPE_BOX) {
      extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
      extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
      extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
      if (this.meshInstance.node === null) {
        spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
      } else {
        spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec33.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
      }
    }
    let emitterPos;
    const emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
    this.emitterScaleUniform[0] = emitterScale.x;
    this.emitterScaleUniform[1] = emitterScale.y;
    this.emitterScaleUniform[2] = emitterScale.z;
    this.material.setParameter("emitterScale", this.emitterScaleUniform);
    if (this.localSpace && this.meshInstance.node) {
      emitterPos = this.meshInstance.node.getPosition();
      this.emitterPosUniform[0] = emitterPos.x;
      this.emitterPosUniform[1] = emitterPos.y;
      this.emitterPosUniform[2] = emitterPos.z;
      this.material.setParameter("emitterPos", this.emitterPosUniform);
    }
    this._compParticleFaceParams();
    if (!this.useCpu) {
      this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
    } else {
      const data2 = new Float32Array(this.vertexBuffer.lock());
      this._cpuUpdater.update(data2, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
    }
    if (!this.loop) {
      if (Date.now() > this.endTime) {
        if (this.onFinished) this.onFinished();
        this.meshInstance.visible = false;
      }
    }
    if (this.meshInstance) {
      this.meshInstance.drawOrder = this.drawOrder;
    }
  }
  _destroyResources() {
    var _this$particleTexIN, _this$particleTexOUT, _this$rtParticleTexIN, _this$rtParticleTexOU, _this$internalTex, _this$internalTex2, _this$internalTex3, _this$internalTex4, _this$colorParam, _this$vertexBuffer, _this$indexBuffer, _this$material;
    (_this$particleTexIN = this.particleTexIN) == null || _this$particleTexIN.destroy();
    this.particleTexIN = null;
    (_this$particleTexOUT = this.particleTexOUT) == null || _this$particleTexOUT.destroy();
    this.particleTexOUT = null;
    if (this.particleTexStart && this.particleTexStart.destroy) {
      this.particleTexStart.destroy();
      this.particleTexStart = null;
    }
    (_this$rtParticleTexIN = this.rtParticleTexIN) == null || _this$rtParticleTexIN.destroy();
    this.rtParticleTexIN = null;
    (_this$rtParticleTexOU = this.rtParticleTexOUT) == null || _this$rtParticleTexOU.destroy();
    this.rtParticleTexOUT = null;
    (_this$internalTex = this.internalTex0) == null || _this$internalTex.destroy();
    this.internalTex0 = null;
    (_this$internalTex2 = this.internalTex1) == null || _this$internalTex2.destroy();
    this.internalTex1 = null;
    (_this$internalTex3 = this.internalTex2) == null || _this$internalTex3.destroy();
    this.internalTex2 = null;
    (_this$internalTex4 = this.internalTex3) == null || _this$internalTex4.destroy();
    this.internalTex3 = null;
    (_this$colorParam = this.colorParam) == null || _this$colorParam.destroy();
    this.colorParam = null;
    (_this$vertexBuffer = this.vertexBuffer) == null || _this$vertexBuffer.destroy();
    this.vertexBuffer = void 0;
    (_this$indexBuffer = this.indexBuffer) == null || _this$indexBuffer.destroy();
    this.indexBuffer = void 0;
    (_this$material = this.material) == null || _this$material.destroy();
    this.material = null;
  }
  destroy() {
    this.camera = null;
    this._destroyResources();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/shader-generator-shader.js
var vShader = `
		#include "shaderPassDefines"
		#include "userCode"
`;
var fShader = `
		#include "shaderPassDefines"
		#include "decodePS"
		#include "gamma"
		#include "tonemapping"
		#include "fog"
		#include "userCode"
`;
var ShaderGeneratorShader = class extends ShaderGenerator {
  generateKey(options2) {
    const desc = options2.shaderDesc;
    const vsHash = desc.vertexCode ? hashCode(desc.vertexCode) : 0;
    const fsHash = desc.fragmentCode ? hashCode(desc.fragmentCode) : 0;
    const definesHash = ShaderGenerator.definesHash(options2.defines);
    let key = `${desc.uniqueName}_${vsHash}_${fsHash}_${definesHash}`;
    key += `_${options2.pass}`;
    key += `_${options2.gamma}`;
    key += `_${options2.toneMapping}`;
    key += `_${options2.fog}`;
    if (options2.skin) key += "_skin";
    if (options2.useInstancing) key += "_inst";
    if (options2.useMorphPosition) key += "_morphp";
    if (options2.useMorphNormal) key += "_morphn";
    if (options2.useMorphTextureBasedInt) key += "_morphi";
    return key;
  }
  createAttributesDefinition(definitionOptions, options2) {
    const srcAttributes = options2.shaderDesc.attributes;
    const attributes = srcAttributes ? _extends({}, srcAttributes) : void 0;
    if (options2.skin) {
      attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
      attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
    }
    if (options2.useMorphPosition || options2.useMorphNormal) {
      attributes.morph_vertex_id = SEMANTIC_ATTR15;
    }
    definitionOptions.attributes = attributes;
  }
  createVertexDefinition(definitionOptions, options2, shaderPassInfo) {
    const desc = options2.shaderDesc;
    if (definitionOptions.shaderLanguage === SHADERLANGUAGE_WGSL) {
      definitionOptions.vertexCode = desc.vertexCode;
    } else {
      const includes = /* @__PURE__ */ new Map();
      const defines = new Map(options2.defines);
      includes.set("shaderPassDefines", shaderPassInfo.shaderDefines);
      includes.set("userCode", desc.vertexCode);
      includes.set("transformCore", shaderChunks.transformCoreVS);
      includes.set("transformInstancing", "");
      includes.set("normalCore", shaderChunks.normalCoreVS);
      includes.set("skinCode", shaderChunks.skinTexVS);
      includes.set("skinTexVS", shaderChunks.skinTexVS);
      if (options2.skin) defines.set("SKIN", true);
      if (options2.useInstancing) defines.set("INSTANCING", true);
      if (options2.useMorphPosition || options2.useMorphNormal) {
        defines.set("MORPHING", true);
        if (options2.useMorphTextureBasedInt) defines.set("MORPHING_INT", true);
        if (options2.useMorphPosition) defines.set("MORPHING_POSITION", true);
        if (options2.useMorphNormal) defines.set("MORPHING_NORMAL", true);
      }
      definitionOptions.vertexCode = vShader;
      definitionOptions.vertexIncludes = includes;
      definitionOptions.vertexDefines = defines;
    }
  }
  createFragmentDefinition(definitionOptions, options2, shaderPassInfo) {
    const desc = options2.shaderDesc;
    if (definitionOptions.shaderLanguage === SHADERLANGUAGE_WGSL) {
      definitionOptions.fragmentCode = desc.fragmentCode;
    } else {
      const includes = /* @__PURE__ */ new Map();
      const defines = new Map(options2.defines);
      includes.set("shaderPassDefines", shaderPassInfo.shaderDefines);
      includes.set("decodePS", shaderChunks.decodePS);
      includes.set("gamma", ShaderGenerator.gammaCode(options2.gamma));
      includes.set("tonemapping", ShaderGenerator.tonemapCode(options2.toneMapping));
      includes.set("fog", ShaderGenerator.fogCode(options2.fog));
      includes.set("userCode", desc.fragmentCode);
      includes.set("pick", shaderChunks.pickPS);
      definitionOptions.fragmentCode = fShader;
      definitionOptions.fragmentIncludes = includes;
      definitionOptions.fragmentDefines = defines;
    }
  }
  createShaderDefinition(device, options2) {
    const shaderPassInfo = ShaderPass.get(device).getByIndex(options2.pass);
    const desc = options2.shaderDesc;
    const definitionOptions = {
      name: `ShaderMaterial-${desc.uniqueName}`,
      shaderLanguage: desc.shaderLanguage,
      fragmentOutputTypes: desc.fragmentOutputTypes,
      meshUniformBufferFormat: desc.meshUniformBufferFormat,
      meshBindGroupFormat: desc.meshBindGroupFormat
    };
    this.createAttributesDefinition(definitionOptions, options2);
    this.createVertexDefinition(definitionOptions, options2, shaderPassInfo);
    this.createFragmentDefinition(definitionOptions, options2, shaderPassInfo);
    return ShaderUtils.createDefinition(device, definitionOptions);
  }
};
var shaderGeneratorShader = new ShaderGeneratorShader();

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/shader-material.js
var ShaderMaterial = class extends Material {
  constructor(shaderDesc2) {
    super();
    this._shaderDesc = void 0;
    this.shaderDesc = shaderDesc2;
  }
  set shaderDesc(value) {
    this._shaderDesc = value ? _extends({}, value) : void 0;
    this.clearVariants();
  }
  get shaderDesc() {
    return this._shaderDesc;
  }
  copy(source) {
    super.copy(source);
    this.shaderDesc = source.shaderDesc;
    return this;
  }
  getShaderVariant(params) {
    const objDefs = params.objDefs;
    const options2 = {
      defines: this.defines,
      skin: (objDefs & SHADERDEF_SKIN) !== 0,
      useInstancing: (objDefs & SHADERDEF_INSTANCING) !== 0,
      useMorphPosition: (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
      useMorphNormal: (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
      useMorphTextureBasedInt: (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0,
      pass: params.pass,
      gamma: params.renderParams.shaderOutputGamma,
      toneMapping: params.renderParams.toneMapping,
      fog: params.scene.fog,
      shaderDesc: this.shaderDesc
    };
    const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
    const library = getProgramLibrary(params.device);
    library.register("shader-material", shaderGeneratorShader);
    return library.getProgram("shader-material", options2, processingOptions, this.userId);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunk-utils.js
var decodeTable = {
  "linear": "decodeLinear",
  "srgb": "decodeGamma",
  "rgbm": "decodeRGBM",
  "rgbe": "decodeRGBE",
  "rgbp": "decodeRGBP"
};
var encodeTable = {
  "linear": "encodeLinear",
  "srgb": "encodeGamma",
  "rgbm": "encodeRGBM",
  "rgbe": "encodeRGBE",
  "rgbp": "encodeRGBP"
};
var ChunkUtils = class {
  static decodeFunc(encoding) {
    return decodeTable[encoding] || "decodeGamma";
  }
  static encodeFunc(encoding) {
    return encodeTable[encoding] || "encodeGamma";
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/skybox.js
var fShader2 = `
		#include "decodePS"
		#include "gamma"
		#include "tonemapping"
		#include "envMultiplyPS"

		#ifdef SKY_CUBEMAP
				#include "skyboxHDRPS"
		#else
				#include "sphericalPS"
				#include "envAtlasPS"
				#include "skyboxEnvPS"
		#endif
`;
var ShaderGeneratorSkybox = class extends ShaderGenerator {
  generateKey(options2) {
    const sharedKey = `skybox-${options2.type}-${options2.encoding}-${options2.gamma}-${options2.toneMapping}-${options2.skymesh}`;
    return sharedKey + (options2.type === "cubemap" ? `-${options2.mip}` : "");
  }
  createShaderDefinition(device, options2) {
    const defines = /* @__PURE__ */ new Map();
    defines.set("SKYBOX_DECODE_FNC", ChunkUtils.decodeFunc(options2.encoding));
    if (options2.skymesh !== SKYTYPE_INFINITE) defines.set("SKYMESH", "");
    if (options2.type === "cubemap") {
      defines.set("SKY_CUBEMAP", "");
    }
    const includes = /* @__PURE__ */ new Map();
    includes.set("decodePS", shaderChunks.decodePS);
    includes.set("gamma", ShaderGenerator.gammaCode(options2.gamma));
    includes.set("tonemapping", ShaderGenerator.tonemapCode(options2.toneMapping));
    includes.set("envMultiplyPS", shaderChunks.envMultiplyPS);
    if (options2.type === "cubemap") {
      includes.set("skyboxHDRPS", shaderChunks.skyboxHDRPS);
    } else {
      includes.set("sphericalPS", shaderChunks.sphericalPS);
      includes.set("envAtlasPS", shaderChunks.envAtlasPS);
      includes.set("skyboxEnvPS", shaderChunks.skyboxEnvPS);
    }
    return ShaderUtils.createDefinition(device, {
      name: "SkyboxShader",
      attributes: {
        aPosition: SEMANTIC_POSITION
      },
      vertexCode: shaderChunks.skyboxVS,
      vertexDefines: defines,
      fragmentCode: fShader2,
      fragmentDefines: defines,
      fragmentIncludes: includes
    });
  }
};
var skybox = new ShaderGeneratorSkybox();

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/geometry-utils.js
var calculateNormals = (positions, indices) => {
  const triangleCount = indices.length / 3;
  const vertexCount = positions.length / 3;
  const p12 = new Vec3();
  const p22 = new Vec3();
  const p3 = new Vec3();
  const p1p2 = new Vec3();
  const p1p3 = new Vec3();
  const faceNormal = new Vec3();
  const normals = [];
  for (let i = 0; i < positions.length; i++) {
    normals[i] = 0;
  }
  for (let i = 0; i < triangleCount; i++) {
    const i1 = indices[i * 3];
    const i2 = indices[i * 3 + 1];
    const i3 = indices[i * 3 + 2];
    p12.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
    p22.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
    p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
    p1p2.sub2(p22, p12);
    p1p3.sub2(p3, p12);
    faceNormal.cross(p1p2, p1p3).normalize();
    normals[i1 * 3] += faceNormal.x;
    normals[i1 * 3 + 1] += faceNormal.y;
    normals[i1 * 3 + 2] += faceNormal.z;
    normals[i2 * 3] += faceNormal.x;
    normals[i2 * 3 + 1] += faceNormal.y;
    normals[i2 * 3 + 2] += faceNormal.z;
    normals[i3 * 3] += faceNormal.x;
    normals[i3 * 3 + 1] += faceNormal.y;
    normals[i3 * 3 + 2] += faceNormal.z;
  }
  for (let i = 0; i < vertexCount; i++) {
    const nx = normals[i * 3];
    const ny = normals[i * 3 + 1];
    const nz = normals[i * 3 + 2];
    const invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
    normals[i * 3] *= invLen;
    normals[i * 3 + 1] *= invLen;
    normals[i * 3 + 2] *= invLen;
  }
  return normals;
};
var calculateTangents = (positions, normals, uvs, indices) => {
  const triangleCount = indices.length / 3;
  const vertexCount = positions.length / 3;
  const v1 = new Vec3();
  const v22 = new Vec3();
  const v32 = new Vec3();
  const w1 = new Vec2();
  const w2 = new Vec2();
  const w3 = new Vec2();
  const sdir = new Vec3();
  const tdir = new Vec3();
  const tan1 = new Float32Array(vertexCount * 3);
  const tan2 = new Float32Array(vertexCount * 3);
  const tangents = [];
  for (let i = 0; i < triangleCount; i++) {
    const i1 = indices[i * 3];
    const i2 = indices[i * 3 + 1];
    const i3 = indices[i * 3 + 2];
    v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
    v22.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
    v32.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
    w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
    w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
    w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
    const x1 = v22.x - v1.x;
    const x2 = v32.x - v1.x;
    const y1 = v22.y - v1.y;
    const y2 = v32.y - v1.y;
    const z1 = v22.z - v1.z;
    const z2 = v32.z - v1.z;
    const s1 = w2.x - w1.x;
    const s2 = w3.x - w1.x;
    const _t = w2.y - w1.y;
    const _t2 = w3.y - w1.y;
    const area = s1 * _t2 - s2 * _t;
    if (area === 0) {
      sdir.set(0, 1, 0);
      tdir.set(1, 0, 0);
    } else {
      const r = 1 / area;
      sdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);
      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
    }
    tan1[i1 * 3 + 0] += sdir.x;
    tan1[i1 * 3 + 1] += sdir.y;
    tan1[i1 * 3 + 2] += sdir.z;
    tan1[i2 * 3 + 0] += sdir.x;
    tan1[i2 * 3 + 1] += sdir.y;
    tan1[i2 * 3 + 2] += sdir.z;
    tan1[i3 * 3 + 0] += sdir.x;
    tan1[i3 * 3 + 1] += sdir.y;
    tan1[i3 * 3 + 2] += sdir.z;
    tan2[i1 * 3 + 0] += tdir.x;
    tan2[i1 * 3 + 1] += tdir.y;
    tan2[i1 * 3 + 2] += tdir.z;
    tan2[i2 * 3 + 0] += tdir.x;
    tan2[i2 * 3 + 1] += tdir.y;
    tan2[i2 * 3 + 2] += tdir.z;
    tan2[i3 * 3 + 0] += tdir.x;
    tan2[i3 * 3 + 1] += tdir.y;
    tan2[i3 * 3 + 2] += tdir.z;
  }
  const t1 = new Vec3();
  const t2 = new Vec3();
  const n = new Vec3();
  const temp = new Vec3();
  for (let i = 0; i < vertexCount; i++) {
    n.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
    t1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);
    t2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);
    const ndott = n.dot(t1);
    temp.copy(n).mulScalar(ndott);
    temp.sub2(t1, temp).normalize();
    tangents[i * 4] = temp.x;
    tangents[i * 4 + 1] = temp.y;
    tangents[i * 4 + 2] = temp.z;
    temp.cross(n, t1);
    tangents[i * 4 + 3] = temp.dot(t2) < 0 ? -1 : 1;
  }
  return tangents;
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/geometry.js
var Geometry = class {
  constructor() {
    this.positions = void 0;
    this.normals = void 0;
    this.colors = void 0;
    this.uvs = void 0;
    this.uvs1 = void 0;
    this.blendIndices = void 0;
    this.blendWeights = void 0;
    this.tangents = void 0;
    this.indices = void 0;
  }
  calculateNormals() {
    this.normals = calculateNormals(this.positions, this.indices);
  }
  calculateTangents() {
    this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/box-geometry.js
var primitiveUv1Padding = 4 / 64;
var primitiveUv1PaddingScale = 1 - primitiveUv1Padding * 2;
var BoxGeometry = class extends Geometry {
  constructor(opts = {}) {
    var _opts$halfExtents, _opts$widthSegments, _opts$lengthSegments, _opts$heightSegments, _opts$yOffset;
    super();
    const he = (_opts$halfExtents = opts.halfExtents) != null ? _opts$halfExtents : new Vec3(0.5, 0.5, 0.5);
    const ws = (_opts$widthSegments = opts.widthSegments) != null ? _opts$widthSegments : 1;
    const ls = (_opts$lengthSegments = opts.lengthSegments) != null ? _opts$lengthSegments : 1;
    const hs = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 1;
    const yOffset = (_opts$yOffset = opts.yOffset) != null ? _opts$yOffset : 0;
    const minY = -he.y + yOffset;
    const maxY = he.y + yOffset;
    const corners = [new Vec3(-he.x, minY, he.z), new Vec3(he.x, minY, he.z), new Vec3(he.x, maxY, he.z), new Vec3(-he.x, maxY, he.z), new Vec3(he.x, minY, -he.z), new Vec3(-he.x, minY, -he.z), new Vec3(-he.x, maxY, -he.z), new Vec3(he.x, maxY, -he.z)];
    const faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
    const faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
    const sides = {
      FRONT: 0,
      BACK: 1,
      TOP: 2,
      BOTTOM: 3,
      RIGHT: 4,
      LEFT: 5
    };
    const positions = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    let vcounter = 0;
    const generateFace = (side, uSegments, vSegments) => {
      const temp1 = new Vec3();
      const temp2 = new Vec3();
      const temp3 = new Vec3();
      const r = new Vec3();
      for (let i = 0; i <= uSegments; i++) {
        for (let j = 0; j <= vSegments; j++) {
          temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
          temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
          temp3.sub2(temp2, corners[faceAxes[side][0]]);
          r.add2(temp1, temp3);
          let u = i / uSegments;
          let v = j / vSegments;
          positions.push(r.x, r.y, r.z);
          normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
          uvs.push(u, 1 - v);
          u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
          v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
          u /= 3;
          v /= 3;
          u += side % 3 / 3;
          v += Math.floor(side / 3) / 3;
          if (i < uSegments && j < vSegments) {
            indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
            indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
          }
          vcounter++;
        }
      }
    };
    generateFace(sides.FRONT, ws, hs);
    generateFace(sides.BACK, ws, hs);
    generateFace(sides.TOP, ws, ls);
    generateFace(sides.BOTTOM, ws, ls);
    generateFace(sides.RIGHT, ls, hs);
    generateFace(sides.LEFT, ls, hs);
    this.positions = positions;
    this.normals = normals;
    this.uvs = uvs;
    this.uvs1 = uvs;
    this.indices = indices;
    if (opts.calculateTangents) {
      this.tangents = calculateTangents(positions, normals, uvs, indices);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/sphere-geometry.js
var SphereGeometry = class extends Geometry {
  constructor(opts = {}) {
    var _opts$radius, _opts$latitudeBands, _opts$longitudeBands;
    super();
    const radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.5;
    const latitudeBands = (_opts$latitudeBands = opts.latitudeBands) != null ? _opts$latitudeBands : 16;
    const longitudeBands = (_opts$longitudeBands = opts.longitudeBands) != null ? _opts$longitudeBands : 16;
    const positions = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    for (let lat = 0; lat <= latitudeBands; lat++) {
      const theta = lat * Math.PI / latitudeBands;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      for (let lon = 0; lon <= longitudeBands; lon++) {
        const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
        const sinPhi = Math.sin(phi);
        const cosPhi = Math.cos(phi);
        const x2 = cosPhi * sinTheta;
        const y2 = cosTheta;
        const z2 = sinPhi * sinTheta;
        const u = 1 - lon / longitudeBands;
        const v = 1 - lat / latitudeBands;
        positions.push(x2 * radius, y2 * radius, z2 * radius);
        normals.push(x2, y2, z2);
        uvs.push(u, 1 - v);
      }
    }
    for (let lat = 0; lat < latitudeBands; ++lat) {
      for (let lon = 0; lon < longitudeBands; ++lon) {
        const first = lat * (longitudeBands + 1) + lon;
        const second = first + longitudeBands + 1;
        indices.push(first + 1, second, first);
        indices.push(first + 1, second + 1, second);
      }
    }
    this.positions = positions;
    this.normals = normals;
    this.uvs = uvs;
    this.uvs1 = uvs;
    this.indices = indices;
    if (opts.calculateTangents) {
      this.tangents = calculateTangents(positions, normals, uvs, indices);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/dome-geometry.js
var DomeGeometry = class extends SphereGeometry {
  constructor(opts = {}) {
    var _opts$latitudeBands, _opts$longitudeBands;
    const radius = 0.5;
    const latitudeBands = (_opts$latitudeBands = opts.latitudeBands) != null ? _opts$latitudeBands : 16;
    const longitudeBands = (_opts$longitudeBands = opts.longitudeBands) != null ? _opts$longitudeBands : 16;
    super({
      radius,
      latitudeBands,
      longitudeBands
    });
    const bottomLimit = 0.1;
    const curvatureRadius = 0.95;
    const curvatureRadiusSq = curvatureRadius * curvatureRadius;
    const positions = this.positions;
    for (let i = 0; i < positions.length; i += 3) {
      const x2 = positions[i] / radius;
      let y2 = positions[i + 1] / radius;
      const z2 = positions[i + 2] / radius;
      if (y2 < 0) {
        y2 *= 0.3;
        if (x2 * x2 + z2 * z2 < curvatureRadiusSq) {
          y2 = -bottomLimit;
        }
      }
      y2 += bottomLimit;
      y2 *= radius;
      positions[i + 1] = y2;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/skybox/sky-geometry.js
var SkyGeometry = class _SkyGeometry {
  static create(device, type) {
    switch (type) {
      case SKYTYPE_BOX:
        return _SkyGeometry.box(device);
      case SKYTYPE_DOME:
        return _SkyGeometry.dome(device);
    }
    return _SkyGeometry.infinite(device);
  }
  static infinite(device) {
    return Mesh.fromGeometry(device, new BoxGeometry(device));
  }
  static box(device) {
    return Mesh.fromGeometry(device, new BoxGeometry({
      yOffset: 0.5
    }));
  }
  static dome(device) {
    const geom = new DomeGeometry({
      latitudeBands: 50,
      longitudeBands: 50
    });
    geom.normals = void 0;
    geom.uvs = void 0;
    return Mesh.fromGeometry(device, geom);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/skybox/sky-mesh.js
var SkyMesh = class {
  constructor(device, scene, node, texture, type) {
    this.meshInstance = null;
    const material = new ShaderMaterial();
    material.name = "SkyMaterial";
    material.getShaderVariant = function(params) {
      const {
        scene: scene2,
        renderParams
      } = params;
      const options2 = {
        defines: this.defines,
        pass: params.pass,
        encoding: texture.encoding,
        gamma: renderParams.shaderOutputGamma,
        toneMapping: renderParams.toneMapping,
        skymesh: type
      };
      if (texture.cubemap) {
        options2.type = "cubemap";
        options2.mip = scene2.skyboxMip;
      } else {
        options2.type = "envAtlas";
      }
      const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat);
      const library = getProgramLibrary(device);
      library.register("skybox", skybox);
      return library.getProgram("skybox", options2, processingOptions);
    };
    if (texture.cubemap) {
      material.setParameter("texture_cubeMap", texture);
    } else {
      material.setParameter("texture_envAtlas", texture);
      material.setParameter("mipLevel", scene._skyboxMip);
    }
    material.cull = CULLFACE_FRONT;
    material.depthWrite = false;
    const skyLayer = scene.layers.getLayerById(LAYERID_SKYBOX);
    if (skyLayer) {
      const mesh = SkyGeometry.create(device, type);
      const meshInstance = new MeshInstance(mesh, material, node);
      this.meshInstance = meshInstance;
      meshInstance.cull = false;
      meshInstance.pick = false;
      skyLayer.addMeshInstances([meshInstance]);
      this.skyLayer = skyLayer;
    }
  }
  destroy() {
    if (this.meshInstance) {
      if (this.skyLayer) {
        this.skyLayer.removeMeshInstances([this.meshInstance]);
      }
      this.meshInstance.destroy();
      this.meshInstance = null;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/skybox/sky.js
var Sky = class {
  constructor(scene) {
    this._type = SKYTYPE_INFINITE;
    this._center = new Vec3(0, 1, 0);
    this.skyMesh = null;
    this.node = new GraphNode("SkyMeshNode");
    this.device = scene.device;
    this.scene = scene;
    this.center = new Vec3(0, 1, 0);
    this.centerArray = new Float32Array(3);
    this.projectedSkydomeCenterId = this.device.scope.resolve("projectedSkydomeCenter");
  }
  applySettings(render) {
    var _render$skyType, _render$skyMeshPositi, _render$skyMeshRotati, _render$skyMeshScale;
    this.type = (_render$skyType = render.skyType) != null ? _render$skyType : SKYTYPE_INFINITE;
    this.node.setLocalPosition(new Vec3((_render$skyMeshPositi = render.skyMeshPosition) != null ? _render$skyMeshPositi : [0, 0, 0]));
    this.node.setLocalEulerAngles(new Vec3((_render$skyMeshRotati = render.skyMeshRotation) != null ? _render$skyMeshRotati : [0, 0, 0]));
    this.node.setLocalScale(new Vec3((_render$skyMeshScale = render.skyMeshScale) != null ? _render$skyMeshScale : [1, 1, 1]));
    if (render.skyCenter) {
      this._center = new Vec3(render.skyCenter);
    }
  }
  set type(value) {
    if (this._type !== value) {
      this._type = value;
      this.scene.updateShaders = true;
      this.updateSkyMesh();
    }
  }
  get type() {
    return this._type;
  }
  set center(value) {
    this._center.copy(value);
  }
  get center() {
    return this._center;
  }
  updateSkyMesh() {
    const texture = this.scene._getSkyboxTex();
    if (texture) {
      this.resetSkyMesh();
      this.skyMesh = new SkyMesh(this.device, this.scene, this.node, texture, this.type);
      this.scene.fire("set:skybox", texture);
    }
  }
  resetSkyMesh() {
    var _this$skyMesh;
    (_this$skyMesh = this.skyMesh) == null || _this$skyMesh.destroy();
    this.skyMesh = null;
  }
  update() {
    if (this.type !== SKYTYPE_INFINITE) {
      const {
        center: center2,
        centerArray
      } = this;
      const temp = new Vec3();
      this.node.getWorldTransform().transformPoint(center2, temp);
      centerArray[0] = temp.x;
      centerArray[1] = temp.y;
      centerArray[2] = temp.z;
      this.projectedSkydomeCenterId.setValue(centerArray);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/immediate/immediate-batch.js
var identityGraphNode = new GraphNode();
identityGraphNode.worldTransform = Mat4.IDENTITY;
identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;
var ImmediateBatch = class {
  constructor(device, material, layer) {
    this.material = material;
    this.layer = layer;
    this.positions = [];
    this.colors = [];
    this.mesh = new Mesh(device);
    this.meshInstance = null;
  }
  addLines(positions, color) {
    const destPos = this.positions;
    const count = positions.length;
    for (let i = 0; i < count; i++) {
      const pos = positions[i];
      destPos.push(pos.x, pos.y, pos.z);
    }
    const destCol = this.colors;
    if (color.length) {
      for (let i = 0; i < count; i++) {
        const col = color[i];
        destCol.push(col.r, col.g, col.b, col.a);
      }
    } else {
      for (let i = 0; i < count; i++) {
        destCol.push(color.r, color.g, color.b, color.a);
      }
    }
  }
  addLinesArrays(positions, color) {
    const destPos = this.positions;
    for (let i = 0; i < positions.length; i += 3) {
      destPos.push(positions[i], positions[i + 1], positions[i + 2]);
    }
    const destCol = this.colors;
    if (color.length) {
      for (let i = 0; i < color.length; i += 4) {
        destCol.push(color[i], color[i + 1], color[i + 2], color[i + 3]);
      }
    } else {
      const count = positions.length / 3;
      for (let i = 0; i < count; i++) {
        destCol.push(color.r, color.g, color.b, color.a);
      }
    }
  }
  onPreRender(visibleList, transparent) {
    if (this.positions.length > 0 && this.material.transparent === transparent) {
      this.mesh.setPositions(this.positions);
      this.mesh.setColors(this.colors);
      this.mesh.update(PRIMITIVE_LINES, false);
      if (!this.meshInstance) {
        this.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);
      }
      visibleList.push(this.meshInstance);
    }
  }
  clear() {
    this.positions.length = 0;
    this.colors.length = 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/immediate/immediate-batches.js
var ImmediateBatches = class {
  constructor(device) {
    this.device = device;
    this.map = /* @__PURE__ */ new Map();
  }
  getBatch(material, layer) {
    let batch = this.map.get(material);
    if (!batch) {
      batch = new ImmediateBatch(this.device, material, layer);
      this.map.set(material, batch);
    }
    return batch;
  }
  onPreRender(visibleList, transparent) {
    this.map.forEach((batch) => {
      batch.onPreRender(visibleList, transparent);
    });
  }
  clear() {
    this.map.forEach((batch) => batch.clear());
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/immediate/immediate.js
var tempPoints = [];
var vec = new Vec3();
var lineShaderDesc = {
  uniqueName: "ImmediateLine",
  vertexCode: `
		attribute vec3 vertex_position;
		attribute vec4 vertex_color;
		uniform mat4 matrix_model;
		uniform mat4 matrix_viewProjection;
		varying vec4 color;
		void main(void) {
			color = vertex_color;
			gl_Position = matrix_viewProjection * matrix_model * vec4(vertex_position, 1);
		}
	`,
  fragmentCode: `
		varying vec4 color;
		void main(void) {
			gl_FragColor = vec4(gammaCorrectOutput(decodeGamma(color.rgb)), color.a);
		}
	`,
  attributes: {
    vertex_position: SEMANTIC_POSITION,
    vertex_color: SEMANTIC_COLOR
  }
};
var Immediate = class {
  constructor(device) {
    this.shaderDescs = /* @__PURE__ */ new Map();
    this.device = device;
    this.quadMesh = null;
    this.textureShader = null;
    this.depthTextureShader = null;
    this.cubeLocalPos = null;
    this.cubeWorldPos = null;
    this.batchesMap = /* @__PURE__ */ new Map();
    this.allBatches = /* @__PURE__ */ new Set();
    this.updatedLayers = /* @__PURE__ */ new Set();
    this._materialDepth = null;
    this._materialNoDepth = null;
    this.layerMeshInstances = /* @__PURE__ */ new Map();
  }
  createMaterial(depthTest) {
    const material = new ShaderMaterial(lineShaderDesc);
    material.blendType = BLEND_NORMAL;
    material.depthTest = depthTest;
    material.update();
    return material;
  }
  get materialDepth() {
    if (!this._materialDepth) {
      this._materialDepth = this.createMaterial(true);
    }
    return this._materialDepth;
  }
  get materialNoDepth() {
    if (!this._materialNoDepth) {
      this._materialNoDepth = this.createMaterial(false);
    }
    return this._materialNoDepth;
  }
  getBatch(layer, depthTest) {
    let batches = this.batchesMap.get(layer);
    if (!batches) {
      batches = new ImmediateBatches(this.device);
      this.batchesMap.set(layer, batches);
    }
    this.allBatches.add(batches);
    const material = depthTest ? this.materialDepth : this.materialNoDepth;
    return batches.getBatch(material, layer);
  }
  getShaderDesc(id13, fragment) {
    if (!this.shaderDescs.has(id13)) {
      const vertex = `
				attribute vec2 vertex_position;
				uniform mat4 matrix_model;
				varying vec2 uv0;
				void main(void) {
					gl_Position = matrix_model * vec4(vertex_position, 0, 1);
					uv0 = vertex_position.xy + 0.5;
				}
			`;
      this.shaderDescs.set(id13, {
        uniqueName: `DebugShader:${id13}`,
        vertexCode: vertex,
        fragmentCode: fragment,
        attributes: {
          vertex_position: SEMANTIC_POSITION
        }
      });
    }
    return this.shaderDescs.get(id13);
  }
  getTextureShaderDesc(encoding) {
    const decodeFunc = ChunkUtils.decodeFunc(encoding);
    return this.getShaderDesc(`textureShader-${encoding}`, `
			varying vec2 uv0;
			uniform sampler2D colorMap;
			void main (void) {
				vec3 linearColor = ${decodeFunc}(texture2D(colorMap, uv0));
				gl_FragColor = vec4(gammaCorrectOutput(linearColor), 1);
			}
		`);
  }
  getUnfilterableTextureShaderDesc() {
    return this.getShaderDesc("textureShaderUnfilterable", `
			varying vec2 uv0;
			uniform highp sampler2D colorMap;
			void main (void) {
				ivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));
				gl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);
			}
		`);
  }
  getDepthTextureShaderDesc() {
    return this.getShaderDesc("depthTextureShader", `
			${shaderChunks.screenDepthPS}
			varying vec2 uv0;
			void main() {
				float depth = getLinearScreenDepth(getImageEffectUV(uv0)) * camera_params.x;
				gl_FragColor = vec4(gammaCorrectOutput(vec3(depth)), 1.0);
			}
		`);
  }
  getQuadMesh() {
    if (!this.quadMesh) {
      this.quadMesh = new Mesh(this.device);
      this.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);
      this.quadMesh.update(PRIMITIVE_TRISTRIP);
    }
    return this.quadMesh;
  }
  drawMesh(material, matrix2, mesh, meshInstance, layer) {
    if (!meshInstance) {
      const graphNode = this.getGraphNode(matrix2);
      meshInstance = new MeshInstance(mesh, material, graphNode);
    }
    let layerMeshInstances = this.layerMeshInstances.get(layer);
    if (!layerMeshInstances) {
      layerMeshInstances = [];
      this.layerMeshInstances.set(layer, layerMeshInstances);
    }
    layerMeshInstances.push(meshInstance);
  }
  drawWireAlignedBox(min, max, color, depthTest, layer, mat2) {
    if (mat2) {
      const mulPoint = (x2, y2, z2) => {
        vec.set(x2, y2, z2);
        mat2.transformPoint(vec, vec);
        tempPoints.push(vec.x, vec.y, vec.z);
      };
      mulPoint(min.x, min.y, min.z);
      mulPoint(min.x, max.y, min.z);
      mulPoint(min.x, max.y, min.z);
      mulPoint(max.x, max.y, min.z);
      mulPoint(max.x, max.y, min.z);
      mulPoint(max.x, min.y, min.z);
      mulPoint(max.x, min.y, min.z);
      mulPoint(min.x, min.y, min.z);
      mulPoint(min.x, min.y, max.z);
      mulPoint(min.x, max.y, max.z);
      mulPoint(min.x, max.y, max.z);
      mulPoint(max.x, max.y, max.z);
      mulPoint(max.x, max.y, max.z);
      mulPoint(max.x, min.y, max.z);
      mulPoint(max.x, min.y, max.z);
      mulPoint(min.x, min.y, max.z);
      mulPoint(min.x, min.y, min.z);
      mulPoint(min.x, min.y, max.z);
      mulPoint(min.x, max.y, min.z);
      mulPoint(min.x, max.y, max.z);
      mulPoint(max.x, max.y, min.z);
      mulPoint(max.x, max.y, max.z);
      mulPoint(max.x, min.y, min.z);
      mulPoint(max.x, min.y, max.z);
    } else {
      tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);
    }
    const batch = this.getBatch(layer, depthTest);
    batch.addLinesArrays(tempPoints, color);
    tempPoints.length = 0;
  }
  drawWireSphere(center2, radius, color, numSegments, depthTest, layer) {
    const step = 2 * Math.PI / numSegments;
    let angle = 0;
    for (let i = 0; i < numSegments; i++) {
      const sin0 = Math.sin(angle);
      const cos0 = Math.cos(angle);
      angle += step;
      const sin1 = Math.sin(angle);
      const cos1 = Math.cos(angle);
      tempPoints.push(center2.x + radius * sin0, center2.y, center2.z + radius * cos0);
      tempPoints.push(center2.x + radius * sin1, center2.y, center2.z + radius * cos1);
      tempPoints.push(center2.x + radius * sin0, center2.y + radius * cos0, center2.z);
      tempPoints.push(center2.x + radius * sin1, center2.y + radius * cos1, center2.z);
      tempPoints.push(center2.x, center2.y + radius * sin0, center2.z + radius * cos0);
      tempPoints.push(center2.x, center2.y + radius * sin1, center2.z + radius * cos1);
    }
    const batch = this.getBatch(layer, depthTest);
    batch.addLinesArrays(tempPoints, color);
    tempPoints.length = 0;
  }
  getGraphNode(matrix2) {
    const graphNode = new GraphNode("ImmediateDebug");
    graphNode.worldTransform = matrix2;
    graphNode._dirtyWorld = graphNode._dirtyNormal = false;
    return graphNode;
  }
  onPreRenderLayer(layer, visibleList, transparent) {
    this.batchesMap.forEach((batches, batchLayer) => {
      if (batchLayer === layer) {
        batches.onPreRender(visibleList, transparent);
      }
    });
    if (!this.updatedLayers.has(layer)) {
      this.updatedLayers.add(layer);
      const meshInstances = this.layerMeshInstances.get(layer);
      if (meshInstances) {
        for (let i = 0; i < meshInstances.length; i++) {
          visibleList.push(meshInstances[i]);
        }
        meshInstances.length = 0;
      }
    }
  }
  onPostRender() {
    this.allBatches.forEach((batch) => batch.clear());
    this.allBatches.clear();
    this.updatedLayers.clear();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/core/math/random.js
var _goldenAngle = 2.399963229728653;
var random = {
  circlePoint(point) {
    const r = Math.sqrt(Math.random());
    const theta = Math.random() * 2 * Math.PI;
    point.x = r * Math.cos(theta);
    point.y = r * Math.sin(theta);
  },
  circlePointDeterministic(point, index, numPoints) {
    const theta = index * _goldenAngle;
    const r = Math.sqrt(index) / Math.sqrt(numPoints);
    point.x = r * Math.cos(theta);
    point.y = r * Math.sin(theta);
  },
  spherePointDeterministic(point, index, numPoints, start = 0, end = 1) {
    start = 1 - 2 * start;
    end = 1 - 2 * end;
    const y2 = math.lerp(start, end, index / numPoints);
    const radius = Math.sqrt(1 - y2 * y2);
    const theta = _goldenAngle * index;
    point.x = Math.cos(theta) * radius;
    point.y = y2;
    point.z = Math.sin(theta) * radius;
  },
  radicalInverse(i) {
    let bits = (i << 16 | i >>> 16) >>> 0;
    bits = ((bits & 1431655765) << 1 | (bits & 2863311530) >>> 1) >>> 0;
    bits = ((bits & 858993459) << 2 | (bits & 3435973836) >>> 2) >>> 0;
    bits = ((bits & 252645135) << 4 | (bits & 4042322160) >>> 4) >>> 0;
    bits = ((bits & 16711935) << 8 | (bits & 4278255360) >>> 8) >>> 0;
    return bits * 23283064365386963e-26;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/reproject-texture.js
var getProjectionName = (projection) => {
  switch (projection) {
    case TEXTUREPROJECTION_CUBE:
      return "Cubemap";
    case TEXTUREPROJECTION_OCTAHEDRAL:
      return "Octahedral";
    default:
      return "Equirect";
  }
};
var packFloat32ToRGBA8 = (value, array2, offset) => {
  if (value <= 0) {
    array2[offset + 0] = 0;
    array2[offset + 1] = 0;
    array2[offset + 2] = 0;
    array2[offset + 3] = 0;
  } else if (value >= 1) {
    array2[offset + 0] = 255;
    array2[offset + 1] = 0;
    array2[offset + 2] = 0;
    array2[offset + 3] = 0;
  } else {
    let encX = 1 * value % 1;
    let encY = 255 * value % 1;
    let encZ = 65025 * value % 1;
    const encW = 16581375 * value % 1;
    encX -= encY / 255;
    encY -= encZ / 255;
    encZ -= encW / 255;
    array2[offset + 0] = Math.min(255, Math.floor(encX * 256));
    array2[offset + 1] = Math.min(255, Math.floor(encY * 256));
    array2[offset + 2] = Math.min(255, Math.floor(encZ * 256));
    array2[offset + 3] = Math.min(255, Math.floor(encW * 256));
  }
};
var packSamples = (samples) => {
  const numSamples = samples.length;
  const w = Math.min(numSamples, 512);
  const h2 = Math.ceil(numSamples / w);
  const data2 = new Uint8Array(w * h2 * 4);
  let off = 0;
  for (let i = 0; i < numSamples; i += 4) {
    packFloat32ToRGBA8(samples[i + 0] * 0.5 + 0.5, data2, off + 0);
    packFloat32ToRGBA8(samples[i + 1] * 0.5 + 0.5, data2, off + 4);
    packFloat32ToRGBA8(samples[i + 2] * 0.5 + 0.5, data2, off + 8);
    packFloat32ToRGBA8(samples[i + 3] / 8, data2, off + 12);
    off += 16;
  }
  return {
    width: w,
    height: h2,
    data: data2
  };
};
var hemisphereSamplePhong = (dstVec, x2, y2, specularPower) => {
  const phi = y2 * 2 * Math.PI;
  const cosTheta = Math.pow(1 - x2, 1 / (specularPower + 1));
  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
  dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};
var hemisphereSampleLambert = (dstVec, x2, y2) => {
  const phi = y2 * 2 * Math.PI;
  const cosTheta = Math.sqrt(1 - x2);
  const sinTheta = Math.sqrt(x2);
  dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};
var hemisphereSampleGGX = (dstVec, x2, y2, a) => {
  const phi = y2 * 2 * Math.PI;
  const cosTheta = Math.sqrt((1 - x2) / (1 + (a * a - 1) * x2));
  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
  dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};
var D_GGX = (NoH, linearRoughness) => {
  const a = NoH * linearRoughness;
  const k = linearRoughness / (1 - NoH * NoH + a * a);
  return k * k * (1 / Math.PI);
};
var generatePhongSamples = (numSamples, specularPower) => {
  const H = new Vec3();
  const result = [];
  for (let i = 0; i < numSamples; ++i) {
    hemisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);
    result.push(H.x, H.y, H.z, 0);
  }
  return result;
};
var generateLambertSamples = (numSamples, sourceTotalPixels) => {
  const pixelsPerSample = sourceTotalPixels / numSamples;
  const H = new Vec3();
  const result = [];
  for (let i = 0; i < numSamples; ++i) {
    hemisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));
    const pdf = H.z / Math.PI;
    const mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
    result.push(H.x, H.y, H.z, mipLevel);
  }
  return result;
};
var requiredSamplesGGX = {
  "16": {
    "2": 26,
    "8": 20,
    "32": 17,
    "128": 16,
    "512": 16
  },
  "32": {
    "2": 53,
    "8": 40,
    "32": 34,
    "128": 32,
    "512": 32
  },
  "128": {
    "2": 214,
    "8": 163,
    "32": 139,
    "128": 130,
    "512": 128
  },
  "1024": {
    "2": 1722,
    "8": 1310,
    "32": 1114,
    "128": 1041,
    "512": 1025
  }
};
var getRequiredSamplesGGX = (numSamples, specularPower) => {
  const table = requiredSamplesGGX[numSamples];
  return table && table[specularPower] || numSamples;
};
var generateGGXSamples = (numSamples, specularPower, sourceTotalPixels) => {
  const pixelsPerSample = sourceTotalPixels / numSamples;
  const roughness = 1 - Math.log2(specularPower) / 11;
  const a = roughness * roughness;
  const H = new Vec3();
  const L = new Vec3();
  const N = new Vec3(0, 0, 1);
  const result = [];
  const requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);
  for (let i = 0; i < requiredSamples; ++i) {
    hemisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);
    const NoH = H.z;
    L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);
    if (L.z > 0) {
      const pdf = D_GGX(Math.min(1, NoH), a) / 4 + 1e-3;
      const mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
      result.push(L.x, L.y, L.z, mipLevel);
    }
  }
  while (result.length < numSamples * 4) {
    result.push(0, 0, 0, 0);
  }
  return result;
};
var createSamplesTex = (device, name, samples) => {
  const packedSamples = packSamples(samples);
  return new Texture(device, {
    name,
    width: packedSamples.width,
    height: packedSamples.height,
    mipmaps: false,
    minFilter: FILTER_NEAREST,
    magFilter: FILTER_NEAREST,
    levels: [packedSamples.data]
  });
};
var SimpleCache = class {
  constructor(destroyContent = true) {
    this.map = /* @__PURE__ */ new Map();
    this.destroyContent = destroyContent;
  }
  destroy() {
    if (this.destroyContent) {
      this.map.forEach((value, key) => {
        value.destroy();
      });
    }
  }
  get(key, missFunc) {
    if (!this.map.has(key)) {
      const result = missFunc();
      this.map.set(key, result);
      return result;
    }
    return this.map.get(key);
  }
};
var samplesCache = new SimpleCache(false);
var deviceCache2 = new DeviceCache();
var getCachedTexture = (device, key, getSamplesFnc) => {
  const cache = deviceCache2.get(device, () => {
    return new SimpleCache();
  });
  return cache.get(key, () => {
    return createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));
  });
};
var generateLambertSamplesTex = (device, numSamples, sourceTotalPixels) => {
  const key = `lambert-samples-${numSamples}-${sourceTotalPixels}`;
  return getCachedTexture(device, key, () => {
    return generateLambertSamples(numSamples, sourceTotalPixels);
  });
};
var generatePhongSamplesTex = (device, numSamples, specularPower) => {
  const key = `phong-samples-${numSamples}-${specularPower}`;
  return getCachedTexture(device, key, () => {
    return generatePhongSamples(numSamples, specularPower);
  });
};
var generateGGXSamplesTex = (device, numSamples, specularPower, sourceTotalPixels) => {
  const key = `ggx-samples-${numSamples}-${specularPower}-${sourceTotalPixels}`;
  return getCachedTexture(device, key, () => {
    return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);
  });
};
var vsCode = `
attribute vec2 vertex_position;

uniform vec4 uvMod;

varying vec2 vUv0;

void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);
}
`;
function reprojectTexture(source, target2, options2 = {}) {
  var _options$seamPixels, _options$rect$z, _options$rect, _options$rect$w, _options$rect2;
  const seamPixels = (_options$seamPixels = options2.seamPixels) != null ? _options$seamPixels : 0;
  const innerWidth = ((_options$rect$z = (_options$rect = options2.rect) == null ? void 0 : _options$rect.z) != null ? _options$rect$z : target2.width) - seamPixels * 2;
  const innerHeight = ((_options$rect$w = (_options$rect2 = options2.rect) == null ? void 0 : _options$rect2.w) != null ? _options$rect$w : target2.height) - seamPixels * 2;
  if (innerWidth < 1 || innerHeight < 1) {
    return false;
  }
  const funcNames = {
    "none": "reproject",
    "lambert": "prefilterSamplesUnweighted",
    "phong": "prefilterSamplesUnweighted",
    "ggx": "prefilterSamples"
  };
  const specularPower = options2.hasOwnProperty("specularPower") ? options2.specularPower : 1;
  const face = options2.hasOwnProperty("face") ? options2.face : null;
  const distribution = options2.hasOwnProperty("distribution") ? options2.distribution : specularPower === 1 ? "none" : "phong";
  const processFunc = funcNames[distribution] || "reproject";
  const prefilterSamples = processFunc.startsWith("prefilterSamples");
  const decodeFunc = ChunkUtils.decodeFunc(source.encoding);
  const encodeFunc = ChunkUtils.encodeFunc(target2.encoding);
  const sourceFunc = `sample${getProjectionName(source.projection)}`;
  const targetFunc = `getDirection${getProjectionName(target2.projection)}`;
  const numSamples = options2.hasOwnProperty("numSamples") ? options2.numSamples : 1024;
  const shaderKey = `${processFunc}_${decodeFunc}_${encodeFunc}_${sourceFunc}_${targetFunc}_${numSamples}`;
  const device = source.device;
  let shader = getProgramLibrary(device).getCachedShader(shaderKey);
  if (!shader) {
    const defines = `#define PROCESS_FUNC ${processFunc}
${prefilterSamples ? "#define USE_SAMPLES_TEX\n" : ""}${source.cubemap ? "#define CUBEMAP_SOURCE\n" : ""}#define DECODE_FUNC ${decodeFunc}
#define ENCODE_FUNC ${encodeFunc}
#define SOURCE_FUNC ${sourceFunc}
#define TARGET_FUNC ${targetFunc}
#define NUM_SAMPLES ${numSamples}
#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(numSamples)).toFixed(1)}
`;
    shader = createShaderFromCode(device, vsCode, `${defines}
${shaderChunks.reprojectPS}`, shaderKey);
  }
  device.setBlendState(BlendState.NOBLEND);
  const constantSource = device.scope.resolve(source.cubemap ? "sourceCube" : "sourceTex");
  constantSource.setValue(source);
  const constantParams = device.scope.resolve("params");
  const uvModParam = device.scope.resolve("uvMod");
  if (seamPixels > 0) {
    uvModParam.setValue([(innerWidth + seamPixels * 2) / innerWidth, (innerHeight + seamPixels * 2) / innerHeight, -seamPixels / innerWidth, -seamPixels / innerHeight]);
  } else {
    uvModParam.setValue([1, 1, 0, 0]);
  }
  const params = [0, specularPower, target2.width * target2.height * (target2.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];
  if (prefilterSamples) {
    const sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);
    const samplesTex = distribution === "ggx" ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === "lambert" ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);
    device.scope.resolve("samplesTex").setValue(samplesTex);
    device.scope.resolve("samplesTexInverseSize").setValue([1 / samplesTex.width, 1 / samplesTex.height]);
  }
  for (let f = 0; f < (target2.cubemap ? 6 : 1); f++) {
    if (face === null || f === face) {
      const renderTarget = new RenderTarget({
        colorBuffer: target2,
        face: f,
        depth: false,
        flipY: device.isWebGPU
      });
      params[0] = f;
      constantParams.setValue(params);
      drawQuadWithShader(device, renderTarget, shader, options2 == null ? void 0 : options2.rect);
      renderTarget.destroy();
    }
  }
  return true;
}

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/env-lighting.js
var calcLevels = (width, height = 0) => {
  return 1 + Math.floor(Math.log2(Math.max(width, height)));
};
var supportsFloat16 = (device) => {
  return device.textureHalfFloatRenderable;
};
var supportsFloat32 = (device) => {
  return device.textureFloatRenderable;
};
var lightingSourcePixelFormat = (device) => {
  return supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA8;
};
var lightingPixelFormat = (device) => {
  return PIXELFORMAT_RGBA8;
};
var createCubemap = (device, size, format, mipmaps) => {
  return new Texture(device, {
    name: `lighting-${size}`,
    cubemap: true,
    width: size,
    height: size,
    format,
    type: format === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBP : TEXTURETYPE_DEFAULT,
    addressU: ADDRESS_CLAMP_TO_EDGE,
    addressV: ADDRESS_CLAMP_TO_EDGE,
    mipmaps: !!mipmaps
  });
};
var EnvLighting = class {
  static generateSkyboxCubemap(source, size) {
    const device = source.device;
    const result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_RGBA8, false);
    reprojectTexture(source, result, {
      numSamples: 1024
    });
    return result;
  }
  static generateLightingSource(source, options2) {
    const device = source.device;
    const format = lightingSourcePixelFormat(device);
    const result = (options2 == null ? void 0 : options2.target) || new Texture(device, {
      name: "lighting-source",
      cubemap: true,
      width: (options2 == null ? void 0 : options2.size) || 128,
      height: (options2 == null ? void 0 : options2.size) || 128,
      format,
      type: format === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBP : TEXTURETYPE_DEFAULT,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      mipmaps: true
    });
    reprojectTexture(source, result, {
      numSamples: source.mipmaps ? 1 : 1024
    });
    return result;
  }
  static generateAtlas(source, options2) {
    const device = source.device;
    const format = lightingPixelFormat();
    const result = (options2 == null ? void 0 : options2.target) || new Texture(device, {
      name: "envAtlas",
      width: (options2 == null ? void 0 : options2.size) || 512,
      height: (options2 == null ? void 0 : options2.size) || 512,
      format,
      type: TEXTURETYPE_RGBP,
      projection: TEXTUREPROJECTION_EQUIRECT,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      mipmaps: false
    });
    const s2 = result.width / 512;
    const rect = new Vec4(0, 0, 512 * s2, 256 * s2);
    const levels = calcLevels(256) - calcLevels(4);
    for (let i = 0; i < levels; ++i) {
      reprojectTexture(source, result, {
        numSamples: 1,
        rect,
        seamPixels: s2
      });
      rect.x += rect.w;
      rect.y += rect.w;
      rect.z = Math.max(1, Math.floor(rect.z * 0.5));
      rect.w = Math.max(1, Math.floor(rect.w * 0.5));
    }
    rect.set(0, 256 * s2, 256 * s2, 128 * s2);
    for (let i = 1; i < 7; ++i) {
      reprojectTexture(source, result, {
        numSamples: (options2 == null ? void 0 : options2.numReflectionSamples) || 1024,
        distribution: (options2 == null ? void 0 : options2.distribution) || "ggx",
        specularPower: Math.max(1, 2048 >> i * 2),
        rect,
        seamPixels: s2
      });
      rect.y += rect.w;
      rect.z = Math.max(1, Math.floor(rect.z * 0.5));
      rect.w = Math.max(1, Math.floor(rect.w * 0.5));
    }
    rect.set(128 * s2, (256 + 128) * s2, 64 * s2, 32 * s2);
    reprojectTexture(source, result, {
      numSamples: (options2 == null ? void 0 : options2.numAmbientSamples) || 2048,
      distribution: "lambert",
      rect,
      seamPixels: s2
    });
    return result;
  }
  static generatePrefilteredAtlas(sources, options2) {
    const device = sources[0].device;
    const format = sources[0].format;
    const type = sources[0].type;
    const result = (options2 == null ? void 0 : options2.target) || new Texture(device, {
      name: "envPrefilteredAtlas",
      width: (options2 == null ? void 0 : options2.size) || 512,
      height: (options2 == null ? void 0 : options2.size) || 512,
      format,
      type,
      projection: TEXTUREPROJECTION_EQUIRECT,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      mipmaps: false
    });
    const s2 = result.width / 512;
    const rect = new Vec4(0, 0, 512 * s2, 256 * s2);
    const levels = calcLevels(512);
    for (let i = 0; i < levels; ++i) {
      reprojectTexture(sources[0], result, {
        numSamples: 1,
        rect,
        seamPixels: s2
      });
      rect.x += rect.w;
      rect.y += rect.w;
      rect.z = Math.max(1, Math.floor(rect.z * 0.5));
      rect.w = Math.max(1, Math.floor(rect.w * 0.5));
    }
    rect.set(0, 256 * s2, 256 * s2, 128 * s2);
    for (let i = 1; i < sources.length; ++i) {
      reprojectTexture(sources[i], result, {
        numSamples: 1,
        rect,
        seamPixels: s2
      });
      rect.y += rect.w;
      rect.z = Math.max(1, Math.floor(rect.z * 0.5));
      rect.w = Math.max(1, Math.floor(rect.w * 0.5));
    }
    rect.set(128 * s2, (256 + 128) * s2, 64 * s2, 32 * s2);
    if (options2 != null && options2.legacyAmbient) {
      reprojectTexture(sources[5], result, {
        numSamples: 1,
        rect,
        seamPixels: s2
      });
    } else {
      reprojectTexture(sources[0], result, {
        numSamples: (options2 == null ? void 0 : options2.numSamples) || 2048,
        distribution: "lambert",
        rect,
        seamPixels: s2
      });
    }
    return result;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/scene.js
var Scene = class extends EventHandler {
  constructor(graphicsDevice) {
    super();
    this.ambientBake = false;
    this.ambientBakeOcclusionBrightness = 0;
    this.ambientBakeOcclusionContrast = 0;
    this.ambientLight = new Color(0, 0, 0);
    this.ambientLuminance = 0;
    this.exposure = 1;
    this.fogColor = new Color(0, 0, 0);
    this.fogDensity = 0;
    this.fogEnd = 1e3;
    this.fogStart = 1;
    this.lightmapSizeMultiplier = 1;
    this.lightmapMaxResolution = 2048;
    this.lightmapMode = BAKE_COLORDIR;
    this.lightmapFilterEnabled = false;
    this.lightmapHDR = false;
    this.root = null;
    this.physicalUnits = false;
    this._envAtlas = null;
    this._skyboxCubeMap = null;
    this._renderingParams = new RenderingParams();
    this.device = graphicsDevice;
    this._gravity = new Vec3(0, -9.8, 0);
    this._layers = null;
    this._fog = FOG_NONE;
    this._prefilteredCubemaps = [];
    this._internalEnvAtlas = null;
    this._skyboxIntensity = 1;
    this._skyboxLuminance = 0;
    this._skyboxMip = 0;
    this._skyboxRotationShaderInclude = false;
    this._skyboxRotation = new Quat();
    this._skyboxRotationMat3 = new Mat3();
    this._skyboxRotationMat4 = new Mat4();
    this._ambientBakeNumSamples = 1;
    this._ambientBakeSpherePart = 0.4;
    this._lightmapFilterRange = 10;
    this._lightmapFilterSmoothness = 0.2;
    this._clusteredLightingEnabled = true;
    this._lightingParams = new LightingParams(this.device.supportsAreaLights, this.device.maxTextureSize, () => {
      this.updateShaders = true;
    });
    this._sky = new Sky(this);
    this._stats = {
      meshInstances: 0,
      lights: 0,
      dynamicLights: 0,
      bakedLights: 0,
      updateShadersTime: 0
    };
    this.updateShaders = true;
    this._shaderVersion = 0;
    this.immediate = new Immediate(this.device);
  }
  get defaultDrawLayer() {
    return this.layers.getLayerById(LAYERID_IMMEDIATE);
  }
  set ambientBakeNumSamples(value) {
    this._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);
  }
  get ambientBakeNumSamples() {
    return this._ambientBakeNumSamples;
  }
  set ambientBakeSpherePart(value) {
    this._ambientBakeSpherePart = math.clamp(value, 1e-3, 1);
  }
  get ambientBakeSpherePart() {
    return this._ambientBakeSpherePart;
  }
  set clusteredLightingEnabled(value) {
    if (this.device.isWebGPU && !value) {
      return;
    }
    if (!this._clusteredLightingEnabled && value) {
      console.error("Turning on disabled clustered lighting is not currently supported");
      return;
    }
    this._clusteredLightingEnabled = value;
  }
  get clusteredLightingEnabled() {
    return this._clusteredLightingEnabled;
  }
  set envAtlas(value) {
    if (value !== this._envAtlas) {
      this._envAtlas = value;
      if (value) {
        value.addressU = ADDRESS_CLAMP_TO_EDGE;
        value.addressV = ADDRESS_CLAMP_TO_EDGE;
        value.minFilter = FILTER_LINEAR;
        value.magFilter = FILTER_LINEAR;
        value.mipmaps = false;
      }
      this._prefilteredCubemaps = [];
      if (this._internalEnvAtlas) {
        this._internalEnvAtlas.destroy();
        this._internalEnvAtlas = null;
      }
      this._resetSkyMesh();
    }
  }
  get envAtlas() {
    return this._envAtlas;
  }
  set fog(type) {
    if (type !== this._fog) {
      this._fog = type;
      this.updateShaders = true;
    }
  }
  get fog() {
    return this._fog;
  }
  set layers(layers) {
    const prev = this._layers;
    this._layers = layers;
    this.fire("set:layers", prev, layers);
  }
  get layers() {
    return this._layers;
  }
  get sky() {
    return this._sky;
  }
  get lighting() {
    return this._lightingParams;
  }
  get rendering() {
    return this._renderingParams;
  }
  set lightmapFilterRange(value) {
    this._lightmapFilterRange = Math.max(value, 1e-3);
  }
  get lightmapFilterRange() {
    return this._lightmapFilterRange;
  }
  set lightmapFilterSmoothness(value) {
    this._lightmapFilterSmoothness = Math.max(value, 1e-3);
  }
  get lightmapFilterSmoothness() {
    return this._lightmapFilterSmoothness;
  }
  set prefilteredCubemaps(value) {
    value = value || [];
    const cubemaps = this._prefilteredCubemaps;
    const changed = cubemaps.length !== value.length || cubemaps.some((c2, i) => c2 !== value[i]);
    if (changed) {
      const complete = value.length === 6 && value.every((c2) => !!c2);
      if (complete) {
        this._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(value, {
          target: this._internalEnvAtlas
        });
        this._envAtlas = this._internalEnvAtlas;
      } else {
        if (this._internalEnvAtlas) {
          this._internalEnvAtlas.destroy();
          this._internalEnvAtlas = null;
        }
        this._envAtlas = null;
      }
      this._prefilteredCubemaps = value.slice();
      this._resetSkyMesh();
    }
  }
  get prefilteredCubemaps() {
    return this._prefilteredCubemaps;
  }
  set skybox(value) {
    if (value !== this._skyboxCubeMap) {
      this._skyboxCubeMap = value;
      this._resetSkyMesh();
    }
  }
  get skybox() {
    return this._skyboxCubeMap;
  }
  set skyboxIntensity(value) {
    if (value !== this._skyboxIntensity) {
      this._skyboxIntensity = value;
      this._resetSkyMesh();
    }
  }
  get skyboxIntensity() {
    return this._skyboxIntensity;
  }
  set skyboxLuminance(value) {
    if (value !== this._skyboxLuminance) {
      this._skyboxLuminance = value;
      this._resetSkyMesh();
    }
  }
  get skyboxLuminance() {
    return this._skyboxLuminance;
  }
  set skyboxMip(value) {
    if (value !== this._skyboxMip) {
      this._skyboxMip = value;
      this._resetSkyMesh();
    }
  }
  get skyboxMip() {
    return this._skyboxMip;
  }
  set skyboxRotation(value) {
    if (!this._skyboxRotation.equals(value)) {
      const isIdentity = value.equals(Quat.IDENTITY);
      this._skyboxRotation.copy(value);
      if (isIdentity) {
        this._skyboxRotationMat3.setIdentity();
      } else {
        this._skyboxRotationMat4.setTRS(Vec3.ZERO, value, Vec3.ONE);
        this._skyboxRotationMat3.invertMat4(this._skyboxRotationMat4);
      }
      if (!this._skyboxRotationShaderInclude && !isIdentity) {
        this._skyboxRotationShaderInclude = true;
        this._resetSkyMesh();
      }
    }
  }
  get skyboxRotation() {
    return this._skyboxRotation;
  }
  destroy() {
    this._resetSkyMesh();
    this.root = null;
    this.off();
  }
  drawLine(start, end, color = Color.WHITE, depthTest = true, layer = this.defaultDrawLayer) {
    const batch = this.immediate.getBatch(layer, depthTest);
    batch.addLines([start, end], [color, color]);
  }
  drawLines(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {
    const batch = this.immediate.getBatch(layer, depthTest);
    batch.addLines(positions, colors);
  }
  drawLineArrays(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {
    const batch = this.immediate.getBatch(layer, depthTest);
    batch.addLinesArrays(positions, colors);
  }
  applySettings(settings) {
    var _render$skyboxIntensi, _render$skyboxLuminan, _render$skyboxMip, _render$clusteredLigh;
    const physics = settings.physics;
    const render = settings.render;
    this._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);
    this.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);
    this.ambientLuminance = render.ambientLuminance;
    this._fog = render.fog;
    this.fogColor.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);
    this.fogStart = render.fog_start;
    this.fogEnd = render.fog_end;
    this.fogDensity = render.fog_density;
    this._renderingParams.gammaCorrection = render.gamma_correction;
    this._renderingParams.toneMapping = render.tonemapping;
    this.lightmapSizeMultiplier = render.lightmapSizeMultiplier;
    this.lightmapMaxResolution = render.lightmapMaxResolution;
    this.lightmapMode = render.lightmapMode;
    this.exposure = render.exposure;
    this._skyboxIntensity = (_render$skyboxIntensi = render.skyboxIntensity) != null ? _render$skyboxIntensi : 1;
    this._skyboxLuminance = (_render$skyboxLuminan = render.skyboxLuminance) != null ? _render$skyboxLuminan : 2e4;
    this._skyboxMip = (_render$skyboxMip = render.skyboxMip) != null ? _render$skyboxMip : 0;
    if (render.skyboxRotation) {
      this.skyboxRotation = new Quat().setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);
    }
    this.sky.applySettings(render);
    this.clusteredLightingEnabled = (_render$clusteredLigh = render.clusteredLightingEnabled) != null ? _render$clusteredLigh : false;
    this.lighting.applySettings(render);
    ["lightmapFilterEnabled", "lightmapFilterRange", "lightmapFilterSmoothness", "ambientBake", "ambientBakeNumSamples", "ambientBakeSpherePart", "ambientBakeOcclusionBrightness", "ambientBakeOcclusionContrast"].forEach((setting) => {
      if (render.hasOwnProperty(setting)) {
        this[setting] = render[setting];
      }
    });
    this._resetSkyMesh();
  }
  _getSkyboxTex() {
    const cubemaps = this._prefilteredCubemaps;
    if (this._skyboxMip) {
      const skyboxMapping = [0, 1, 3, 4, 5, 6];
      return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;
    }
    return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;
  }
  _updateSkyMesh() {
    if (!this.sky.skyMesh) {
      this.sky.updateSkyMesh();
    }
    this.sky.update();
  }
  _resetSkyMesh() {
    this.sky.resetSkyMesh();
    this.updateShaders = true;
  }
  setSkybox(cubemaps) {
    if (!cubemaps) {
      this.skybox = null;
      this.envAtlas = null;
    } else {
      this.skybox = cubemaps[0] || null;
      if (cubemaps[1] && !cubemaps[1].cubemap) {
        this.envAtlas = cubemaps[1];
      } else {
        this.prefilteredCubemaps = cubemaps.slice(1);
      }
    }
  }
  get lightmapPixelFormat() {
    return this.lightmapHDR && this.device.getRenderableHdrFormat() || PIXELFORMAT_RGBA8;
  }
};
Scene.EVENT_SETLAYERS = "set:layers";
Scene.EVENT_SETSKYBOX = "set:skybox";

// ../node_modules/playcanvas/build/playcanvas/src/scene/skin.js
var Skin = class {
  constructor(graphicsDevice, ibp, boneNames) {
    this.device = graphicsDevice;
    this.inverseBindPose = ibp;
    this.boneNames = boneNames;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/sprite.js
var spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
var spriteIndices = [0, 1, 3, 2, 3, 1];
var Sprite = class extends EventHandler {
  constructor(device, options2) {
    super();
    this._device = device;
    this._pixelsPerUnit = options2 && options2.pixelsPerUnit !== void 0 ? options2.pixelsPerUnit : 1;
    this._renderMode = options2 && options2.renderMode !== void 0 ? options2.renderMode : SPRITE_RENDERMODE_SIMPLE;
    this._atlas = options2 && options2.atlas !== void 0 ? options2.atlas : null;
    this._frameKeys = options2 && options2.frameKeys !== void 0 ? options2.frameKeys : null;
    this._meshes = [];
    this._updatingProperties = false;
    this._meshesDirty = false;
    if (this._atlas && this._frameKeys) {
      this._createMeshes();
    }
  }
  set frameKeys(value) {
    this._frameKeys = value;
    if (this._atlas && this._frameKeys) {
      if (this._updatingProperties) {
        this._meshesDirty = true;
      } else {
        this._createMeshes();
      }
    }
    this.fire("set:frameKeys", value);
  }
  get frameKeys() {
    return this._frameKeys;
  }
  set atlas(value) {
    if (value === this._atlas) return;
    if (this._atlas) {
      this._atlas.off("set:frames", this._onSetFrames, this);
      this._atlas.off("set:frame", this._onFrameChanged, this);
      this._atlas.off("remove:frame", this._onFrameRemoved, this);
    }
    this._atlas = value;
    if (this._atlas && this._frameKeys) {
      this._atlas.on("set:frames", this._onSetFrames, this);
      this._atlas.on("set:frame", this._onFrameChanged, this);
      this._atlas.on("remove:frame", this._onFrameRemoved, this);
      if (this._updatingProperties) {
        this._meshesDirty = true;
      } else {
        this._createMeshes();
      }
    }
    this.fire("set:atlas", value);
  }
  get atlas() {
    return this._atlas;
  }
  set pixelsPerUnit(value) {
    if (this._pixelsPerUnit === value) return;
    this._pixelsPerUnit = value;
    this.fire("set:pixelsPerUnit", value);
    if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
      if (this._updatingProperties) {
        this._meshesDirty = true;
      } else {
        this._createMeshes();
      }
    }
  }
  get pixelsPerUnit() {
    return this._pixelsPerUnit;
  }
  set renderMode(value) {
    if (this._renderMode === value) {
      return;
    }
    const prev = this._renderMode;
    this._renderMode = value;
    this.fire("set:renderMode", value);
    if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
      if (this._atlas && this._frameKeys) {
        if (this._updatingProperties) {
          this._meshesDirty = true;
        } else {
          this._createMeshes();
        }
      }
    }
  }
  get renderMode() {
    return this._renderMode;
  }
  get meshes() {
    return this._meshes;
  }
  _createMeshes() {
    const len = this._meshes.length;
    for (let i = 0; i < len; i++) {
      const mesh = this._meshes[i];
      if (mesh) {
        mesh.destroy();
      }
    }
    const count = this._frameKeys.length;
    this._meshes = new Array(count);
    const createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;
    for (let i = 0; i < count; i++) {
      const frame = this._atlas.frames[this._frameKeys[i]];
      this._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;
    }
    this.fire("set:meshes");
  }
  _createSimpleMesh(frame) {
    const rect = frame.rect;
    const texWidth = this._atlas.texture.width;
    const texHeight = this._atlas.texture.height;
    const w = rect.z / this._pixelsPerUnit;
    const h2 = rect.w / this._pixelsPerUnit;
    const hp = frame.pivot.x;
    const vp = frame.pivot.y;
    const positions = [-hp * w, -vp * h2, 0, (1 - hp) * w, -vp * h2, 0, (1 - hp) * w, (1 - vp) * h2, 0, -hp * w, (1 - vp) * h2, 0];
    const lu = rect.x / texWidth;
    const bv = 1 - rect.y / texHeight;
    const ru = (rect.x + rect.z) / texWidth;
    const tv = 1 - (rect.y + rect.w) / texHeight;
    const uvs = [lu, bv, ru, bv, ru, tv, lu, tv];
    const geom = new Geometry();
    geom.positions = positions;
    geom.normals = spriteNormals;
    geom.uvs = uvs;
    geom.indices = spriteIndices;
    return Mesh.fromGeometry(this._device, geom);
  }
  _create9SliceMesh() {
    const he = Vec2.ONE;
    const ws = 3;
    const ls = 3;
    const positions = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    let vcounter = 0;
    for (let i = 0; i <= ws; i++) {
      const u = i === 0 || i === ws ? 0 : 1;
      for (let j = 0; j <= ls; j++) {
        const x2 = -he.x + 2 * he.x * (i <= 1 ? 0 : 3) / ws;
        const y2 = 0;
        const z2 = -(-he.y + 2 * he.y * (j <= 1 ? 0 : 3) / ls);
        const v = j === 0 || j === ls ? 0 : 1;
        positions.push(-x2, y2, z2);
        normals.push(0, 1, 0);
        uvs.push(u, v);
        if (i < ws && j < ls) {
          indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
          indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
        }
        vcounter++;
      }
    }
    const geom = new Geometry();
    geom.positions = positions;
    geom.normals = normals;
    geom.uvs = uvs;
    geom.indices = indices;
    return Mesh.fromGeometry(this._device, geom);
  }
  _onSetFrames(frames) {
    if (this._updatingProperties) {
      this._meshesDirty = true;
    } else {
      this._createMeshes();
    }
  }
  _onFrameChanged(frameKey, frame) {
    const idx = this._frameKeys.indexOf(frameKey);
    if (idx < 0) return;
    if (frame) {
      if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
        this._meshes[idx] = this._createSimpleMesh(frame);
      }
    } else {
      this._meshes[idx] = null;
    }
    this.fire("set:meshes");
  }
  _onFrameRemoved(frameKey) {
    const idx = this._frameKeys.indexOf(frameKey);
    if (idx < 0) return;
    this._meshes[idx] = null;
    this.fire("set:meshes");
  }
  startUpdate() {
    this._updatingProperties = true;
    this._meshesDirty = false;
  }
  endUpdate() {
    this._updatingProperties = false;
    if (this._meshesDirty && this._atlas && this._frameKeys) {
      this._createMeshes();
    }
    this._meshesDirty = false;
  }
  destroy() {
    for (const mesh of this._meshes) {
      if (mesh) {
        mesh.destroy();
      }
    }
    this._meshes.length = 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/texture-atlas.js
var TextureAtlas = class extends EventHandler {
  constructor() {
    super();
    this._texture = null;
    this._frames = null;
  }
  set texture(value) {
    this._texture = value;
    this.fire("set:texture", value);
  }
  get texture() {
    return this._texture;
  }
  set frames(value) {
    this._frames = value;
    this.fire("set:frames", value);
  }
  get frames() {
    return this._frames;
  }
  setFrame(key, data2) {
    let frame = this._frames[key];
    if (!frame) {
      frame = {
        rect: data2.rect.clone(),
        pivot: data2.pivot.clone(),
        border: data2.border.clone()
      };
      this._frames[key] = frame;
    } else {
      frame.rect.copy(data2.rect);
      frame.pivot.copy(data2.pivot);
      frame.border.copy(data2.border);
    }
    this.fire("set:frame", key.toString(), frame);
  }
  removeFrame(key) {
    const frame = this._frames[key];
    if (frame) {
      delete this._frames[key];
      this.fire("remove:frame", key.toString(), frame);
    }
  }
  destroy() {
    if (this._texture) {
      this._texture.destroy();
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/animation/animation.js
var Key = class {
  constructor(time, position3, rotation2, scale2) {
    this.time = time;
    this.position = position3;
    this.rotation = rotation2;
    this.scale = scale2;
  }
};
var Node = class {
  constructor() {
    this._name = "";
    this._keys = [];
  }
};
var Animation = class {
  constructor() {
    this.name = "";
    this.duration = 0;
    this._nodes = [];
    this._nodeDict = {};
  }
  getNode(name) {
    return this._nodeDict[name];
  }
  addNode(node) {
    this._nodes.push(node);
    this._nodeDict[node._name] = node;
  }
  get nodes() {
    return this._nodes;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/animation/skeleton.js
var InterpolatedKey = class {
  constructor() {
    this._written = false;
    this._name = "";
    this._keyFrames = [];
    this._quat = new Quat();
    this._pos = new Vec3();
    this._scale = new Vec3();
    this._targetNode = null;
  }
  getTarget() {
    return this._targetNode;
  }
  setTarget(node) {
    this._targetNode = node;
  }
};
var Skeleton = class {
  constructor(graph) {
    this.looping = true;
    this._animation = null;
    this._time = 0;
    this._interpolatedKeys = [];
    this._interpolatedKeyDict = {};
    this._currKeyIndices = {};
    this.graph = null;
    const addInterpolatedKeys = (node) => {
      const interpKey = new InterpolatedKey();
      interpKey._name = node.name;
      this._interpolatedKeys.push(interpKey);
      this._interpolatedKeyDict[node.name] = interpKey;
      this._currKeyIndices[node.name] = 0;
      for (let i = 0; i < node._children.length; i++) {
        addInterpolatedKeys(node._children[i]);
      }
    };
    addInterpolatedKeys(graph);
  }
  set animation(value) {
    this._animation = value;
    this.currentTime = 0;
  }
  get animation() {
    return this._animation;
  }
  set currentTime(value) {
    this._time = value;
    const numNodes = this._interpolatedKeys.length;
    for (let i = 0; i < numNodes; i++) {
      const node = this._interpolatedKeys[i];
      const nodeName = node._name;
      this._currKeyIndices[nodeName] = 0;
    }
    this.addTime(0);
    this.updateGraph();
  }
  get currentTime() {
    return this._time;
  }
  get numNodes() {
    return this._interpolatedKeys.length;
  }
  addTime(delta) {
    if (this._animation !== null) {
      const nodes = this._animation._nodes;
      const duration = this._animation.duration;
      if (this._time === duration && !this.looping) {
        return;
      }
      this._time += delta;
      if (this._time > duration) {
        this._time = this.looping ? 0 : duration;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          const nodeName = node._name;
          this._currKeyIndices[nodeName] = 0;
        }
      } else if (this._time < 0) {
        this._time = this.looping ? duration : 0;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          const nodeName = node._name;
          this._currKeyIndices[nodeName] = node._keys.length - 2;
        }
      }
      const offset = delta >= 0 ? 1 : -1;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const nodeName = node._name;
        const keys = node._keys;
        const interpKey = this._interpolatedKeyDict[nodeName];
        if (interpKey === void 0) {
          continue;
        }
        let foundKey = false;
        if (keys.length !== 1) {
          for (let currKeyIndex = this._currKeyIndices[nodeName]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {
            const k1 = keys[currKeyIndex];
            const k2 = keys[currKeyIndex + 1];
            if (k1.time <= this._time && k2.time >= this._time) {
              const alpha = (this._time - k1.time) / (k2.time - k1.time);
              interpKey._pos.lerp(k1.position, k2.position, alpha);
              interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);
              interpKey._scale.lerp(k1.scale, k2.scale, alpha);
              interpKey._written = true;
              this._currKeyIndices[nodeName] = currKeyIndex;
              foundKey = true;
              break;
            }
          }
        }
        if (keys.length === 1 || !foundKey && this._time === 0 && this.looping) {
          interpKey._pos.copy(keys[0].position);
          interpKey._quat.copy(keys[0].rotation);
          interpKey._scale.copy(keys[0].scale);
          interpKey._written = true;
        }
      }
    }
  }
  blend(skel1, skel2, alpha) {
    const numNodes = this._interpolatedKeys.length;
    for (let i = 0; i < numNodes; i++) {
      const key1 = skel1._interpolatedKeys[i];
      const key2 = skel2._interpolatedKeys[i];
      const dstKey = this._interpolatedKeys[i];
      if (key1._written && key2._written) {
        dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);
        dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);
        dstKey._scale.lerp(key1._scale, key2._scale, alpha);
        dstKey._written = true;
      } else if (key1._written) {
        dstKey._quat.copy(key1._quat);
        dstKey._pos.copy(key1._pos);
        dstKey._scale.copy(key1._scale);
        dstKey._written = true;
      } else if (key2._written) {
        dstKey._quat.copy(key2._quat);
        dstKey._pos.copy(key2._pos);
        dstKey._scale.copy(key2._scale);
        dstKey._written = true;
      }
    }
  }
  setGraph(graph) {
    this.graph = graph;
    if (graph) {
      for (let i = 0; i < this._interpolatedKeys.length; i++) {
        const interpKey = this._interpolatedKeys[i];
        const graphNode = graph.findByName(interpKey._name);
        this._interpolatedKeys[i].setTarget(graphNode);
      }
    } else {
      for (let i = 0; i < this._interpolatedKeys.length; i++) {
        this._interpolatedKeys[i].setTarget(null);
      }
    }
  }
  updateGraph() {
    if (this.graph) {
      for (let i = 0; i < this._interpolatedKeys.length; i++) {
        const interpKey = this._interpolatedKeys[i];
        if (interpKey._written) {
          const transform = interpKey.getTarget();
          transform.localPosition.copy(interpKey._pos);
          transform.localRotation.copy(interpKey._quat);
          transform.localScale.copy(interpKey._scale);
          if (!transform._dirtyLocal) {
            transform._dirtifyLocal();
          }
          interpKey._written = false;
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/post-effect.js
var _viewport3 = new Vec4();
var PostEffect = class {
  constructor(graphicsDevice) {
    this.device = graphicsDevice;
    this.needsDepthBuffer = false;
  }
  render(inputTarget, outputTarget, rect) {
  }
  drawQuad(target2, shader, rect) {
    let viewport2;
    if (rect) {
      const w = target2 ? target2.width : this.device.width;
      const h2 = target2 ? target2.height : this.device.height;
      viewport2 = _viewport3.set(rect.x * w, rect.y * h2, rect.z * w, rect.w * h2);
    }
    this.device.setBlendState(BlendState.NOBLEND);
    drawQuadWithShader(this.device, target2, shader, viewport2);
  }
};
PostEffect.quadVertexShader = `
				attribute vec2 aPosition;
				varying vec2 vUv0;
				void main(void)
				{
						gl_Position = vec4(aPosition, 0.0, 1.0);
						vUv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);
				}
		`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/graphics/render-pass-shader-quad.js
var RenderPassShaderQuad = class _RenderPassShaderQuad extends RenderPass {
  constructor(...args) {
    super(...args);
    this._shader = null;
    this.quadRender = null;
    this.cullMode = CULLFACE_NONE;
    this.blendState = BlendState.NOBLEND;
    this.depthState = DepthState.NODEPTH;
    this.stencilFront = null;
    this.stencilBack = null;
  }
  set shader(shader) {
    var _this$quadRender, _this$_shader;
    (_this$quadRender = this.quadRender) == null || _this$quadRender.destroy();
    this.quadRender = null;
    (_this$_shader = this._shader) == null || _this$_shader.destroy();
    this._shader = shader;
    if (shader) {
      this.quadRender = new QuadRender(shader);
    }
  }
  get shader() {
    return this._shader;
  }
  createQuadShader(name, fs3, shaderDefinitionOptions = {}) {
    return createShaderFromCode(this.device, _RenderPassShaderQuad.quadVertexShader, fs3, name, {
      aPosition: SEMANTIC_POSITION
    }, shaderDefinitionOptions);
  }
  destroy() {
    var _this$shader;
    (_this$shader = this.shader) == null || _this$shader.destroy();
    this.shader = null;
  }
  execute() {
    const device = this.device;
    device.setBlendState(this.blendState);
    device.setCullMode(this.cullMode);
    device.setDepthState(this.depthState);
    device.setStencilState(this.stencilFront, this.stencilBack);
    this.quadRender.render();
  }
};
RenderPassShaderQuad.quadVertexShader = `
				attribute vec2 aPosition;
				varying vec2 uv0;
				void main(void)
				{
						gl_Position = vec4(aPosition, 0.0, 1.0);
						uv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);
				}
		`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/lit-shader-options.js
var LitShaderOptions = class {
  constructor() {
    this.hasTangents = false;
    this.chunks = {};
    this.pass = 0;
    this.alphaTest = false;
    this.blendType = BLEND_NONE;
    this.separateAmbient = false;
    this.screenSpace = false;
    this.skin = false;
    this.batch = false;
    this.useInstancing = false;
    this.useMorphPosition = false;
    this.useMorphNormal = false;
    this.useMorphTextureBasedInt = false;
    this.nineSlicedMode = 0;
    this.clusteredLightingEnabled = true;
    this.clusteredLightingCookiesEnabled = false;
    this.clusteredLightingShadowsEnabled = false;
    this.clusteredLightingShadowType = 0;
    this.clusteredLightingAreaLightsEnabled = false;
    this.vertexColors = false;
    this.lightMapEnabled = false;
    this.dirLightMapEnabled = false;
    this.useHeights = false;
    this.useNormals = false;
    this.useClearCoatNormals = false;
    this.useAo = false;
    this.diffuseMapEnabled = false;
    this.customFragmentShader = null;
    this.pixelSnap = false;
    this.ambientSH = false;
    this.twoSidedLighting = false;
    this.occludeDirect = false;
    this.occludeSpecular = 0;
    this.occludeSpecularFloat = false;
    this.useMsdf = false;
    this.msdfTextAttribute = false;
    this.alphaToCoverage = false;
    this.opacityFadesSpecular = false;
    this.opacityDither = DITHER_NONE;
    this.opacityShadowDither = DITHER_NONE;
    this.cubeMapProjection = 0;
    this.useSpecular = false;
    this.useSpecularityFactor = false;
    this.enableGGXSpecular = false;
    this.fresnelModel = 0;
    this.useRefraction = false;
    this.useClearCoat = false;
    this.useSheen = false;
    this.useIridescence = false;
    this.useMetalness = false;
    this.useDynamicRefraction = false;
    this.dispersion = false;
    this.fog = FOG_NONE;
    this.gamma = GAMMA_NONE;
    this.toneMap = -1;
    this.reflectionSource = null;
    this.reflectionEncoding = null;
    this.reflectionCubemapEncoding = null;
    this.ambientSource = "constant";
    this.ambientEncoding = null;
    this.skyboxIntensity = 1;
    this.useCubeMapRotation = false;
    this.lightMapWithoutAmbient = false;
    this.lights = [];
    this.noShadow = false;
    this.lightMaskDynamic = 0;
    this.userAttributes = {};
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/lit-material-options.js
var LitMaterialOptions = class {
  constructor() {
    this.usedUvs = void 0;
    this.shaderChunk = void 0;
    this.litOptions = new LitShaderOptions();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/lit-material-options-builder.js
var LitMaterialOptionsBuilder = class _LitMaterialOptionsBuilder {
  static update(litOptions, material, scene, renderParams, objDefs, pass, sortedLights) {
    _LitMaterialOptionsBuilder.updateSharedOptions(litOptions, material, scene, objDefs, pass);
    _LitMaterialOptionsBuilder.updateMaterialOptions(litOptions, material);
    _LitMaterialOptionsBuilder.updateEnvOptions(litOptions, material, scene, renderParams);
    _LitMaterialOptionsBuilder.updateLightingOptions(litOptions, material, objDefs, sortedLights);
  }
  static updateSharedOptions(litOptions, material, scene, objDefs, pass) {
    litOptions.chunks = material.chunks;
    litOptions.pass = pass;
    litOptions.alphaTest = material.alphaTest > 0;
    litOptions.blendType = material.blendType;
    litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
    litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
    litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
    litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
    litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
    litOptions.useMorphTextureBasedInt = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0;
    litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
    litOptions.nineSlicedMode = material.nineSlicedMode || SPRITE_RENDERMODE_SIMPLE;
    if (material.useLighting && scene.clusteredLightingEnabled) {
      litOptions.clusteredLightingEnabled = true;
      litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
      litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
      litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
      litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
    } else {
      litOptions.clusteredLightingEnabled = false;
      litOptions.clusteredLightingCookiesEnabled = false;
      litOptions.clusteredLightingShadowsEnabled = false;
      litOptions.clusteredLightingAreaLightsEnabled = false;
    }
  }
  static updateMaterialOptions(litOptions, material) {
    litOptions.separateAmbient = false;
    litOptions.customFragmentShader = null;
    litOptions.pixelSnap = material.pixelSnap;
    litOptions.ambientSH = material.ambientSH;
    litOptions.twoSidedLighting = material.twoSidedLighting;
    litOptions.occludeDirect = material.occludeDirect;
    litOptions.occludeSpecular = material.occludeSpecular;
    litOptions.occludeSpecularFloat = material.occludeSpecularIntensity !== 1;
    litOptions.useMsdf = false;
    litOptions.msdfTextAttribute = false;
    litOptions.alphaToCoverage = material.alphaToCoverage;
    litOptions.opacityFadesSpecular = material.opacityFadesSpecular;
    litOptions.opacityDither = material.opacityDither;
    litOptions.cubeMapProjection = CUBEPROJ_NONE;
    litOptions.useSpecular = material.hasSpecular;
    litOptions.useSpecularityFactor = material.hasSpecularityFactor;
    litOptions.enableGGXSpecular = material.ggxSpecular;
    litOptions.fresnelModel = material.fresnelModel;
    litOptions.useRefraction = material.hasRefraction;
    litOptions.useClearCoat = material.hasClearCoat;
    litOptions.useSheen = material.hasSheen;
    litOptions.useIridescence = material.hasIrridescence;
    litOptions.useMetalness = material.hasMetalness;
    litOptions.useDynamicRefraction = material.dynamicRefraction;
    litOptions.dispersion = material.dispersion > 0;
    litOptions.vertexColors = false;
    litOptions.lightMapEnabled = material.hasLighting;
    litOptions.dirLightMapEnabled = material.dirLightMap;
    litOptions.useHeights = material.hasHeights;
    litOptions.useNormals = material.hasNormals;
    litOptions.useClearCoatNormals = material.hasClearCoatNormals;
    litOptions.useAo = material.hasAo;
    litOptions.diffuseMapEnabled = material.hasDiffuseMap;
  }
  static updateEnvOptions(litOptions, material, scene, renderParams) {
    litOptions.fog = material.useFog ? scene.fog : FOG_NONE;
    litOptions.gamma = renderParams.shaderOutputGamma;
    litOptions.toneMap = material.useTonemap ? renderParams.toneMapping : TONEMAP_NONE;
    if (material.useSkybox && scene.envAtlas && scene.skybox) {
      litOptions.reflectionSource = "envAtlasHQ";
      litOptions.reflectionEncoding = scene.envAtlas.encoding;
      litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
    } else if (material.useSkybox && scene.envAtlas) {
      litOptions.reflectionSource = "envAtlas";
      litOptions.reflectionEncoding = scene.envAtlas.encoding;
    } else if (material.useSkybox && scene.skybox) {
      litOptions.reflectionSource = "cubeMap";
      litOptions.reflectionEncoding = scene.skybox.encoding;
    } else {
      litOptions.reflectionSource = null;
      litOptions.reflectionEncoding = null;
    }
    if (material.ambientSH) {
      litOptions.ambientSource = "ambientSH";
      litOptions.ambientEncoding = null;
    } else if (litOptions.reflectionSource && scene.envAtlas) {
      litOptions.ambientSource = "envAtlas";
      litOptions.ambientEncoding = scene.envAtlas.encoding;
    } else {
      litOptions.ambientSource = "constant";
      litOptions.ambientEncoding = null;
    }
    const hasSkybox = !!litOptions.reflectionSource;
    litOptions.skyboxIntensity = hasSkybox;
    litOptions.useCubeMapRotation = hasSkybox && scene._skyboxRotationShaderInclude;
  }
  static updateLightingOptions(litOptions, material, objDefs, sortedLights) {
    litOptions.lightMapWithoutAmbient = false;
    if (material.useLighting) {
      const lightsFiltered = [];
      const mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
      litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
      litOptions.lightMapWithoutAmbient = false;
      if (sortedLights) {
        _LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
        _LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
        _LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
      }
      litOptions.lights = lightsFiltered;
    } else {
      litOptions.lights = [];
    }
    if (litOptions.lights.length === 0 || (objDefs & SHADERDEF_NOSHADOW) !== 0) {
      litOptions.noShadow = true;
    }
  }
  static collectLights(lType, lights2, lightsFiltered, mask) {
    for (let i = 0; i < lights2.length; i++) {
      const light = lights2[i];
      if (light.enabled) {
        if (light.mask & mask) {
          lightsFiltered.push(light);
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunk-builder.js
var ChunkBuilder = class {
  constructor() {
    this.code = "";
  }
  append(...chunks) {
    chunks.forEach((chunk) => {
      if (chunk.endsWith("\n")) {
        this.code += chunk;
      } else {
        this.code += `${chunk}
`;
      }
    });
  }
  prepend(...chunks) {
    chunks.forEach((chunk) => {
      if (chunk.endsWith("\n")) {
        this.code = chunk + this.code;
      } else {
        this.code = `${chunk}
${this.code}`;
      }
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/lit-shader.js
var builtinAttributes = {
  vertex_normal: SEMANTIC_NORMAL,
  vertex_tangent: SEMANTIC_TANGENT,
  vertex_texCoord0: SEMANTIC_TEXCOORD0,
  vertex_texCoord1: SEMANTIC_TEXCOORD1,
  vertex_color: SEMANTIC_COLOR,
  vertex_boneWeights: SEMANTIC_BLENDWEIGHT,
  vertex_boneIndices: SEMANTIC_BLENDINDICES
};
var builtinVaryings = {
  vVertexColor: "vec4",
  vPositionW: "vec3",
  vNormalV: "vec3",
  vNormalW: "vec3",
  vTangentW: "vec3",
  vBinormalW: "vec3",
  vObjectSpaceUpW: "vec3",
  vUv0: "vec2",
  vUv1: "vec2"
};
var LitShader = class {
  constructor(device, options2) {
    this.device = device;
    this.options = options2;
    this.attributes = {
      vertex_position: SEMANTIC_POSITION
    };
    if (options2.userAttributes) {
      for (const [semantic, name] of Object.entries(options2.userAttributes)) {
        this.attributes[name] = semantic;
      }
    }
    if (options2.chunks) {
      const userChunks = options2.chunks;
      this.chunks = Object.create(shaderChunks);
      for (const chunkName in shaderChunks) {
        if (userChunks.hasOwnProperty(chunkName)) {
          const chunk = userChunks[chunkName];
          for (const a in builtinAttributes) {
            if (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {
              this.attributes[a] = builtinAttributes[a];
            }
          }
          this.chunks[chunkName] = chunk;
        }
      }
    } else {
      this.chunks = shaderChunks;
    }
    this.shaderPassInfo = ShaderPass.get(this.device).getByIndex(options2.pass);
    this.shadowPass = this.shaderPassInfo.isShadow;
    this.lighting = options2.lights.length > 0 || options2.dirLightMapEnabled || options2.clusteredLightingEnabled;
    this.reflections = !!options2.reflectionSource;
    this.needsNormal = this.lighting || this.reflections || options2.useSpecular || options2.ambientSH || options2.useHeights || options2.enableGGXSpecular || options2.clusteredLightingEnabled && !this.shadowPass || options2.useClearCoatNormals;
    this.needsNormal = this.needsNormal && !this.shadowPass;
    this.needsSceneColor = options2.useDynamicRefraction;
    this.needsScreenSize = options2.useDynamicRefraction;
    this.needsTransforms = options2.useDynamicRefraction;
    this.varyings = "";
    this.varyingDefines = "";
    this.vshader = null;
    this.frontendDecl = null;
    this.frontendCode = null;
    this.frontendFunc = null;
    this.lightingUv = null;
    this.defines = [];
    this.fshader = null;
  }
  _vsAddBaseCode(code, chunks, options2) {
    code += chunks.baseVS;
    if (options2.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options2.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
      code += chunks.baseNineSlicedVS;
    }
    return code;
  }
  _setMapTransform(codes, name, id13, uv) {
    const checkId = id13 + uv * 100;
    if (!codes[3][checkId]) {
      const varName = `texture_${name}MapTransform`;
      codes[0] += `uniform vec3 ${varName}0;
`;
      codes[0] += `uniform vec3 ${varName}1;
`;
      codes[1] += `varying vec2 vUV${uv}_${id13};
`;
      codes[2] += `   vUV${uv}_${id13} = vec2(dot(vec3(uv${uv}, 1), ${varName}0), dot(vec3(uv${uv}, 1), ${varName}1));
`;
      codes[3][checkId] = true;
    }
    return codes;
  }
  _fsGetBaseCode() {
    const options2 = this.options;
    const chunks = this.chunks;
    let result = this.chunks.basePS;
    if (options2.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
      result += chunks.baseNineSlicedPS;
    } else if (options2.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
      result += chunks.baseNineSlicedTiledPS;
    }
    return result;
  }
  _fsGetStartCode(code, device, chunks, options2) {
    let result = chunks.startPS;
    if (options2.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
      result += chunks.startNineSlicedPS;
    } else if (options2.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
      result += chunks.startNineSlicedTiledPS;
    }
    return result;
  }
  _getLightSourceShapeString(shape) {
    switch (shape) {
      case LIGHTSHAPE_RECT:
        return "Rect";
      case LIGHTSHAPE_DISK:
        return "Disk";
      case LIGHTSHAPE_SPHERE:
        return "Sphere";
      default:
        return "";
    }
  }
  generateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {
    const device = this.device;
    const options2 = this.options;
    const chunks = this.chunks;
    let code = "";
    let codeBody = "";
    let codeDefines = "";
    code = this._vsAddBaseCode(code, chunks, options2);
    codeBody += "   vPositionW    = getWorldPosition();\n";
    if (this.options.pass === SHADER_DEPTH || this.options.pass === SHADER_PREPASS_VELOCITY) {
      code += "varying float vDepth;\n";
      code += "#ifndef VIEWMATRIX\n";
      code += "#define VIEWMATRIX\n";
      code += "uniform mat4 matrix_view;\n";
      code += "#endif\n";
      code += "#ifndef CAMERAPLANES\n";
      code += "#define CAMERAPLANES\n";
      code += "uniform vec4 camera_params;\n\n";
      code += "#endif\n";
      codeBody += "    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
    }
    if (this.options.pass === SHADER_PREPASS_VELOCITY) ;
    if (this.options.useInstancing) {
      if (this.chunks.transformInstancingVS === shaderChunks.transformInstancingVS) {
        this.attributes.instance_line1 = SEMANTIC_ATTR12;
        this.attributes.instance_line2 = SEMANTIC_ATTR13;
        this.attributes.instance_line3 = SEMANTIC_ATTR14;
        this.attributes.instance_line4 = SEMANTIC_ATTR15;
      }
    }
    code += chunks.transformVS;
    if (this.needsNormal) {
      code += chunks.normalCoreVS;
      code += chunks.normalVS;
    }
    if (this.needsNormal) {
      this.attributes.vertex_normal = SEMANTIC_NORMAL;
      codeBody += "   vNormalW = getNormal();\n";
      if (options2.reflectionSource === "sphereMap" && device.fragmentUniformsCount <= 16) {
        code += chunks.viewNormalVS;
        codeBody += "   vNormalV    = getViewNormal();\n";
      }
      if (options2.hasTangents && (options2.useHeights || options2.useNormals || options2.enableGGXSpecular)) {
        this.attributes.vertex_tangent = SEMANTIC_TANGENT;
        code += chunks.tangentBinormalVS;
        codeBody += "   vTangentW   = getTangent();\n";
        codeBody += "   vBinormalW  = getBinormal();\n";
      } else if (options2.enableGGXSpecular) {
        codeBody += "   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));\n";
      }
    }
    const maxUvSets = 2;
    for (let i = 0; i < maxUvSets; i++) {
      if (useUv[i]) {
        this.attributes[`vertex_texCoord${i}`] = `TEXCOORD${i}`;
        code += chunks[`uv${i}VS`];
        codeBody += `   vec2 uv${i} = getUv${i}();
`;
      }
      if (useUnmodifiedUv[i]) {
        codeBody += `   vUv${i} = uv${i};
`;
      }
    }
    const codes = [code, this.varyings, codeBody, []];
    mapTransforms.forEach((mapTransform) => {
      this._setMapTransform(codes, mapTransform.name, mapTransform.id, mapTransform.uv);
    });
    code = codes[0];
    this.varyings = codes[1];
    codeBody = codes[2];
    if (options2.vertexColors) {
      this.attributes.vertex_color = SEMANTIC_COLOR;
      codeBody += "   vVertexColor = vertex_color;\n";
    }
    if (options2.useMsdf && options2.msdfTextAttribute) {
      this.attributes.vertex_outlineParameters = SEMANTIC_ATTR8;
      this.attributes.vertex_shadowParameters = SEMANTIC_ATTR9;
      codeBody += "    unpackMsdfParams();\n";
      code += chunks.msdfVS;
    }
    if (options2.useMorphPosition || options2.useMorphNormal) {
      codeDefines += "#define MORPHING\n";
      if (options2.useMorphTextureBasedInt) {
        codeDefines += "#define MORPHING_INT\n";
      }
      if (options2.useMorphPosition) {
        codeDefines += "#define MORPHING_POSITION\n";
      }
      if (options2.useMorphNormal) {
        codeDefines += "#define MORPHING_NORMAL\n";
      }
      this.attributes.morph_vertex_id = SEMANTIC_ATTR15;
    }
    if (options2.skin) {
      this.attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
      if (options2.batch) {
        codeDefines += "#define BATCH\n";
      } else {
        this.attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
        codeDefines += "#define SKIN\n";
      }
    } else if (options2.useInstancing) {
      codeDefines += "#define INSTANCING\n";
    }
    if (options2.screenSpace) {
      codeDefines += "#define SCREENSPACE\n";
    }
    if (options2.pixelSnap) {
      codeDefines += "#define PIXELSNAP\n";
    }
    code += "\n";
    code += chunks.startVS;
    code += codeBody;
    code += chunks.endVS;
    code += "}";
    Object.keys(builtinVaryings).forEach((v) => {
      if (code.indexOf(v) >= 0) {
        this.varyings += `varying ${builtinVaryings[v]} ${v};
`;
        this.varyingDefines += `#define VARYING_${v.toUpperCase()}
`;
      }
    });
    const shaderPassDefines = this.shaderPassInfo.shaderDefines;
    this.vshader = shaderPassDefines + codeDefines + this.varyings + code;
  }
  _fsGetBeginCode() {
    let code = this.shaderPassInfo.shaderDefines;
    for (let i = 0; i < this.defines.length; i++) {
      code += `#define ${this.defines[i]}
`;
    }
    return code;
  }
  _fsGetPickPassCode() {
    return `
						${this._fsGetBeginCode()}
						${this.varyings}
						${this.varyingDefines}
						${this.frontendDecl}
						${this.frontendCode}
						${this.chunks.pickPS}

						void main(void) {
								${this.frontendFunc}
								gl_FragColor = getPickOutput();
						}
				`;
  }
  _fsGetDepthPassCode() {
    const chunks = this.chunks;
    let code = this._fsGetBeginCode();
    code += "varying float vDepth;\n";
    code += this.varyings;
    code += this.varyingDefines;
    code += chunks.packDepthPS;
    code += this.frontendDecl;
    code += this.frontendCode;
    code += ShaderGenerator.begin();
    code += this.frontendFunc;
    code += "    gl_FragColor = packFloat(vDepth);\n";
    code += ShaderGenerator.end();
    return code;
  }
  _fsGetPrePassVelocityCode() {
    return this._fsGetDepthPassCode();
  }
  _fsGetShadowPassCode() {
    const options2 = this.options;
    const chunks = this.chunks;
    const varyings = this.varyings;
    const lightType = this.shaderPassInfo.lightType;
    let shadowType = this.shaderPassInfo.shadowType;
    if (lightType !== LIGHTTYPE_DIRECTIONAL && options2.clusteredLightingEnabled) {
      if (shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32 || shadowType === SHADOW_PCSS) {
        shadowType = SHADOW_PCF3;
      }
    }
    let code = this._fsGetBeginCode();
    if (shadowType === SHADOW_VSM32) {
      code += "#define VSM_EXPONENT 15.0\n\n";
    } else if (shadowType === SHADOW_VSM16) {
      code += "#define VSM_EXPONENT 5.54\n\n";
    }
    if (lightType !== LIGHTTYPE_DIRECTIONAL) {
      code += "uniform vec3 view_position;\n";
      code += "uniform float light_radius;\n";
    }
    code += varyings;
    code += this.varyingDefines;
    code += this.frontendDecl;
    code += this.frontendCode;
    const usePackedDepth = lightType === LIGHTTYPE_OMNI && shadowType !== SHADOW_PCSS && !options2.clusteredLightingEnabled;
    if (usePackedDepth) {
      code += chunks.packDepthPS;
    } else if (shadowType === SHADOW_VSM8) {
      code += "vec2 encodeFloatRG( float v ) {\n";
      code += "    vec2 enc = vec2(1.0, 255.0) * v;\n";
      code += "    enc = fract(enc);\n";
      code += "    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
      code += "    return enc;\n";
      code += "}\n\n";
    }
    if (shadowType === SHADOW_PCSS) {
      code += shaderChunks.linearizeDepthPS;
    }
    code += ShaderGenerator.begin();
    code += this.frontendFunc;
    const isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;
    const usePerspectiveDepth = lightType === LIGHTTYPE_DIRECTIONAL || !isVsm && lightType === LIGHTTYPE_SPOT;
    let hasModifiedDepth = false;
    if (usePerspectiveDepth) {
      code += "    float depth = gl_FragCoord.z;\n";
    } else {
      code += "    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
      hasModifiedDepth = true;
    }
    if (usePackedDepth) {
      code += "    gl_FragColor = packFloat(depth);\n";
    } else if (!isVsm) {
      const exportR32 = shadowType === SHADOW_PCSS;
      if (exportR32) {
        code += "    gl_FragColor.r = depth;\n";
      } else {
        if (hasModifiedDepth) {
          code += "    gl_FragDepth = depth;\n";
        }
        code += "    gl_FragColor = vec4(1.0);\n";
      }
    } else if (shadowType === SHADOW_VSM8) {
      code += "    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
    } else {
      code += chunks.storeEVSMPS;
    }
    code += ShaderGenerator.end();
    return code;
  }
  _fsGetLitPassCode() {
    const device = this.device;
    const options2 = this.options;
    const chunks = this.chunks;
    const decl = new ChunkBuilder();
    const func = new ChunkBuilder();
    const backend = new ChunkBuilder();
    const code = new ChunkBuilder();
    if (options2.opacityFadesSpecular === false) {
      decl.append("uniform float material_alphaFade;");
    }
    if (options2.useSpecular) {
      this.defines.push("LIT_SPECULAR");
      if (this.reflections) {
        this.defines.push("LIT_REFLECTIONS");
      }
      if (options2.useClearCoat) {
        this.defines.push("LIT_CLEARCOAT");
      }
      if (options2.fresnelModel > 0) {
        this.defines.push("LIT_SPECULAR_FRESNEL");
      }
      if (options2.useSheen) {
        this.defines.push("LIT_SHEEN");
      }
      if (options2.useIridescence) {
        this.defines.push("LIT_IRIDESCENCE");
      }
    }
    const shadowTypeUsed = [];
    let numShadowLights = 0;
    let shadowedDirectionalLightUsed = false;
    let useVsm = false;
    let usePcss = false;
    let hasAreaLights = options2.lights.some((light) => {
      return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
    });
    if (options2.clusteredLightingEnabled && options2.clusteredLightingAreaLightsEnabled) {
      hasAreaLights = true;
    }
    if (hasAreaLights || options2.clusteredLightingEnabled) {
      decl.append("#define AREA_LIGHTS");
      decl.append("uniform highp sampler2D areaLightsLutTex1;");
      decl.append("uniform highp sampler2D areaLightsLutTex2;");
    }
    for (let i = 0; i < options2.lights.length; i++) {
      const light = options2.lights[i];
      const lightType = light._type;
      if (options2.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
        continue;
      }
      const lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;
      decl.append(`uniform vec3 light${i}_color;`);
      if (light._shadowType === SHADOW_PCSS && light.castShadows && !options2.noShadow) {
        decl.append(`uniform float light${i}_shadowSearchArea;`);
        decl.append(`uniform vec4 light${i}_cameraParams;`);
      }
      if (lightType === LIGHTTYPE_DIRECTIONAL) {
        decl.append(`uniform vec3 light${i}_direction;`);
      } else {
        decl.append(`uniform vec3 light${i}_position;`);
        decl.append(`uniform float light${i}_radius;`);
        if (lightType === LIGHTTYPE_SPOT) {
          decl.append(`uniform vec3 light${i}_direction;`);
          decl.append(`uniform float light${i}_innerConeAngle;`);
          decl.append(`uniform float light${i}_outerConeAngle;`);
        }
      }
      if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
        if (lightType === LIGHTTYPE_DIRECTIONAL) {
          decl.append(`uniform vec3 light${i}_position;`);
        }
        decl.append(`uniform vec3 light${i}_halfWidth;`);
        decl.append(`uniform vec3 light${i}_halfHeight;`);
      }
      if (light.castShadows && !options2.noShadow) {
        decl.append(`uniform mat4 light${i}_shadowMatrix;`);
        decl.append(`uniform float light${i}_shadowIntensity;`);
        if (lightType === LIGHTTYPE_DIRECTIONAL) {
          decl.append(`uniform mat4 light${i}_shadowMatrixPalette[4];`);
          decl.append(`uniform float light${i}_shadowCascadeDistances[4];`);
          decl.append(`uniform float light${i}_shadowCascadeCount;`);
        }
        decl.append(`uniform vec4 light${i}_shadowParams;`);
        if (lightType === LIGHTTYPE_DIRECTIONAL) {
          shadowedDirectionalLightUsed = true;
        }
        if (lightType === LIGHTTYPE_OMNI) {
          decl.append(`uniform samplerCube light${i}_shadowMap;`);
        } else {
          if (light._isPcf) {
            decl.append(`uniform sampler2DShadow light${i}_shadowMap;`);
          } else {
            decl.append(`uniform sampler2D light${i}_shadowMap;`);
          }
        }
        numShadowLights++;
        shadowTypeUsed[light._shadowType] = true;
        if (light._isVsm) useVsm = true;
        if (light._shadowType === SHADOW_PCSS) usePcss = true;
      }
      if (light._cookie) {
        if (light._cookie._cubemap) {
          if (lightType === LIGHTTYPE_OMNI) {
            decl.append(`uniform samplerCube light${i}_cookie;`);
            decl.append(`uniform float light${i}_cookieIntensity;`);
            if (!light.castShadows || options2.noShadow) {
              decl.append(`uniform mat4 light${i}_shadowMatrix;`);
            }
          }
        } else {
          if (lightType === LIGHTTYPE_SPOT) {
            decl.append(`uniform sampler2D light${i}_cookie;`);
            decl.append(`uniform float light${i}_cookieIntensity;`);
            if (!light.castShadows || options2.noShadow) {
              decl.append(`uniform mat4 light${i}_shadowMatrix;`);
            }
            if (light._cookieTransform) {
              decl.append(`uniform vec4 light${i}_cookieMatrix;`);
              decl.append(`uniform vec2 light${i}_cookieOffset;`);
            }
          }
        }
      }
    }
    const hasTBN = this.needsNormal && (options2.useNormals || options2.useClearCoatNormals || options2.enableGGXSpecular && !options2.useHeights);
    if (hasTBN) {
      if (options2.hasTangents) {
        func.append(chunks.TBNPS);
      } else {
        if (options2.useNormals || options2.useClearCoatNormals) {
          func.append(chunks.TBNderivativePS.replace(/\$UV/g, this.lightingUv));
        } else {
          func.append(chunks.TBNObjectSpacePS);
        }
      }
      if (options2.twoSidedLighting) {
        func.append(chunks.twoSidedLightingPS);
      }
    }
    func.append(chunks.sphericalPS);
    func.append(chunks.decodePS);
    func.append(ShaderGenerator.gammaCode(options2.gamma, chunks));
    func.append(ShaderGenerator.tonemapCode(options2.toneMap, chunks));
    func.append(ShaderGenerator.fogCode(options2.fog, chunks));
    func.append(this.frontendCode);
    if (options2.useCubeMapRotation) {
      decl.append("#define CUBEMAP_ROTATION");
    }
    if (this.needsNormal) {
      func.append(chunks.cubeMapRotatePS);
      func.append(options2.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS);
      func.append(options2.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS);
    }
    if (this.lighting && options2.useSpecular || this.reflections) {
      if (options2.useMetalness) {
        func.append(chunks.metalnessModulatePS);
      }
      if (options2.fresnelModel === FRESNEL_SCHLICK) {
        func.append(chunks.fresnelSchlickPS);
      }
      if (options2.useIridescence) {
        func.append(chunks.iridescenceDiffractionPS);
      }
    }
    if (options2.useAo) {
      func.append(chunks.aoDiffuseOccPS);
      switch (options2.occludeSpecular) {
        case SPECOCC_AO:
          func.append(options2.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS);
          break;
        case SPECOCC_GLOSSDEPENDENT:
          func.append(options2.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS);
          break;
      }
    }
    if (options2.reflectionSource === "envAtlasHQ") {
      func.append(chunks.envAtlasPS);
      func.append(chunks.reflectionEnvHQPS.replace(/\$DECODE_CUBEMAP/g, ChunkUtils.decodeFunc(options2.reflectionCubemapEncoding)).replace(/\$DECODE/g, ChunkUtils.decodeFunc(options2.reflectionEncoding)));
    } else if (options2.reflectionSource === "envAtlas") {
      func.append(chunks.envAtlasPS);
      func.append(chunks.reflectionEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options2.reflectionEncoding)));
    } else if (options2.reflectionSource === "cubeMap") {
      func.append(chunks.reflectionCubePS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options2.reflectionEncoding)));
    } else if (options2.reflectionSource === "sphereMap") {
      func.append(chunks.reflectionSpherePS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options2.reflectionEncoding)));
    }
    if (this.reflections) {
      if (options2.useClearCoat) {
        func.append(chunks.reflectionCCPS);
      }
      if (options2.useSheen) {
        func.append(chunks.reflectionSheenPS);
      }
    }
    if (options2.useRefraction) {
      if (options2.useDynamicRefraction) {
        if (options2.dispersion) {
          decl.append("uniform float material_dispersion;");
          decl.append("#define DISPERSION\n");
        }
        func.append(chunks.refractionDynamicPS);
      } else if (this.reflections) {
        func.append(chunks.refractionCubePS);
      }
    }
    if (options2.useSheen) {
      func.append(chunks.lightSheenPS);
    }
    if (options2.clusteredLightingEnabled) {
      func.append(chunks.clusteredLightUtilsPS);
      if (options2.clusteredLightingCookiesEnabled) {
        func.append(chunks.clusteredLightCookiesPS);
      }
      if (options2.clusteredLightingShadowsEnabled && !options2.noShadow) {
        shadowTypeUsed[SHADOW_PCF3] = true;
        shadowTypeUsed[SHADOW_PCF5] = true;
        shadowTypeUsed[SHADOW_PCSS] = true;
      }
    }
    if (numShadowLights > 0 || options2.clusteredLightingEnabled) {
      if (shadowedDirectionalLightUsed) {
        func.append(chunks.shadowCascadesPS);
      }
      if (shadowTypeUsed[SHADOW_PCF1] || shadowTypeUsed[SHADOW_PCF3]) {
        func.append(chunks.shadowStandardPS);
      }
      if (shadowTypeUsed[SHADOW_PCF5]) {
        func.append(chunks.shadowStandardGL2PS);
      }
      if (useVsm) {
        func.append(chunks.shadowVSM_commonPS);
        if (shadowTypeUsed[SHADOW_VSM8]) {
          func.append(chunks.shadowVSM8PS);
        }
        if (shadowTypeUsed[SHADOW_VSM16]) {
          func.append(chunks.shadowEVSMPS.replace(/\$/g, "16"));
        }
        if (shadowTypeUsed[SHADOW_VSM32]) {
          func.append(device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32"));
        }
      }
      if (usePcss) {
        func.append(chunks.linearizeDepthPS);
        func.append(chunks.shadowPCSSPS);
      }
    }
    if (options2.enableGGXSpecular) func.append("uniform float material_anisotropy;");
    if (this.lighting) {
      func.append(chunks.lightDiffuseLambertPS);
      if (hasAreaLights || options2.clusteredLightingAreaLightsEnabled) {
        func.append(chunks.ltcPS);
      }
    }
    let useOldAmbient = false;
    if (options2.useSpecular) {
      if (this.lighting) {
        func.append(options2.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS);
      }
      if (!options2.fresnelModel && !this.reflections && !options2.diffuseMapEnabled) {
        decl.append("uniform vec3 material_ambient;");
        decl.append("#define LIT_OLD_AMBIENT");
        useOldAmbient = true;
      }
    }
    func.append(chunks.combinePS);
    if (options2.lightMapEnabled) {
      func.append(options2.useSpecular && options2.dirLightMapEnabled ? chunks.lightmapDirAddPS : chunks.lightmapAddPS);
    }
    const addAmbient = !options2.lightMapEnabled || options2.lightMapWithoutAmbient;
    if (addAmbient) {
      if (options2.ambientSource === "ambientSH") {
        func.append(chunks.ambientSHPS);
      } else if (options2.ambientSource === "envAtlas") {
        if (options2.reflectionSource !== "envAtlas" && options2.reflectionSource !== "envAtlasHQ") {
          func.append(chunks.envAtlasPS);
        }
        func.append(chunks.ambientEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options2.ambientEncoding)));
      } else {
        func.append(chunks.ambientConstantPS);
      }
    }
    if (!useOldAmbient) {
      decl.append("uniform vec3 material_ambient;");
    }
    if (options2.useMsdf) {
      if (!options2.msdfTextAttribute) {
        decl.append("#define UNIFORM_TEXT_PARAMETERS");
      }
      func.append(chunks.msdfPS);
    }
    if (this.needsNormal) {
      func.append(chunks.viewDirPS);
      if (options2.useSpecular) {
        func.append(options2.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS);
      }
    }
    let hasPointLights = false;
    let usesLinearFalloff = false;
    let usesInvSquaredFalloff = false;
    let usesSpot = false;
    let usesCookie = false;
    let usesCookieNow;
    if (options2.clusteredLightingEnabled && this.lighting) {
      usesSpot = true;
      hasPointLights = true;
      usesLinearFalloff = true;
      usesCookie = true;
      func.append(chunks.floatUnpackingPS);
      if (options2.lightMaskDynamic) {
        decl.append("#define CLUSTER_MESH_DYNAMIC_LIGHTS");
      }
      if (options2.clusteredLightingCookiesEnabled) {
        decl.append("#define CLUSTER_COOKIES");
      }
      if (options2.clusteredLightingShadowsEnabled && !options2.noShadow) {
        decl.append("#define CLUSTER_SHADOWS");
        decl.append(`#define CLUSTER_SHADOW_TYPE_${shadowTypeToString[options2.clusteredLightingShadowType]}`);
      }
      if (options2.clusteredLightingAreaLightsEnabled) {
        decl.append("#define CLUSTER_AREALIGHTS");
      }
      decl.append(LightsBuffer.getShaderDefines());
      if (options2.clusteredLightingShadowsEnabled && !options2.noShadow) {
        func.append(chunks.clusteredLightShadowsPS);
      }
      func.append(chunks.clusteredLightPS);
    }
    code.append(this._fsGetStartCode(code, device, chunks, options2));
    if (this.needsNormal) {
      code.append("    dVertexNormalW = normalize(vNormalW);");
      if ((options2.useHeights || options2.useNormals) && options2.hasTangents) {
        code.append("    dTangentW = vTangentW;");
        code.append("    dBinormalW = vBinormalW;");
      }
      code.append("    getViewDir();");
      if (hasTBN) {
        code.append("    getTBN(dTangentW, dBinormalW, dVertexNormalW);");
        if (options2.twoSidedLighting) {
          code.append("    handleTwoSidedLighting();");
        }
      }
    }
    code.append(this.frontendFunc);
    if (this.needsNormal) {
      if (options2.useSpecular) {
        backend.append("    getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);");
      }
      if (options2.useClearCoat) {
        backend.append("    ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));");
      }
    }
    if (this.lighting && options2.useSpecular || this.reflections) {
      if (options2.useMetalness) {
        backend.append("    float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;");
        backend.append("    litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);");
        backend.append("    litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);");
      }
      if (options2.useIridescence) {
        backend.append("    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);");
      }
    }
    if (addAmbient) {
      backend.append("    addAmbient(litArgs_worldNormal);");
      if (options2.useSpecular) {
        backend.append("   dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);");
      }
      if (options2.separateAmbient) {
        backend.append(`
										vec3 dAmbientLight = dDiffuseLight;
										dDiffuseLight = vec3(0);
								`);
      }
    }
    if (!useOldAmbient) {
      backend.append("    dDiffuseLight *= material_ambient;");
    }
    if (options2.useAo && !options2.occludeDirect) {
      backend.append("    occludeDiffuse(litArgs_ao);");
    }
    if (options2.lightMapEnabled) {
      backend.append(`    addLightMap(
								litArgs_lightmap, 
								litArgs_lightmapDir, 
								litArgs_worldNormal, 
								dViewDirW, 
								dReflDirW, 
								litArgs_gloss, 
								litArgs_specularity, 
								dVertexNormalW,
								dTBN
						#if defined(LIT_IRIDESCENCE)
								, iridescenceFresnel,
								litArgs_iridescence_intensity
						#endif
								);`);
    }
    if (this.lighting || this.reflections) {
      if (this.reflections) {
        if (options2.useClearCoat) {
          backend.append("    addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);");
          if (options2.fresnelModel > 0) {
            backend.append("    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));");
            backend.append("    ccReflection.rgb *= ccFresnel;");
          } else {
            backend.append("    ccFresnel = 0.0;");
          }
        }
        if (options2.useSpecularityFactor) {
          backend.append("    ccReflection.rgb *= litArgs_specularityFactor;");
        }
        if (options2.useSheen) {
          backend.append("    addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);");
        }
        backend.append("    addReflection(dReflDirW, litArgs_gloss);");
        if (options2.fresnelModel > 0) {
          backend.append(`    dReflection.rgb *= 
												getFresnel(
														dot(dViewDirW, litArgs_worldNormal), 
														litArgs_gloss, 
														litArgs_specularity
												#if defined(LIT_IRIDESCENCE)
														, iridescenceFresnel,
														litArgs_iridescence_intensity
												#endif
														);`);
        } else {
          backend.append("    dReflection.rgb *= litArgs_specularity;");
        }
        if (options2.useSpecularityFactor) {
          backend.append("    dReflection.rgb *= litArgs_specularityFactor;");
        }
      }
      if (hasAreaLights) {
        backend.append("    dSpecularLight *= litArgs_specularity;");
        if (options2.useSpecular) {
          backend.append("    calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);");
        }
      }
      for (let i = 0; i < options2.lights.length; i++) {
        const light = options2.lights[i];
        const lightType = light._type;
        if (options2.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
          continue;
        }
        usesCookieNow = false;
        const lightShape = hasAreaLights && light._shape ? light.shape : LIGHTSHAPE_PUNCTUAL;
        const shapeString = hasAreaLights && light._shape ? this._getLightSourceShapeString(lightShape) : "";
        if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
          backend.append(`    calc${shapeString}LightValues(light${i}_position, light${i}_halfWidth, light${i}_halfHeight);`);
        }
        if (lightType === LIGHTTYPE_DIRECTIONAL) {
          backend.append(`    dLightDirNormW = light${i}_direction;`);
          backend.append("    dAtten = 1.0;");
        } else {
          if (light._cookie) {
            if (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {
              usesCookie = true;
              usesCookieNow = true;
            } else if (lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {
              usesCookie = true;
              usesCookieNow = true;
            }
          }
          backend.append(`    getLightDirPoint(light${i}_position);`);
          hasPointLights = true;
          if (usesCookieNow) {
            if (lightType === LIGHTTYPE_SPOT) {
              backend.append(`    dAtten3 = getCookie2D${light._cookieFalloff ? "" : "Clip"}${light._cookieTransform ? "Xform" : ""}(light${i}_cookie, light${i}_shadowMatrix, light${i}_cookieIntensity${light._cookieTransform ? `, light${i}_cookieMatrix, light${i}_cookieOffset` : ""}).${light._cookieChannel};`);
            } else {
              backend.append(`    dAtten3 = getCookieCube(light${i}_cookie, light${i}_shadowMatrix, light${i}_cookieIntensity).${light._cookieChannel};`);
            }
          }
          if (lightShape === LIGHTSHAPE_PUNCTUAL) {
            if (light._falloffMode === LIGHTFALLOFF_LINEAR) {
              backend.append(`    dAtten = getFalloffLinear(light${i}_radius, dLightDirW);`);
              usesLinearFalloff = true;
            } else {
              backend.append(`    dAtten = getFalloffInvSquared(light${i}_radius, dLightDirW);`);
              usesInvSquaredFalloff = true;
            }
          } else {
            backend.append(`    dAtten = getFalloffWindow(light${i}_radius, dLightDirW);`);
            usesInvSquaredFalloff = true;
          }
          backend.append("    if (dAtten > 0.00001) {");
          if (lightType === LIGHTTYPE_SPOT) {
            if (!(usesCookieNow && !light._cookieFalloff)) {
              backend.append(`    dAtten *= getSpotEffect(light${i}_direction, light${i}_innerConeAngle, light${i}_outerConeAngle, dLightDirNormW);`);
              usesSpot = true;
            }
          }
        }
        if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
          if (lightType === LIGHTTYPE_DIRECTIONAL) {
            backend.append("    dAttenD = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);");
          } else {
            backend.append(`    dAttenD = get${shapeString}LightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;`);
          }
        } else {
          backend.append("    dAtten *= getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);");
        }
        if (light.castShadows && !options2.noShadow) {
          const pcssShadows = light._shadowType === SHADOW_PCSS;
          const vsmShadows = light._shadowType === SHADOW_VSM8 || light._shadowType === SHADOW_VSM16 || light._shadowType === SHADOW_VSM32;
          const pcfShadows = light._shadowType === SHADOW_PCF1 || light._shadowType === SHADOW_PCF3 || light._shadowType === SHADOW_PCF5;
          let shadowReadMode = null;
          let evsmExp;
          switch (light._shadowType) {
            case SHADOW_VSM8:
              shadowReadMode = "VSM8";
              evsmExp = "0.0";
              break;
            case SHADOW_VSM16:
              shadowReadMode = "VSM16";
              evsmExp = "5.54";
              break;
            case SHADOW_VSM32:
              shadowReadMode = "VSM32";
              evsmExp = "15.0";
              break;
            case SHADOW_PCF1:
              shadowReadMode = "PCF1x1";
              break;
            case SHADOW_PCF5:
              shadowReadMode = "PCF5x5";
              break;
            case SHADOW_PCSS:
              shadowReadMode = "PCSS";
              break;
            case SHADOW_PCF3:
            default:
              shadowReadMode = "PCF3x3";
              break;
          }
          if (shadowReadMode !== null) {
            if (light._normalOffsetBias && !light._isVsm) {
              func.append("#define SHADOW_SAMPLE_NORMAL_OFFSET");
            }
            if (lightType === LIGHTTYPE_DIRECTIONAL) {
              func.append("#define SHADOW_SAMPLE_ORTHO");
            }
            if (pcfShadows || pcssShadows || device.isWebGPU) {
              func.append("#define SHADOW_SAMPLE_SOURCE_ZBUFFER");
            }
            if (lightType === LIGHTTYPE_OMNI) {
              func.append("#define SHADOW_SAMPLE_POINT");
            }
            const coordCode = chunks.shadowSampleCoordPS;
            func.append(coordCode.replace("$LIGHT", i));
            func.append("#undef SHADOW_SAMPLE_NORMAL_OFFSET");
            func.append("#undef SHADOW_SAMPLE_ORTHO");
            func.append("#undef SHADOW_SAMPLE_SOURCE_ZBUFFER");
            func.append("#undef SHADOW_SAMPLE_POINT");
            let shadowMatrix = `light${i}_shadowMatrix`;
            if (lightType === LIGHTTYPE_DIRECTIONAL && light.numCascades > 1) {
              backend.append(`    getShadowCascadeMatrix(light${i}_shadowMatrixPalette, light${i}_shadowCascadeDistances, light${i}_shadowCascadeCount);`);
              shadowMatrix = "cascadeShadowMat";
            }
            backend.append(`    dShadowCoord = getShadowSampleCoord${i}(${shadowMatrix}, light${i}_shadowParams, vPositionW, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);`);
            if (lightType === LIGHTTYPE_DIRECTIONAL) {
              backend.append(`    fadeShadow(light${i}_shadowCascadeDistances);`);
            }
            var shadowCoordArgs = `SHADOWMAP_PASS(light${i}_shadowMap), dShadowCoord, light${i}_shadowParams`;
            if (vsmShadows) {
              shadowCoordArgs = `${shadowCoordArgs}, ${evsmExp}, dLightDirW`;
            } else if (pcssShadows) {
              let penumbraSizeArg = `vec2(light${i}_shadowSearchArea)`;
              if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
                penumbraSizeArg = `vec2(length(light${i}_halfWidth), length(light${i}_halfHeight)) * light${i}_shadowSearchArea`;
              }
              shadowCoordArgs = `${shadowCoordArgs}, light${i}_cameraParams, ${penumbraSizeArg}, dLightDirW`;
            }
            if (lightType === LIGHTTYPE_OMNI) {
              shadowReadMode = `Point${shadowReadMode}`;
              if (!pcssShadows) {
                shadowCoordArgs = `${shadowCoordArgs}, dLightDirW`;
              }
            } else if (lightType === LIGHTTYPE_SPOT) {
              shadowReadMode = `Spot${shadowReadMode}`;
            }
            backend.append(`    float shadow${i} = getShadow${shadowReadMode}(${shadowCoordArgs});`);
            backend.append(`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);`);
          }
        }
        if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
          if (options2.useSpecular) {
            backend.append(`    dDiffuseLight += ((dAttenD * dAtten) * light${i}_color${usesCookieNow ? " * dAtten3" : ""}) * (1.0 - dLTCSpecFres);`);
          } else {
            backend.append(`    dDiffuseLight += (dAttenD * dAtten) * light${i}_color${usesCookieNow ? " * dAtten3" : ""};`);
          }
        } else {
          if (hasAreaLights && options2.useSpecular) {
            backend.append(`    dDiffuseLight += (dAtten * light${i}_color${usesCookieNow ? " * dAtten3" : ""}) * (1.0 - litArgs_specularity);`);
          } else {
            backend.append(`    dDiffuseLight += dAtten * light${i}_color${usesCookieNow ? " * dAtten3" : ""};`);
          }
        }
        if (options2.useSpecular) {
          backend.append("    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);");
        }
        if (light.affectSpecularity) {
          if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
            if (options2.useClearCoat) {
              backend.append(`    ccSpecularLight += ccLTCSpecFres * get${shapeString}LightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * light${i}_color${usesCookieNow ? " * dAtten3" : ""};`);
            }
            if (options2.useSpecular) {
              backend.append(`    dSpecularLight += dLTCSpecFres * get${shapeString}LightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * light${i}_color${usesCookieNow ? " * dAtten3" : ""};`);
            }
          } else {
            var calcFresnel = false;
            if (lightType === LIGHTTYPE_DIRECTIONAL && options2.fresnelModel > 0) {
              calcFresnel = true;
            }
            if (options2.useClearCoat) {
              backend.append(`    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * light${i}_color${usesCookieNow ? " * dAtten3" : ""}${calcFresnel ? " * getFresnelCC(dot(dViewDirW, dHalfDirW));" : ";"}`);
            }
            if (options2.useSheen) {
              backend.append(`    sSpecularLight += getLightSpecularSheen(dHalfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * light${i}_color${usesCookieNow ? " * dAtten3;" : ";"}`);
            }
            if (options2.useSpecular) {
              backend.append(`    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * light${i}_color${usesCookieNow ? " * dAtten3" : ""}${calcFresnel ? ` 
																		* getFresnel(
																				dot(dViewDirW, dHalfDirW), 
																				litArgs_gloss, 
																				litArgs_specularity
																		#if defined(LIT_IRIDESCENCE)
																				, iridescenceFresnel, 
																				litArgs_iridescence_intensity
																		#endif
																		);` : "* litArgs_specularity;"}`);
            }
          }
        }
        if (lightType !== LIGHTTYPE_DIRECTIONAL) {
          backend.append("    }");
        }
      }
      if (options2.clusteredLightingEnabled && this.lighting) {
        usesLinearFalloff = true;
        usesInvSquaredFalloff = true;
        hasPointLights = true;
        backend.append(`    addClusteredLights(
																				litArgs_worldNormal, 
																				dViewDirW, 
																				dReflDirW,
																#if defined(LIT_CLEARCOAT)
																				ccReflDirW,
																#endif
																				litArgs_gloss, 
																				litArgs_specularity, 
																				dVertexNormalW, 
																				dTBN, 
																#if defined(LIT_IRIDESCENCE)
																				iridescenceFresnel,
																#endif
																				litArgs_clearcoat_worldNormal, 
																				litArgs_clearcoat_gloss,
																				litArgs_sheen_gloss,
																				litArgs_iridescence_intensity
																		);`);
      }
      if (hasAreaLights) {
        if (options2.useClearCoat) {
          backend.append("    litArgs_clearcoat_specularity = 1.0;");
        }
        if (options2.useSpecular) {
          backend.append("    litArgs_specularity = vec3(1);");
        }
      }
      if (options2.useRefraction) {
        backend.append(`    addRefraction(
												litArgs_worldNormal, 
												dViewDirW, 
												litArgs_thickness, 
												litArgs_gloss, 
												litArgs_specularity, 
												litArgs_albedo, 
												litArgs_transmission,
												litArgs_ior,
												litArgs_dispersion
										#if defined(LIT_IRIDESCENCE)
												, iridescenceFresnel, 
												litArgs_iridescence_intensity
										#endif
										);`);
      }
    }
    if (options2.useAo) {
      if (options2.occludeDirect) {
        backend.append("    occludeDiffuse(litArgs_ao);");
      }
      if (options2.occludeSpecular === SPECOCC_AO || options2.occludeSpecular === SPECOCC_GLOSSDEPENDENT) {
        backend.append("    occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);");
      }
    }
    if (options2.useSpecularityFactor) {
      backend.append("    dSpecularLight *= litArgs_specularityFactor;");
    }
    if (options2.opacityFadesSpecular === false) {
      if (options2.blendType === BLEND_NORMAL || options2.blendType === BLEND_PREMULTIPLIED) {
        backend.append("float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));");
        backend.append("#ifdef LIT_CLEARCOAT\n specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif");
        backend.append("litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);");
      }
      backend.append("litArgs_opacity *= material_alphaFade;");
    }
    backend.append(chunks.endPS);
    if (options2.blendType === BLEND_NORMAL || options2.blendType === BLEND_ADDITIVEALPHA || options2.alphaToCoverage) {
      backend.append(chunks.outputAlphaPS);
    } else if (options2.blendType === BLEND_PREMULTIPLIED) {
      backend.append(chunks.outputAlphaPremulPS);
    } else {
      backend.append(chunks.outputAlphaOpaquePS);
    }
    if (options2.useMsdf) {
      backend.append("    gl_FragColor = applyMsdf(gl_FragColor);");
    }
    backend.append(chunks.outputPS);
    backend.append(chunks.debugOutputPS);
    if (hasPointLights) {
      func.prepend(chunks.lightDirPointPS);
    }
    if (usesLinearFalloff) {
      func.prepend(chunks.falloffLinearPS);
    }
    if (usesInvSquaredFalloff) {
      func.prepend(chunks.falloffInvSquaredPS);
    }
    if (usesSpot) {
      func.prepend(chunks.spotPS);
    }
    if (usesCookie && !options2.clusteredLightingEnabled) {
      func.prepend(chunks.cookiePS);
    }
    let structCode = "";
    const backendCode = `void evaluateBackend() {
${backend.code}
}`;
    func.append(backendCode);
    code.append(chunks.debugProcessFrontendPS);
    code.append("    evaluateBackend();");
    code.append(ShaderGenerator.end());
    const mergedCode = decl.code + func.code + code.code;
    if (mergedCode.includes("dTBN")) structCode += "mat3 dTBN;\n";
    if (mergedCode.includes("dVertexNormalW")) structCode += "vec3 dVertexNormalW;\n";
    if (mergedCode.includes("dTangentW")) structCode += "vec3 dTangentW;\n";
    if (mergedCode.includes("dBinormalW")) structCode += "vec3 dBinormalW;\n";
    if (mergedCode.includes("dViewDirW")) structCode += "vec3 dViewDirW;\n";
    if (mergedCode.includes("dReflDirW")) structCode += "vec3 dReflDirW;\n";
    if (mergedCode.includes("dHalfDirW")) structCode += "vec3 dHalfDirW;\n";
    if (mergedCode.includes("ccReflDirW")) structCode += "vec3 ccReflDirW;\n";
    if (mergedCode.includes("dLightDirNormW")) structCode += "vec3 dLightDirNormW;\n";
    if (mergedCode.includes("dLightDirW")) structCode += "vec3 dLightDirW;\n";
    if (mergedCode.includes("dLightPosW")) structCode += "vec3 dLightPosW;\n";
    if (mergedCode.includes("dShadowCoord")) structCode += "vec3 dShadowCoord;\n";
    if (mergedCode.includes("dReflection")) structCode += "vec4 dReflection;\n";
    if (mergedCode.includes("dDiffuseLight")) structCode += "vec3 dDiffuseLight;\n";
    if (mergedCode.includes("dSpecularLight")) structCode += "vec3 dSpecularLight;\n";
    if (mergedCode.includes("dAtten")) structCode += "float dAtten;\n";
    if (mergedCode.includes("dAttenD")) structCode += "float dAttenD;\n";
    if (mergedCode.includes("dAtten3")) structCode += "vec3 dAtten3;\n";
    if (mergedCode.includes("dMsdf")) structCode += "vec4 dMsdf;\n";
    if (mergedCode.includes("ccFresnel")) structCode += "float ccFresnel;\n";
    if (mergedCode.includes("ccReflection")) structCode += "vec3 ccReflection;\n";
    if (mergedCode.includes("ccSpecularLight")) structCode += "vec3 ccSpecularLight;\n";
    if (mergedCode.includes("ccSpecularityNoFres")) structCode += "float ccSpecularityNoFres;\n";
    if (mergedCode.includes("sSpecularLight")) structCode += "vec3 sSpecularLight;\n";
    if (mergedCode.includes("sReflection")) structCode += "vec3 sReflection;\n";
    const result = this._fsGetBeginCode() + this.varyings + this.varyingDefines + this._fsGetBaseCode() + structCode + this.frontendDecl + mergedCode;
    return result;
  }
  generateFragmentShader(frontendDecl, frontendCode, frontendFunc, lightingUv) {
    var _this$handleCompatibi;
    const options2 = this.options;
    this.frontendDecl = frontendDecl;
    this.frontendCode = frontendCode;
    this.frontendFunc = frontendFunc;
    this.lightingUv = lightingUv;
    if (options2.pass === SHADER_PICK) {
      this.fshader = this._fsGetPickPassCode();
    } else if (options2.pass === SHADER_DEPTH) {
      this.fshader = this._fsGetDepthPassCode();
    } else if (options2.pass === SHADER_PREPASS_VELOCITY) {
      this.fshader = this._fsGetPrePassVelocityCode();
    } else if (this.shadowPass) {
      this.fshader = this._fsGetShadowPassCode();
    } else if (options2.customFragmentShader) {
      this.fshader = this._fsGetBeginCode() + options2.customFragmentShader;
    } else {
      this.fshader = this._fsGetLitPassCode();
    }
    (_this$handleCompatibi = this.handleCompatibility) == null || _this$handleCompatibi.call(this);
  }
  getDefinition(options2) {
    const vIncludes = /* @__PURE__ */ new Map();
    vIncludes.set("transformCore", this.chunks.transformCoreVS);
    vIncludes.set("transformInstancing", this.chunks.transformInstancingVS);
    vIncludes.set("skinTexVS", this.chunks.skinTexVS);
    vIncludes.set("skinBatchTexVS", this.chunks.skinBatchTexVS);
    const defines = new Map(options2.defines);
    const definition = ShaderUtils.createDefinition(this.device, {
      name: "LitShader",
      attributes: this.attributes,
      vertexCode: this.vshader,
      fragmentCode: this.fshader,
      vertexIncludes: vIncludes,
      fragmentDefines: defines,
      vertexDefines: defines
    });
    if (this.shaderPassInfo.isForward) {
      definition.tag = SHADERTAG_MATERIAL;
    }
    return definition;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/lit-options-utils.js
var LitOptionsUtils = {
  generateKey(options2) {
    return `lit${Object.keys(options2).sort().map((key) => {
      if (key === "chunks") {
        return LitOptionsUtils.generateChunksKey(options2);
      } else if (key === "lights") {
        return LitOptionsUtils.generateLightsKey(options2);
      }
      return key + options2[key];
    }).join("\n")}`;
  },
  generateLightsKey(options2) {
    return `lights:${options2.lights.map((light) => {
      return !options2.clusteredLightingEnabled || light._type === LIGHTTYPE_DIRECTIONAL ? `${light.key},` : "";
    }).join("")}`;
  },
  generateChunksKey(options2) {
    var _options$chunks;
    return `chunks:
${Object.keys((_options$chunks = options2.chunks) != null ? _options$chunks : {}).sort().map((key) => key + options2.chunks[key]).join("")}`;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/lit.js
var dummyUvs = [0, 1, 2, 3, 4, 5, 6, 7];
var ShaderGeneratorLit = class extends ShaderGenerator {
  generateKey(options2) {
    const key = `lit${dummyUvs.map((dummy, index) => {
      return options2.usedUvs[index] ? "1" : "0";
    }).join("")}${options2.shaderChunk}${LitOptionsUtils.generateKey(options2.litOptions)}`;
    return key;
  }
  createShaderDefinition(device, options2) {
    const litShader = new LitShader(device, options2.litOptions);
    const decl = new ChunkBuilder();
    const code = new ChunkBuilder();
    const func = new ChunkBuilder();
    decl.append("uniform float textureBias;");
    decl.append(litShader.chunks.litShaderArgsPS);
    code.append(options2.shaderChunk);
    func.code = "evaluateFrontend();";
    func.code = `
${func.code.split("\n").map((l) => `    ${l}`).join("\n")}

`;
    const usedUvSets = options2.usedUvs || [true];
    const mapTransforms = [];
    litShader.generateVertexShader(usedUvSets, usedUvSets, mapTransforms);
    litShader.generateFragmentShader(decl.code, code.code, func.code, "vUv0");
    return litShader.getDefinition(options2);
  }
};
var lit = new ShaderGeneratorLit();

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/lit-material.js
var options = new LitMaterialOptions();
var LitMaterial = class extends Material {
  constructor(...args) {
    super(...args);
    this.usedUvs = [true];
    this.shaderChunk = "void evaluateFrontend() {}\n";
    this.chunks = null;
    this.useLighting = true;
    this.useFog = true;
    this.useTonemap = true;
    this.useSkybox = true;
    this.ambientSH = null;
    this.pixelSnap = false;
    this.nineSlicedMode = null;
    this.twoSidedLighting = false;
    this.occludeDirect = false;
    this.occludeSpecular = SPECOCC_AO;
    this.occludeSpecularIntensity = 1;
    this.opacityFadesSpecular = true;
    this.opacityDither = DITHER_NONE;
    this.opacityShadowDither = DITHER_NONE;
    this.ggxSpecular = false;
    this.fresnelModel = FRESNEL_SCHLICK;
    this.dynamicRefraction = false;
    this.hasAo = false;
    this.hasSpecular = false;
    this.hasSpecularityFactor = false;
    this.hasLighting = false;
    this.hasHeights = false;
    this.hasNormals = false;
    this.hasSheen = false;
    this.hasRefraction = false;
    this.hasIrridescence = false;
    this.hasMetalness = false;
    this.hasClearCoat = false;
    this.hasClearCoatNormals = false;
  }
  getShaderVariant(params) {
    options.usedUvs = this.usedUvs.slice();
    options.shaderChunk = this.shaderChunk;
    options.defines = this.defines;
    LitMaterialOptionsBuilder.update(options.litOptions, this, params.scene, params.renderParams, params.objDefs, params.pass, params.sortedLights);
    const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
    const library = getProgramLibrary(params.device);
    library.register("lit", lit);
    const shader = library.getProgram("lit", options, processingOptions, this.userId);
    return shader;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material-options.js
var StandardMaterialOptions = class {
  constructor() {
    this.forceUv1 = false;
    this.specularTint = false;
    this.metalnessTint = false;
    this.glossTint = false;
    this.emissiveEncoding = "linear";
    this.lightMapEncoding = "linear";
    this.packedNormal = false;
    this.glossInvert = false;
    this.sheenGlossInvert = false;
    this.clearCoatGlossInvert = false;
    this.litOptions = new LitShaderOptions();
  }
  get pass() {
    return this.litOptions.pass;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/standard.js
var _matTex2D = [];
var buildPropertiesList = (options2) => {
  return Object.keys(options2).filter((key) => key !== "litOptions").sort();
};
var ShaderGeneratorStandard = class extends ShaderGenerator {
  constructor(...args) {
    super(...args);
    this.optionsContext = new StandardMaterialOptions();
    this.optionsContextMin = new StandardMaterialOptions();
  }
  generateKey(options2) {
    let props;
    if (options2 === this.optionsContextMin) {
      if (!this.propsMin) this.propsMin = buildPropertiesList(options2);
      props = this.propsMin;
    } else if (options2 === this.optionsContext) {
      if (!this.props) this.props = buildPropertiesList(options2);
      props = this.props;
    } else {
      props = buildPropertiesList(options2);
    }
    const definesHash = ShaderGenerator.definesHash(options2.defines);
    const key = `standard:
${definesHash}
${props.map((prop) => prop + options2[prop]).join("\n")}${LitOptionsUtils.generateKey(options2.litOptions)}`;
    return key;
  }
  _getUvSourceExpression(transformPropName, uVPropName, options2) {
    const transformId = options2[transformPropName];
    const uvChannel = options2[uVPropName];
    const isMainPass = options2.litOptions.pass === SHADER_FORWARD;
    let expression;
    if (isMainPass && options2.litOptions.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
      expression = "nineSlicedUv";
    } else if (isMainPass && options2.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
      expression = "nineSlicedUv";
    } else {
      if (transformId === 0) {
        expression = `vUv${uvChannel}`;
      } else {
        expression = `vUV${uvChannel}_${transformId}`;
      }
      if (options2.heightMap && transformPropName !== "heightMapTransform") {
        expression += " + dUvOffset";
      }
    }
    return expression;
  }
  _addMapDef(name, enabled) {
    return enabled ? `#define ${name}
` : `#undef ${name}
`;
  }
  _addMapDefs(float, color, vertex, map, invert) {
    return this._addMapDef("MAPFLOAT", float) + this._addMapDef("MAPCOLOR", color) + this._addMapDef("MAPVERTEX", vertex) + this._addMapDef("MAPTEXTURE", map) + this._addMapDef("MAPINVERT", invert);
  }
  _addMap(propName, chunkName, options2, chunks, mapping, encoding = null) {
    const mapPropName = `${propName}Map`;
    const uVPropName = `${mapPropName}Uv`;
    const identifierPropName = `${mapPropName}Identifier`;
    const transformPropName = `${mapPropName}Transform`;
    const channelPropName = `${mapPropName}Channel`;
    const vertexColorChannelPropName = `${propName}VertexColorChannel`;
    const tintPropName = `${propName}Tint`;
    const vertexColorPropName = `${propName}VertexColor`;
    const detailModePropName = `${propName}Mode`;
    const invertName = `${propName}Invert`;
    const tintOption = options2[tintPropName];
    const vertexColorOption = options2[vertexColorPropName];
    const textureOption = options2[mapPropName];
    const textureIdentifier = options2[identifierPropName];
    const detailModeOption = options2[detailModePropName];
    let subCode = chunks[chunkName];
    if (textureOption) {
      const uv = this._getUvSourceExpression(transformPropName, uVPropName, options2);
      subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options2[channelPropName]);
      if (mapping && subCode.search(/\$SAMPLER/g) !== -1) {
        let samplerName = `texture_${mapPropName}`;
        const alias = mapping[textureIdentifier];
        if (alias) {
          samplerName = alias;
        } else {
          mapping[textureIdentifier] = samplerName;
        }
        subCode = subCode.replace(/\$SAMPLER/g, samplerName);
      }
      if (encoding) {
        if (options2[channelPropName] === "aaa") {
          subCode = subCode.replace(/\$DECODE/g, "passThrough");
        } else {
          subCode = subCode.replace(/\$DECODE/g, ChunkUtils.decodeFunc(encoding));
        }
        if (subCode.indexOf("$texture2DSAMPLE")) {
          const decodeTable2 = {
            linear: "texture2D",
            srgb: "texture2DSRGB",
            rgbm: "texture2DRGBM",
            rgbe: "texture2DRGBE"
          };
          subCode = subCode.replace(/\$texture2DSAMPLE/g, decodeTable2[encoding] || "texture2D");
        }
      }
    }
    if (vertexColorOption) {
      subCode = subCode.replace(/\$VC/g, options2[vertexColorChannelPropName]);
    }
    if (detailModeOption) {
      subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
    }
    const isFloatTint = !!(tintOption & 1);
    const isVecTint = !!(tintOption & 2);
    const invertOption = !!options2[invertName];
    subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption, invertOption) + subCode;
    return subCode.replace(/\$/g, "");
  }
  _correctChannel(p, chan, _matTex2D2) {
    if (_matTex2D2[p] > 0) {
      if (_matTex2D2[p] < chan.length) {
        return chan.substring(0, _matTex2D2[p]);
      } else if (_matTex2D2[p] > chan.length) {
        let str = chan;
        const chr = str.charAt(str.length - 1);
        const addLen = _matTex2D2[p] - str.length;
        for (let i = 0; i < addLen; i++) str += chr;
        return str;
      }
      return chan;
    }
  }
  createShaderDefinition(device, options2) {
    const shaderPassInfo = ShaderPass.get(device).getByIndex(options2.litOptions.pass);
    const isForwardPass = shaderPassInfo.isForward;
    const litShader = new LitShader(device, options2.litOptions);
    const useUv = [];
    const useUnmodifiedUv = [];
    const mapTransforms = [];
    const maxUvSets = 2;
    const textureMapping = {};
    for (const p in _matTex2D) {
      const mname = `${p}Map`;
      if (options2[`${p}VertexColor`]) {
        const cname = `${p}VertexColorChannel`;
        options2[cname] = this._correctChannel(p, options2[cname], _matTex2D);
      }
      if (options2[mname]) {
        const cname = `${mname}Channel`;
        const tname = `${mname}Transform`;
        const uname = `${mname}Uv`;
        options2[uname] = Math.min(options2[uname], maxUvSets - 1);
        options2[cname] = this._correctChannel(p, options2[cname], _matTex2D);
        const uvSet = options2[uname];
        useUv[uvSet] = true;
        useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options2[mname] && !options2[tname];
        if (options2[tname]) {
          mapTransforms.push({
            name: p,
            id: options2[tname],
            uv: options2[uname]
          });
        }
      }
    }
    if (options2.forceUv1) {
      useUv[1] = true;
      useUnmodifiedUv[1] = useUnmodifiedUv[1] !== void 0 ? useUnmodifiedUv[1] : true;
    }
    litShader.generateVertexShader(useUv, useUnmodifiedUv, mapTransforms);
    options2.litOptions.fresnelModel = options2.litOptions.fresnelModel === 0 ? FRESNEL_SCHLICK : options2.litOptions.fresnelModel;
    const decl = new ChunkBuilder();
    const code = new ChunkBuilder();
    const func = new ChunkBuilder();
    const args = new ChunkBuilder();
    let lightingUv = "";
    if (options2.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
      decl.append("const float textureBias = -1000.0;");
    } else {
      decl.append("uniform float textureBias;");
    }
    if (isForwardPass) {
      if (options2.heightMap) {
        decl.append("vec2 dUvOffset;");
        code.append(this._addMap("height", "parallaxPS", options2, litShader.chunks, textureMapping));
        func.append("getParallax();");
      }
      if (options2.litOptions.blendType !== BLEND_NONE || options2.litOptions.alphaTest || options2.litOptions.alphaToCoverage || options2.litOptions.opacityDither !== DITHER_NONE) {
        decl.append("float dAlpha;");
        code.append(this._addMap("opacity", "opacityPS", options2, litShader.chunks, textureMapping));
        func.append("getOpacity();");
        args.append("litArgs_opacity = dAlpha;");
        if (options2.litOptions.alphaTest) {
          code.append(litShader.chunks.alphaTestPS);
          func.append("alphaTest(dAlpha);");
        }
        const opacityDither = options2.litOptions.opacityDither;
        if (opacityDither !== DITHER_NONE) {
          if (opacityDither === DITHER_BAYER8) {
            decl.append(litShader.chunks.bayerPS);
          }
          decl.append(`#define DITHER_${opacityDither.toUpperCase()}
`);
          decl.append(litShader.chunks.opacityDitherPS);
          func.append("opacityDither(dAlpha, 0.0);");
        }
      } else {
        decl.append("float dAlpha = 1.0;");
      }
      if (litShader.needsNormal) {
        if (options2.normalMap || options2.clearCoatNormalMap) {
          code.append(options2.packedNormal ? litShader.chunks.normalXYPS : litShader.chunks.normalXYZPS);
          if (!options2.litOptions.hasTangents) {
            const baseName = options2.normalMap ? "normalMap" : "clearCoatNormalMap";
            lightingUv = this._getUvSourceExpression(`${baseName}Transform`, `${baseName}Uv`, options2);
          }
        }
        decl.append("vec3 dNormalW;");
        code.append(this._addMap("normalDetail", "normalDetailMapPS", options2, litShader.chunks, textureMapping));
        code.append(this._addMap("normal", "normalMapPS", options2, litShader.chunks, textureMapping));
        func.append("getNormal();");
        args.append("litArgs_worldNormal = dNormalW;");
      }
      if (litShader.needsSceneColor) {
        decl.append("uniform sampler2D uSceneColorMap;");
      }
      if (litShader.needsScreenSize) {
        decl.append("uniform vec4 uScreenSize;");
      }
      if (litShader.needsTransforms) {
        decl.append("uniform mat4 matrix_viewProjection;");
        decl.append("uniform mat4 matrix_model;");
      }
      if (options2.diffuseDetail || options2.aoDetail) {
        code.append(litShader.chunks.detailModesPS);
      }
      decl.append("vec3 dAlbedo;");
      if (options2.diffuseDetail) {
        code.append(this._addMap("diffuseDetail", "diffuseDetailMapPS", options2, litShader.chunks, textureMapping, options2.diffuseDetailEncoding));
      }
      code.append(this._addMap("diffuse", "diffusePS", options2, litShader.chunks, textureMapping, options2.diffuseEncoding));
      func.append("getAlbedo();");
      args.append("litArgs_albedo = dAlbedo;");
      if (options2.litOptions.useRefraction) {
        decl.append("float dTransmission;");
        code.append(this._addMap("refraction", "transmissionPS", options2, litShader.chunks, textureMapping));
        func.append("getRefraction();");
        args.append("litArgs_transmission = dTransmission;");
        decl.append("float dThickness;");
        code.append(this._addMap("thickness", "thicknessPS", options2, litShader.chunks, textureMapping));
        func.append("getThickness();");
        args.append("litArgs_thickness = dThickness;");
        if (options2.litOptions.dispersion) {
          args.append("litArgs_dispersion = material_dispersion;");
        }
      }
      if (options2.litOptions.useIridescence) {
        decl.append("float dIridescence;");
        code.append(this._addMap("iridescence", "iridescencePS", options2, litShader.chunks, textureMapping));
        func.append("getIridescence();");
        args.append("litArgs_iridescence_intensity = dIridescence;");
        decl.append("float dIridescenceThickness;");
        code.append(this._addMap("iridescenceThickness", "iridescenceThicknessPS", options2, litShader.chunks, textureMapping));
        func.append("getIridescenceThickness();");
        args.append("litArgs_iridescence_thickness = dIridescenceThickness;");
      }
      if (litShader.lighting && options2.litOptions.useSpecular || litShader.reflections) {
        decl.append("vec3 dSpecularity;");
        decl.append("float dGlossiness;");
        if (options2.litOptions.useSheen) {
          decl.append("vec3 sSpecularity;");
          code.append(this._addMap("sheen", "sheenPS", options2, litShader.chunks, textureMapping, options2.sheenEncoding));
          func.append("getSheen();");
          args.append("litArgs_sheen_specularity = sSpecularity;");
          decl.append("float sGlossiness;");
          code.append(this._addMap("sheenGloss", "sheenGlossPS", options2, litShader.chunks, textureMapping));
          func.append("getSheenGlossiness();");
          args.append("litArgs_sheen_gloss = sGlossiness;");
        }
        if (options2.litOptions.useMetalness) {
          decl.append("float dMetalness;");
          code.append(this._addMap("metalness", "metalnessPS", options2, litShader.chunks, textureMapping));
          func.append("getMetalness();");
          args.append("litArgs_metalness = dMetalness;");
          decl.append("float dIor;");
          code.append(this._addMap("ior", "iorPS", options2, litShader.chunks, textureMapping));
          func.append("getIor();");
          args.append("litArgs_ior = dIor;");
        }
        if (options2.litOptions.useSpecularityFactor) {
          decl.append("float dSpecularityFactor;");
          code.append(this._addMap("specularityFactor", "specularityFactorPS", options2, litShader.chunks, textureMapping));
          func.append("getSpecularityFactor();");
          args.append("litArgs_specularityFactor = dSpecularityFactor;");
        }
        if (options2.useSpecularColor) {
          code.append(this._addMap("specular", "specularPS", options2, litShader.chunks, textureMapping, options2.specularEncoding));
        } else {
          code.append("void getSpecularity() { dSpecularity = vec3(1); }");
        }
        code.append(this._addMap("gloss", "glossPS", options2, litShader.chunks, textureMapping));
        func.append("getGlossiness();");
        func.append("getSpecularity();");
        args.append("litArgs_specularity = dSpecularity;");
        args.append("litArgs_gloss = dGlossiness;");
      } else {
        decl.append("vec3 dSpecularity = vec3(0.0);");
        decl.append("float dGlossiness = 0.0;");
      }
      if (options2.aoDetail) {
        code.append(this._addMap("aoDetail", "aoDetailMapPS", options2, litShader.chunks, textureMapping));
      }
      if (options2.aoMap || options2.aoVertexColor) {
        decl.append("float dAo;");
        code.append(this._addMap("ao", "aoPS", options2, litShader.chunks, textureMapping));
        func.append("getAO();");
        args.append("litArgs_ao = dAo;");
      }
      decl.append("vec3 dEmission;");
      code.append(this._addMap("emissive", "emissivePS", options2, litShader.chunks, textureMapping, options2.emissiveEncoding));
      func.append("getEmission();");
      args.append("litArgs_emission = dEmission;");
      if (options2.litOptions.useClearCoat) {
        decl.append("float ccSpecularity;");
        decl.append("float ccGlossiness;");
        decl.append("vec3 ccNormalW;");
        code.append(this._addMap("clearCoat", "clearCoatPS", options2, litShader.chunks, textureMapping));
        code.append(this._addMap("clearCoatGloss", "clearCoatGlossPS", options2, litShader.chunks, textureMapping));
        code.append(this._addMap("clearCoatNormal", "clearCoatNormalPS", options2, litShader.chunks, textureMapping));
        func.append("getClearCoat();");
        func.append("getClearCoatGlossiness();");
        func.append("getClearCoatNormal();");
        args.append("litArgs_clearcoat_specularity = ccSpecularity;");
        args.append("litArgs_clearcoat_gloss = ccGlossiness;");
        args.append("litArgs_clearcoat_worldNormal = ccNormalW;");
      }
      if (options2.lightMap || options2.lightVertexColor) {
        const lightmapDir = options2.dirLightMap && options2.litOptions.useSpecular;
        const lightmapChunkPropName = lightmapDir ? "lightmapDirPS" : "lightmapSinglePS";
        decl.append("vec3 dLightmap;");
        if (lightmapDir) {
          decl.append("vec3 dLightmapDir;");
        }
        code.append(this._addMap("light", lightmapChunkPropName, options2, litShader.chunks, textureMapping, options2.lightMapEncoding));
        func.append("getLightMap();");
        args.append("litArgs_lightmap = dLightmap;");
        if (lightmapDir) {
          args.append("litArgs_lightmapDir = dLightmapDir;");
        }
      }
    } else {
      const opacityShadowDither = options2.litOptions.opacityShadowDither;
      if (options2.litOptions.alphaTest || opacityShadowDither) {
        decl.append("float dAlpha;");
        code.append(this._addMap("opacity", "opacityPS", options2, litShader.chunks, textureMapping));
        func.append("getOpacity();");
        args.append("litArgs_opacity = dAlpha;");
        if (options2.litOptions.alphaTest) {
          code.append(litShader.chunks.alphaTestPS);
          func.append("alphaTest(dAlpha);");
        }
        if (opacityShadowDither !== DITHER_NONE) {
          if (opacityShadowDither === DITHER_BAYER8) {
            decl.append(litShader.chunks.bayerPS);
          }
          decl.append(`#define DITHER_${opacityShadowDither.toUpperCase()}
`);
          decl.append(litShader.chunks.opacityDitherPS);
          func.append("opacityDither(dAlpha, 0.0);");
        }
      }
    }
    decl.append(litShader.chunks.litShaderArgsPS);
    code.append(`void evaluateFrontend() { 
${func.code}
${args.code}
 }
`);
    func.code = "evaluateFrontend();";
    for (const texture in textureMapping) {
      decl.append(`uniform sampler2D ${textureMapping[texture]};`);
    }
    func.code = `
${func.code.split("\n").map((l) => `    ${l}`).join("\n")}

`;
    litShader.generateFragmentShader(decl.code, code.code, func.code, lightingUv);
    return litShader.getDefinition(options2);
  }
};
var standard = new ShaderGeneratorStandard();

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material-options-builder.js
var arraysEqual = (a, b) => {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
};
var notWhite = (color) => {
  return color.r !== 1 || color.g !== 1 || color.b !== 1;
};
var notBlack = (color) => {
  return color.r !== 0 || color.g !== 0 || color.b !== 0;
};
var StandardMaterialOptionsBuilder = class {
  constructor() {
    this._mapXForms = null;
  }
  updateMinRef(options2, scene, stdMat, objDefs, pass, sortedLights) {
    this._updateSharedOptions(options2, scene, stdMat, objDefs, pass);
    this._updateMinOptions(options2, stdMat, pass);
    this._updateUVOptions(options2, stdMat, objDefs, true);
  }
  updateRef(options2, scene, renderParams, stdMat, objDefs, pass, sortedLights) {
    this._updateSharedOptions(options2, scene, stdMat, objDefs, pass);
    this._updateEnvOptions(options2, stdMat, scene, renderParams);
    this._updateMaterialOptions(options2, stdMat);
    options2.litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
    this._updateLightOptions(options2, scene, stdMat, objDefs, sortedLights);
    this._updateUVOptions(options2, stdMat, objDefs, false);
  }
  _updateSharedOptions(options2, scene, stdMat, objDefs, pass) {
    options2.forceUv1 = stdMat.forceUv1;
    if (stdMat.userAttributes) {
      options2.litOptions.userAttributes = Object.fromEntries(stdMat.userAttributes.entries());
    }
    options2.litOptions.chunks = stdMat.chunks || {};
    options2.litOptions.pass = pass;
    options2.litOptions.alphaTest = stdMat.alphaTest > 0;
    options2.litOptions.blendType = stdMat.blendType;
    options2.litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
    options2.litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
    options2.litOptions.batch = objDefs && (objDefs & SHADERDEF_BATCH) !== 0;
    options2.litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
    options2.litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
    options2.litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
    options2.litOptions.useMorphTextureBasedInt = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0;
    options2.litOptions.nineSlicedMode = stdMat.nineSlicedMode || 0;
    if (scene.clusteredLightingEnabled && stdMat.useLighting) {
      options2.litOptions.clusteredLightingEnabled = true;
      options2.litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
      options2.litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
      options2.litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
      options2.litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
    } else {
      options2.litOptions.clusteredLightingEnabled = false;
      options2.litOptions.clusteredLightingCookiesEnabled = false;
      options2.litOptions.clusteredLightingShadowsEnabled = false;
      options2.litOptions.clusteredLightingAreaLightsEnabled = false;
    }
  }
  _updateUVOptions(options2, stdMat, objDefs, minimalOptions) {
    let hasUv0 = false;
    let hasUv1 = false;
    let hasVcolor = false;
    if (objDefs) {
      hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
      hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
      hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
    }
    options2.litOptions.vertexColors = false;
    this._mapXForms = [];
    const uniqueTextureMap = {};
    for (const p in _matTex2D) {
      this._updateTexOptions(options2, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap);
    }
    this._mapXForms = null;
    options2.litOptions.lightMapEnabled = options2.lightMap;
    options2.litOptions.dirLightMapEnabled = options2.dirLightMap;
    options2.litOptions.useHeights = options2.heightMap;
    options2.litOptions.useNormals = options2.normalMap;
    options2.litOptions.useClearCoatNormals = options2.clearCoatNormalMap;
    options2.litOptions.useAo = options2.aoMap || options2.aoVertexColor;
    options2.litOptions.diffuseMapEnabled = options2.diffuseMap;
  }
  _updateTexOptions(options2, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap) {
    const isOpacity = p === "opacity";
    if (!minimalOptions || isOpacity) {
      const mname = `${p}Map`;
      const vname = `${p}VertexColor`;
      const vcname = `${p}VertexColorChannel`;
      const cname = `${mname}Channel`;
      const tname = `${mname}Transform`;
      const uname = `${mname}Uv`;
      const iname = `${mname}Identifier`;
      if (p !== "light") {
        options2[mname] = false;
        options2[iname] = void 0;
        options2[cname] = "";
        options2[tname] = 0;
        options2[uname] = 0;
      }
      options2[vname] = false;
      options2[vcname] = "";
      if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0 && !stdMat.alphaToCoverage && stdMat.opacityDither === DITHER_NONE) {
        return;
      }
      if (p !== "height" && stdMat[vname]) {
        if (hasVcolor) {
          options2[vname] = stdMat[vname];
          options2[vcname] = stdMat[vcname];
          options2.litOptions.vertexColors = true;
        }
      }
      if (stdMat[mname]) {
        let allow = true;
        if (stdMat[uname] === 0 && !hasUv0) allow = false;
        if (stdMat[uname] === 1 && !hasUv1) allow = false;
        if (allow) {
          const mapId = stdMat[mname].id;
          let identifier = uniqueTextureMap[mapId];
          if (identifier === void 0) {
            uniqueTextureMap[mapId] = p;
            identifier = p;
          }
          options2[mname] = !!stdMat[mname];
          options2[iname] = identifier;
          options2[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);
          options2[cname] = stdMat[cname];
          options2[uname] = stdMat[uname];
        }
      }
    }
  }
  _updateMinOptions(options2, stdMat, pass) {
    const isPrepass = pass === SHADER_PREPASS_VELOCITY;
    options2.litOptions.opacityShadowDither = isPrepass ? stdMat.opacityDither : stdMat.opacityShadowDither;
    options2.litOptions.lights = [];
  }
  _updateMaterialOptions(options2, stdMat) {
    var _stdMat$diffuseMap, _stdMat$diffuseDetail, _stdMat$emissiveMap, _stdMat$lightMap;
    const useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.specularityFactor > 0 && stdMat.useMetalness || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);
    const useSpecularColor = !stdMat.useMetalness || stdMat.useMetalnessSpecularColor;
    const specularTint = useSpecular && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);
    const specularityFactorTint = useSpecular && stdMat.useMetalnessSpecularColor && (stdMat.specularityFactorTint || stdMat.specularityFactor < 1 && !stdMat.specularityFactorMap);
    const isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;
    options2.specularTint = specularTint ? 2 : 0;
    options2.specularityFactorTint = specularityFactorTint ? 1 : 0;
    options2.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;
    options2.glossTint = 1;
    options2.diffuseEncoding = (_stdMat$diffuseMap = stdMat.diffuseMap) == null ? void 0 : _stdMat$diffuseMap.encoding;
    options2.diffuseDetailEncoding = (_stdMat$diffuseDetail = stdMat.diffuseDetailMap) == null ? void 0 : _stdMat$diffuseDetail.encoding;
    options2.emissiveEncoding = (_stdMat$emissiveMap = stdMat.emissiveMap) == null ? void 0 : _stdMat$emissiveMap.encoding;
    options2.lightMapEncoding = (_stdMat$lightMap = stdMat.lightMap) == null ? void 0 : _stdMat$lightMap.encoding;
    options2.packedNormal = isPackedNormalMap;
    options2.refractionTint = stdMat.refraction !== 1 ? 1 : 0;
    options2.refractionIndexTint = stdMat.refractionIndex !== 1 / 1.5 ? 1 : 0;
    options2.thicknessTint = stdMat.useDynamicRefraction && stdMat.thickness !== 1 ? 1 : 0;
    options2.specularEncoding = stdMat.specularEncoding || "linear";
    options2.sheenEncoding = stdMat.sheenEncoding || "linear";
    options2.aoMapUv = stdMat.aoUvSet;
    options2.aoDetail = !!stdMat.aoMap;
    options2.diffuseDetail = !!stdMat.diffuseMap;
    options2.normalDetail = !!stdMat.normalMap;
    options2.diffuseDetailMode = stdMat.diffuseDetailMode;
    options2.aoDetailMode = stdMat.aoDetailMode;
    options2.clearCoatTint = stdMat.clearCoat !== 1 ? 1 : 0;
    options2.clearCoatGloss = !!stdMat.clearCoatGloss;
    options2.clearCoatGlossTint = stdMat.clearCoatGloss !== 1 ? 1 : 0;
    options2.iorTint = stdMat.refractionIndex !== 1 / 1.5 ? 1 : 0;
    options2.iridescenceTint = stdMat.iridescence !== 1 ? 1 : 0;
    options2.glossInvert = stdMat.glossInvert;
    options2.sheenGlossInvert = stdMat.sheenGlossInvert;
    options2.clearCoatGlossInvert = stdMat.clearCoatGlossInvert;
    options2.useSpecularColor = useSpecularColor;
    options2.litOptions.separateAmbient = false;
    options2.litOptions.customFragmentShader = stdMat.customFragmentShader;
    options2.litOptions.pixelSnap = stdMat.pixelSnap;
    options2.litOptions.ambientSH = !!stdMat.ambientSH;
    options2.litOptions.twoSidedLighting = stdMat.twoSidedLighting;
    options2.litOptions.occludeSpecular = stdMat.occludeSpecular;
    options2.litOptions.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1;
    options2.litOptions.useMsdf = !!stdMat.msdfMap;
    options2.litOptions.msdfTextAttribute = !!stdMat.msdfTextAttribute;
    options2.litOptions.alphaToCoverage = stdMat.alphaToCoverage;
    options2.litOptions.opacityFadesSpecular = stdMat.opacityFadesSpecular;
    options2.litOptions.opacityDither = stdMat.opacityDither;
    options2.litOptions.cubeMapProjection = stdMat.cubeMapProjection;
    options2.litOptions.occludeDirect = stdMat.occludeDirect;
    options2.litOptions.useSpecular = useSpecular;
    options2.litOptions.useSpecularityFactor = (specularityFactorTint || !!stdMat.specularityFactorMap) && stdMat.useMetalnessSpecularColor;
    options2.litOptions.enableGGXSpecular = stdMat.enableGGXSpecular;
    options2.litOptions.fresnelModel = stdMat.fresnelModel;
    options2.litOptions.useRefraction = (stdMat.refraction || !!stdMat.refractionMap) && (stdMat.useDynamicRefraction || !!options2.litOptions.reflectionSource);
    options2.litOptions.useClearCoat = !!stdMat.clearCoat;
    options2.litOptions.useSheen = stdMat.useSheen;
    options2.litOptions.useIridescence = stdMat.useIridescence && stdMat.iridescence !== 0;
    options2.litOptions.useMetalness = stdMat.useMetalness;
    options2.litOptions.useDynamicRefraction = stdMat.useDynamicRefraction;
    options2.litOptions.dispersion = stdMat.dispersion > 0;
  }
  _updateEnvOptions(options2, stdMat, scene, renderParams) {
    options2.litOptions.fog = stdMat.useFog ? scene.fog : FOG_NONE;
    options2.litOptions.gamma = renderParams.shaderOutputGamma;
    options2.litOptions.toneMap = stdMat.useTonemap ? renderParams.toneMapping : TONEMAP_NONE;
    let usingSceneEnv = false;
    if (stdMat.envAtlas && stdMat.cubeMap) {
      options2.litOptions.reflectionSource = "envAtlasHQ";
      options2.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
      options2.litOptions.reflectionCubemapEncoding = stdMat.cubeMap.encoding;
    } else if (stdMat.envAtlas) {
      options2.litOptions.reflectionSource = "envAtlas";
      options2.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
    } else if (stdMat.cubeMap) {
      options2.litOptions.reflectionSource = "cubeMap";
      options2.litOptions.reflectionEncoding = stdMat.cubeMap.encoding;
    } else if (stdMat.sphereMap) {
      options2.litOptions.reflectionSource = "sphereMap";
      options2.litOptions.reflectionEncoding = stdMat.sphereMap.encoding;
    } else if (stdMat.useSkybox && scene.envAtlas && scene.skybox) {
      options2.litOptions.reflectionSource = "envAtlasHQ";
      options2.litOptions.reflectionEncoding = scene.envAtlas.encoding;
      options2.litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
      usingSceneEnv = true;
    } else if (stdMat.useSkybox && scene.envAtlas) {
      options2.litOptions.reflectionSource = "envAtlas";
      options2.litOptions.reflectionEncoding = scene.envAtlas.encoding;
      usingSceneEnv = true;
    } else if (stdMat.useSkybox && scene.skybox) {
      options2.litOptions.reflectionSource = "cubeMap";
      options2.litOptions.reflectionEncoding = scene.skybox.encoding;
      usingSceneEnv = true;
    } else {
      options2.litOptions.reflectionSource = null;
      options2.litOptions.reflectionEncoding = null;
    }
    if (stdMat.ambientSH) {
      options2.litOptions.ambientSource = "ambientSH";
      options2.litOptions.ambientEncoding = null;
    } else {
      const envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);
      if (envAtlas) {
        options2.litOptions.ambientSource = "envAtlas";
        options2.litOptions.ambientEncoding = envAtlas.encoding;
      } else {
        options2.litOptions.ambientSource = "constant";
        options2.litOptions.ambientEncoding = null;
      }
    }
    options2.litOptions.skyboxIntensity = usingSceneEnv;
    options2.litOptions.useCubeMapRotation = usingSceneEnv && scene._skyboxRotationShaderInclude;
  }
  _updateLightOptions(options2, scene, stdMat, objDefs, sortedLights) {
    options2.lightMap = false;
    options2.lightMapChannel = "";
    options2.lightMapUv = 0;
    options2.lightMapTransform = 0;
    options2.litOptions.lightMapWithoutAmbient = false;
    options2.dirLightMap = false;
    if (objDefs) {
      options2.litOptions.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;
      if ((objDefs & SHADERDEF_LM) !== 0) {
        options2.lightMapEncoding = scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? "rgbm" : "linear";
        options2.lightMap = true;
        options2.lightMapChannel = "rgb";
        options2.lightMapUv = 1;
        options2.lightMapTransform = 0;
        options2.litOptions.lightMapWithoutAmbient = !stdMat.lightMap;
        if ((objDefs & SHADERDEF_DIRLM) !== 0) {
          options2.dirLightMap = true;
        }
        if ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {
          options2.litOptions.lightMapWithoutAmbient = false;
        }
      }
    }
    if (stdMat.useLighting) {
      const lightsFiltered = [];
      const mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
      options2.litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
      if (sortedLights) {
        LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
        LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
        LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
      }
      options2.litOptions.lights = lightsFiltered;
    } else {
      options2.litOptions.lights = [];
    }
    if (options2.litOptions.lights.length === 0) {
      options2.litOptions.noShadow = true;
    }
  }
  _getMapTransformID(xform, uv) {
    if (!xform) return 0;
    let xforms = this._mapXForms[uv];
    if (!xforms) {
      xforms = [];
      this._mapXForms[uv] = xforms;
    }
    for (let i = 0; i < xforms.length; i++) {
      if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {
        return i + 1;
      }
    }
    return xforms.push(xform);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material-parameters.js
function _textureParameter(name, channel = true, vertexColor = true) {
  const result = {};
  result[`${name}Map`] = "texture";
  result[`${name}MapTiling`] = "vec2";
  result[`${name}MapOffset`] = "vec2";
  result[`${name}MapRotation`] = "number";
  result[`${name}MapUv`] = "number";
  if (channel) {
    result[`${name}MapChannel`] = "string";
    if (vertexColor) {
      result[`${name}VertexColor`] = "boolean";
      result[`${name}VertexColorChannel`] = "string";
    }
  }
  return result;
}
var standardMaterialParameterTypes = _extends({
  name: "string",
  chunks: "chunks",
  mappingFormat: "string",
  _engine: "boolean",
  ambient: "rgb"
}, _textureParameter("ao"), _textureParameter("aoDetail", true, false), {
  aoDetailMode: "string",
  diffuse: "rgb"
}, _textureParameter("diffuse"), _textureParameter("diffuseDetail", true, false), {
  diffuseDetailMode: "string",
  specular: "rgb",
  specularTint: "boolean"
}, _textureParameter("specular"), {
  occludeSpecular: "enum:occludeSpecular",
  specularityFactor: "number",
  specularityFactorTint: "boolean"
}, _textureParameter("specularityFactor"), {
  useMetalness: "boolean",
  metalness: "number",
  enableGGXSpecular: "boolean",
  anisotropy: "number",
  metalnessTint: "boolean"
}, _textureParameter("metalness"), {
  useMetalnessSpecularColor: "boolean",
  shininess: "number",
  gloss: "number",
  glossInvert: "boolean"
}, _textureParameter("gloss"), {
  clearCoat: "number"
}, _textureParameter("clearCoat"), {
  clearCoatGloss: "number",
  clearCoatGlossInvert: "boolean"
}, _textureParameter("clearCoatGloss"), {
  clearCoatBumpiness: "number"
}, _textureParameter("clearCoatNormal", false), {
  useSheen: "boolean",
  sheen: "rgb"
}, _textureParameter("sheen"), {
  sheenGloss: "number",
  sheenGlossInvert: "boolean"
}, _textureParameter("sheenGloss"), {
  fresnelModel: "number",
  emissive: "rgb"
}, _textureParameter("emissive"), {
  emissiveIntensity: "number"
}, _textureParameter("normal", false), {
  bumpiness: "number"
}, _textureParameter("normalDetail", false), {
  normalDetailMapBumpiness: "number"
}, _textureParameter("height", true, false), {
  heightMapFactor: "number",
  alphaToCoverage: "boolean",
  alphaTest: "number",
  alphaFade: "number",
  opacity: "number"
}, _textureParameter("opacity"), {
  opacityFadesSpecular: "boolean",
  opacityDither: "string",
  opacityShadowDither: "string",
  reflectivity: "number",
  refraction: "number",
  refractionTint: "boolean"
}, _textureParameter("refraction"), {
  refractionIndex: "number",
  dispersion: "number",
  thickness: "number",
  thicknessTint: "boolean"
}, _textureParameter("thickness"), {
  attenuation: "rgb",
  attenuationDistance: "number",
  useDynamicRefraction: "boolean",
  sphereMap: "texture",
  cubeMap: "cubemap",
  cubeMapProjection: "number",
  cubeMapProjectionBox: "boundingbox",
  useIridescence: "boolean",
  iridescence: "number",
  iridescenceTint: "boolean"
}, _textureParameter("iridescence"), {
  iridescenceThicknessTint: "boolean",
  iridescenceThicknessMin: "number",
  iridescenceThicknessMax: "number",
  iridescenceRefractionIndex: "number"
}, _textureParameter("iridescenceThickness"), _textureParameter("light"), {
  depthTest: "boolean",
  depthFunc: "enum:depthFunc",
  depthWrite: "boolean",
  depthBias: "number",
  slopeDepthBias: "number",
  cull: "enum:cull",
  blendType: "enum:blendType",
  useFog: "boolean",
  useLighting: "boolean",
  useSkybox: "boolean",
  useTonemap: "boolean",
  envAtlas: "texture",
  twoSidedLighting: "boolean"
});
var standardMaterialTextureParameters = [];
for (const key in standardMaterialParameterTypes) {
  const type = standardMaterialParameterTypes[key];
  if (type === "texture") {
    standardMaterialTextureParameters.push(key);
  }
}
var standardMaterialCubemapParameters = [];
for (const key in standardMaterialParameterTypes) {
  const type = standardMaterialParameterTypes[key];
  if (type === "cubemap") {
    standardMaterialCubemapParameters.push(key);
  }
}
var standardMaterialRemovedParameters = {
  aoMapVertexColor: "boolean",
  diffuseMapTint: "boolean",
  diffuseMapVertexColor: "boolean",
  emissiveMapTint: "boolean",
  emissiveMapVertexColor: "boolean",
  glossMapVertexColor: "boolean",
  metalnessMapVertexColor: "boolean",
  opacityMapVertexColor: "boolean",
  specularAntialias: "boolean",
  specularMapTint: "boolean",
  specularMapVertexColor: "boolean"
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material.js
var _props = {};
var _uniforms = {};
var _params = /* @__PURE__ */ new Set();
var _tempColor = new Color();
var StandardMaterial = class extends Material {
  constructor() {
    super();
    this.userAttributes = /* @__PURE__ */ new Map();
    this._dirtyShader = true;
    this._assetReferences = {};
    this._activeParams = /* @__PURE__ */ new Set();
    this._activeLightingParams = /* @__PURE__ */ new Set();
    this.shaderOptBuilder = new StandardMaterialOptionsBuilder();
    this.reset();
  }
  reset() {
    Object.keys(_props).forEach((name) => {
      this[`_${name}`] = _props[name].value();
    });
    this._chunks = {};
    this._uniformCache = {};
  }
  set chunks(value) {
    this._dirtyShader = true;
    this._chunks = value;
  }
  get chunks() {
    this._dirtyShader = true;
    return this._chunks;
  }
  copy(source) {
    super.copy(source);
    Object.keys(_props).forEach((k) => {
      this[k] = source[k];
    });
    for (const p in source._chunks) {
      if (source._chunks.hasOwnProperty(p)) {
        this._chunks[p] = source._chunks[p];
      }
    }
    this.userAttributes = new Map(source.userAttributes);
    return this;
  }
  setAttribute(name, semantic) {
    this.userAttributes.set(semantic, name);
  }
  _setParameter(name, value) {
    _params.add(name);
    this.setParameter(name, value);
  }
  _setParameters(parameters) {
    parameters.forEach((v) => {
      this._setParameter(v.name, v.value);
    });
  }
  _processParameters(paramsName) {
    const prevParams = this[paramsName];
    prevParams.forEach((param) => {
      if (!_params.has(param)) {
        delete this.parameters[param];
      }
    });
    this[paramsName] = _params;
    _params = prevParams;
    _params.clear();
  }
  _updateMap(p) {
    const mname = `${p}Map`;
    const map = this[mname];
    if (map) {
      this._setParameter(`texture_${mname}`, map);
      const tname = `${mname}Transform`;
      const uniform = this.getUniform(tname);
      if (uniform) {
        this._setParameters(uniform);
      }
    }
  }
  _allocUniform(name, allocFunc) {
    let uniform = this._uniformCache[name];
    if (!uniform) {
      uniform = allocFunc();
      this._uniformCache[name] = uniform;
    }
    return uniform;
  }
  getUniform(name, device, scene) {
    return _uniforms[name](this, device, scene);
  }
  updateUniforms(device, scene) {
    const getUniform = (name) => {
      return this.getUniform(name, device, scene);
    };
    this._setParameter("material_ambient", getUniform("ambient"));
    this._setParameter("material_diffuse", getUniform("diffuse"));
    this._setParameter("material_aoIntensity", this.aoIntensity);
    if (this.useMetalness) {
      if (!this.metalnessMap || this.metalness < 1) {
        this._setParameter("material_metalness", this.metalness);
      }
      if (!this.specularMap || this.specularTint) {
        this._setParameter("material_specular", getUniform("specular"));
      }
      if (!this.specularityFactorMap || this.specularityFactorTint) {
        this._setParameter("material_specularityFactor", this.specularityFactor);
      }
      this._setParameter("material_sheen", getUniform("sheen"));
      this._setParameter("material_sheenGloss", this.sheenGloss);
      this._setParameter("material_refractionIndex", this.refractionIndex);
    } else {
      if (!this.specularMap || this.specularTint) {
        this._setParameter("material_specular", getUniform("specular"));
      }
    }
    if (this.enableGGXSpecular) {
      this._setParameter("material_anisotropy", this.anisotropy);
    }
    if (this.clearCoat > 0) {
      this._setParameter("material_clearCoat", this.clearCoat);
      this._setParameter("material_clearCoatGloss", this.clearCoatGloss);
      this._setParameter("material_clearCoatBumpiness", this.clearCoatBumpiness);
    }
    this._setParameter("material_gloss", this.gloss);
    this._setParameter("material_emissive", getUniform("emissive"));
    this._setParameter("material_emissiveIntensity", this.emissiveIntensity);
    if (this.refraction > 0) {
      this._setParameter("material_refraction", this.refraction);
    }
    if (this.dispersion > 0) {
      this._setParameter("material_dispersion", this.dispersion);
    }
    if (this.useDynamicRefraction) {
      this._setParameter("material_thickness", this.thickness);
      this._setParameter("material_attenuation", getUniform("attenuation"));
      this._setParameter("material_invAttenuationDistance", this.attenuationDistance === 0 ? 0 : 1 / this.attenuationDistance);
    }
    if (this.useIridescence) {
      this._setParameter("material_iridescence", this.iridescence);
      this._setParameter("material_iridescenceRefractionIndex", this.iridescenceRefractionIndex);
      this._setParameter("material_iridescenceThicknessMin", this.iridescenceThicknessMin);
      this._setParameter("material_iridescenceThicknessMax", this.iridescenceThicknessMax);
    }
    this._setParameter("material_opacity", this.opacity);
    if (this.opacityFadesSpecular === false) {
      this._setParameter("material_alphaFade", this.alphaFade);
    }
    if (this.occludeSpecular) {
      this._setParameter("material_occludeSpecularIntensity", this.occludeSpecularIntensity);
    }
    if (this.cubeMapProjection === CUBEPROJ_BOX) {
      this._setParameter(getUniform("cubeMapProjectionBox"));
    }
    for (const p in _matTex2D) {
      this._updateMap(p);
    }
    if (this.ambientSH) {
      this._setParameter("ambientSH[0]", this.ambientSH);
    }
    if (this.normalMap) {
      this._setParameter("material_bumpiness", this.bumpiness);
    }
    if (this.normalMap && this.normalDetailMap) {
      this._setParameter("material_normalDetailMapBumpiness", this.normalDetailMapBumpiness);
    }
    if (this.heightMap) {
      this._setParameter("material_heightMapFactor", getUniform("heightMapFactor"));
    }
    if (this.envAtlas && this.cubeMap) {
      this._setParameter("texture_envAtlas", this.envAtlas);
      this._setParameter("texture_cubeMap", this.cubeMap);
    } else if (this.envAtlas) {
      this._setParameter("texture_envAtlas", this.envAtlas);
    } else if (this.cubeMap) {
      this._setParameter("texture_cubeMap", this.cubeMap);
    } else if (this.sphereMap) {
      this._setParameter("texture_sphereMap", this.sphereMap);
    }
    this._setParameter("material_reflectivity", this.reflectivity);
    this._processParameters("_activeParams");
    if (this._dirtyShader) {
      this.clearVariants();
    }
  }
  updateEnvUniforms(device, scene) {
    const hasLocalEnvOverride = this.envAtlas || this.cubeMap || this.sphereMap;
    if (!hasLocalEnvOverride && this.useSkybox) {
      if (scene.envAtlas && scene.skybox) {
        this._setParameter("texture_envAtlas", scene.envAtlas);
        this._setParameter("texture_cubeMap", scene.skybox);
      } else if (scene.envAtlas) {
        this._setParameter("texture_envAtlas", scene.envAtlas);
      } else if (scene.skybox) {
        this._setParameter("texture_cubeMap", scene.skybox);
      }
    }
    this._processParameters("_activeLightingParams");
  }
  getShaderVariant(params) {
    const {
      device,
      scene,
      pass,
      objDefs,
      sortedLights,
      renderParams
    } = params;
    this.updateEnvUniforms(device, scene);
    const shaderPassInfo = ShaderPass.get(device).getByIndex(pass);
    const minimalOptions = pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS_VELOCITY || shaderPassInfo.isShadow;
    let options2 = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
    options2.defines = this.defines;
    if (minimalOptions) {
      this.shaderOptBuilder.updateMinRef(options2, scene, this, objDefs, pass, sortedLights);
    } else {
      this.shaderOptBuilder.updateRef(options2, scene, renderParams, this, objDefs, pass, sortedLights);
    }
    if (this.onUpdateShader) {
      options2 = this.onUpdateShader(options2);
    }
    const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
    const library = getProgramLibrary(device);
    library.register("standard", standard);
    const shader = library.getProgram("standard", options2, processingOptions, this.userId);
    this._dirtyShader = false;
    return shader;
  }
  destroy() {
    for (const asset in this._assetReferences) {
      this._assetReferences[asset]._unbind();
    }
    this._assetReferences = null;
    super.destroy();
  }
};
StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;
var defineUniform = (name, getUniformFunc) => {
  _uniforms[name] = getUniformFunc;
};
var definePropInternal = (name, constructorFunc, setterFunc, getterFunc) => {
  Object.defineProperty(StandardMaterial.prototype, name, {
    get: getterFunc || function() {
      return this[`_${name}`];
    },
    set: setterFunc
  });
  _props[name] = {
    value: constructorFunc
  };
};
var defineValueProp = (prop) => {
  const internalName = `_${prop.name}`;
  const dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);
  const setterFunc = function setterFunc2(value) {
    const oldValue = this[internalName];
    if (oldValue !== value) {
      this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
      this[internalName] = value;
    }
  };
  definePropInternal(prop.name, () => prop.defaultValue, setterFunc, prop.getterFunc);
};
var defineAggProp = (prop) => {
  const internalName = `_${prop.name}`;
  const dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);
  const setterFunc = function setterFunc2(value) {
    const oldValue = this[internalName];
    if (!oldValue.equals(value)) {
      this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
      this[internalName] = oldValue.copy(value);
    }
  };
  definePropInternal(prop.name, () => prop.defaultValue.clone(), setterFunc, prop.getterFunc);
};
var defineProp = (prop) => {
  return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);
};
function _defineTex2D(name, channel = "rgb", vertexColor = true, uv = 0) {
  _matTex2D[name] = channel.length || -1;
  defineProp({
    name: `${name}Map`,
    defaultValue: null,
    dirtyShaderFunc: (oldValue, newValue) => {
      return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.format !== newValue.format);
    }
  });
  defineProp({
    name: `${name}MapTiling`,
    defaultValue: new Vec2(1, 1)
  });
  defineProp({
    name: `${name}MapOffset`,
    defaultValue: new Vec2(0, 0)
  });
  defineProp({
    name: `${name}MapRotation`,
    defaultValue: 0
  });
  defineProp({
    name: `${name}MapUv`,
    defaultValue: uv
  });
  if (channel) {
    defineProp({
      name: `${name}MapChannel`,
      defaultValue: channel
    });
    if (vertexColor) {
      defineProp({
        name: `${name}VertexColor`,
        defaultValue: false
      });
      defineProp({
        name: `${name}VertexColorChannel`,
        defaultValue: channel
      });
    }
  }
  const mapTiling = `${name}MapTiling`;
  const mapOffset = `${name}MapOffset`;
  const mapRotation = `${name}MapRotation`;
  const mapTransform = `${name}MapTransform`;
  defineUniform(mapTransform, (material, device, scene) => {
    const tiling = material[mapTiling];
    const offset = material[mapOffset];
    const rotation2 = material[mapRotation];
    if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation2 === 0) {
      return null;
    }
    const uniform = material._allocUniform(mapTransform, () => {
      return [{
        name: `texture_${mapTransform}0`,
        value: new Float32Array(3)
      }, {
        name: `texture_${mapTransform}1`,
        value: new Float32Array(3)
      }];
    });
    const cr = Math.cos(rotation2 * math.DEG_TO_RAD);
    const sr = Math.sin(rotation2 * math.DEG_TO_RAD);
    const uniform0 = uniform[0].value;
    uniform0[0] = cr * tiling.x;
    uniform0[1] = -sr * tiling.y;
    uniform0[2] = offset.x;
    const uniform1 = uniform[1].value;
    uniform1[0] = sr * tiling.x;
    uniform1[1] = cr * tiling.y;
    uniform1[2] = 1 - tiling.y - offset.y;
    return uniform;
  });
}
function _defineColor(name, defaultValue) {
  defineProp({
    name,
    defaultValue,
    getterFunc: function() {
      this._dirtyShader = true;
      return this[`_${name}`];
    }
  });
  defineUniform(name, (material, device, scene) => {
    const uniform = material._allocUniform(name, () => new Float32Array(3));
    const color = material[name];
    _tempColor.linear(color);
    uniform[0] = _tempColor.r;
    uniform[1] = _tempColor.g;
    uniform[2] = _tempColor.b;
    return uniform;
  });
}
function _defineFloat(name, defaultValue, getUniformFunc) {
  defineProp({
    name,
    defaultValue,
    dirtyShaderFunc: (oldValue, newValue) => {
      return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);
    }
  });
  defineUniform(name, getUniformFunc);
}
function _defineObject(name, getUniformFunc) {
  defineProp({
    name,
    defaultValue: null,
    dirtyShaderFunc: (oldValue, newValue) => {
      return !!oldValue === !!newValue;
    }
  });
  defineUniform(name, getUniformFunc);
}
function _defineFlag(name, defaultValue) {
  defineProp({
    name,
    defaultValue
  });
}
function _defineMaterialProps() {
  _defineColor("ambient", new Color(1, 1, 1));
  _defineColor("diffuse", new Color(1, 1, 1));
  _defineColor("specular", new Color(0, 0, 0));
  _defineColor("emissive", new Color(0, 0, 0));
  _defineColor("sheen", new Color(1, 1, 1));
  _defineColor("attenuation", new Color(1, 1, 1));
  _defineFloat("emissiveIntensity", 1);
  _defineFloat("specularityFactor", 1);
  _defineFloat("sheenGloss", 0);
  _defineFloat("gloss", 0.25);
  _defineFloat("aoIntensity", 1);
  _defineFloat("heightMapFactor", 1, (material, device, scene) => {
    return material.heightMapFactor * 0.025;
  });
  _defineFloat("opacity", 1);
  _defineFloat("alphaFade", 1);
  _defineFloat("alphaTest", 0);
  _defineFloat("bumpiness", 1);
  _defineFloat("normalDetailMapBumpiness", 1);
  _defineFloat("reflectivity", 1);
  _defineFloat("occludeSpecularIntensity", 1);
  _defineFloat("refraction", 0);
  _defineFloat("refractionIndex", 1 / 1.5);
  _defineFloat("dispersion", 0);
  _defineFloat("thickness", 0);
  _defineFloat("attenuationDistance", 0);
  _defineFloat("metalness", 1);
  _defineFloat("anisotropy", 0);
  _defineFloat("clearCoat", 0);
  _defineFloat("clearCoatGloss", 1);
  _defineFloat("clearCoatBumpiness", 1);
  _defineFloat("aoUvSet", 0, null);
  _defineFloat("iridescence", 0);
  _defineFloat("iridescenceRefractionIndex", 1 / 1.5);
  _defineFloat("iridescenceThicknessMin", 0);
  _defineFloat("iridescenceThicknessMax", 0);
  _defineObject("ambientSH");
  _defineObject("cubeMapProjectionBox", (material, device, scene) => {
    const uniform = material._allocUniform("cubeMapProjectionBox", () => {
      return [{
        name: "envBoxMin",
        value: new Float32Array(3)
      }, {
        name: "envBoxMax",
        value: new Float32Array(3)
      }];
    });
    const bboxMin = material.cubeMapProjectionBox.getMin();
    const minUniform = uniform[0].value;
    minUniform[0] = bboxMin.x;
    minUniform[1] = bboxMin.y;
    minUniform[2] = bboxMin.z;
    const bboxMax = material.cubeMapProjectionBox.getMax();
    const maxUniform = uniform[1].value;
    maxUniform[0] = bboxMax.x;
    maxUniform[1] = bboxMax.y;
    maxUniform[2] = bboxMax.z;
    return uniform;
  });
  _defineFlag("specularTint", false);
  _defineFlag("specularityFactorTint", false);
  _defineFlag("useMetalness", false);
  _defineFlag("useMetalnessSpecularColor", false);
  _defineFlag("useSheen", false);
  _defineFlag("enableGGXSpecular", false);
  _defineFlag("occludeDirect", false);
  _defineFlag("opacityFadesSpecular", true);
  _defineFlag("occludeSpecular", SPECOCC_AO);
  _defineFlag("fresnelModel", FRESNEL_SCHLICK);
  _defineFlag("useDynamicRefraction", false);
  _defineFlag("cubeMapProjection", CUBEPROJ_NONE);
  _defineFlag("customFragmentShader", null);
  _defineFlag("useFog", true);
  _defineFlag("useLighting", true);
  _defineFlag("useTonemap", true);
  _defineFlag("useSkybox", true);
  _defineFlag("forceUv1", false);
  _defineFlag("pixelSnap", false);
  _defineFlag("twoSidedLighting", false);
  _defineFlag("nineSlicedMode", void 0);
  _defineFlag("msdfTextAttribute", false);
  _defineFlag("useIridescence", false);
  _defineFlag("glossInvert", false);
  _defineFlag("sheenGlossInvert", false);
  _defineFlag("clearCoatGlossInvert", false);
  _defineFlag("opacityDither", DITHER_NONE);
  _defineFlag("opacityShadowDither", DITHER_NONE);
  _defineTex2D("diffuse");
  _defineTex2D("specular");
  _defineTex2D("emissive");
  _defineTex2D("thickness", "g");
  _defineTex2D("specularityFactor", "g");
  _defineTex2D("normal", "");
  _defineTex2D("metalness", "g");
  _defineTex2D("gloss", "g");
  _defineTex2D("opacity", "a");
  _defineTex2D("refraction", "g");
  _defineTex2D("height", "g", false);
  _defineTex2D("ao", "g");
  _defineTex2D("light", "rgb", true, 1);
  _defineTex2D("msdf", "");
  _defineTex2D("diffuseDetail", "rgb", false);
  _defineTex2D("normalDetail", "");
  _defineTex2D("aoDetail", "g", false);
  _defineTex2D("clearCoat", "g");
  _defineTex2D("clearCoatGloss", "g");
  _defineTex2D("clearCoatNormal", "");
  _defineTex2D("sheen", "rgb");
  _defineTex2D("sheenGloss", "g");
  _defineTex2D("iridescence", "g");
  _defineTex2D("iridescenceThickness", "g");
  _defineFlag("diffuseDetailMode", DETAILMODE_MUL);
  _defineFlag("aoDetailMode", DETAILMODE_MUL);
  _defineObject("cubeMap");
  _defineObject("sphereMap");
  _defineObject("envAtlas");
  const getterFunc = function getterFunc2() {
    return this._prefilteredCubemaps;
  };
  const setterFunc = function setterFunc2(value) {
    const cubemaps = this._prefilteredCubemaps;
    value = value || [];
    let changed = false;
    let complete = true;
    for (let i = 0; i < 6; ++i) {
      const v = value[i] || null;
      if (cubemaps[i] !== v) {
        cubemaps[i] = v;
        changed = true;
      }
      complete = complete && !!cubemaps[i];
    }
    if (changed) {
      if (complete) {
        this.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
          target: this.envAtlas
        });
      } else {
        if (this.envAtlas) {
          this.envAtlas.destroy();
          this.envAtlas = null;
        }
      }
      this._dirtyShader = true;
    }
  };
  const empty = [null, null, null, null, null, null];
  definePropInternal("prefilteredCubemaps", () => empty.slice(), setterFunc, getterFunc);
}
_defineMaterialProps();

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/cone-base-geometry.js
var primitiveUv1Padding2 = 4 / 64;
var primitiveUv1PaddingScale2 = 1 - primitiveUv1Padding2 * 2;
var ConeBaseGeometry = class extends Geometry {
  constructor(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
    super();
    const pos = new Vec3();
    const bottomToTop = new Vec3();
    const norm = new Vec3();
    const top = new Vec3();
    const bottom = new Vec3();
    const tangent = new Vec3();
    const positions = [];
    const normals = [];
    const uvs = [];
    const uvs1 = [];
    const indices = [];
    let offset;
    if (height > 0) {
      for (let i = 0; i <= heightSegments; i++) {
        for (let j = 0; j <= capSegments; j++) {
          const theta = j / capSegments * 2 * Math.PI - Math.PI;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);
          top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);
          pos.lerp(bottom, top, i / heightSegments);
          bottomToTop.sub2(top, bottom).normalize();
          tangent.set(cosTheta, 0, -sinTheta);
          norm.cross(tangent, bottomToTop).normalize();
          positions.push(pos.x, pos.y, pos.z);
          normals.push(norm.x, norm.y, norm.z);
          let u = j / capSegments;
          let v = i / heightSegments;
          uvs.push(u, 1 - v);
          const _v = v;
          v = u;
          u = _v;
          u = u * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          v = v * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          u /= 3;
          uvs1.push(u, 1 - v);
          if (i < heightSegments && j < capSegments) {
            const first = i * (capSegments + 1) + j;
            const second = i * (capSegments + 1) + (j + 1);
            const third = (i + 1) * (capSegments + 1) + j;
            const fourth = (i + 1) * (capSegments + 1) + (j + 1);
            indices.push(first, second, third);
            indices.push(second, fourth, third);
          }
        }
      }
    }
    if (roundedCaps) {
      const latitudeBands = Math.floor(capSegments / 2);
      const longitudeBands = capSegments;
      const capOffset = height / 2;
      for (let lat = 0; lat <= latitudeBands; lat++) {
        const theta = lat * Math.PI * 0.5 / latitudeBands;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        for (let lon = 0; lon <= longitudeBands; lon++) {
          const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
          const sinPhi = Math.sin(phi);
          const cosPhi = Math.cos(phi);
          const x2 = cosPhi * sinTheta;
          const y2 = cosTheta;
          const z2 = sinPhi * sinTheta;
          let u = 1 - lon / longitudeBands;
          let v = 1 - lat / latitudeBands;
          positions.push(x2 * peakRadius, y2 * peakRadius + capOffset, z2 * peakRadius);
          normals.push(x2, y2, z2);
          uvs.push(u, 1 - v);
          u = u * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          v = v * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          u /= 3;
          v /= 3;
          u += 1 / 3;
          uvs1.push(u, 1 - v);
        }
      }
      offset = (heightSegments + 1) * (capSegments + 1);
      for (let lat = 0; lat < latitudeBands; ++lat) {
        for (let lon = 0; lon < longitudeBands; ++lon) {
          const first = lat * (longitudeBands + 1) + lon;
          const second = first + longitudeBands + 1;
          indices.push(offset + first + 1, offset + second, offset + first);
          indices.push(offset + first + 1, offset + second + 1, offset + second);
        }
      }
      for (let lat = 0; lat <= latitudeBands; lat++) {
        const theta = Math.PI * 0.5 + lat * Math.PI * 0.5 / latitudeBands;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        for (let lon = 0; lon <= longitudeBands; lon++) {
          const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
          const sinPhi = Math.sin(phi);
          const cosPhi = Math.cos(phi);
          const x2 = cosPhi * sinTheta;
          const y2 = cosTheta;
          const z2 = sinPhi * sinTheta;
          let u = 1 - lon / longitudeBands;
          let v = 1 - lat / latitudeBands;
          positions.push(x2 * peakRadius, y2 * peakRadius - capOffset, z2 * peakRadius);
          normals.push(x2, y2, z2);
          uvs.push(u, 1 - v);
          u = u * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          v = v * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          u /= 3;
          v /= 3;
          u += 2 / 3;
          uvs1.push(u, 1 - v);
        }
      }
      offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);
      for (let lat = 0; lat < latitudeBands; ++lat) {
        for (let lon = 0; lon < longitudeBands; ++lon) {
          const first = lat * (longitudeBands + 1) + lon;
          const second = first + longitudeBands + 1;
          indices.push(offset + first + 1, offset + second, offset + first);
          indices.push(offset + first + 1, offset + second + 1, offset + second);
        }
      }
    } else {
      offset = (heightSegments + 1) * (capSegments + 1);
      if (baseRadius > 0) {
        for (let i = 0; i < capSegments; i++) {
          const theta = i / capSegments * 2 * Math.PI;
          const x2 = Math.sin(theta);
          const y2 = -height / 2;
          const z2 = Math.cos(theta);
          let u = 1 - (x2 + 1) / 2;
          let v = (z2 + 1) / 2;
          positions.push(x2 * baseRadius, y2, z2 * baseRadius);
          normals.push(0, -1, 0);
          uvs.push(u, 1 - v);
          u = u * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          v = v * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          u /= 3;
          v /= 3;
          u += 1 / 3;
          uvs1.push(u, 1 - v);
          if (i > 1) {
            indices.push(offset, offset + i, offset + i - 1);
          }
        }
      }
      offset += capSegments;
      if (peakRadius > 0) {
        for (let i = 0; i < capSegments; i++) {
          const theta = i / capSegments * 2 * Math.PI;
          const x2 = Math.sin(theta);
          const y2 = height / 2;
          const z2 = Math.cos(theta);
          let u = 1 - (x2 + 1) / 2;
          let v = (z2 + 1) / 2;
          positions.push(x2 * peakRadius, y2, z2 * peakRadius);
          normals.push(0, 1, 0);
          uvs.push(u, 1 - v);
          u = u * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          v = v * primitiveUv1PaddingScale2 + primitiveUv1Padding2;
          u /= 3;
          v /= 3;
          u += 2 / 3;
          uvs1.push(u, 1 - v);
          if (i > 1) {
            indices.push(offset, offset + i - 1, offset + i);
          }
        }
      }
    }
    this.positions = positions;
    this.normals = normals;
    this.uvs = uvs;
    this.uvs1 = uvs1;
    this.indices = indices;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/capsule-geometry.js
var CapsuleGeometry = class extends ConeBaseGeometry {
  constructor(opts = {}) {
    var _opts$radius, _opts$height, _opts$heightSegments, _opts$sides;
    const radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.3;
    const height = (_opts$height = opts.height) != null ? _opts$height : 1;
    const heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 1;
    const sides = (_opts$sides = opts.sides) != null ? _opts$sides : 20;
    super(radius, radius, height - 2 * radius, heightSegments, sides, true);
    if (opts.calculateTangents) {
      this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/cone-geometry.js
var ConeGeometry = class extends ConeBaseGeometry {
  constructor(opts = {}) {
    var _opts$baseRadius, _opts$peakRadius, _opts$height, _opts$heightSegments, _opts$capSegments;
    const baseRadius = (_opts$baseRadius = opts.baseRadius) != null ? _opts$baseRadius : 0.5;
    const peakRadius = (_opts$peakRadius = opts.peakRadius) != null ? _opts$peakRadius : 0;
    const height = (_opts$height = opts.height) != null ? _opts$height : 1;
    const heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 5;
    const capSegments = (_opts$capSegments = opts.capSegments) != null ? _opts$capSegments : 18;
    super(baseRadius, peakRadius, height, heightSegments, capSegments, false);
    if (opts.calculateTangents) {
      this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/cylinder-geometry.js
var CylinderGeometry = class extends ConeBaseGeometry {
  constructor(opts = {}) {
    var _opts$radius, _opts$height, _opts$heightSegments, _opts$capSegments;
    const radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.5;
    const height = (_opts$height = opts.height) != null ? _opts$height : 1;
    const heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 5;
    const capSegments = (_opts$capSegments = opts.capSegments) != null ? _opts$capSegments : 20;
    super(radius, radius, height, heightSegments, capSegments, false);
    if (opts.calculateTangents) {
      this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/plane-geometry.js
var PlaneGeometry = class extends Geometry {
  constructor(opts = {}) {
    var _opts$halfExtents, _opts$widthSegments, _opts$lengthSegments;
    super();
    const he = (_opts$halfExtents = opts.halfExtents) != null ? _opts$halfExtents : new Vec2(0.5, 0.5);
    const ws = (_opts$widthSegments = opts.widthSegments) != null ? _opts$widthSegments : 5;
    const ls = (_opts$lengthSegments = opts.lengthSegments) != null ? _opts$lengthSegments : 5;
    const positions = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    let vcounter = 0;
    for (let i = 0; i <= ws; i++) {
      for (let j = 0; j <= ls; j++) {
        const x2 = -he.x + 2 * he.x * i / ws;
        const y2 = 0;
        const z2 = -(-he.y + 2 * he.y * j / ls);
        const u = i / ws;
        const v = j / ls;
        positions.push(x2, y2, z2);
        normals.push(0, 1, 0);
        uvs.push(u, 1 - v);
        if (i < ws && j < ls) {
          indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
          indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
        }
        vcounter++;
      }
    }
    this.positions = positions;
    this.normals = normals;
    this.uvs = uvs;
    this.uvs1 = uvs;
    this.indices = indices;
    if (opts.calculateTangents) {
      this.tangents = calculateTangents(positions, normals, uvs, indices);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/geometry/torus-geometry.js
var TorusGeometry = class extends Geometry {
  constructor(opts = {}) {
    var _opts$tubeRadius, _opts$ringRadius, _opts$sectorAngle, _opts$segments, _opts$sides;
    super();
    const rc = (_opts$tubeRadius = opts.tubeRadius) != null ? _opts$tubeRadius : 0.2;
    const rt = (_opts$ringRadius = opts.ringRadius) != null ? _opts$ringRadius : 0.3;
    const sectorAngle = ((_opts$sectorAngle = opts.sectorAngle) != null ? _opts$sectorAngle : 360) * math.DEG_TO_RAD;
    const segments = (_opts$segments = opts.segments) != null ? _opts$segments : 30;
    const sides = (_opts$sides = opts.sides) != null ? _opts$sides : 20;
    const positions = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    for (let i = 0; i <= sides; i++) {
      for (let j = 0; j <= segments; j++) {
        const x2 = Math.cos(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
        const y2 = Math.sin(2 * Math.PI * i / sides) * rc;
        const z2 = Math.sin(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
        const nx = Math.cos(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);
        const ny = Math.sin(2 * Math.PI * i / sides);
        const nz = Math.sin(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);
        const u = i / sides;
        const v = 1 - j / segments;
        positions.push(x2, y2, z2);
        normals.push(nx, ny, nz);
        uvs.push(u, 1 - v);
        if (i < sides && j < segments) {
          const first = i * (segments + 1) + j;
          const second = (i + 1) * (segments + 1) + j;
          const third = i * (segments + 1) + (j + 1);
          const fourth = (i + 1) * (segments + 1) + (j + 1);
          indices.push(first, second, third);
          indices.push(second, fourth, third);
        }
      }
    }
    this.positions = positions;
    this.normals = normals;
    this.uvs = uvs;
    this.uvs1 = uvs;
    this.indices = indices;
    if (opts.calculateTangents) {
      this.tangents = calculateTangents(positions, normals, uvs, indices);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/program-library.js
var ProgramLibrary = class {
  constructor(device, standardMaterial) {
    this.processedCache = /* @__PURE__ */ new Map();
    this.definitionsCache = /* @__PURE__ */ new Map();
    this._generators = /* @__PURE__ */ new Map();
    this._device = device;
    this._isClearingCache = false;
    this._precached = false;
    this._programsCollection = [];
    this._defaultStdMatOption = new StandardMaterialOptions();
    this._defaultStdMatOptionMin = new StandardMaterialOptions();
    const defaultRenderParams = new RenderingParams();
    standardMaterial.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, defaultRenderParams, standardMaterial, null, [], SHADER_FORWARD, null);
    standardMaterial.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, standardMaterial, null, SHADER_SHADOW, null);
    device.on("destroy:shader", (shader) => {
      this.removeFromCache(shader);
    });
  }
  destroy() {
    this.clearCache();
  }
  register(name, generator) {
    if (!this._generators.has(name)) {
      this._generators.set(name, generator);
    }
  }
  unregister(name) {
    if (this._generators.has(name)) {
      this._generators.delete(name);
    }
  }
  isRegistered(name) {
    return this._generators.has(name);
  }
  generateShaderDefinition(generator, name, key, options2) {
    let def = this.definitionsCache.get(key);
    if (!def) {
      var _options$litOptions, _options$litOptions2, _def$name;
      let lights2;
      if ((_options$litOptions = options2.litOptions) != null && _options$litOptions.lights) {
        lights2 = options2.litOptions.lights;
        options2.litOptions.lights = lights2.map((l) => {
          const lcopy = l.clone ? l.clone() : l;
          lcopy.key = l.key;
          return lcopy;
        });
      }
      this.storeNewProgram(name, options2);
      if ((_options$litOptions2 = options2.litOptions) != null && _options$litOptions2.lights) {
        options2.litOptions.lights = lights2;
      }
      if (this._precached) ;
      const device = this._device;
      def = generator.createShaderDefinition(device, options2);
      def.name = (_def$name = def.name) != null ? _def$name : options2.pass ? `${name}-pass:${options2.pass}` : name;
      this.definitionsCache.set(key, def);
    }
    return def;
  }
  getCachedShader(key) {
    return this.processedCache.get(key);
  }
  setCachedShader(key, shader) {
    this.processedCache.set(key, shader);
  }
  getProgram(name, options2, processingOptions, userMaterialId) {
    const generator = this._generators.get(name);
    if (!generator) {
      return null;
    }
    const generationKeyString = generator.generateKey(options2);
    const generationKey = hashCode(generationKeyString);
    const processingKeyString = processingOptions.generateKey(this._device);
    const processingKey = hashCode(processingKeyString);
    const totalKey = `${generationKey}#${processingKey}`;
    let processedShader = this.getCachedShader(totalKey);
    if (!processedShader) {
      const generatedShaderDef = this.generateShaderDefinition(generator, name, generationKey, options2);
      let passName = "";
      let shaderPassInfo;
      if (options2.pass !== void 0) {
        shaderPassInfo = ShaderPass.get(this._device).getByIndex(options2.pass);
        passName = `-${shaderPassInfo.name}`;
      }
      this._device.fire("shader:generate", {
        userMaterialId,
        shaderPassInfo,
        definition: generatedShaderDef
      });
      const shaderDefinition = {
        name: `${generatedShaderDef.name}${passName}-proc`,
        attributes: generatedShaderDef.attributes,
        vshader: generatedShaderDef.vshader,
        vincludes: generatedShaderDef.vincludes,
        fincludes: generatedShaderDef.fincludes,
        fshader: generatedShaderDef.fshader,
        processingOptions,
        shaderLanguage: generatedShaderDef.shaderLanguage,
        meshUniformBufferFormat: generatedShaderDef.meshUniformBufferFormat,
        meshBindGroupFormat: generatedShaderDef.meshBindGroupFormat
      };
      processedShader = new Shader(this._device, shaderDefinition);
      this.setCachedShader(totalKey, processedShader);
    }
    return processedShader;
  }
  storeNewProgram(name, options2) {
    let opt = {};
    if (name === "standard") {
      const defaultMat = this._getDefaultStdMatOptions(options2.pass);
      for (const p in options2) {
        if (options2.hasOwnProperty(p) && defaultMat[p] !== options2[p] || p === "pass") {
          opt[p] = options2[p];
        }
      }
      for (const p in options2.litOptions) {
        opt[p] = options2.litOptions[p];
      }
    } else {
      opt = options2;
    }
    this._programsCollection.push(JSON.stringify({
      name,
      options: opt
    }));
  }
  dumpPrograms() {
    let text = "let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n";
    text += "let shaders = [";
    if (this._programsCollection[0]) {
      text += `
	${this._programsCollection[0]}`;
    }
    for (let i = 1; i < this._programsCollection.length; ++i) {
      text += `,
	${this._programsCollection[i]}`;
    }
    text += "\n];\n";
    text += "pc.getProgramLibrary(device).precompile(shaders);\n";
    text += `if (pc.version != "${version}" || pc.revision != "${revision}")
`;
    text += '	console.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';
    const element = document.createElement("a");
    element.setAttribute("href", `data:text/plain;charset=utf-8,${encodeURIComponent(text)}`);
    element.setAttribute("download", "precompile-shaders.js");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  clearCache() {
    this._isClearingCache = true;
    this.processedCache.forEach((shader) => {
      shader.destroy();
    });
    this.processedCache.clear();
    this._isClearingCache = false;
  }
  removeFromCache(shader) {
    if (this._isClearingCache) {
      return;
    }
    this.processedCache.forEach((cachedShader, key) => {
      if (shader === cachedShader) {
        this.processedCache.delete(key);
      }
    });
  }
  _getDefaultStdMatOptions(pass) {
    const shaderPassInfo = ShaderPass.get(this._device).getByIndex(pass);
    return pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS_VELOCITY || shaderPassInfo.isShadow ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
  }
  precompile(cache) {
    if (cache) {
      const shaders = new Array(cache.length);
      for (let i = 0; i < cache.length; i++) {
        if (cache[i].name === "standard") {
          const opt = cache[i].options;
          const defaultMat = this._getDefaultStdMatOptions(opt.pass);
          for (const p in defaultMat) {
            if (defaultMat.hasOwnProperty(p) && opt[p] === void 0) {
              opt[p] = defaultMat[p];
            }
          }
        }
        shaders[i] = this.getProgram(cache[i].name, cache[i].options);
      }
    }
    this._precached = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lightmapper/frag/bakeDirLmEnd.js
var bakeDirLmEndPS = `
	vec4 dirLm = texture2D(texture_dirLightMap, vUv1);
	if (bakeDir > 0.5) {
		if (dAtten > 0.00001) {
			dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);
			dAtten = saturate(dAtten);
			gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);
			gl_FragColor.a = dirLm.w + dAtten;
			gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);
		} else {
			gl_FragColor = dirLm;
		}
	} else {
		gl_FragColor.rgb = dirLm.xyz;
		gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);
	}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lightmapper/frag/bakeLmEnd.js
var bakeLmEndPS = `
#ifdef LIGHTMAP_RGBM
	gl_FragColor.rgb = dDiffuseLight;
	gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));
	gl_FragColor.rgb /= 8.0;
	gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );
	gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;
	gl_FragColor.rgb /= gl_FragColor.a;
#else
	gl_FragColor = vec4(dDiffuseLight, 1.0);
#endif
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lightmapper/frag/dilate.js
var dilatePS = `
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
void main(void) {
	vec4 c = texture2DLodEXT(source, vUv0, 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 - pixelOffset, 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(0, -pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(-pixelOffset.x, 0), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(pixelOffset.x, 0), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(0, pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + pixelOffset, 0.0);
	gl_FragColor = c;
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lightmapper/frag/bilateralDeNoise.js
var bilateralDeNoisePS = `
float normpdf3(in vec3 v, in float sigma) {
	return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;
}
vec3 decodeRGBM(vec4 rgbm) {
	vec3 color = (8.0 * rgbm.a) * rgbm.rgb;
	return color * color;
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec4 encodeRGBM(vec3 color) {
	vec4 encoded;
	encoded.rgb = pow(color.rgb, vec3(0.5));
	encoded.rgb *= 1.0 / 8.0;
	encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );
	encoded.a = ceil(encoded.a * 255.0) / 255.0;
	encoded.rgb /= encoded.a;
	return encoded;
}
#define MSIZE 15
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
uniform vec2 sigmas;
uniform float bZnorm;
uniform float kernel[MSIZE];
void main(void) {
	
	vec4 pixelRgbm = texture2DLodEXT(source, vUv0, 0.0);
	if (pixelRgbm.a <= 0.0) {
		gl_FragColor = pixelRgbm;
		return ;
	}
	float sigma = sigmas.x;
	float bSigma = sigmas.y;
	vec3 pixelHdr = decodeRGBM(pixelRgbm);
	vec3 accumulatedHdr = vec3(0.0);
	float accumulatedFactor = 0.0;
	const int kSize = (MSIZE-1)/2;
	for (int i = -kSize; i <= kSize; ++i) {
		for (int j = -kSize; j <= kSize; ++j) {
			
			vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;
			vec4 rgbm = texture2DLodEXT(source, coord, 0.0);
			if (rgbm.a > 0.0) {
				vec3 hdr = decodeRGBM(rgbm);
				float factor = kernel[kSize + j] * kernel[kSize + i];
				factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;
				accumulatedHdr += factor * hdr;
				accumulatedFactor += factor;
			}
		}
	}
	gl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);
}
`;

// ../node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/chunks-lightmapper.js
var shaderChunksLightmapper = {
  bakeDirLmEndPS,
  bakeLmEndPS,
  dilatePS,
  bilateralDeNoisePS
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-data.js
var vec3 = new Vec3();
var mat4 = new Mat4();
var quat = new Quat();
var quat2 = new Quat();
var aabb = new BoundingBox();
var aabb2 = new BoundingBox();
var debugColor = new Color(1, 1, 0, 0.4);
var SH_C0 = 0.28209479177387814;
var SplatIterator = class {
  constructor(gsplatData, p, r, s2, c2) {
    const x2 = gsplatData.getProp("x");
    const y2 = gsplatData.getProp("y");
    const z2 = gsplatData.getProp("z");
    const rx = gsplatData.getProp("rot_1");
    const ry = gsplatData.getProp("rot_2");
    const rz = gsplatData.getProp("rot_3");
    const rw = gsplatData.getProp("rot_0");
    const sx = gsplatData.getProp("scale_0");
    const sy = gsplatData.getProp("scale_1");
    const sz = gsplatData.getProp("scale_2");
    const cr = gsplatData.getProp("f_dc_0");
    const cg = gsplatData.getProp("f_dc_1");
    const cb = gsplatData.getProp("f_dc_2");
    const ca = gsplatData.getProp("opacity");
    const sigmoid = (v) => {
      if (v > 0) {
        return 1 / (1 + Math.exp(-v));
      }
      const t = Math.exp(v);
      return t / (1 + t);
    };
    this.read = (i) => {
      if (p) {
        p.x = x2[i];
        p.y = y2[i];
        p.z = z2[i];
      }
      if (r) {
        r.set(rx[i], ry[i], rz[i], rw[i]);
      }
      if (s2) {
        s2.set(Math.exp(sx[i]), Math.exp(sy[i]), Math.exp(sz[i]));
      }
      if (c2) {
        c2.set(0.5 + cr[i] * SH_C0, 0.5 + cg[i] * SH_C0, 0.5 + cb[i] * SH_C0, sigmoid(ca[i]));
      }
    };
  }
};
var calcSplatMat = (result, p, r) => {
  quat.set(r.x, r.y, r.z, r.w).normalize();
  result.setTRS(p, quat, Vec3.ONE);
};
var GSplatData = class _GSplatData {
  constructor(elements) {
    this.elements = void 0;
    this.numSplats = void 0;
    this.elements = elements;
    this.numSplats = this.getElement("vertex").count;
  }
  static calcSplatAabb(result, p, r, s2) {
    calcSplatMat(mat4, p, r);
    aabb.center.set(0, 0, 0);
    aabb.halfExtents.set(s2.x * 2, s2.y * 2, s2.z * 2);
    result.setFromTransformedAabb(aabb, mat4);
  }
  transform(mat2) {
    const x2 = this.getProp("x");
    const y2 = this.getProp("y");
    const z2 = this.getProp("z");
    if (x2 && y2 && z2) {
      for (let i = 0; i < this.numSplats; ++i) {
        vec3.set(x2[i], y2[i], z2[i]);
        mat2.transformPoint(vec3, vec3);
        x2[i] = vec3.x;
        y2[i] = vec3.y;
        z2[i] = vec3.z;
      }
    }
    const rx = this.getProp("rot_1");
    const ry = this.getProp("rot_2");
    const rz = this.getProp("rot_3");
    const rw = this.getProp("rot_0");
    if (rx && ry && rz && rw) {
      quat2.setFromMat4(mat2);
      for (let i = 0; i < this.numSplats; ++i) {
        quat.set(rx[i], ry[i], rz[i], rw[i]).mul2(quat2, quat);
        rx[i] = quat.x;
        ry[i] = quat.y;
        rz[i] = quat.z;
        rw[i] = quat.w;
      }
    }
  }
  getProp(name, elementName = "vertex") {
    var _this$getElement;
    return (_this$getElement = this.getElement(elementName)) == null || (_this$getElement = _this$getElement.properties.find((p) => p.name === name)) == null ? void 0 : _this$getElement.storage;
  }
  getElement(name) {
    return this.elements.find((e) => e.name === name);
  }
  addProp(name, storage) {
    this.getElement("vertex").properties.push({
      type: "float",
      name,
      storage,
      byteSize: 4
    });
  }
  createIter(p, r, s2, c2) {
    return new SplatIterator(this, p, r, s2, c2);
  }
  calcAabb(result, pred) {
    let mx, my, mz, Mx, My, Mz;
    let first = true;
    const p = new Vec3();
    const s2 = new Vec3();
    const iter = this.createIter(p, null, s2);
    for (let i = 0; i < this.numSplats; ++i) {
      if (pred && !pred(i)) {
        continue;
      }
      iter.read(i);
      const scaleVal = 2 * Math.max(s2.x, s2.y, s2.z);
      if (first) {
        first = false;
        mx = p.x - scaleVal;
        my = p.y - scaleVal;
        mz = p.z - scaleVal;
        Mx = p.x + scaleVal;
        My = p.y + scaleVal;
        Mz = p.z + scaleVal;
      } else {
        mx = Math.min(mx, p.x - scaleVal);
        my = Math.min(my, p.y - scaleVal);
        mz = Math.min(mz, p.z - scaleVal);
        Mx = Math.max(Mx, p.x + scaleVal);
        My = Math.max(My, p.y + scaleVal);
        Mz = Math.max(Mz, p.z + scaleVal);
      }
    }
    if (!first) {
      result.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);
      result.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);
    }
    return !first;
  }
  calcAabbExact(result, pred) {
    const p = new Vec3();
    const r = new Quat();
    const s2 = new Vec3();
    const iter = this.createIter(p, r, s2);
    let first = true;
    for (let i = 0; i < this.numSplats; ++i) {
      if (pred && !pred(i)) {
        continue;
      }
      iter.read(i);
      if (first) {
        first = false;
        _GSplatData.calcSplatAabb(result, p, r, s2);
      } else {
        _GSplatData.calcSplatAabb(aabb2, p, r, s2);
        result.add(aabb2);
      }
    }
    return !first;
  }
  getCenters(result) {
    const p = new Vec3();
    const iter = this.createIter(p);
    for (let i = 0; i < this.numSplats; ++i) {
      iter.read(i);
      result[i * 3 + 0] = p.x;
      result[i * 3 + 1] = p.y;
      result[i * 3 + 2] = p.z;
    }
  }
  calcFocalPoint(result, pred) {
    const p = new Vec3();
    const s2 = new Vec3();
    const iter = this.createIter(p, null, s2, null);
    result.x = 0;
    result.y = 0;
    result.z = 0;
    let sum = 0;
    for (let i = 0; i < this.numSplats; ++i) {
      if (pred && !pred(i)) {
        continue;
      }
      iter.read(i);
      const weight = 1 / (1 + Math.max(s2.x, s2.y, s2.z));
      result.x += p.x * weight;
      result.y += p.y * weight;
      result.z += p.z * weight;
      sum += weight;
    }
    result.mulScalar(1 / sum);
  }
  renderWireframeBounds(scene, worldMat) {
    const p = new Vec3();
    const r = new Quat();
    const s2 = new Vec3();
    const min = new Vec3();
    const max = new Vec3();
    const iter = this.createIter(p, r, s2);
    for (let i = 0; i < this.numSplats; ++i) {
      iter.read(i);
      calcSplatMat(mat4, p, r);
      mat4.mul2(worldMat, mat4);
      min.set(s2.x * -2, s2.y * -2, s2.z * -2);
      max.set(s2.x * 2, s2.y * 2, s2.z * 2);
      scene.immediate.drawWireAlignedBox(min, max, debugColor, true, scene.defaultDrawLayer, mat4);
    }
  }
  get isCompressed() {
    return false;
  }
  calcMortonOrder() {
    const calcMinMax = (arr) => {
      let min = arr[0];
      let max = arr[0];
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] < min) min = arr[i];
        if (arr[i] > max) max = arr[i];
      }
      return {
        min,
        max
      };
    };
    const encodeMorton3 = (x3, y3, z3) => {
      const Part1By2 = (x4) => {
        x4 &= 1023;
        x4 = (x4 ^ x4 << 16) & 4278190335;
        x4 = (x4 ^ x4 << 8) & 50393103;
        x4 = (x4 ^ x4 << 4) & 51130563;
        x4 = (x4 ^ x4 << 2) & 153391689;
        return x4;
      };
      return (Part1By2(z3) << 2) + (Part1By2(y3) << 1) + Part1By2(x3);
    };
    const x2 = this.getProp("x");
    const y2 = this.getProp("y");
    const z2 = this.getProp("z");
    const {
      min: minX,
      max: maxX
    } = calcMinMax(x2);
    const {
      min: minY,
      max: maxY
    } = calcMinMax(y2);
    const {
      min: minZ,
      max: maxZ
    } = calcMinMax(z2);
    const sizeX = minX === maxX ? 0 : 1024 / (maxX - minX);
    const sizeY = minY === maxY ? 0 : 1024 / (maxY - minY);
    const sizeZ = minZ === maxZ ? 0 : 1024 / (maxZ - minZ);
    const codes = /* @__PURE__ */ new Map();
    for (let i = 0; i < this.numSplats; i++) {
      const ix = Math.floor((x2[i] - minX) * sizeX);
      const iy = Math.floor((y2[i] - minY) * sizeY);
      const iz = Math.floor((z2[i] - minZ) * sizeZ);
      const code = encodeMorton3(ix, iy, iz);
      const val = codes.get(code);
      if (val) {
        val.push(i);
      } else {
        codes.set(code, [i]);
      }
    }
    const keys = Array.from(codes.keys()).sort((a, b) => a - b);
    const indices = new Uint32Array(this.numSplats);
    let idx = 0;
    for (let i = 0; i < keys.length; ++i) {
      const val = codes.get(keys[i]);
      for (let j = 0; j < val.length; ++j) {
        indices[idx++] = val[j];
      }
    }
    return indices;
  }
  reorder(order) {
    const cache = /* @__PURE__ */ new Map();
    const getStorage = (size) => {
      if (cache.has(size)) {
        const buffer = cache.get(size);
        cache.delete(size);
        return buffer;
      }
      return new ArrayBuffer(size);
    };
    const returnStorage = (buffer) => {
      cache.set(buffer.byteLength, buffer);
    };
    const reorder = (data2) => {
      const result = new data2.constructor(getStorage(data2.byteLength));
      for (let i = 0; i < order.length; i++) {
        result[i] = data2[order[i]];
      }
      returnStorage(data2.buffer);
      return result;
    };
    this.elements.forEach((element) => {
      element.properties.forEach((property) => {
        if (property.storage) {
          property.storage = reorder(property.storage);
        }
      });
    });
  }
  reorderData() {
    this.reorder(this.calcMortonOrder());
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/gsplat/shader-generator-gsplat.js
var splatCoreVS = `
	uniform mat4 matrix_model;
	uniform mat4 matrix_view;
	uniform mat4 matrix_projection;
	uniform vec2 viewport;
	uniform vec4 tex_params;
	uniform highp usampler2D splatOrder;
	uniform highp sampler2D transformA;
	uniform highp sampler2D transformB;
	uniform highp sampler2D transformC;
	uniform sampler2D splatColor;
	attribute vec3 vertex_position;
	attribute uint vertex_id_attrib;
	varying vec2 texCoord;
	varying vec4 color;
	#ifndef DITHER_NONE
		varying float id;
	#endif
	uint orderId;
	uint splatId;
	ivec2 splatUV;
	vec3 center;
	vec3 covA;
	vec3 covB;
	bool calcSplatUV() {
		uint numSplats = uint(tex_params.x);
		uint textureWidth = uint(tex_params.y);
		orderId = vertex_id_attrib + uint(vertex_position.z);
		if (orderId >= numSplats) {
			return false;
		}
		ivec2 orderUV = ivec2(
			int(orderId % textureWidth),
			int(orderId / textureWidth)
		);
		splatId = texelFetch(splatOrder, orderUV, 0).r;
		splatUV = ivec2(
			int(splatId % textureWidth),
			int(splatId / textureWidth)
		);
		return true;
	}
	void readData() {
		vec4 tA = texelFetch(transformA, splatUV, 0);
		vec4 tB = texelFetch(transformB, splatUV, 0);
		vec4 tC = texelFetch(transformC, splatUV, 0);
		center = tA.xyz;
		covA = tB.xyz;
		covB = vec3(tA.w, tB.w, tC.x);
	}
	vec4 getColor() {
		return texelFetch(splatColor, splatUV, 0);
	}
	bool evalSplat(out vec4 result)
	{
		vec4 centerWorld = matrix_model * vec4(center, 1.0);
		vec4 splat_cam = matrix_view * centerWorld;
		vec4 splat_proj = matrix_projection * splat_cam;
		if (splat_proj.z < -splat_proj.w) {
			return false;
		}
		mat3 Vrk = mat3(
			covA.x, covA.y, covA.z, 
			covA.y, covB.x, covB.y,
			covA.z, covB.y, covB.z
		);
		float focal = viewport.x * matrix_projection[0][0];
		float J1 = focal / splat_cam.z;
		vec2 J2 = -J1 / splat_cam.z * splat_cam.xy;
		mat3 J = mat3(
			J1, 0., J2.x, 
			0., J1, J2.y, 
			0., 0., 0.
		);
		mat3 W = transpose(mat3(matrix_view) * mat3(matrix_model));
		mat3 T = W * J;
		mat3 cov = transpose(T) * Vrk * T;
		float diagonal1 = cov[0][0] + 0.3;
		float offDiagonal = cov[0][1];
		float diagonal2 = cov[1][1] + 0.3;
		float mid = 0.5 * (diagonal1 + diagonal2);
		float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));
		float lambda1 = mid + radius;
		float lambda2 = max(mid - radius, 0.1);
		vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));
		vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
		vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);
		if (dot(v1, v1) < 4.0 && dot(v2, v2) < 4.0) {
			return false;
		}
		result = splat_proj + vec4((vertex_position.x * v1 + vertex_position.y * v2) / viewport * splat_proj.w, 0, 0);
		return true;
	}
`;
var splatCoreFS = `
	varying vec2 texCoord;
	varying vec4 color;
	#ifndef DITHER_NONE
		varying float id;
	#endif
	#ifdef PICK_PASS
		uniform vec4 uColor;
	#endif
	vec4 evalSplat() {
		float A = -dot(texCoord, texCoord);
		if (A < -4.0) discard;
		float B = exp(A) * color.a;
		#ifdef PICK_PASS
			if (B < 0.3) discard;
			return(uColor);
		#endif
		#ifndef DITHER_NONE
			opacityDither(B, id * 0.013);
		#endif
		#ifdef TONEMAP_ENABLED
			return vec4(gammaCorrectOutput(toneMap(decodeGamma(color.rgb))), B);
		#else
			return vec4(color.rgb, B);
		#endif
	}
`;
var GSplatShaderGenerator = class {
  generateKey(options2) {
    const vsHash = hashCode(options2.vertex);
    const fsHash = hashCode(options2.fragment);
    const definesHash = ShaderGenerator.definesHash(options2.defines);
    return `splat-${options2.pass}-${options2.gamma}-${options2.toneMapping}-${vsHash}-${fsHash}-${options2.dither}-${definesHash}`;
  }
  createShaderDefinition(device, options2) {
    const shaderPassInfo = ShaderPass.get(device).getByIndex(options2.pass);
    const shaderPassDefines = shaderPassInfo.shaderDefines;
    const defines = `${shaderPassDefines}#define DITHER_${options2.dither.toUpperCase()}
#define TONEMAP_${options2.toneMapping === TONEMAP_LINEAR ? "DISABLED" : "ENABLED"}
`;
    const vs = defines + splatCoreVS + options2.vertex;
    const fs3 = defines + shaderChunks.decodePS + (options2.dither === DITHER_NONE ? "" : shaderChunks.bayerPS + shaderChunks.opacityDitherPS) + ShaderGenerator.tonemapCode(options2.toneMapping) + ShaderGenerator.gammaCode(options2.gamma) + splatCoreFS + options2.fragment;
    const defineMap = /* @__PURE__ */ new Map();
    options2.defines.forEach((value) => defineMap.set(value, true));
    return ShaderUtils.createDefinition(device, {
      name: "SplatShader",
      attributes: {
        vertex_position: SEMANTIC_POSITION,
        vertex_id_attrib: SEMANTIC_ATTR13
      },
      vertexCode: vs,
      fragmentCode: fs3,
      fragmentDefines: defineMap,
      vertexDefines: defineMap
    });
  }
};
var gsplat = new GSplatShaderGenerator();

// ../node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-material.js
var splatMainVS = `
		vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);

		void main(void)
		{
				// calculate splat uv
				if (!calcSplatUV()) {
						gl_Position = discardVec;
						return;
				}

				// read data
				readData();

				vec4 pos;
				if (!evalSplat(pos)) {
						gl_Position = discardVec;
						return;
				}

				gl_Position = pos;

				texCoord = vertex_position.xy;
				color = getColor();

				#ifndef DITHER_NONE
						id = float(splatId);
				#endif
		}
`;
var splatMainFS = `
		void main(void)
		{
				gl_FragColor = evalSplat();
		}
`;
var createGSplatMaterial = (options2 = {}) => {
  var _options$dither;
  const ditherEnum = (_options$dither = options2.dither) != null ? _options$dither : DITHER_NONE;
  const dither = ditherEnum !== DITHER_NONE;
  const material = new ShaderMaterial();
  material.name = "splatMaterial";
  material.cull = CULLFACE_NONE;
  material.blendType = dither ? BLEND_NONE : BLEND_NORMAL;
  material.depthWrite = dither;
  material.getShaderVariant = function(params) {
    var _options$vertex, _options$fragment;
    const programOptions = {
      defines: material.defines,
      pass: params.pass,
      gamma: params.renderParams.shaderOutputGamma,
      toneMapping: params.renderParams.toneMapping,
      vertex: (_options$vertex = options2.vertex) != null ? _options$vertex : splatMainVS,
      fragment: (_options$fragment = options2.fragment) != null ? _options$fragment : splatMainFS,
      dither: ditherEnum
    };
    const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat);
    const library = getProgramLibrary(params.device);
    library.register("splat", gsplat);
    return library.getProgram("splat", programOptions, processingOptions);
  };
  material.update();
  return material;
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat.js
var _tmpVecA = new Vec3();
var _tmpVecB = new Vec3();
var _tmpVecC = new Vec3();
var _m0 = new Vec3();
var _m1 = new Vec3();
var _m2 = new Vec3();
var GSplat = class {
  constructor(device, gsplatData) {
    this.device = void 0;
    this.numSplats = void 0;
    this.centers = void 0;
    this.aabb = void 0;
    this.colorTexture = void 0;
    this.transformATexture = void 0;
    this.transformBTexture = void 0;
    this.transformCTexture = void 0;
    const numSplats = gsplatData.numSplats;
    this.device = device;
    this.numSplats = numSplats;
    this.centers = new Float32Array(gsplatData.numSplats * 3);
    gsplatData.getCenters(this.centers);
    this.aabb = new BoundingBox();
    gsplatData.calcAabb(this.aabb);
    const size = this.evalTextureSize(numSplats);
    this.colorTexture = this.createTexture("splatColor", PIXELFORMAT_RGBA8, size);
    this.transformATexture = this.createTexture("transformA", PIXELFORMAT_RGBA32F, size);
    this.transformBTexture = this.createTexture("transformB", PIXELFORMAT_RGBA16F, size);
    this.transformCTexture = this.createTexture("transformC", PIXELFORMAT_R16F, size);
    this.updateColorData(gsplatData);
    this.updateTransformData(gsplatData);
  }
  destroy() {
    var _this$colorTexture, _this$transformATextu, _this$transformBTextu, _this$transformCTextu;
    (_this$colorTexture = this.colorTexture) == null || _this$colorTexture.destroy();
    (_this$transformATextu = this.transformATexture) == null || _this$transformATextu.destroy();
    (_this$transformBTextu = this.transformBTexture) == null || _this$transformBTextu.destroy();
    (_this$transformCTextu = this.transformCTexture) == null || _this$transformCTextu.destroy();
  }
  createMaterial(options2) {
    const result = createGSplatMaterial(options2);
    result.setParameter("splatColor", this.colorTexture);
    result.setParameter("transformA", this.transformATexture);
    result.setParameter("transformB", this.transformBTexture);
    result.setParameter("transformC", this.transformCTexture);
    result.setParameter("tex_params", new Float32Array([this.numSplats, this.colorTexture.width, 0, 0]));
    return result;
  }
  evalTextureSize(count) {
    const width = Math.ceil(Math.sqrt(count));
    const height = Math.ceil(count / width);
    return new Vec2(width, height);
  }
  createTexture(name, format, size) {
    return new Texture(this.device, {
      name,
      width: size.x,
      height: size.y,
      format,
      cubemap: false,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
  }
  updateColorData(gsplatData) {
    const texture = this.colorTexture;
    if (!texture) {
      return;
    }
    const data2 = texture.lock();
    const c2 = new Vec4();
    const iter = gsplatData.createIter(null, null, null, c2);
    for (let i = 0; i < this.numSplats; ++i) {
      iter.read(i);
      data2[i * 4 + 0] = math.clamp(c2.x * 255, 0, 255);
      data2[i * 4 + 1] = math.clamp(c2.y * 255, 0, 255);
      data2[i * 4 + 2] = math.clamp(c2.z * 255, 0, 255);
      data2[i * 4 + 3] = math.clamp(c2.w * 255, 0, 255);
    }
    texture.unlock();
  }
  updateTransformData(gsplatData) {
    const float2Half = FloatPacking.float2Half;
    if (!this.transformATexture) {
      return;
    }
    const dataA = this.transformATexture.lock();
    const dataB = this.transformBTexture.lock();
    const dataC = this.transformCTexture.lock();
    const p = new Vec3();
    const r = new Quat();
    const s2 = new Vec3();
    const iter = gsplatData.createIter(p, r, s2);
    const mat2 = new Mat3();
    const cA = new Vec3();
    const cB = new Vec3();
    for (let i = 0; i < this.numSplats; i++) {
      iter.read(i);
      r.normalize();
      mat2.setFromQuat(r);
      this.computeCov3d(mat2, s2, cA, cB);
      dataA[i * 4 + 0] = p.x;
      dataA[i * 4 + 1] = p.y;
      dataA[i * 4 + 2] = p.z;
      dataA[i * 4 + 3] = cB.x;
      dataB[i * 4 + 0] = float2Half(cA.x);
      dataB[i * 4 + 1] = float2Half(cA.y);
      dataB[i * 4 + 2] = float2Half(cA.z);
      dataB[i * 4 + 3] = float2Half(cB.y);
      dataC[i] = float2Half(cB.z);
    }
    this.transformATexture.unlock();
    this.transformBTexture.unlock();
    this.transformCTexture.unlock();
  }
  computeCov3d(rot, scale2, covA, covB) {
    const r0 = rot.getX(_tmpVecA).mulScalar(scale2.x);
    const r1 = rot.getY(_tmpVecB).mulScalar(scale2.y);
    const r2 = rot.getZ(_tmpVecC).mulScalar(scale2.z);
    _m0.set(r0.x, r1.x, r2.x);
    _m1.set(r0.y, r1.y, r2.y);
    _m2.set(r0.z, r1.z, r2.z);
    covA.set(_m0.dot(_m0), _m0.dot(_m1), _m0.dot(_m2));
    covB.set(_m1.dot(_m1), _m1.dot(_m2), _m2.dot(_m2));
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-sorter.js
function SortWorker() {
  const compareBits = 16;
  const bucketCount = 2 ** compareBits + 1;
  let order;
  let centers;
  let mapping;
  let cameraPosition2;
  let cameraDirection2;
  let forceUpdate = false;
  const lastCameraPosition = {
    x: 0,
    y: 0,
    z: 0
  };
  const lastCameraDirection = {
    x: 0,
    y: 0,
    z: 0
  };
  const boundMin = {
    x: 0,
    y: 0,
    z: 0
  };
  const boundMax = {
    x: 0,
    y: 0,
    z: 0
  };
  let distances;
  let countBuffer;
  const binarySearch = (m, n, compare_fn) => {
    while (m <= n) {
      const k = n + m >> 1;
      const cmp = compare_fn(k);
      if (cmp > 0) {
        m = k + 1;
      } else if (cmp < 0) {
        n = k - 1;
      } else {
        return k;
      }
    }
    return ~m;
  };
  const update = () => {
    var _distances;
    if (!order || !centers || !cameraPosition2 || !cameraDirection2) return;
    const px = cameraPosition2.x;
    const py = cameraPosition2.y;
    const pz = cameraPosition2.z;
    const dx = cameraDirection2.x;
    const dy = cameraDirection2.y;
    const dz = cameraDirection2.z;
    const epsilon3 = 1e-3;
    if (!forceUpdate && Math.abs(px - lastCameraPosition.x) < epsilon3 && Math.abs(py - lastCameraPosition.y) < epsilon3 && Math.abs(pz - lastCameraPosition.z) < epsilon3 && Math.abs(dx - lastCameraDirection.x) < epsilon3 && Math.abs(dy - lastCameraDirection.y) < epsilon3 && Math.abs(dz - lastCameraDirection.z) < epsilon3) {
      return;
    }
    forceUpdate = false;
    lastCameraPosition.x = px;
    lastCameraPosition.y = py;
    lastCameraPosition.z = pz;
    lastCameraDirection.x = dx;
    lastCameraDirection.y = dy;
    lastCameraDirection.z = dz;
    const numVertices = centers.length / 3;
    if (((_distances = distances) == null ? void 0 : _distances.length) !== numVertices) {
      distances = new Uint32Array(numVertices);
    }
    let minDist;
    let maxDist;
    for (let i = 0; i < 8; ++i) {
      const x2 = (i & 1 ? boundMin.x : boundMax.x) - px;
      const y2 = (i & 2 ? boundMin.y : boundMax.y) - py;
      const z2 = (i & 4 ? boundMin.z : boundMax.z) - pz;
      const d = x2 * dx + y2 * dy + z2 * dz;
      if (i === 0) {
        minDist = maxDist = d;
      } else {
        minDist = Math.min(minDist, d);
        maxDist = Math.max(maxDist, d);
      }
    }
    if (!countBuffer) {
      countBuffer = new Uint32Array(bucketCount);
    } else {
      countBuffer.fill(0);
    }
    const range = maxDist - minDist;
    const divider = range < 1e-6 ? 0 : 1 / range * 2 ** compareBits;
    for (let i = 0; i < numVertices; ++i) {
      const istride = i * 3;
      const x2 = centers[istride + 0] - px;
      const y2 = centers[istride + 1] - py;
      const z2 = centers[istride + 2] - pz;
      const d = x2 * dx + y2 * dy + z2 * dz;
      const sortKey = Math.floor((d - minDist) * divider);
      distances[i] = sortKey;
      countBuffer[sortKey]++;
    }
    for (let i = 1; i < bucketCount; i++) {
      countBuffer[i] += countBuffer[i - 1];
    }
    for (let i = 0; i < numVertices; i++) {
      const distance = distances[i];
      const destIndex = --countBuffer[distance];
      order[destIndex] = i;
    }
    const dist = (i) => distances[order[i]] / divider + minDist;
    const findZero = () => {
      const result = binarySearch(0, numVertices - 1, (i) => -dist(i));
      return Math.min(numVertices, Math.abs(result));
    };
    const count = dist(numVertices - 1) >= 0 ? findZero() : numVertices;
    if (mapping) {
      for (let i = 0; i < numVertices; ++i) {
        order[i] = mapping[order[i]];
      }
    }
    self.postMessage({
      order: order.buffer,
      count
    }, [order.buffer]);
    order = null;
  };
  self.onmessage = (message) => {
    if (message.data.order) {
      order = new Uint32Array(message.data.order);
    }
    if (message.data.centers) {
      centers = new Float32Array(message.data.centers);
      boundMin.x = boundMax.x = centers[0];
      boundMin.y = boundMax.y = centers[1];
      boundMin.z = boundMax.z = centers[2];
      const numVertices = centers.length / 3;
      for (let i = 1; i < numVertices; ++i) {
        const x2 = centers[i * 3 + 0];
        const y2 = centers[i * 3 + 1];
        const z2 = centers[i * 3 + 2];
        boundMin.x = Math.min(boundMin.x, x2);
        boundMin.y = Math.min(boundMin.y, y2);
        boundMin.z = Math.min(boundMin.z, z2);
        boundMax.x = Math.max(boundMax.x, x2);
        boundMax.y = Math.max(boundMax.y, y2);
        boundMax.z = Math.max(boundMax.z, z2);
      }
      forceUpdate = true;
    }
    if (message.data.hasOwnProperty("mapping")) {
      mapping = message.data.mapping ? new Uint32Array(message.data.mapping) : null;
      forceUpdate = true;
    }
    if (message.data.cameraPosition) cameraPosition2 = message.data.cameraPosition;
    if (message.data.cameraDirection) cameraDirection2 = message.data.cameraDirection;
    update();
  };
}
var GSplatSorter = class extends EventHandler {
  constructor() {
    super();
    this.worker = void 0;
    this.orderTexture = void 0;
    this.centers = void 0;
    this.worker = new Worker(URL.createObjectURL(new Blob([`(${SortWorker.toString()})()`], {
      type: "application/javascript"
    })));
    this.worker.onmessage = (message) => {
      const newOrder = message.data.order;
      const oldOrder = this.orderTexture._levels[0].buffer;
      this.worker.postMessage({
        order: oldOrder
      }, [oldOrder]);
      this.orderTexture._levels[0] = new Uint32Array(newOrder);
      this.orderTexture.upload();
      this.fire("updated", message.data.count);
    };
  }
  destroy() {
    this.worker.terminate();
    this.worker = null;
  }
  init(orderTexture, centers) {
    this.orderTexture = orderTexture;
    this.centers = centers.slice();
    const orderBuffer = this.orderTexture.lock({
      mode: TEXTURELOCK_READ
    }).buffer.slice();
    this.orderTexture.unlock();
    this.worker.postMessage({
      order: orderBuffer,
      centers: centers.buffer
    }, [orderBuffer, centers.buffer]);
  }
  setMapping(mapping) {
    if (mapping) {
      const centers = new Float32Array(mapping.length * 3);
      for (let i = 0; i < mapping.length; ++i) {
        const src = mapping[i] * 3;
        const dst = i * 3;
        centers[dst + 0] = this.centers[src + 0];
        centers[dst + 1] = this.centers[src + 1];
        centers[dst + 2] = this.centers[src + 2];
      }
      this.worker.postMessage({
        centers: centers.buffer,
        mapping: mapping.buffer
      }, [centers.buffer, mapping.buffer]);
    } else {
      const centers = this.centers.slice();
      this.worker.postMessage({
        centers: centers.buffer,
        mapping: null
      }, [centers.buffer]);
    }
  }
  setCamera(pos, dir) {
    this.worker.postMessage({
      cameraPosition: {
        x: pos.x,
        y: pos.y,
        z: pos.z
      },
      cameraDirection: {
        x: dir.x,
        y: dir.y,
        z: dir.z
      }
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-instance.js
var mat = new Mat4();
var cameraPosition = new Vec3();
var cameraDirection = new Vec3();
var viewport = [0, 0];
var GSplatInstance = class _GSplatInstance {
  constructor(splat, options2) {
    this.splat = void 0;
    this.mesh = void 0;
    this.meshInstance = void 0;
    this.material = void 0;
    this.orderTexture = void 0;
    this.options = {};
    this.sorter = null;
    this.lastCameraPosition = new Vec3();
    this.lastCameraDirection = new Vec3();
    this.cameras = [];
    this.splat = splat;
    options2 = Object.assign(this.options, options2);
    const device = splat.device;
    this.orderTexture = this.splat.createTexture("splatOrder", PIXELFORMAT_R32U, this.splat.evalTextureSize(this.splat.numSplats));
    this.createMaterial(options2);
    const splatInstanceSize = 128;
    const numSplats = Math.ceil(splat.numSplats / splatInstanceSize) * splatInstanceSize;
    const numSplatInstances = numSplats / splatInstanceSize;
    const indexData = new Uint32Array(numSplatInstances);
    for (let i = 0; i < numSplatInstances; ++i) {
      indexData[i] = i * splatInstanceSize;
    }
    const vertexFormat = new VertexFormat(device, [{
      semantic: SEMANTIC_ATTR13,
      components: 1,
      type: TYPE_UINT32,
      asInt: true
    }]);
    const indicesVB = new VertexBuffer(device, vertexFormat, numSplatInstances, {
      usage: BUFFER_STATIC,
      data: indexData.buffer
    });
    const meshPositions = new Float32Array(12 * splatInstanceSize);
    const meshIndices = new Uint32Array(6 * splatInstanceSize);
    for (let i = 0; i < splatInstanceSize; ++i) {
      meshPositions.set([-2, -2, i, 2, -2, i, 2, 2, i, -2, 2, i], i * 12);
      const b = i * 4;
      meshIndices.set([0 + b, 1 + b, 2 + b, 0 + b, 2 + b, 3 + b], i * 6);
    }
    const mesh = new Mesh(device);
    mesh.setPositions(meshPositions, 3);
    mesh.setIndices(meshIndices);
    mesh.update();
    this.mesh = mesh;
    this.mesh.aabb.copy(splat.aabb);
    this.meshInstance = new MeshInstance(this.mesh, this.material);
    this.meshInstance.setInstancing(indicesVB, true);
    this.meshInstance.gsplatInstance = this;
    this.meshInstance.instancingCount = 0;
    this.centers = new Float32Array(splat.centers);
    if (!options2.dither || options2.dither === DITHER_NONE) {
      this.sorter = new GSplatSorter();
      this.sorter.init(this.orderTexture, this.centers);
      this.sorter.on("updated", (count) => {
        this.meshInstance.instancingCount = Math.ceil(count / splatInstanceSize);
        const tex_params = this.material.getParameter("tex_params");
        if (tex_params != null && tex_params.data) {
          tex_params.data[0] = count;
        }
      });
    }
  }
  destroy() {
    var _this$material, _this$meshInstance, _this$sorter;
    (_this$material = this.material) == null || _this$material.destroy();
    (_this$meshInstance = this.meshInstance) == null || _this$meshInstance.destroy();
    (_this$sorter = this.sorter) == null || _this$sorter.destroy();
  }
  clone() {
    return new _GSplatInstance(this.splat, this.options);
  }
  createMaterial(options2) {
    this.material = this.splat.createMaterial(options2);
    this.material.setParameter("splatOrder", this.orderTexture);
    if (this.meshInstance) {
      this.meshInstance.material = this.material;
    }
  }
  updateViewport() {
    const device = this.splat.device;
    viewport[0] = device.width;
    viewport[1] = device.height;
    this.material.setParameter("viewport", viewport);
  }
  sort(cameraNode) {
    if (this.sorter) {
      const cameraMat = cameraNode.getWorldTransform();
      cameraMat.getTranslation(cameraPosition);
      cameraMat.getZ(cameraDirection);
      const modelMat = this.meshInstance.node.getWorldTransform();
      const invModelMat = mat.invert(modelMat);
      invModelMat.transformPoint(cameraPosition, cameraPosition);
      invModelMat.transformVector(cameraDirection, cameraDirection);
      if (!cameraPosition.equalsApprox(this.lastCameraPosition) || !cameraDirection.equalsApprox(this.lastCameraDirection)) {
        this.lastCameraPosition.copy(cameraPosition);
        this.lastCameraDirection.copy(cameraDirection);
        this.sorter.setCamera(cameraPosition, cameraDirection);
      }
    }
    this.updateViewport();
  }
  update() {
    if (this.cameras.length > 0) {
      const camera = this.cameras[0];
      this.sort(camera._node);
      this.cameras.length = 0;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/constants.js
var FILLMODE_NONE = "NONE";
var FILLMODE_FILL_WINDOW = "FILL_WINDOW";
var FILLMODE_KEEP_ASPECT = "KEEP_ASPECT";
var RESOLUTION_AUTO = "AUTO";
var RESOLUTION_FIXED = "FIXED";

// ../node_modules/playcanvas/build/playcanvas/src/framework/globals.js
var currentApplication;
function getApplication() {
  return currentApplication;
}
function setApplication(app2) {
  currentApplication = app2;
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/script.js
var _createdLoadingScreen = false;
var script = {
  app: null,
  createLoadingScreen(callback) {
    if (_createdLoadingScreen) {
      return;
    }
    _createdLoadingScreen = true;
    const app2 = getApplication();
    callback(app2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/frame-graph.js
var FrameGraph = class {
  constructor() {
    this.renderPasses = [];
    this.renderTargetMap = /* @__PURE__ */ new Map();
  }
  addRenderPass(renderPass) {
    renderPass.frameUpdate();
    const beforePasses = renderPass.beforePasses;
    for (let i = 0; i < beforePasses.length; i++) {
      const pass = beforePasses[i];
      if (pass.enabled) {
        this.addRenderPass(pass);
      }
    }
    if (renderPass.enabled) {
      this.renderPasses.push(renderPass);
    }
    const afterPasses = renderPass.afterPasses;
    for (let i = 0; i < afterPasses.length; i++) {
      const pass = afterPasses[i];
      if (pass.enabled) {
        this.addRenderPass(pass);
      }
    }
  }
  reset() {
    this.renderPasses.length = 0;
  }
  compile() {
    const renderTargetMap = this.renderTargetMap;
    const renderPasses = this.renderPasses;
    for (let i = 0; i < renderPasses.length; i++) {
      const renderPass = renderPasses[i];
      const renderTarget = renderPass.renderTarget;
      if (renderTarget !== void 0) {
        const prevPass = renderTargetMap.get(renderTarget);
        if (prevPass) {
          const count = renderPass.colorArrayOps.length;
          for (let j = 0; j < count; j++) {
            const colorOps = renderPass.colorArrayOps[j];
            if (!colorOps.clear) {
              prevPass.colorArrayOps[j].store = true;
            }
          }
          if (!renderPass.depthStencilOps.clearDepth) {
            prevPass.depthStencilOps.storeDepth = true;
          }
          if (!renderPass.depthStencilOps.clearStencil) {
            prevPass.depthStencilOps.storeStencil = true;
          }
        }
        renderTargetMap.set(renderTarget, renderPass);
      }
    }
    let lastCubeTexture = null;
    let lastCubeRenderPass = null;
    for (let i = 0; i < renderPasses.length; i++) {
      const renderPass = renderPasses[i];
      const renderTarget = renderPass.renderTarget;
      const thisTexture = renderTarget == null ? void 0 : renderTarget.colorBuffer;
      if (thisTexture != null && thisTexture.cubemap) {
        if (lastCubeTexture === thisTexture) {
          const count = lastCubeRenderPass.colorArrayOps.length;
          for (let j = 0; j < count; j++) {
            lastCubeRenderPass.colorArrayOps[j].mipmaps = false;
          }
        }
        lastCubeTexture = renderTarget.colorBuffer;
        lastCubeRenderPass = renderPass;
      } else if (renderPass.requiresCubemaps) {
        lastCubeTexture = null;
        lastCubeRenderPass = null;
      }
    }
    renderTargetMap.clear();
  }
  render(device) {
    this.compile();
    const renderPasses = this.renderPasses;
    for (let i = 0; i < renderPasses.length; i++) {
      renderPasses[i].render();
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/area-light-luts.js
var AreaLightCacheEntry = class {
  constructor(texture0, texture1) {
    this.texture0 = texture0;
    this.texture1 = texture1;
  }
  destroy() {
    var _this$texture, _this$texture2;
    (_this$texture = this.texture0) == null || _this$texture.destroy();
    (_this$texture2 = this.texture1) == null || _this$texture2.destroy();
  }
};
var deviceCache3 = new DeviceCache();
var AreaLightLuts = class _AreaLightLuts {
  static createTexture(device, format, size, postfix = "") {
    const tex = new Texture(device, {
      name: `AreaLightLUT${postfix}`,
      width: size,
      height: size,
      format,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      type: TEXTURETYPE_DEFAULT,
      magFilter: FILTER_LINEAR,
      minFilter: FILTER_NEAREST,
      anisotropy: 1,
      mipmaps: false
    });
    return tex;
  }
  static applyTextures(device, texture1, texture2) {
    deviceCache3.remove(device);
    deviceCache3.get(device, () => {
      return new AreaLightCacheEntry(texture1, texture1 === texture2 ? null : texture2);
    });
    device.scope.resolve("areaLightsLutTex1").setValue(texture1);
    device.scope.resolve("areaLightsLutTex2").setValue(texture2);
  }
  static createPlaceholder(device) {
    const texture = _AreaLightLuts.createTexture(device, PIXELFORMAT_RGBA16F, 2, "placeholder");
    const pixels = texture.lock();
    pixels.fill(0);
    texture.unlock();
    _AreaLightLuts.applyTextures(device, texture, texture);
  }
  static set(device, ltcMat1, ltcMat2) {
    function buildTexture(device2, data3, format) {
      const texture = _AreaLightLuts.createTexture(device2, format, 64);
      texture.lock().set(data3);
      texture.unlock();
      return texture;
    }
    function convertToHalfFloat(data3) {
      const count = data3.length;
      const ret = new Uint16Array(count);
      const float2Half = FloatPacking.float2Half;
      for (let i = 0; i < count; i++) {
        ret[i] = float2Half(data3[i]);
      }
      return ret;
    }
    const srcData1 = ltcMat1;
    const srcData2 = ltcMat2;
    const data1 = convertToHalfFloat(srcData1);
    const data2 = convertToHalfFloat(srcData2);
    const tex1 = buildTexture(device, data1, PIXELFORMAT_RGBA16F);
    const tex2 = buildTexture(device, data2, PIXELFORMAT_RGBA16F);
    _AreaLightLuts.applyTextures(device, tex1, tex2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/i18n/constants.js
var DEFAULT_LOCALE = "en-US";
var DEFAULT_LOCALE_FALLBACKS = {
  "en": "en-US",
  "es": "en-ES",
  "zh": "zh-CN",
  "zh-HK": "zh-TW",
  "zh-TW": "zh-HK",
  "zh-MO": "zh-HK",
  "fr": "fr-FR",
  "de": "de-DE",
  "it": "it-IT",
  "ru": "ru-RU",
  "ja": "ja-JP"
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/i18n/utils.js
var PLURALS = {};
function definePluralFn(locales, fn) {
  for (let i = 0, len = locales.length; i < len; i++) {
    PLURALS[locales[i]] = fn;
  }
}
function getLang(locale) {
  const idx = locale.indexOf("-");
  if (idx !== -1) {
    return locale.substring(0, idx);
  }
  return locale;
}
function replaceLang(locale, desiredLang) {
  const idx = locale.indexOf("-");
  if (idx !== -1) {
    return desiredLang + locale.substring(idx);
  }
  return desiredLang;
}
function findAvailableLocale(desiredLocale, availableLocales) {
  if (availableLocales[desiredLocale]) {
    return desiredLocale;
  }
  let fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];
  if (fallback && availableLocales[fallback]) {
    return fallback;
  }
  const lang = getLang(desiredLocale);
  fallback = DEFAULT_LOCALE_FALLBACKS[lang];
  if (availableLocales[fallback]) {
    return fallback;
  }
  if (availableLocales[lang]) {
    return lang;
  }
  return DEFAULT_LOCALE;
}
definePluralFn(["ja", "ko", "th", "vi", "zh", "id"], (n) => {
  return 0;
});
definePluralFn(["fa", "hi"], (n) => {
  if (n >= 0 && n <= 1) {
    return 0;
  }
  return 1;
});
definePluralFn(["fr", "pt"], (n) => {
  if (n >= 0 && n < 2) {
    return 0;
  }
  return 1;
});
definePluralFn(["da"], (n) => {
  if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
    return 0;
  }
  return 1;
});
definePluralFn(["de", "en", "it", "el", "es", "tr", "fi", "sv", "nb", "no", "ur"], (n) => {
  if (n === 1) {
    return 0;
  }
  return 1;
});
definePluralFn(["ru", "uk"], (n) => {
  if (Number.isInteger(n)) {
    const mod10 = n % 10;
    const mod100 = n % 100;
    if (mod10 === 1 && mod100 !== 11) {
      return 0;
    } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
      return 1;
    } else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
      return 2;
    }
  }
  return 3;
});
definePluralFn(["pl"], (n) => {
  if (Number.isInteger(n)) {
    if (n === 1) {
      return 0;
    }
    const mod10 = n % 10;
    const mod100 = n % 100;
    if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
      return 1;
    } else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
      return 2;
    }
  }
  return 3;
});
definePluralFn(["ar"], (n) => {
  if (n === 0) {
    return 0;
  } else if (n === 1) {
    return 1;
  } else if (n === 2) {
    return 2;
  }
  if (Number.isInteger(n)) {
    const mod100 = n % 100;
    if (mod100 >= 3 && mod100 <= 10) {
      return 3;
    } else if (mod100 >= 11 && mod100 <= 99) {
      return 4;
    }
  }
  return 5;
});
var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];
function getPluralFn(lang) {
  return PLURALS[lang] || DEFAULT_PLURAL_FN;
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/asset/constants.js
var ABSOLUTE_URL = new RegExp("^\\s*(?:(?:[a-z]+[a-z0-9\\-+.]*:)?//|data:|blob:)", "i");
var ASSET_ANIMATION = "animation";
var ASSET_AUDIO = "audio";
var ASSET_IMAGE = "image";
var ASSET_JSON = "json";
var ASSET_MODEL = "model";
var ASSET_MATERIAL = "material";
var ASSET_TEXT = "text";
var ASSET_TEXTURE = "texture";
var ASSET_TEXTUREATLAS = "textureatlas";
var ASSET_CUBEMAP = "cubemap";
var ASSET_SHADER = "shader";
var ASSET_CSS = "css";
var ASSET_HTML = "html";
var ASSET_SCRIPT = "script";
var ASSET_CONTAINER = "container";

// ../node_modules/playcanvas/build/playcanvas/src/framework/asset/asset-file.js
var AssetFile = class {
  constructor(url = "", filename = "", hash = null, size = null, opt = null, contents = null) {
    this.url = url;
    this.filename = filename;
    this.hash = hash;
    this.size = size;
    this.opt = opt;
    this.contents = contents;
  }
  equals(other) {
    return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/asset/asset.js
var assetIdCounter = -1;
var VARIANT_SUPPORT = {
  pvr: "extCompressedTexturePVRTC",
  dxt: "extCompressedTextureS3TC",
  etc2: "extCompressedTextureETC",
  etc1: "extCompressedTextureETC1",
  basis: "canvas"
};
var VARIANT_DEFAULT_PRIORITY = ["pvr", "dxt", "etc2", "etc1", "basis"];
var Asset = class extends EventHandler {
  constructor(name, type, file, data2, options2) {
    super();
    this._id = assetIdCounter--;
    this._name = name || "";
    this.type = type;
    this.tags = new Tags(this);
    this._preload = false;
    this._file = null;
    this._data = data2 || {};
    this.options = options2 || {};
    this._resources = [];
    this.urlObject = null;
    this._i18n = {};
    this.loaded = false;
    this.loading = false;
    this.registry = null;
    if (file) this.file = file;
  }
  set id(value) {
    this._id = value;
  }
  get id() {
    return this._id;
  }
  set name(value) {
    if (this._name === value) {
      return;
    }
    const old = this._name;
    this._name = value;
    this.fire("name", this, this._name, old);
  }
  get name() {
    return this._name;
  }
  set file(value) {
    if (value && value.variants && ["texture", "textureatlas", "bundle"].indexOf(this.type) !== -1) {
      var _this$registry;
      const app2 = ((_this$registry = this.registry) == null || (_this$registry = _this$registry._loader) == null ? void 0 : _this$registry._app) || getApplication();
      const device = app2 == null ? void 0 : app2.graphicsDevice;
      if (device) {
        for (let i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
          const variant = VARIANT_DEFAULT_PRIORITY[i];
          if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {
            value = value.variants[variant];
            break;
          }
          if (app2.enableBundles) {
            const bundles = app2.bundles.listBundlesForAsset(this);
            if (bundles && bundles.find((b) => {
              var _b$file;
              return b == null || (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];
            })) {
              break;
            }
          }
        }
      }
    }
    const oldFile = this._file;
    const newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;
    if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {
      this._file = newFile;
      this.fire("change", this, "file", newFile, oldFile);
      this.reload();
    }
  }
  get file() {
    return this._file;
  }
  set data(value) {
    const old = this._data;
    this._data = value;
    if (value !== old) {
      this.fire("change", this, "data", value, old);
      if (this.loaded) {
        this.registry._loader.patch(this, this.registry);
      }
    }
  }
  get data() {
    return this._data;
  }
  set resource(value) {
    const _old = this._resources[0];
    this._resources[0] = value;
    this.fire("change", this, "resource", value, _old);
  }
  get resource() {
    return this._resources[0];
  }
  set resources(value) {
    const _old = this._resources;
    this._resources = value;
    this.fire("change", this, "resources", value, _old);
  }
  get resources() {
    return this._resources;
  }
  set preload(value) {
    value = !!value;
    if (this._preload === value) {
      return;
    }
    this._preload = value;
    if (this._preload && !this.loaded && !this.loading && this.registry) {
      this.registry.load(this);
    }
  }
  get preload() {
    return this._preload;
  }
  set loadFaces(value) {
    value = !!value;
    if (!this.hasOwnProperty("_loadFaces") || value !== this._loadFaces) {
      this._loadFaces = value;
      if (this.loaded) {
        this.registry._loader.patch(this, this.registry);
      }
    }
  }
  get loadFaces() {
    return this._loadFaces;
  }
  getFileUrl() {
    const file = this.file;
    if (!file || !file.url) {
      return null;
    }
    let url = file.url;
    if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) {
      url = this.registry.prefix + url;
    }
    if (this.type !== "script" && file.hash) {
      const separator = url.indexOf("?") !== -1 ? "&" : "?";
      url += `${separator}t=${file.hash}`;
    }
    return url;
  }
  getAbsoluteUrl(relativePath) {
    if (relativePath.startsWith("blob:") || relativePath.startsWith("data:")) {
      return relativePath;
    }
    const base = path.getDirectory(this.file.url);
    return path.join(base, relativePath);
  }
  getLocalizedAssetId(locale) {
    locale = findAvailableLocale(locale, this._i18n);
    return this._i18n[locale] || null;
  }
  addLocalizedAssetId(locale, assetId) {
    this._i18n[locale] = assetId;
    this.fire("add:localized", locale, assetId);
  }
  removeLocalizedAssetId(locale) {
    const assetId = this._i18n[locale];
    if (assetId) {
      delete this._i18n[locale];
      this.fire("remove:localized", locale, assetId);
    }
  }
  ready(callback, scope) {
    scope = scope || this;
    if (this.loaded) {
      callback.call(scope, this);
    } else {
      this.once("load", (asset) => {
        callback.call(scope, asset);
      });
    }
  }
  reload() {
    if (this.loaded) {
      this.loaded = false;
      this.registry.load(this);
    }
  }
  unload() {
    if (!this.loaded && this._resources.length === 0) {
      return;
    }
    this.fire("unload", this);
    this.registry.fire(`unload:${this.id}`, this);
    const old = this._resources;
    if (this.urlObject) {
      URL.revokeObjectURL(this.urlObject);
      this.urlObject = null;
    }
    this.resources = [];
    this.loaded = false;
    if (this.file) {
      this.registry._loader.clearCache(this.getFileUrl(), this.type);
    }
    for (let i = 0; i < old.length; ++i) {
      const resource = old[i];
      if (resource && resource.destroy) {
        resource.destroy();
      }
    }
  }
  static fetchArrayBuffer(loadUrl, callback, asset, maxRetries = 0) {
    var _asset$file;
    if (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {
      setTimeout(() => {
        callback(null, asset.file.contents);
      });
    } else {
      http.get(loadUrl, {
        cache: true,
        responseType: "arraybuffer",
        retry: maxRetries > 0,
        maxRetries
      }, callback);
    }
  }
};
Asset.EVENT_LOAD = "load";
Asset.EVENT_UNLOAD = "unload";
Asset.EVENT_REMOVE = "remove";
Asset.EVENT_ERROR = "error";
Asset.EVENT_CHANGE = "change";
Asset.EVENT_ADDLOCALIZED = "add:localized";
Asset.EVENT_REMOVELOCALIZED = "remove:localized";

// ../node_modules/playcanvas/build/playcanvas/src/core/tags-cache.js
var TagsCache = class {
  constructor(key = null) {
    this._index = {};
    this._key = void 0;
    this._key = key;
  }
  addItem(item) {
    const tags = item.tags._list;
    for (const tag of tags) {
      this.add(tag, item);
    }
  }
  removeItem(item) {
    const tags = item.tags._list;
    for (const tag of tags) {
      this.remove(tag, item);
    }
  }
  add(tag, item) {
    if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) {
      return;
    }
    if (!this._index[tag]) {
      this._index[tag] = {
        list: []
      };
      if (this._key) {
        this._index[tag].keys = {};
      }
    }
    this._index[tag].list.push(item);
    if (this._key) {
      this._index[tag].keys[item[this._key]] = item;
    }
  }
  remove(tag, item) {
    if (!this._index[tag]) {
      return;
    }
    if (this._key) {
      if (!this._index[tag].keys[item[this._key]]) {
        return;
      }
    }
    const ind = this._index[tag].list.indexOf(item);
    if (ind === -1) {
      return;
    }
    this._index[tag].list.splice(ind, 1);
    if (this._key) {
      delete this._index[tag].keys[item[this._key]];
    }
    if (this._index[tag].list.length === 0) {
      delete this._index[tag];
    }
  }
  find(args) {
    const index = {};
    const items = [];
    let item, tag, tags, tagsRest, missingIndex;
    const sort = (a, b) => {
      return this._index[a].list.length - this._index[b].list.length;
    };
    for (let i = 0; i < args.length; i++) {
      tag = args[i];
      if (tag instanceof Array) {
        if (tag.length === 0) {
          continue;
        }
        if (tag.length === 1) {
          tag = tag[0];
        } else {
          missingIndex = false;
          for (let t = 0; t < tag.length; t++) {
            if (!this._index[tag[t]]) {
              missingIndex = true;
              break;
            }
          }
          if (missingIndex) {
            continue;
          }
          tags = tag.slice(0).sort(sort);
          tagsRest = tags.slice(1);
          if (tagsRest.length === 1) {
            tagsRest = tagsRest[0];
          }
          for (let n = 0; n < this._index[tags[0]].list.length; n++) {
            item = this._index[tags[0]].list[n];
            if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
              if (this._key) {
                index[item[this._key]] = true;
              }
              items.push(item);
            }
          }
          continue;
        }
      }
      if (tag && typeof tag === "string" && this._index[tag]) {
        for (let n = 0; n < this._index[tag].list.length; n++) {
          item = this._index[tag].list[n];
          if (this._key) {
            if (!index[item[this._key]]) {
              index[item[this._key]] = true;
              items.push(item);
            }
          } else if (items.indexOf(item) === -1) {
            items.push(item);
          }
        }
      }
    }
    return items;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/asset/asset-registry.js
var AssetRegistry = class extends EventHandler {
  constructor(loader) {
    super();
    this._assets = /* @__PURE__ */ new Set();
    this._loader = void 0;
    this._idToAsset = /* @__PURE__ */ new Map();
    this._urlToAsset = /* @__PURE__ */ new Map();
    this._nameToAsset = /* @__PURE__ */ new Map();
    this._tags = new TagsCache("_id");
    this.prefix = null;
    this.bundles = null;
    this._loader = loader;
  }
  list(filters = {}) {
    const assets = Array.from(this._assets);
    if (filters.preload !== void 0) {
      return assets.filter((asset) => asset.preload === filters.preload);
    }
    return assets;
  }
  add(asset) {
    var _asset$file, _asset$file2;
    if (this._assets.has(asset)) return;
    this._assets.add(asset);
    this._idToAsset.set(asset.id, asset);
    if ((_asset$file = asset.file) != null && _asset$file.url) {
      this._urlToAsset.set(asset.file.url, asset);
    }
    if (!this._nameToAsset.has(asset.name)) {
      this._nameToAsset.set(asset.name, /* @__PURE__ */ new Set());
    }
    this._nameToAsset.get(asset.name).add(asset);
    asset.on("name", this._onNameChange, this);
    asset.registry = this;
    this._tags.addItem(asset);
    asset.tags.on("add", this._onTagAdd, this);
    asset.tags.on("remove", this._onTagRemove, this);
    this.fire("add", asset);
    this.fire(`add:${asset.id}`, asset);
    if ((_asset$file2 = asset.file) != null && _asset$file2.url) {
      this.fire(`add:url:${asset.file.url}`, asset);
    }
    if (asset.preload) {
      this.load(asset);
    }
  }
  remove(asset) {
    var _asset$file3, _asset$file4;
    if (!this._assets.has(asset)) return false;
    this._assets.delete(asset);
    this._idToAsset.delete(asset.id);
    if ((_asset$file3 = asset.file) != null && _asset$file3.url) {
      this._urlToAsset.delete(asset.file.url);
    }
    asset.off("name", this._onNameChange, this);
    if (this._nameToAsset.has(asset.name)) {
      const items = this._nameToAsset.get(asset.name);
      items.delete(asset);
      if (items.size === 0) {
        this._nameToAsset.delete(asset.name);
      }
    }
    this._tags.removeItem(asset);
    asset.tags.off("add", this._onTagAdd, this);
    asset.tags.off("remove", this._onTagRemove, this);
    asset.fire("remove", asset);
    this.fire("remove", asset);
    this.fire(`remove:${asset.id}`, asset);
    if ((_asset$file4 = asset.file) != null && _asset$file4.url) {
      this.fire(`remove:url:${asset.file.url}`, asset);
    }
    return true;
  }
  get(id13) {
    return this._idToAsset.get(Number(id13));
  }
  getByUrl(url) {
    return this._urlToAsset.get(url);
  }
  load(asset, options2) {
    if ((asset.loading || asset.loaded) && !(options2 != null && options2.force)) {
      return;
    }
    const file = asset.file;
    const _fireLoad = () => {
      this.fire("load", asset);
      this.fire(`load:${asset.id}`, asset);
      if (file && file.url) {
        this.fire(`load:url:${file.url}`, asset);
      }
      asset.fire("load", asset);
    };
    const _opened = (resource) => {
      if (resource instanceof Array) {
        asset.resources = resource;
      } else {
        asset.resource = resource;
      }
      this._loader.patch(asset, this);
      if (asset.type === "bundle") {
        const assetIds = asset.data.assets;
        for (let i = 0; i < assetIds.length; i++) {
          const assetInBundle = this._idToAsset.get(assetIds[i]);
          if (assetInBundle && !assetInBundle.loaded) {
            this.load(assetInBundle, {
              force: true
            });
          }
        }
        if (asset.resource.loaded) {
          _fireLoad();
        } else {
          this.fire("load:start", asset);
          this.fire(`load:start:${asset.id}`, asset);
          if (file && file.url) {
            this.fire(`load:start:url:${file.url}`, asset);
          }
          asset.fire("load:start", asset);
          asset.resource.on("load", _fireLoad);
        }
      } else {
        _fireLoad();
      }
    };
    const _loaded = (err3, resource, extra) => {
      asset.loaded = true;
      asset.loading = false;
      if (err3) {
        this.fire("error", err3, asset);
        this.fire(`error:${asset.id}`, err3, asset);
        asset.fire("error", err3, asset);
      } else {
        if (asset.type === "script") {
          const handler = this._loader.getHandler("script");
          if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
            document.head.removeChild(handler._cache[asset.id]);
          }
          handler._cache[asset.id] = extra;
        }
        _opened(resource);
      }
    };
    if (file || asset.type === "cubemap") {
      this.fire("load:start", asset);
      this.fire(`load:${asset.id}:start`, asset);
      asset.loading = true;
      const fileUrl = asset.getFileUrl();
      if (asset.type === "bundle") {
        const assetIds = asset.data.assets;
        for (let i = 0; i < assetIds.length; i++) {
          const assetInBundle = this._idToAsset.get(assetIds[i]);
          if (!assetInBundle) {
            continue;
          }
          if (assetInBundle.loaded || assetInBundle.resource || assetInBundle.loading) {
            continue;
          }
          assetInBundle.loading = true;
        }
      }
      this._loader.load(fileUrl, asset.type, _loaded, asset, options2);
    } else {
      const resource = this._loader.open(asset.type, asset.data);
      asset.loaded = true;
      _opened(resource);
    }
  }
  loadFromUrl(url, type, callback) {
    this.loadFromUrlAndFilename(url, null, type, callback);
  }
  loadFromUrlAndFilename(url, filename, type, callback) {
    const name = path.getBasename(filename || url);
    const file = {
      filename: filename || name,
      url
    };
    let asset = this.getByUrl(url);
    if (!asset) {
      asset = new Asset(name, type, file);
      this.add(asset);
    } else if (asset.loaded) {
      callback(asset.loadFromUrlError || null, asset);
      return;
    }
    const startLoad = (asset2) => {
      asset2.once("load", (loadedAsset) => {
        if (type === "material") {
          this._loadTextures(loadedAsset, (err3, textures) => {
            callback(err3, loadedAsset);
          });
        } else {
          callback(null, loadedAsset);
        }
      });
      asset2.once("error", (err3) => {
        if (err3) {
          this.loadFromUrlError = err3;
        }
        callback(err3, asset2);
      });
      this.load(asset2);
    };
    if (asset.resource) {
      callback(null, asset);
    } else if (type === "model") {
      this._loadModel(asset, startLoad);
    } else {
      startLoad(asset);
    }
  }
  _loadModel(modelAsset, continuation) {
    const url = modelAsset.getFileUrl();
    const ext = path.getExtension(url);
    if (ext === ".json" || ext === ".glb") {
      const dir = path.getDirectory(url);
      const basename = path.getBasename(url);
      const mappingUrl = path.join(dir, basename.replace(ext, ".mapping.json"));
      this._loader.load(mappingUrl, "json", (err3, data2) => {
        if (err3) {
          modelAsset.data = {
            mapping: []
          };
          continuation(modelAsset);
        } else {
          this._loadMaterials(modelAsset, data2, (e, materials) => {
            modelAsset.data = data2;
            continuation(modelAsset);
          });
        }
      });
    } else {
      continuation(modelAsset);
    }
  }
  _loadMaterials(modelAsset, mapping, callback) {
    const materials = [];
    let count = 0;
    const onMaterialLoaded = (err3, materialAsset) => {
      this._loadTextures(materialAsset, (err4, textures) => {
        materials.push(materialAsset);
        if (materials.length === count) {
          callback(null, materials);
        }
      });
    };
    for (let i = 0; i < mapping.mapping.length; i++) {
      const path2 = mapping.mapping[i].path;
      if (path2) {
        count++;
        const url = modelAsset.getAbsoluteUrl(path2);
        this.loadFromUrl(url, "material", onMaterialLoaded);
      }
    }
    if (count === 0) {
      callback(null, materials);
    }
  }
  _loadTextures(materialAsset, callback) {
    const textures = [];
    let count = 0;
    const data2 = materialAsset.data;
    if (data2.mappingFormat !== "path") {
      callback(null, textures);
      return;
    }
    const onTextureLoaded = (err3, texture) => {
      if (err3) console.error(err3);
      textures.push(texture);
      if (textures.length === count) {
        callback(null, textures);
      }
    };
    const texParams = standardMaterialTextureParameters;
    for (let i = 0; i < texParams.length; i++) {
      const path2 = data2[texParams[i]];
      if (path2 && typeof path2 === "string") {
        count++;
        const url = materialAsset.getAbsoluteUrl(path2);
        this.loadFromUrl(url, "texture", onTextureLoaded);
      }
    }
    if (count === 0) {
      callback(null, textures);
    }
  }
  _onTagAdd(tag, asset) {
    this._tags.add(tag, asset);
  }
  _onTagRemove(tag, asset) {
    this._tags.remove(tag, asset);
  }
  _onNameChange(asset, name, nameOld) {
    if (this._nameToAsset.has(nameOld)) {
      const items = this._nameToAsset.get(nameOld);
      items.delete(asset);
      if (items.size === 0) {
        this._nameToAsset.delete(nameOld);
      }
    }
    if (!this._nameToAsset.has(asset.name)) {
      this._nameToAsset.set(asset.name, /* @__PURE__ */ new Set());
    }
    this._nameToAsset.get(asset.name).add(asset);
  }
  findByTag(...query) {
    return this._tags.find(query);
  }
  filter(callback) {
    return Array.from(this._assets).filter((asset) => callback(asset));
  }
  find(name, type) {
    const items = this._nameToAsset.get(name);
    if (!items) return null;
    for (const asset of items) {
      if (!type || asset.type === type) {
        return asset;
      }
    }
    return null;
  }
  findAll(name, type) {
    const items = this._nameToAsset.get(name);
    if (!items) return [];
    const results = Array.from(items);
    if (!type) return results;
    return results.filter((asset) => asset.type === type);
  }
};
AssetRegistry.EVENT_LOAD = "load";
AssetRegistry.EVENT_ADD = "add";
AssetRegistry.EVENT_REMOVE = "remove";
AssetRegistry.EVENT_ERROR = "error";

// ../node_modules/playcanvas/build/playcanvas/src/framework/bundle/bundle-registry.js
var BundleRegistry = class {
  constructor(assets) {
    this._idToBundle = /* @__PURE__ */ new Map();
    this._assetToBundles = /* @__PURE__ */ new Map();
    this._urlsToBundles = /* @__PURE__ */ new Map();
    this._fileRequests = /* @__PURE__ */ new Map();
    this._assets = assets;
    this._assets.bundles = this;
    this._assets.on("add", this._onAssetAdd, this);
    this._assets.on("remove", this._onAssetRemove, this);
  }
  _onAssetAdd(asset) {
    if (asset.type === "bundle") {
      this._idToBundle.set(asset.id, asset);
      this._assets.on(`load:start:${asset.id}`, this._onBundleLoadStart, this);
      this._assets.on(`load:${asset.id}`, this._onBundleLoad, this);
      this._assets.on(`error:${asset.id}`, this._onBundleError, this);
      const assetIds = asset.data.assets;
      for (let i = 0; i < assetIds.length; i++) {
        this._indexAssetInBundle(assetIds[i], asset);
      }
    } else {
      if (this._assetToBundles.has(asset.id)) {
        this._indexAssetFileUrls(asset);
      }
    }
  }
  _unbindAssetEvents(id13) {
    this._assets.off(`load:start:${id13}`, this._onBundleLoadStart, this);
    this._assets.off(`load:${id13}`, this._onBundleLoad, this);
    this._assets.off(`error:${id13}`, this._onBundleError, this);
  }
  _indexAssetInBundle(id13, bundle) {
    let bundles = this._assetToBundles.get(id13);
    if (!bundles) {
      bundles = /* @__PURE__ */ new Set();
      this._assetToBundles.set(id13, bundles);
    }
    bundles.add(bundle);
    const asset = this._assets.get(id13);
    if (asset) this._indexAssetFileUrls(asset);
  }
  _indexAssetFileUrls(asset) {
    const urls = this._getAssetFileUrls(asset);
    if (!urls) return;
    for (let i = 0; i < urls.length; i++) {
      const bundles = this._assetToBundles.get(asset.id);
      if (!bundles) continue;
      this._urlsToBundles.set(urls[i], bundles);
    }
  }
  _getAssetFileUrls(asset) {
    let url = asset.getFileUrl();
    if (!url) return null;
    url = url.split("?")[0];
    const urls = [url];
    if (asset.type === "font") {
      const numFiles = asset.data.info.maps.length;
      for (let i = 1; i < numFiles; i++) {
        urls.push(url.replace(".png", `${i}.png`));
      }
    }
    return urls;
  }
  _onAssetRemove(asset) {
    if (asset.type === "bundle") {
      this._idToBundle.delete(asset.id);
      this._unbindAssetEvents(asset.id);
      const assetIds = asset.data.assets;
      for (let i = 0; i < assetIds.length; i++) {
        const bundles = this._assetToBundles.get(assetIds[i]);
        if (!bundles) continue;
        bundles.delete(asset);
        if (bundles.size === 0) {
          this._assetToBundles.delete(assetIds[i]);
          for (const [url, otherBundles] of this._urlsToBundles) {
            if (otherBundles !== bundles) {
              continue;
            }
            this._urlsToBundles.delete(url);
          }
        }
      }
      this._onBundleError(`Bundle ${asset.id} was removed`);
    } else {
      const bundles = this._assetToBundles.get(asset.id);
      if (!bundles) return;
      this._assetToBundles.delete(asset.id);
      const urls = this._getAssetFileUrls(asset);
      if (!urls) return;
      for (let i = 0; i < urls.length; i++) {
        this._urlsToBundles.delete(urls[i]);
      }
    }
  }
  _onBundleLoadStart(asset) {
    asset.resource.on("add", (url, data2) => {
      const callbacks = this._fileRequests.get(url);
      if (!callbacks) return;
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](null, data2);
      }
      this._fileRequests.delete(url);
    });
  }
  _onBundleLoad(asset) {
    if (!asset.resource) {
      this._onBundleError(`Bundle ${asset.id} failed to load`);
      return;
    }
    if (!this._fileRequests) {
      return;
    }
    for (const [url, requests] of this._fileRequests) {
      const bundles = this._urlsToBundles.get(url);
      if (!bundles || !bundles.has(asset)) continue;
      const decodedUrl = decodeURIComponent(url);
      let err3, data2;
      if (asset.resource.has(decodedUrl)) {
        data2 = asset.resource.get(decodedUrl);
      } else if (asset.resource.loaded) {
        err3 = `Bundle ${asset.id} does not contain URL ${url}`;
      } else {
        continue;
      }
      for (let i = 0; i < requests.length; i++) {
        requests[i](err3, err3 || data2);
      }
      this._fileRequests.delete(url);
    }
  }
  _onBundleError(err3) {
    for (const [url, requests] of this._fileRequests) {
      const bundle = this._findLoadedOrLoadingBundleForUrl(url);
      if (!bundle) {
        for (let i = 0; i < requests.length; i++) {
          requests[i](err3);
        }
        this._fileRequests.delete(url);
      }
    }
  }
  _findLoadedOrLoadingBundleForUrl(url) {
    const bundles = this._urlsToBundles.get(url);
    if (!bundles) return null;
    let candidate = null;
    for (const bundle of bundles) {
      if (bundle.loaded && bundle.resource) {
        return bundle;
      } else if (bundle.loading) {
        candidate = bundle;
      }
    }
    return candidate;
  }
  listBundlesForAsset(asset) {
    const bundles = this._assetToBundles.get(asset.id);
    if (bundles) return Array.from(bundles);
    return null;
  }
  list() {
    return Array.from(this._idToBundle.values());
  }
  hasUrl(url) {
    return this._urlsToBundles.has(url);
  }
  urlIsLoadedOrLoading(url) {
    return !!this._findLoadedOrLoadingBundleForUrl(url);
  }
  loadUrl(url, callback) {
    const bundle = this._findLoadedOrLoadingBundleForUrl(url);
    if (!bundle) {
      callback(`URL ${url} not found in any bundles`);
      return;
    }
    if (bundle.loaded) {
      const decodedUrl = decodeURIComponent(url);
      if (bundle.resource.has(decodedUrl)) {
        callback(null, bundle.resource.get(decodedUrl));
        return;
      } else if (bundle.resource.loaded) {
        callback(`Bundle ${bundle.id} does not contain URL ${url}`);
        return;
      }
    }
    let callbacks = this._fileRequests.get(url);
    if (!callbacks) {
      callbacks = [];
      this._fileRequests.set(url, callbacks);
    }
    callbacks.push(callback);
  }
  destroy() {
    this._assets.off("add", this._onAssetAdd, this);
    this._assets.off("remove", this._onAssetRemove, this);
    for (const id13 of this._idToBundle.keys()) {
      this._unbindAssetEvents(id13);
    }
    this._assets = null;
    this._idToBundle.clear();
    this._idToBundle = null;
    this._assetToBundles.clear();
    this._assetToBundles = null;
    this._urlsToBundles.clear();
    this._urlsToBundles = null;
    this._fileRequests.clear();
    this._fileRequests = null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/registry.js
var ComponentSystemRegistry = class extends EventHandler {
  constructor() {
    super();
    this.anim = void 0;
    this.animation = void 0;
    this.audiolistener = void 0;
    this.button = void 0;
    this.camera = void 0;
    this.collision = void 0;
    this.element = void 0;
    this.joint = void 0;
    this.layoutchild = void 0;
    this.layoutgroup = void 0;
    this.light = void 0;
    this.model = void 0;
    this.particlesystem = void 0;
    this.render = void 0;
    this.rigidbody = void 0;
    this.screen = void 0;
    this.script = void 0;
    this.scrollbar = void 0;
    this.scrollview = void 0;
    this.sound = void 0;
    this.sprite = void 0;
    this.zone = void 0;
    this.list = [];
  }
  add(system) {
    const id13 = system.id;
    if (this[id13]) {
      throw new Error(`ComponentSystem name '${id13}' already registered or not allowed`);
    }
    this[id13] = system;
    this.list.push(system);
  }
  remove(system) {
    const id13 = system.id;
    if (!this[id13]) {
      throw new Error(`No ComponentSystem named '${id13}' registered`);
    }
    delete this[id13];
    const index = this.list.indexOf(this[id13]);
    if (index !== -1) {
      this.list.splice(index, 1);
    }
  }
  destroy() {
    this.off();
    for (let i = 0; i < this.list.length; i++) {
      this.list[i].destroy();
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/bundle/bundle.js
var Bundle = class extends EventHandler {
  constructor(...args) {
    super(...args);
    this._index = /* @__PURE__ */ new Map();
    this._loaded = false;
  }
  addFile(url, data2) {
    if (this._index.has(url)) {
      return;
    }
    this._index.set(url, data2);
    this.fire("add", url, data2);
  }
  has(url) {
    return this._index.has(url);
  }
  get(url) {
    return this._index.get(url) || null;
  }
  destroy() {
    this._index.clear();
  }
  set loaded(value) {
    if (!value || this._loaded) {
      return;
    }
    this._loaded = true;
    this.fire("load");
  }
  get loaded() {
    return this._loaded;
  }
};
Bundle.EVENT_ADD = "add";
Bundle.EVENT_LOAD = "load";

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/untar.js
var Untar = class extends EventHandler {
  constructor(fetchPromise, assetsPrefix = "") {
    super();
    this.headerSize = 512;
    this.paddingSize = 512;
    this.bytesRead = 0;
    this.bytesReceived = 0;
    this.headerRead = false;
    this.reader = null;
    this.data = new Uint8Array(0);
    this.decoder = null;
    this.prefix = "";
    this.fileName = "";
    this.fileSize = 0;
    this.fileType = "";
    this.ustarFormat = "";
    this.prefix = assetsPrefix || "";
    this.reader = fetchPromise.body.getReader();
    this.reader.read().then((res) => {
      this.pump(res.done, res.value);
    }).catch((err3) => {
      this.fire("error", err3);
    });
  }
  pump(done, value) {
    if (done) {
      this.fire("done");
      return null;
    }
    this.bytesReceived += value.byteLength;
    const data2 = new Uint8Array(this.data.length + value.length);
    data2.set(this.data);
    data2.set(value, this.data.length);
    this.data = data2;
    while (this.readFile()) ;
    return this.reader.read().then((res) => {
      this.pump(res.done, res.value);
    }).catch((err3) => {
      this.fire("error", err3);
    });
  }
  readFile() {
    if (!this.headerRead && this.bytesReceived > this.bytesRead + this.headerSize) {
      var _this$decoder;
      this.headerRead = true;
      const view = new DataView(this.data.buffer, this.bytesRead, this.headerSize);
      (_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder("windows-1252");
      const headers = this.decoder.decode(view);
      this.fileName = headers.substring(0, 100).replace(/\0/g, "");
      this.fileSize = parseInt(headers.substring(124, 136), 8);
      this.fileType = headers.substring(156, 157);
      this.ustarFormat = headers.substring(257, 263);
      if (this.ustarFormat.indexOf("ustar") !== -1) {
        const prefix = headers.substring(345, 500).replace(/\0/g, "");
        if (prefix.length > 0) {
          this.fileName = prefix.trim() + this.fileName.trim();
        }
      }
      this.bytesRead += 512;
    }
    if (this.headerRead) {
      if (this.bytesReceived < this.bytesRead + this.fileSize) {
        return false;
      }
      if (this.fileType === "" || this.fileType === "0") {
        const dataView = new DataView(this.data.buffer, this.bytesRead, this.fileSize);
        const file = {
          name: this.prefix + this.fileName,
          size: this.fileSize,
          data: dataView
        };
        this.fire("file", file);
      }
      this.bytesRead += this.fileSize;
      this.headerRead = false;
      const bytesRemained = this.bytesRead % this.paddingSize;
      if (bytesRemained !== 0) {
        this.bytesRead += this.paddingSize - bytesRemained;
      }
      return true;
    }
    return false;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/handler.js
var ResourceHandler = class {
  constructor(app2, handlerType) {
    this.handlerType = "";
    this._app = void 0;
    this._maxRetries = 0;
    this._app = app2;
    this.handlerType = handlerType;
  }
  set maxRetries(value) {
    this._maxRetries = value;
  }
  get maxRetries() {
    return this._maxRetries;
  }
  load(url, callback, asset) {
  }
  open(url, data2, asset) {
    return data2;
  }
  patch(asset, assets) {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/bundle.js
var BundleHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "bundle");
    this._assets = app2.assets;
  }
  _fetchRetries(url, options2, retries = 0) {
    return new Promise((resolve, reject) => {
      const tryFetch = () => {
        fetch(url, options2).then(resolve).catch((err3) => {
          retries++;
          if (retries < this.maxRetries) {
            tryFetch();
          } else {
            reject(err3);
          }
        });
      };
      tryFetch();
    });
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    this._fetchRetries(url.load, {
      mode: "cors",
      credentials: "include"
    }, this.maxRetries).then((res) => {
      const bundle = new Bundle();
      callback(null, bundle);
      const untar = new Untar(res, this._assets.prefix);
      untar.on("file", (file) => {
        bundle.addFile(file.name, file.data);
      });
      untar.on("done", () => {
        bundle.loaded = true;
      });
      untar.on("error", (err3) => {
        callback(err3);
      });
    }).catch((err3) => {
      callback(err3);
    });
  }
  open(url, bundle) {
    return bundle;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/loader.js
var ResourceLoader = class _ResourceLoader {
  constructor(app2) {
    this._handlers = {};
    this._requests = {};
    this._cache = {};
    this._app = app2;
  }
  addHandler(type, handler) {
    this._handlers[type] = handler;
    handler._loader = this;
  }
  removeHandler(type) {
    delete this._handlers[type];
  }
  getHandler(type) {
    return this._handlers[type];
  }
  static makeKey(url, type) {
    return `${url}-${type}`;
  }
  load(url, type, callback, asset, options2) {
    const handler = this._handlers[type];
    if (!handler) {
      const err3 = `No resource handler for asset type: '${type}' when loading [${url}]`;
      callback(err3);
      return;
    }
    if (!url) {
      this._loadNull(handler, callback, asset);
      return;
    }
    const key = _ResourceLoader.makeKey(url, type);
    if (this._cache[key] !== void 0) {
      callback(null, this._cache[key]);
    } else if (this._requests[key]) {
      this._requests[key].push(callback);
    } else {
      this._requests[key] = [callback];
      const self2 = this;
      const handleLoad = function handleLoad2(err3, urlObj) {
        if (err3) {
          self2._onFailure(key, err3);
          return;
        }
        if (urlObj.load instanceof DataView) {
          if (handler.openBinary) {
            if (!self2._requests[key]) {
              return;
            }
            try {
              const data2 = handler.openBinary(urlObj.load);
              self2._onSuccess(key, data2);
            } catch (err4) {
              self2._onFailure(key, err4);
            }
            return;
          }
          urlObj.load = URL.createObjectURL(new Blob([urlObj.load]));
          if (asset) {
            if (asset.urlObject) {
              URL.revokeObjectURL(asset.urlObject);
            }
            asset.urlObject = urlObj.load;
          }
        }
        handler.load(urlObj, (err4, data2, extra) => {
          if (!self2._requests[key]) {
            return;
          }
          if (err4) {
            self2._onFailure(key, err4);
            return;
          }
          try {
            self2._onSuccess(key, handler.open(urlObj.original, data2, asset), extra);
          } catch (e) {
            self2._onFailure(key, e);
          }
        }, asset);
      };
      const normalizedUrl = url.split("?")[0];
      if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl) && !(options2 && options2.bundlesIgnore)) {
        if (!this._app.bundles.urlIsLoadedOrLoading(normalizedUrl)) {
          var _this$_app$assets;
          const bundles = this._app.bundles.listBundlesForAsset(asset);
          let bundle;
          if (options2 && options2.bundlesFilter) {
            bundle = options2.bundlesFilter(bundles);
          }
          if (!bundle) {
            bundles == null || bundles.sort((a, b) => {
              return a.file.size - b.file.size;
            });
            bundle = bundles == null ? void 0 : bundles[0];
          }
          if (bundle) (_this$_app$assets = this._app.assets) == null || _this$_app$assets.load(bundle);
        }
        this._app.bundles.loadUrl(normalizedUrl, (err3, fileUrlFromBundle) => {
          handleLoad(err3, {
            load: fileUrlFromBundle,
            original: normalizedUrl
          });
        });
      } else {
        handleLoad(null, {
          load: url,
          original: asset && asset.file.filename || url
        });
      }
    }
  }
  _loadNull(handler, callback, asset) {
    const onLoad = function onLoad2(err3, data2, extra) {
      if (err3) {
        callback(err3);
      } else {
        try {
          callback(null, handler.open(null, data2, asset), extra);
        } catch (e) {
          callback(e);
        }
      }
    };
    handler.load(null, onLoad, asset);
  }
  _onSuccess(key, result, extra) {
    if (result !== null) {
      this._cache[key] = result;
    } else {
      delete this._cache[key];
    }
    for (let i = 0; i < this._requests[key].length; i++) {
      this._requests[key][i](null, result, extra);
    }
    delete this._requests[key];
  }
  _onFailure(key, err3) {
    console.error(err3);
    if (this._requests[key]) {
      for (let i = 0; i < this._requests[key].length; i++) {
        this._requests[key][i](err3);
      }
      delete this._requests[key];
    }
  }
  open(type, data2) {
    const handler = this._handlers[type];
    if (!handler) {
      console.warn(`No resource handler found for: ${type}`);
      return data2;
    }
    return handler.open(null, data2);
  }
  patch(asset, assets) {
    const handler = this._handlers[asset.type];
    if (!handler) {
      console.warn(`No resource handler found for: ${asset.type}`);
      return;
    }
    if (handler.patch) {
      handler.patch(asset, assets);
    }
  }
  clearCache(url, type) {
    const key = _ResourceLoader.makeKey(url, type);
    delete this._cache[key];
  }
  getFromCache(url, type) {
    const key = _ResourceLoader.makeKey(url, type);
    if (this._cache[key]) {
      return this._cache[key];
    }
    return void 0;
  }
  enableRetry(maxRetries = 5) {
    maxRetries = Math.max(0, maxRetries) || 0;
    for (const key in this._handlers) {
      this._handlers[key].maxRetries = maxRetries;
    }
  }
  disableRetry() {
    for (const key in this._handlers) {
      this._handlers[key].maxRetries = 0;
    }
  }
  destroy() {
    this._handlers = {};
    this._requests = {};
    this._cache = {};
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/i18n/i18n-parser.js
var I18nParser = class {
  _validate(data2) {
    if (!data2.header) {
      throw new Error('pc.I18n#addData: Missing "header" field');
    }
    if (!data2.header.version) {
      throw new Error('pc.I18n#addData: Missing "header.version" field');
    }
    if (data2.header.version !== 1) {
      throw new Error('pc.I18n#addData: Invalid "header.version" field');
    }
    if (!data2.data) {
      throw new Error('pc.I18n#addData: Missing "data" field');
    } else if (!Array.isArray(data2.data)) {
      throw new Error('pc.I18n#addData: "data" field must be an array');
    }
    for (let i = 0, len = data2.data.length; i < len; i++) {
      const entry = data2.data[i];
      if (!entry.info) {
        throw new Error(`pc.I18n#addData: missing "data[${i}].info" field`);
      }
      if (!entry.info.locale) {
        throw new Error(`pc.I18n#addData: missing "data[${i}].info.locale" field`);
      }
      if (typeof entry.info.locale !== "string") {
        throw new Error(`pc.I18n#addData: "data[${i}].info.locale" must be a string`);
      }
      if (!entry.messages) {
        throw new Error(`pc.I18n#addData: missing "data[${i}].messages" field`);
      }
    }
  }
  parse(data2) {
    return data2.data;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/i18n/i18n.js
var I18n = class extends EventHandler {
  constructor(app2) {
    super();
    this.locale = DEFAULT_LOCALE;
    this._translations = {};
    this._availableLangs = {};
    this._app = app2;
    this._assets = [];
    this._parser = new I18nParser();
  }
  set assets(value) {
    const index = {};
    for (let _i = 0, len = value.length; _i < len; _i++) {
      const id13 = value[_i] instanceof Asset ? value[_i].id : value[_i];
      index[id13] = true;
    }
    let i = this._assets.length;
    while (i--) {
      const id13 = this._assets[i];
      if (!index[id13]) {
        this._app.assets.off(`add:${id13}`, this._onAssetAdd, this);
        const asset = this._app.assets.get(id13);
        if (asset) {
          this._onAssetRemove(asset);
        }
        this._assets.splice(i, 1);
      }
    }
    for (const id13 in index) {
      const idNum = parseInt(id13, 10);
      if (this._assets.indexOf(idNum) !== -1) continue;
      this._assets.push(idNum);
      const asset = this._app.assets.get(idNum);
      if (!asset) {
        this._app.assets.once(`add:${idNum}`, this._onAssetAdd, this);
      } else {
        this._onAssetAdd(asset);
      }
    }
  }
  get assets() {
    return this._assets;
  }
  set locale(value) {
    if (this._locale === value) {
      return;
    }
    let lang = getLang(value);
    if (lang === "in") {
      lang = "id";
      value = replaceLang(value, lang);
      if (this._locale === value) {
        return;
      }
    }
    const old = this._locale;
    this._locale = value;
    this._lang = lang;
    this._pluralFn = getPluralFn(this._lang);
    this.fire("set:locale", value, old);
  }
  get locale() {
    return this._locale;
  }
  static findAvailableLocale(desiredLocale, availableLocales) {
    return findAvailableLocale(desiredLocale, availableLocales);
  }
  findAvailableLocale(desiredLocale) {
    if (this._translations[desiredLocale]) {
      return desiredLocale;
    }
    const lang = getLang(desiredLocale);
    return this._findFallbackLocale(desiredLocale, lang);
  }
  getText(key, locale) {
    let result = key;
    let lang;
    if (!locale) {
      locale = this._locale;
      lang = this._lang;
    }
    let translations = this._translations[locale];
    if (!translations) {
      if (!lang) {
        lang = getLang(locale);
      }
      locale = this._findFallbackLocale(locale, lang);
      translations = this._translations[locale];
    }
    if (translations && translations.hasOwnProperty(key)) {
      result = translations[key];
      if (Array.isArray(result)) {
        result = result[0];
      }
      if (result === null || result === void 0) {
        result = key;
      }
    }
    return result;
  }
  getPluralText(key, n, locale) {
    let result = key;
    let lang;
    let pluralFn;
    if (!locale) {
      locale = this._locale;
      lang = this._lang;
      pluralFn = this._pluralFn;
    } else {
      lang = getLang(locale);
      pluralFn = getPluralFn(lang);
    }
    let translations = this._translations[locale];
    if (!translations) {
      locale = this._findFallbackLocale(locale, lang);
      lang = getLang(locale);
      pluralFn = getPluralFn(lang);
      translations = this._translations[locale];
    }
    if (translations && translations[key] && pluralFn) {
      const index = pluralFn(n);
      result = translations[key][index];
      if (result === null || result === void 0) {
        result = key;
      }
    }
    return result;
  }
  addData(data2) {
    let parsed;
    try {
      parsed = this._parser.parse(data2);
    } catch (err3) {
      console.error(err3);
      return;
    }
    for (let i = 0, len = parsed.length; i < len; i++) {
      const entry = parsed[i];
      const locale = entry.info.locale;
      const messages = entry.messages;
      if (!this._translations[locale]) {
        this._translations[locale] = {};
        const lang = getLang(locale);
        if (!this._availableLangs[lang]) {
          this._availableLangs[lang] = locale;
        }
      }
      Object.assign(this._translations[locale], messages);
      this.fire("data:add", locale, messages);
    }
  }
  removeData(data2) {
    let parsed;
    try {
      parsed = this._parser.parse(data2);
    } catch (err3) {
      console.error(err3);
      return;
    }
    for (let i = 0, len = parsed.length; i < len; i++) {
      const entry = parsed[i];
      const locale = entry.info.locale;
      const translations = this._translations[locale];
      if (!translations) continue;
      const messages = entry.messages;
      for (const key in messages) {
        delete translations[key];
      }
      if (Object.keys(translations).length === 0) {
        delete this._translations[locale];
        delete this._availableLangs[getLang(locale)];
      }
      this.fire("data:remove", locale, messages);
    }
  }
  destroy() {
    this._translations = null;
    this._availableLangs = null;
    this._assets = null;
    this._parser = null;
    this.off();
  }
  _findFallbackLocale(locale, lang) {
    let result = DEFAULT_LOCALE_FALLBACKS[locale];
    if (result && this._translations[result]) {
      return result;
    }
    result = DEFAULT_LOCALE_FALLBACKS[lang];
    if (result && this._translations[result]) {
      return result;
    }
    result = this._availableLangs[lang];
    if (result && this._translations[result]) {
      return result;
    }
    return DEFAULT_LOCALE;
  }
  _onAssetAdd(asset) {
    asset.on("load", this._onAssetLoad, this);
    asset.on("change", this._onAssetChange, this);
    asset.on("remove", this._onAssetRemove, this);
    asset.on("unload", this._onAssetUnload, this);
    if (asset.resource) {
      this._onAssetLoad(asset);
    }
  }
  _onAssetLoad(asset) {
    this.addData(asset.resource);
  }
  _onAssetChange(asset) {
    if (asset.resource) {
      this.addData(asset.resource);
    }
  }
  _onAssetRemove(asset) {
    asset.off("load", this._onAssetLoad, this);
    asset.off("change", this._onAssetChange, this);
    asset.off("remove", this._onAssetRemove, this);
    asset.off("unload", this._onAssetUnload, this);
    if (asset.resource) {
      this.removeData(asset.resource);
    }
    this._app.assets.once(`add:${asset.id}`, this._onAssetAdd, this);
  }
  _onAssetUnload(asset) {
    if (asset.resource) {
      this.removeData(asset.resource);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/script/script-registry.js
var ScriptRegistry = class extends EventHandler {
  constructor(app2) {
    super();
    this._scripts = {};
    this._list = [];
    this._scriptSchemas = /* @__PURE__ */ new Map();
    this.app = app2;
  }
  destroy() {
    this.app = null;
    this.off();
  }
  addSchema(id13, schema) {
    if (!schema) return;
    this._scriptSchemas.set(id13, schema);
  }
  getSchema(id13) {
    return this._scriptSchemas.get(id13);
  }
  add(script2) {
    const scriptName = script2.__name;
    if (this._scripts.hasOwnProperty(scriptName)) {
      setTimeout(() => {
        if (script2.prototype.swap) {
          const old = this._scripts[scriptName];
          const ind = this._list.indexOf(old);
          this._list[ind] = script2;
          this._scripts[scriptName] = script2;
          this.fire("swap", scriptName, script2);
          this.fire(`swap:${scriptName}`, script2);
        } else {
          console.warn(`script registry already has '${scriptName}' script, define 'swap' method for new script type to enable code hot swapping`);
        }
      });
      return false;
    }
    this._scripts[scriptName] = script2;
    this._list.push(script2);
    this.fire("add", scriptName, script2);
    this.fire(`add:${scriptName}`, script2);
    setTimeout(() => {
      if (!this._scripts.hasOwnProperty(scriptName)) {
        return;
      }
      if (!this.app || !this.app.systems || !this.app.systems.script) {
        return;
      }
      const components2 = this.app.systems.script._components;
      let attributes;
      const scriptInstances = [];
      const scriptInstancesInitialized = [];
      for (components2.loopIndex = 0; components2.loopIndex < components2.length; components2.loopIndex++) {
        const component = components2.items[components2.loopIndex];
        if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
          if (component._scriptsData && component._scriptsData[scriptName]) {
            attributes = component._scriptsData[scriptName].attributes;
          }
          const scriptInstance = component.create(scriptName, {
            preloading: true,
            ind: component._scriptsIndex[scriptName].ind,
            attributes
          });
          if (scriptInstance) {
            scriptInstances.push(scriptInstance);
          }
          for (const script3 of component.scripts) {
            component.initializeAttributes(script3);
          }
        }
      }
      for (let i = 0; i < scriptInstances.length; i++) {
        if (scriptInstances[i].enabled) {
          scriptInstances[i]._initialized = true;
          scriptInstancesInitialized.push(scriptInstances[i]);
          if (scriptInstances[i].initialize) {
            scriptInstances[i].initialize();
          }
        }
      }
      for (let i = 0; i < scriptInstancesInitialized.length; i++) {
        if (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {
          continue;
        }
        scriptInstancesInitialized[i]._postInitialized = true;
        if (scriptInstancesInitialized[i].postInitialize) {
          scriptInstancesInitialized[i].postInitialize();
        }
      }
    });
    return true;
  }
  remove(nameOrType) {
    let scriptType = nameOrType;
    let scriptName = nameOrType;
    if (typeof scriptName !== "string") {
      scriptName = scriptType.__name;
    } else {
      scriptType = this.get(scriptName);
    }
    if (this.get(scriptName) !== scriptType) {
      return false;
    }
    delete this._scripts[scriptName];
    const ind = this._list.indexOf(scriptType);
    this._list.splice(ind, 1);
    this.fire("remove", scriptName, scriptType);
    this.fire(`remove:${scriptName}`, scriptType);
    return true;
  }
  get(name) {
    return this._scripts[name] || null;
  }
  has(nameOrType) {
    if (typeof nameOrType === "string") {
      return this._scripts.hasOwnProperty(nameOrType);
    }
    if (!nameOrType) return false;
    const scriptName = nameOrType.__name;
    return this._scripts[scriptName] === nameOrType;
  }
  list() {
    return this._list;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/entity.js
var cmpStaticOrder = (a, b) => a.constructor.order - b.constructor.order;
var sortStaticOrder = (arr) => arr.sort(cmpStaticOrder);
var _enableList = [];
var tmpPool = [];
var getTempArray = () => {
  var _tmpPool$pop;
  return (_tmpPool$pop = tmpPool.pop()) != null ? _tmpPool$pop : [];
};
var releaseTempArray = (a) => {
  a.length = 0;
  tmpPool.push(a);
};
var Entity = class _Entity extends GraphNode {
  constructor(name, app2 = getApplication()) {
    super(name);
    this.anim = void 0;
    this.animation = void 0;
    this.audiolistener = void 0;
    this.button = void 0;
    this.camera = void 0;
    this.collision = void 0;
    this.element = void 0;
    this.gsplat = void 0;
    this.layoutchild = void 0;
    this.layoutgroup = void 0;
    this.light = void 0;
    this.model = void 0;
    this.particlesystem = void 0;
    this.render = void 0;
    this.rigidbody = void 0;
    this.screen = void 0;
    this.script = void 0;
    this.scrollbar = void 0;
    this.scrollview = void 0;
    this.sound = void 0;
    this.sprite = void 0;
    this.c = {};
    this._app = void 0;
    this._destroying = false;
    this._guid = null;
    this._template = false;
    this._app = app2;
  }
  addComponent(type, data2) {
    const system = this._app.systems[type];
    if (!system) {
      return null;
    }
    if (this.c[type]) {
      return null;
    }
    return system.addComponent(this, data2);
  }
  removeComponent(type) {
    const system = this._app.systems[type];
    if (!system) {
      return;
    }
    if (!this.c[type]) {
      return;
    }
    system.removeComponent(this);
  }
  findComponent(type) {
    const entity = this.findOne((entity2) => {
      var _entity$c;
      return (_entity$c = entity2.c) == null ? void 0 : _entity$c[type];
    });
    return entity && entity.c[type];
  }
  findComponents(type) {
    return this.find((entity) => {
      var _entity$c2;
      return (_entity$c2 = entity.c) == null ? void 0 : _entity$c2[type];
    }).map((entity) => entity.c[type]);
  }
  findScript(nameOrType) {
    const entity = this.findOne((node) => {
      var _node$c;
      return (_node$c = node.c) == null || (_node$c = _node$c.script) == null ? void 0 : _node$c.has(nameOrType);
    });
    return entity == null ? void 0 : entity.c.script.get(nameOrType);
  }
  findScripts(nameOrType) {
    const entities = this.find((node) => {
      var _node$c2;
      return (_node$c2 = node.c) == null || (_node$c2 = _node$c2.script) == null ? void 0 : _node$c2.has(nameOrType);
    });
    return entities.map((entity) => entity.c.script.get(nameOrType));
  }
  getGuid() {
    if (!this._guid) {
      this.setGuid(guid.create());
    }
    return this._guid;
  }
  setGuid(guid2) {
    const index = this._app._entityIndex;
    if (this._guid) {
      delete index[this._guid];
    }
    this._guid = guid2;
    index[this._guid] = this;
  }
  _notifyHierarchyStateChanged(node, enabled) {
    let enableFirst = false;
    if (node === this && _enableList.length === 0) {
      enableFirst = true;
    }
    node._beingEnabled = true;
    node._onHierarchyStateChanged(enabled);
    if (node._onHierarchyStatePostChanged) {
      _enableList.push(node);
    }
    const c2 = node._children;
    for (let i = 0, len = c2.length; i < len; i++) {
      if (c2[i]._enabled) {
        this._notifyHierarchyStateChanged(c2[i], enabled);
      }
    }
    node._beingEnabled = false;
    if (enableFirst) {
      for (let i = 0; i < _enableList.length; i++) {
        _enableList[i]._onHierarchyStatePostChanged();
      }
      _enableList.length = 0;
    }
  }
  _onHierarchyStateChanged(enabled) {
    super._onHierarchyStateChanged(enabled);
    const components2 = this._getSortedComponents();
    for (let i = 0; i < components2.length; i++) {
      const component = components2[i];
      if (component.enabled) {
        if (enabled) {
          component.onEnable();
        } else {
          component.onDisable();
        }
      }
    }
    releaseTempArray(components2);
  }
  _onHierarchyStatePostChanged() {
    const components2 = this._getSortedComponents();
    for (let i = 0; i < components2.length; i++) {
      components2[i].onPostStateChange();
    }
    releaseTempArray(components2);
  }
  findByGuid(guid2) {
    if (this._guid === guid2) return this;
    const e = this._app._entityIndex[guid2];
    if (e && (e === this || e.isDescendantOf(this))) {
      return e;
    }
    return null;
  }
  destroy() {
    this._destroying = true;
    for (const name in this.c) {
      this.c[name].enabled = false;
    }
    for (const name in this.c) {
      this.c[name].system.removeComponent(this);
    }
    super.destroy();
    if (this._guid) {
      delete this._app._entityIndex[this._guid];
    }
    this._destroying = false;
  }
  clone() {
    const duplicatedIdsMap = {};
    const clone = this._cloneRecursively(duplicatedIdsMap);
    duplicatedIdsMap[this.getGuid()] = clone;
    resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
    return clone;
  }
  _getSortedComponents() {
    const components2 = this.c;
    const sortedArray = getTempArray();
    let needSort = 0;
    for (const type in components2) {
      if (components2.hasOwnProperty(type)) {
        const component = components2[type];
        needSort |= component.constructor.order !== 0;
        sortedArray.push(component);
      }
    }
    if (needSort && sortedArray.length > 1) {
      sortStaticOrder(sortedArray);
    }
    return sortedArray;
  }
  _cloneRecursively(duplicatedIdsMap) {
    const clone = new this.constructor(void 0, this._app);
    super._cloneInternal(clone);
    for (const type in this.c) {
      const component = this.c[type];
      component.system.cloneComponent(this, clone);
    }
    for (let i = 0; i < this._children.length; i++) {
      const oldChild = this._children[i];
      if (oldChild instanceof _Entity) {
        const newChild = oldChild._cloneRecursively(duplicatedIdsMap);
        clone.addChild(newChild);
        duplicatedIdsMap[oldChild.getGuid()] = newChild;
      }
    }
    return clone;
  }
};
Entity.EVENT_DESTROY = "destroy";
function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
  if (oldEntity instanceof Entity) {
    const components2 = oldEntity.c;
    for (const componentName in components2) {
      const component = components2[componentName];
      const entityProperties = component.system.getPropertiesOfType("entity");
      for (let i = 0, len = entityProperties.length; i < len; i++) {
        const propertyDescriptor = entityProperties[i];
        const propertyName = propertyDescriptor.name;
        const oldEntityReferenceId = component[propertyName];
        const entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);
        if (entityIsWithinOldSubtree) {
          const newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();
          if (newEntityReferenceId) {
            newEntity.c[componentName][propertyName] = newEntityReferenceId;
          }
        }
      }
    }
    if (components2.script) {
      newEntity.script.resolveDuplicatedEntityReferenceProperties(components2.script, duplicatedIdsMap);
    }
    if (components2.render) {
      newEntity.render.resolveDuplicatedEntityReferenceProperties(components2.render, duplicatedIdsMap);
    }
    if (components2.anim) {
      newEntity.anim.resolveDuplicatedEntityReferenceProperties(components2.anim, duplicatedIdsMap);
    }
    const _old = oldEntity.children.filter((e) => e instanceof Entity);
    const _new = newEntity.children.filter((e) => e instanceof Entity);
    for (let i = 0, len = _old.length; i < len; i++) {
      resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);
    }
  }
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/scene-registry-item.js
var SceneRegistryItem = class {
  constructor(name, url) {
    this.name = void 0;
    this.url = void 0;
    this.data = null;
    this._loading = false;
    this._onLoadedCallbacks = [];
    this.name = name;
    this.url = url;
  }
  get loaded() {
    return !!this.data;
  }
  get loading() {
    return this._loading;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/scene-registry.js
var SceneRegistry = class {
  constructor(app2) {
    this._app = void 0;
    this._list = [];
    this._index = {};
    this._urlIndex = {};
    this._app = app2;
  }
  destroy() {
    this._app = null;
  }
  list() {
    return this._list;
  }
  add(name, url) {
    if (this._index.hasOwnProperty(name)) {
      return false;
    }
    const item = new SceneRegistryItem(name, url);
    const i = this._list.push(item);
    this._index[item.name] = i - 1;
    this._urlIndex[item.url] = i - 1;
    return true;
  }
  find(name) {
    if (this._index.hasOwnProperty(name)) {
      return this._list[this._index[name]];
    }
    return null;
  }
  findByUrl(url) {
    if (this._urlIndex.hasOwnProperty(url)) {
      return this._list[this._urlIndex[url]];
    }
    return null;
  }
  remove(name) {
    if (this._index.hasOwnProperty(name)) {
      const idx = this._index[name];
      let item = this._list[idx];
      delete this._urlIndex[item.url];
      delete this._index[name];
      this._list.splice(idx, 1);
      for (let i = 0; i < this._list.length; i++) {
        item = this._list[i];
        this._index[item.name] = i;
        this._urlIndex[item.url] = i;
      }
    }
  }
  _loadSceneData(sceneItem, storeInCache, callback) {
    const app2 = this._app;
    let url = sceneItem;
    if (typeof sceneItem === "string") {
      sceneItem = this.findByUrl(url) || this.find(url) || new SceneRegistryItem("Untitled", url);
    }
    url = sceneItem.url;
    if (!url) {
      callback("Cannot find scene to load");
      return;
    }
    if (sceneItem.loaded) {
      callback(null, sceneItem);
      return;
    }
    if (app2.assets && app2.assets.prefix && !ABSOLUTE_URL.test(url)) {
      url = path.join(app2.assets.prefix, url);
    }
    sceneItem._onLoadedCallbacks.push(callback);
    if (!sceneItem._loading) {
      const handler = app2.loader.getHandler("hierarchy");
      handler.load(url, (err3, data2) => {
        sceneItem.data = data2;
        sceneItem._loading = false;
        for (let i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {
          sceneItem._onLoadedCallbacks[i](err3, sceneItem);
        }
        if (!storeInCache) {
          sceneItem.data = null;
        }
        sceneItem._onLoadedCallbacks.length = 0;
      });
    }
    sceneItem._loading = true;
  }
  loadSceneData(sceneItem, callback) {
    this._loadSceneData(sceneItem, true, callback);
  }
  unloadSceneData(sceneItem) {
    if (typeof sceneItem === "string") {
      sceneItem = this.findByUrl(sceneItem);
    }
    if (sceneItem) {
      sceneItem.data = null;
    }
  }
  _loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback) {
    this._loadSceneData(sceneItem, false, (err3, sceneItem2) => {
      if (err3) {
        if (callback) {
          callback(err3);
        }
        return;
      }
      if (onBeforeAddHierarchy) {
        onBeforeAddHierarchy(sceneItem2);
      }
      const app2 = this._app;
      const _loaded = () => {
        const handler = app2.loader.getHandler("hierarchy");
        app2.systems.script.preloading = true;
        const entity = handler.open(sceneItem2.url, sceneItem2.data);
        app2.systems.script.preloading = false;
        app2.loader.clearCache(sceneItem2.url, "hierarchy");
        app2.root.addChild(entity);
        app2.systems.fire("initialize", entity);
        app2.systems.fire("postInitialize", entity);
        app2.systems.fire("postPostInitialize", entity);
        if (callback) callback(null, entity);
      };
      app2._preloadScripts(sceneItem2.data, _loaded);
    });
  }
  loadSceneHierarchy(sceneItem, callback) {
    this._loadSceneHierarchy(sceneItem, null, callback);
  }
  loadSceneSettings(sceneItem, callback) {
    this._loadSceneData(sceneItem, false, (err3, sceneItem2) => {
      if (!err3) {
        this._app.applySceneSettings(sceneItem2.data.settings);
        if (callback) {
          callback(null);
        }
      } else {
        if (callback) {
          callback(err3);
        }
      }
    });
  }
  changeScene(sceneItem, callback) {
    const app2 = this._app;
    const onBeforeAddHierarchy = (sceneItem2) => {
      const {
        children
      } = app2.root;
      while (children.length) {
        children[0].destroy();
      }
      app2.applySceneSettings(sceneItem2.data.settings);
    };
    this._loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback);
  }
  loadScene(url, callback) {
    const app2 = this._app;
    const handler = app2.loader.getHandler("scene");
    if (app2.assets && app2.assets.prefix && !ABSOLUTE_URL.test(url)) {
      url = path.join(app2.assets.prefix, url);
    }
    handler.load(url, (err3, data2) => {
      if (!err3) {
        const _loaded = () => {
          app2.systems.script.preloading = true;
          const scene = handler.open(url, data2);
          const sceneItem = this.findByUrl(url);
          if (sceneItem && !sceneItem.loaded) {
            sceneItem.data = data2;
          }
          app2.systems.script.preloading = false;
          app2.loader.clearCache(url, "scene");
          app2.loader.patch({
            resource: scene,
            type: "scene"
          }, app2.assets);
          app2.root.addChild(scene.root);
          if (app2.systems.rigidbody && typeof Ammo !== "undefined") {
            app2.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
          }
          if (callback) {
            callback(null, scene);
          }
        };
        app2._preloadScripts(data2, _loaded);
      } else {
        if (callback) {
          callback(err3);
        }
      }
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/stats.js
var ApplicationStats = class {
  constructor(device) {
    this.frame = {
      fps: 0,
      ms: 0,
      dt: 0,
      updateStart: 0,
      updateTime: 0,
      renderStart: 0,
      renderTime: 0,
      physicsStart: 0,
      physicsTime: 0,
      cullTime: 0,
      sortTime: 0,
      skinTime: 0,
      morphTime: 0,
      instancingTime: 0,
      triangles: 0,
      otherPrimitives: 0,
      shaders: 0,
      materials: 0,
      cameras: 0,
      shadowMapUpdates: 0,
      shadowMapTime: 0,
      depthMapTime: 0,
      forwardTime: 0,
      lightClustersTime: 0,
      lightClusters: 0,
      _timeToCountFrames: 0,
      _fpsAccum: 0
    };
    this.drawCalls = {
      forward: 0,
      depth: 0,
      shadow: 0,
      immediate: 0,
      misc: 0,
      total: 0,
      skinned: 0,
      instanced: 0,
      removedByInstancing: 0
    };
    this.misc = {
      renderTargetCreationTime: 0
    };
    this.particles = {
      updatesPerFrame: 0,
      _updatesPerFrame: 0,
      frameTime: 0,
      _frameTime: 0
    };
    this.shaders = device._shaderStats;
    this.vram = device._vram;
    Object.defineProperty(this.vram, "totalUsed", {
      get: function() {
        return this.tex + this.vb + this.ib;
      }
    });
    Object.defineProperty(this.vram, "geom", {
      get: function() {
        return this.vb + this.ib;
      }
    });
  }
  get scene() {
    return getApplication().scene._stats;
  }
  get lightmapper() {
    var _getApplication$light;
    return (_getApplication$light = getApplication().lightmapper) == null ? void 0 : _getApplication$light.stats;
  }
  get batcher() {
    const batcher = getApplication()._batcher;
    return batcher ? batcher._stats : null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/app-base.js
var app = null;
var AppBase = class _AppBase extends EventHandler {
  constructor(canvas) {
    super();
    this._batcher = null;
    this._destroyRequested = false;
    this._inFrameUpdate = false;
    this._librariesLoaded = false;
    this._fillMode = FILLMODE_KEEP_ASPECT;
    this._resolutionMode = RESOLUTION_FIXED;
    this._allowResize = true;
    this._skyboxAsset = null;
    this._soundManager = void 0;
    this._visibilityChangeHandler = void 0;
    this._entityIndex = {};
    this._inTools = false;
    this._scriptPrefix = "";
    this._time = 0;
    this.enableBundles = typeof TextDecoder !== "undefined";
    this.frameRequestId = void 0;
    this.timeScale = 1;
    this.maxDeltaTime = 0.1;
    this.frame = 0;
    this.frameGraph = new FrameGraph();
    this.renderer = void 0;
    this.scriptsOrder = [];
    this.stats = void 0;
    this.autoRender = true;
    this.renderNextFrame = false;
    this.graphicsDevice = void 0;
    this.root = void 0;
    this.scene = void 0;
    this.lightmapper = null;
    this.loader = new ResourceLoader(this);
    this.assets = void 0;
    this.bundles = void 0;
    this.scenes = new SceneRegistry(this);
    this.scripts = new ScriptRegistry(this);
    this.systems = new ComponentSystemRegistry();
    this.i18n = new I18n(this);
    this.keyboard = null;
    this.mouse = null;
    this.touch = null;
    this.gamepads = null;
    this.elementInput = null;
    this.xr = null;
    _AppBase._applications[canvas.id] = this;
    setApplication(this);
    app = this;
    this.root = new Entity();
    this.root._enabledInHierarchy = true;
  }
  init(appOptions) {
    const {
      assetPrefix,
      batchManager,
      componentSystems,
      elementInput,
      gamepads: gamepads2,
      graphicsDevice,
      keyboard,
      lightmapper,
      mouse,
      resourceHandlers,
      scriptsOrder,
      scriptPrefix,
      soundManager,
      touch: touch2,
      xr
    } = appOptions;
    this.graphicsDevice = graphicsDevice;
    this._initDefaultMaterial();
    this._initProgramLibrary();
    this.stats = new ApplicationStats(graphicsDevice);
    this._soundManager = soundManager;
    this.scene = new Scene(graphicsDevice);
    this._registerSceneImmediate(this.scene);
    this.assets = new AssetRegistry(this.loader);
    if (assetPrefix) this.assets.prefix = assetPrefix;
    this.bundles = new BundleRegistry(this.assets);
    this.scriptsOrder = scriptsOrder || [];
    this.defaultLayerWorld = new Layer({
      name: "World",
      id: LAYERID_WORLD
    });
    this.defaultLayerDepth = new Layer({
      name: "Depth",
      id: LAYERID_DEPTH,
      enabled: false,
      opaqueSortMode: SORTMODE_NONE
    });
    this.defaultLayerSkybox = new Layer({
      name: "Skybox",
      id: LAYERID_SKYBOX,
      opaqueSortMode: SORTMODE_NONE
    });
    this.defaultLayerUi = new Layer({
      name: "UI",
      id: LAYERID_UI,
      transparentSortMode: SORTMODE_MANUAL
    });
    this.defaultLayerImmediate = new Layer({
      name: "Immediate",
      id: LAYERID_IMMEDIATE,
      opaqueSortMode: SORTMODE_NONE
    });
    const defaultLayerComposition = new LayerComposition("default");
    defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
    defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
    defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
    defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
    defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
    defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
    defaultLayerComposition.pushTransparent(this.defaultLayerUi);
    this.scene.layers = defaultLayerComposition;
    AreaLightLuts.createPlaceholder(graphicsDevice);
    this.renderer = new ForwardRenderer(graphicsDevice);
    this.renderer.scene = this.scene;
    if (lightmapper) {
      this.lightmapper = new lightmapper(graphicsDevice, this.root, this.scene, this.renderer, this.assets);
      this.once("prerender", this._firstBake, this);
    }
    if (batchManager) {
      this._batcher = new batchManager(graphicsDevice, this.root, this.scene);
      this.once("prerender", this._firstBatch, this);
    }
    this.keyboard = keyboard || null;
    this.mouse = mouse || null;
    this.touch = touch2 || null;
    this.gamepads = gamepads2 || null;
    if (elementInput) {
      this.elementInput = elementInput;
      this.elementInput.app = this;
    }
    this.xr = xr ? new xr(this) : null;
    if (this.elementInput) this.elementInput.attachSelectEvents();
    this._scriptPrefix = scriptPrefix || "";
    if (this.enableBundles) {
      this.loader.addHandler("bundle", new BundleHandler(this));
    }
    resourceHandlers.forEach((resourceHandler) => {
      const handler = new resourceHandler(this);
      this.loader.addHandler(handler.handlerType, handler);
    });
    componentSystems.forEach((componentSystem) => {
      this.systems.add(new componentSystem(this));
    });
    this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
    if (typeof document !== "undefined") {
      if (document.hidden !== void 0) {
        this._hiddenAttr = "hidden";
        document.addEventListener("visibilitychange", this._visibilityChangeHandler, false);
      } else if (document.mozHidden !== void 0) {
        this._hiddenAttr = "mozHidden";
        document.addEventListener("mozvisibilitychange", this._visibilityChangeHandler, false);
      } else if (document.msHidden !== void 0) {
        this._hiddenAttr = "msHidden";
        document.addEventListener("msvisibilitychange", this._visibilityChangeHandler, false);
      } else if (document.webkitHidden !== void 0) {
        this._hiddenAttr = "webkitHidden";
        document.addEventListener("webkitvisibilitychange", this._visibilityChangeHandler, false);
      }
    }
    this.tick = makeTick(this);
  }
  static getApplication(id13) {
    return id13 ? _AppBase._applications[id13] : getApplication();
  }
  _initDefaultMaterial() {
    const material = new StandardMaterial();
    material.name = "Default Material";
    setDefaultMaterial(this.graphicsDevice, material);
  }
  _initProgramLibrary() {
    const library = new ProgramLibrary(this.graphicsDevice, new StandardMaterial());
    setProgramLibrary(this.graphicsDevice, library);
  }
  get soundManager() {
    return this._soundManager;
  }
  get batcher() {
    return this._batcher;
  }
  get fillMode() {
    return this._fillMode;
  }
  get resolutionMode() {
    return this._resolutionMode;
  }
  configure(url, callback) {
    http.get(url, (err3, response) => {
      if (err3) {
        callback(err3);
        return;
      }
      const props = response.application_properties;
      const scenes = response.scenes;
      const assets = response.assets;
      this._parseApplicationProperties(props, (err4) => {
        this._parseScenes(scenes);
        this._parseAssets(assets);
        if (!err4) {
          callback(null);
        } else {
          callback(err4);
        }
      });
    });
  }
  preload(callback) {
    this.fire("preload:start");
    const assets = this.assets.list({
      preload: true
    });
    if (assets.length === 0) {
      this.fire("preload:end");
      callback();
      return;
    }
    let loadedCount = 0;
    const onAssetLoadOrError = () => {
      loadedCount++;
      this.fire("preload:progress", loadedCount / assets.length);
      if (loadedCount === assets.length) {
        this.fire("preload:end");
        callback();
      }
    };
    assets.forEach((asset) => {
      if (!asset.loaded) {
        asset.once("load", onAssetLoadOrError);
        asset.once("error", onAssetLoadOrError);
        this.assets.load(asset);
      } else {
        onAssetLoadOrError();
      }
    });
  }
  _preloadScripts(sceneData, callback) {
    callback();
  }
  _parseApplicationProperties(props, callback) {
    if (typeof props.maxAssetRetries === "number" && props.maxAssetRetries > 0) {
      this.loader.enableRetry(props.maxAssetRetries);
    }
    if (!props.useDevicePixelRatio) {
      props.useDevicePixelRatio = props.use_device_pixel_ratio;
    }
    if (!props.resolutionMode) {
      props.resolutionMode = props.resolution_mode;
    }
    if (!props.fillMode) {
      props.fillMode = props.fill_mode;
    }
    this._width = props.width;
    this._height = props.height;
    if (props.useDevicePixelRatio) {
      this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
    }
    this.setCanvasResolution(props.resolutionMode, this._width, this._height);
    this.setCanvasFillMode(props.fillMode, this._width, this._height);
    if (props.layers && props.layerOrder) {
      const composition = new LayerComposition("application");
      const layers = {};
      for (const key in props.layers) {
        const data2 = props.layers[key];
        data2.id = parseInt(key, 10);
        data2.enabled = data2.id !== LAYERID_DEPTH;
        layers[key] = new Layer(data2);
      }
      for (let i = 0, len = props.layerOrder.length; i < len; i++) {
        const sublayer = props.layerOrder[i];
        const layer = layers[sublayer.layer];
        if (!layer) continue;
        if (sublayer.transparent) {
          composition.pushTransparent(layer);
        } else {
          composition.pushOpaque(layer);
        }
        composition.subLayerEnabled[i] = sublayer.enabled;
      }
      this.scene.layers = composition;
    }
    if (props.batchGroups) {
      const batcher = this.batcher;
      if (batcher) {
        for (let i = 0, len = props.batchGroups.length; i < len; i++) {
          const grp = props.batchGroups[i];
          batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
        }
      }
    }
    if (props.i18nAssets) {
      this.i18n.assets = props.i18nAssets;
    }
    this._loadLibraries(props.libraries, callback);
  }
  _loadLibraries(urls, callback) {
    const len = urls.length;
    let count = len;
    const regex = /^https?:\/\//;
    if (len) {
      const onLoad = (err3, script2) => {
        count--;
        if (err3) {
          callback(err3);
        } else if (count === 0) {
          this.onLibrariesLoaded();
          callback(null);
        }
      };
      for (let i = 0; i < len; ++i) {
        let url = urls[i];
        if (!regex.test(url.toLowerCase()) && this._scriptPrefix) {
          url = path.join(this._scriptPrefix, url);
        }
        this.loader.load(url, "script", onLoad);
      }
    } else {
      this.onLibrariesLoaded();
      callback(null);
    }
  }
  _parseScenes(scenes) {
    if (!scenes) return;
    for (let i = 0; i < scenes.length; i++) {
      this.scenes.add(scenes[i].name, scenes[i].url);
    }
  }
  _parseAssets(assets) {
    const list = [];
    const scriptsIndex = {};
    const bundlesIndex = {};
    for (let i = 0; i < this.scriptsOrder.length; i++) {
      const id13 = this.scriptsOrder[i];
      if (!assets[id13]) {
        continue;
      }
      scriptsIndex[id13] = true;
      list.push(assets[id13]);
    }
    if (this.enableBundles) {
      for (const id13 in assets) {
        if (assets[id13].type === "bundle") {
          bundlesIndex[id13] = true;
          list.push(assets[id13]);
        }
      }
    }
    for (const id13 in assets) {
      if (scriptsIndex[id13] || bundlesIndex[id13]) {
        continue;
      }
      list.push(assets[id13]);
    }
    for (let i = 0; i < list.length; i++) {
      const data2 = list[i];
      const asset = new Asset(data2.name, data2.type, data2.file, data2.data);
      asset.id = parseInt(data2.id, 10);
      asset.preload = data2.preload ? data2.preload : false;
      asset.loaded = data2.type === "script" && data2.data && data2.data.loadingType > 0;
      asset.tags.add(data2.tags);
      if (data2.i18n) {
        for (const locale in data2.i18n) {
          asset.addLocalizedAssetId(locale, data2.i18n[locale]);
        }
      }
      this.assets.add(asset);
    }
  }
  start() {
    this.frame = 0;
    this.fire("start", {
      timestamp: now(),
      target: this
    });
    if (!this._librariesLoaded) {
      this.onLibrariesLoaded();
    }
    this.systems.fire("initialize", this.root);
    this.fire("initialize");
    this.systems.fire("postInitialize", this.root);
    this.systems.fire("postPostInitialize", this.root);
    this.fire("postinitialize");
    this.tick();
  }
  inputUpdate(dt) {
    if (this.controller) {
      this.controller.update(dt);
    }
    if (this.mouse) {
      this.mouse.update();
    }
    if (this.keyboard) {
      this.keyboard.update();
    }
    if (this.gamepads) {
      this.gamepads.update();
    }
  }
  update(dt) {
    this.frame++;
    this.graphicsDevice.updateClientRect();
    this.systems.fire(this._inTools ? "toolsUpdate" : "update", dt);
    this.systems.fire("animationUpdate", dt);
    this.systems.fire("postUpdate", dt);
    this.fire("update", dt);
    this.inputUpdate(dt);
  }
  frameStart() {
    this.graphicsDevice.frameStart();
  }
  frameEnd() {
    this.graphicsDevice.frameEnd();
  }
  render() {
    this.fire("prerender");
    this.root.syncHierarchy();
    if (this._batcher) {
      this._batcher.updateAll();
    }
    this.renderComposition(this.scene.layers);
    this.fire("postrender");
  }
  renderComposition(layerComposition) {
    this.renderer.update(layerComposition);
    this.renderer.buildFrameGraph(this.frameGraph, layerComposition);
    this.frameGraph.render(this.graphicsDevice);
  }
  _fillFrameStatsBasic(now2, dt, ms) {
    const stats = this.stats.frame;
    stats.dt = dt;
    stats.ms = ms;
    if (now2 > stats._timeToCountFrames) {
      stats.fps = stats._fpsAccum;
      stats._fpsAccum = 0;
      stats._timeToCountFrames = now2 + 1e3;
    } else {
      stats._fpsAccum++;
    }
    this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
    this.graphicsDevice._drawCallsPerFrame = 0;
  }
  _fillFrameStats() {
    let stats = this.stats.frame;
    stats.cameras = this.renderer._camerasRendered;
    stats.materials = this.renderer._materialSwitches;
    stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
    stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
    stats.shadowMapTime = this.renderer._shadowMapTime;
    stats.depthMapTime = this.renderer._depthMapTime;
    stats.forwardTime = this.renderer._forwardTime;
    const prims = this.graphicsDevice._primsPerFrame;
    stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
    stats.cullTime = this.renderer._cullTime;
    stats.sortTime = this.renderer._sortTime;
    stats.skinTime = this.renderer._skinTime;
    stats.morphTime = this.renderer._morphTime;
    stats.lightClusters = this.renderer._lightClusters;
    stats.lightClustersTime = this.renderer._lightClustersTime;
    stats.otherPrimitives = 0;
    for (let i = 0; i < prims.length; i++) {
      if (i < PRIMITIVE_TRIANGLES) {
        stats.otherPrimitives += prims[i];
      }
      prims[i] = 0;
    }
    this.renderer._camerasRendered = 0;
    this.renderer._materialSwitches = 0;
    this.renderer._shadowMapUpdates = 0;
    this.graphicsDevice._shaderSwitchesPerFrame = 0;
    this.renderer._cullTime = 0;
    this.renderer._layerCompositionUpdateTime = 0;
    this.renderer._lightClustersTime = 0;
    this.renderer._sortTime = 0;
    this.renderer._skinTime = 0;
    this.renderer._morphTime = 0;
    this.renderer._shadowMapTime = 0;
    this.renderer._depthMapTime = 0;
    this.renderer._forwardTime = 0;
    stats = this.stats.drawCalls;
    stats.forward = this.renderer._forwardDrawCalls;
    stats.culled = this.renderer._numDrawCallsCulled;
    stats.depth = 0;
    stats.shadow = this.renderer._shadowDrawCalls;
    stats.skinned = this.renderer._skinDrawCalls;
    stats.immediate = 0;
    stats.instanced = 0;
    stats.removedByInstancing = 0;
    stats.misc = stats.total - (stats.forward + stats.shadow);
    this.renderer._depthDrawCalls = 0;
    this.renderer._shadowDrawCalls = 0;
    this.renderer._forwardDrawCalls = 0;
    this.renderer._numDrawCallsCulled = 0;
    this.renderer._skinDrawCalls = 0;
    this.renderer._immediateRendered = 0;
    this.renderer._instancedDrawCalls = 0;
    this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
    stats = this.stats.particles;
    stats.updatesPerFrame = stats._updatesPerFrame;
    stats.frameTime = stats._frameTime;
    stats._updatesPerFrame = 0;
    stats._frameTime = 0;
  }
  setCanvasFillMode(mode, width, height) {
    this._fillMode = mode;
    this.resizeCanvas(width, height);
  }
  setCanvasResolution(mode, width, height) {
    this._resolutionMode = mode;
    if (mode === RESOLUTION_AUTO && width === void 0) {
      width = this.graphicsDevice.canvas.clientWidth;
      height = this.graphicsDevice.canvas.clientHeight;
    }
    this.graphicsDevice.resizeCanvas(width, height);
  }
  isHidden() {
    return document[this._hiddenAttr];
  }
  onVisibilityChange() {
    if (this.isHidden()) {
      if (this._soundManager) {
        this._soundManager.suspend();
      }
    } else {
      if (this._soundManager) {
        this._soundManager.resume();
      }
    }
  }
  resizeCanvas(width, height) {
    if (!this._allowResize) return void 0;
    if (this.xr && this.xr.session) {
      return void 0;
    }
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    if (this._fillMode === FILLMODE_KEEP_ASPECT) {
      const r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
      const winR = windowWidth / windowHeight;
      if (r > winR) {
        width = windowWidth;
        height = width / r;
      } else {
        height = windowHeight;
        width = height * r;
      }
    } else if (this._fillMode === FILLMODE_FILL_WINDOW) {
      width = windowWidth;
      height = windowHeight;
    }
    this.graphicsDevice.canvas.style.width = `${width}px`;
    this.graphicsDevice.canvas.style.height = `${height}px`;
    this.updateCanvasSize();
    return {
      width,
      height
    };
  }
  updateCanvasSize() {
    var _this$xr;
    if (!this._allowResize || (_this$xr = this.xr) != null && _this$xr.active) {
      return;
    }
    if (this._resolutionMode === RESOLUTION_AUTO) {
      const canvas = this.graphicsDevice.canvas;
      this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);
    }
  }
  onLibrariesLoaded() {
    this._librariesLoaded = true;
    if (this.systems.rigidbody) {
      this.systems.rigidbody.onLibraryLoaded();
    }
  }
  applySceneSettings(settings) {
    let asset;
    if (this.systems.rigidbody && typeof Ammo !== "undefined") {
      const [x2, y2, z2] = settings.physics.gravity;
      this.systems.rigidbody.gravity.set(x2, y2, z2);
    }
    this.scene.applySettings(settings);
    if (settings.render.hasOwnProperty("skybox")) {
      if (settings.render.skybox) {
        asset = this.assets.get(settings.render.skybox);
        if (asset) {
          this.setSkybox(asset);
        } else {
          this.assets.once(`add:${settings.render.skybox}`, this.setSkybox, this);
        }
      } else {
        this.setSkybox(null);
      }
    }
  }
  setAreaLightLuts(ltcMat1, ltcMat2) {
    if (ltcMat1 && ltcMat2) {
      AreaLightLuts.set(this.graphicsDevice, ltcMat1, ltcMat2);
    }
  }
  setSkybox(asset) {
    if (asset !== this._skyboxAsset) {
      const onSkyboxRemoved = () => {
        this.setSkybox(null);
      };
      const onSkyboxChanged = () => {
        this.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);
      };
      if (this._skyboxAsset) {
        this.assets.off(`load:${this._skyboxAsset.id}`, onSkyboxChanged, this);
        this.assets.off(`remove:${this._skyboxAsset.id}`, onSkyboxRemoved, this);
        this._skyboxAsset.off("change", onSkyboxChanged, this);
      }
      this._skyboxAsset = asset;
      if (this._skyboxAsset) {
        this.assets.on(`load:${this._skyboxAsset.id}`, onSkyboxChanged, this);
        this.assets.once(`remove:${this._skyboxAsset.id}`, onSkyboxRemoved, this);
        this._skyboxAsset.on("change", onSkyboxChanged, this);
        if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {
          this._skyboxAsset.loadFaces = true;
        }
        this.assets.load(this._skyboxAsset);
      }
      onSkyboxChanged();
    }
  }
  _firstBake() {
    var _this$lightmapper;
    (_this$lightmapper = this.lightmapper) == null || _this$lightmapper.bake(null, this.scene.lightmapMode);
  }
  _firstBatch() {
    var _this$batcher;
    (_this$batcher = this.batcher) == null || _this$batcher.generate();
  }
  _processTimestamp(timestamp) {
    return timestamp;
  }
  drawLine(start, end, color, depthTest, layer) {
    this.scene.drawLine(start, end, color, depthTest, layer);
  }
  drawLines(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {
    this.scene.drawLines(positions, colors, depthTest, layer);
  }
  drawLineArrays(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {
    this.scene.drawLineArrays(positions, colors, depthTest, layer);
  }
  drawWireSphere(center2, radius, color = Color.WHITE, segments = 20, depthTest = true, layer = this.scene.defaultDrawLayer) {
    this.scene.immediate.drawWireSphere(center2, radius, color, segments, depthTest, layer);
  }
  drawWireAlignedBox(minPoint, maxPoint, color = Color.WHITE, depthTest = true, layer = this.scene.defaultDrawLayer, mat2) {
    this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer, mat2);
  }
  drawMeshInstance(meshInstance, layer = this.scene.defaultDrawLayer) {
    this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
  }
  drawMesh(mesh, material, matrix2, layer = this.scene.defaultDrawLayer) {
    this.scene.immediate.drawMesh(material, matrix2, mesh, null, layer);
  }
  drawQuad(matrix2, material, layer = this.scene.defaultDrawLayer) {
    this.scene.immediate.drawMesh(material, matrix2, this.scene.immediate.getQuadMesh(), null, layer);
  }
  drawTexture(x2, y2, width, height, texture, material, layer = this.scene.defaultDrawLayer, filterable = true) {
    if (filterable === false && !this.graphicsDevice.isWebGPU) {
      return;
    }
    const matrix2 = new Mat4();
    matrix2.setTRS(new Vec3(x2, y2, 0), Quat.IDENTITY, new Vec3(width, -height, 0));
    if (!material) {
      material = new ShaderMaterial();
      material.cull = CULLFACE_NONE;
      material.setParameter("colorMap", texture);
      material.shaderDesc = filterable ? this.scene.immediate.getTextureShaderDesc(texture.encoding) : this.scene.immediate.getUnfilterableTextureShaderDesc();
      material.update();
    }
    this.drawQuad(matrix2, material, layer);
  }
  drawDepthTexture(x2, y2, width, height, layer = this.scene.defaultDrawLayer) {
    const material = new ShaderMaterial();
    material.cull = CULLFACE_NONE;
    material.shaderDesc = this.scene.immediate.getDepthTextureShaderDesc();
    material.update();
    this.drawTexture(x2, y2, width, height, null, material, layer);
  }
  destroy() {
    var _this$lightmapper2, _this$xr2, _this$xr3, _this$_soundManager;
    if (this._inFrameUpdate) {
      this._destroyRequested = true;
      return;
    }
    const canvasId = this.graphicsDevice.canvas.id;
    this.fire("destroy", this);
    this.off("librariesloaded");
    if (typeof document !== "undefined") {
      document.removeEventListener("visibilitychange", this._visibilityChangeHandler, false);
      document.removeEventListener("mozvisibilitychange", this._visibilityChangeHandler, false);
      document.removeEventListener("msvisibilitychange", this._visibilityChangeHandler, false);
      document.removeEventListener("webkitvisibilitychange", this._visibilityChangeHandler, false);
    }
    this._visibilityChangeHandler = null;
    this.root.destroy();
    this.root = null;
    if (this.mouse) {
      this.mouse.off();
      this.mouse.detach();
      this.mouse = null;
    }
    if (this.keyboard) {
      this.keyboard.off();
      this.keyboard.detach();
      this.keyboard = null;
    }
    if (this.touch) {
      this.touch.off();
      this.touch.detach();
      this.touch = null;
    }
    if (this.elementInput) {
      this.elementInput.detach();
      this.elementInput = null;
    }
    if (this.gamepads) {
      this.gamepads.destroy();
      this.gamepads = null;
    }
    if (this.controller) {
      this.controller = null;
    }
    this.systems.destroy();
    if (this.scene.layers) {
      this.scene.layers.destroy();
    }
    const assets = this.assets.list();
    for (let i = 0; i < assets.length; i++) {
      assets[i].unload();
      assets[i].off();
    }
    this.assets.off();
    this.bundles.destroy();
    this.bundles = null;
    this.i18n.destroy();
    this.i18n = null;
    const scriptHandler = this.loader.getHandler("script");
    scriptHandler == null || scriptHandler.clearCache();
    this.loader.destroy();
    this.loader = null;
    this.scene.destroy();
    this.scene = null;
    this.systems = null;
    this.context = null;
    this.scripts.destroy();
    this.scripts = null;
    this.scenes.destroy();
    this.scenes = null;
    (_this$lightmapper2 = this.lightmapper) == null || _this$lightmapper2.destroy();
    this.lightmapper = null;
    if (this._batcher) {
      this._batcher.destroy();
      this._batcher = null;
    }
    this._entityIndex = {};
    this.defaultLayerDepth.onDisable = null;
    this.defaultLayerDepth.onEnable = null;
    this.defaultLayerDepth = null;
    this.defaultLayerWorld = null;
    (_this$xr2 = this.xr) == null || _this$xr2.end();
    (_this$xr3 = this.xr) == null || _this$xr3.destroy();
    this.renderer.destroy();
    this.renderer = null;
    this.graphicsDevice.destroy();
    this.graphicsDevice = null;
    this.tick = null;
    this.off();
    (_this$_soundManager = this._soundManager) == null || _this$_soundManager.destroy();
    this._soundManager = null;
    script.app = null;
    _AppBase._applications[canvasId] = null;
    if (getApplication() === this) {
      setApplication(null);
    }
    _AppBase.cancelTick(this);
  }
  static cancelTick(app2) {
    if (app2.frameRequestId) {
      window.cancelAnimationFrame(app2.frameRequestId);
      app2.frameRequestId = void 0;
    }
  }
  getEntityFromIndex(guid2) {
    return this._entityIndex[guid2];
  }
  _registerSceneImmediate(scene) {
    this.on("postrender", scene.immediate.onPostRender, scene.immediate);
  }
};
AppBase._applications = {};
var _frameEndData = {};
var makeTick = function makeTick2(_app) {
  const application = _app;
  return function(timestamp, frame) {
    var _application$xr2;
    if (!application.graphicsDevice) {
      return;
    }
    if (application.frameRequestId) {
      var _application$xr;
      (_application$xr = application.xr) == null || (_application$xr = _application$xr.session) == null || _application$xr.cancelAnimationFrame(application.frameRequestId);
      cancelAnimationFrame(application.frameRequestId);
      application.frameRequestId = null;
    }
    application._inFrameUpdate = true;
    setApplication(application);
    app = application;
    const currentTime = application._processTimestamp(timestamp) || now();
    const ms = currentTime - (application._time || currentTime);
    let dt = ms / 1e3;
    dt = math.clamp(dt, 0, application.maxDeltaTime);
    dt *= application.timeScale;
    application._time = currentTime;
    if ((_application$xr2 = application.xr) != null && _application$xr2.session) {
      application.frameRequestId = application.xr.session.requestAnimationFrame(application.tick);
    } else {
      application.frameRequestId = platform.browser || platform.worker ? requestAnimationFrame(application.tick) : null;
    }
    if (application.graphicsDevice.contextLost) {
      return;
    }
    application._fillFrameStatsBasic(currentTime, dt, ms);
    application.fire("frameupdate", ms);
    let shouldRenderFrame = true;
    if (frame) {
      var _application$xr3;
      shouldRenderFrame = (_application$xr3 = application.xr) == null ? void 0 : _application$xr3.update(frame);
      application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
    } else {
      application.graphicsDevice.defaultFramebuffer = null;
    }
    if (shouldRenderFrame) {
      application.update(dt);
      application.fire("framerender");
      if (application.autoRender || application.renderNextFrame) {
        application.updateCanvasSize();
        application.frameStart();
        application.render();
        application.frameEnd();
        application.renderNextFrame = false;
      }
      _frameEndData.timestamp = now();
      _frameEndData.target = application;
      application.fire("frameend", _frameEndData);
    }
    application._inFrameUpdate = false;
    if (application._destroyRequested) {
      application.destroy();
    }
  };
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/app-options.js
var AppOptions = class {
  constructor() {
    this.elementInput = void 0;
    this.keyboard = void 0;
    this.mouse = void 0;
    this.touch = void 0;
    this.gamepads = void 0;
    this.scriptPrefix = void 0;
    this.assetPrefix = void 0;
    this.scriptsOrder = void 0;
    this.soundManager = void 0;
    this.graphicsDevice = void 0;
    this.lightmapper = void 0;
    this.batchManager = void 0;
    this.xr = void 0;
    this.componentSystems = [];
    this.resourceHandlers = [];
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/bake-light.js
var tempSphere2 = new BoundingSphere();
var BakeLight = class {
  constructor(scene, light, lightingParams) {
    this.scene = scene;
    this.light = light;
    this.store();
    light.numCascades = 1;
    if (this.scene.clusteredLightingEnabled) {
      light.castShadows = light.bakeShadows && lightingParams.shadowsEnabled;
    }
    if (light.type !== LIGHTTYPE_DIRECTIONAL) {
      light._node.getWorldTransform();
      light.getBoundingSphere(tempSphere2);
      this.lightBounds = new BoundingBox();
      this.lightBounds.center.copy(tempSphere2.center);
      this.lightBounds.halfExtents.set(tempSphere2.radius, tempSphere2.radius, tempSphere2.radius);
    }
  }
  store() {
    this.mask = this.light.mask;
    this.shadowUpdateMode = this.light.shadowUpdateMode;
    this.enabled = this.light.enabled;
    this.intensity = this.light.intensity;
    this.rotation = this.light._node.getLocalRotation().clone();
    this.numCascades = this.light.numCascades;
    this.castShadows = this.light.castShadows;
  }
  restore() {
    const light = this.light;
    light.mask = this.mask;
    light.shadowUpdateMode = this.shadowUpdateMode;
    light.enabled = this.enabled;
    light.intensity = this.intensity;
    light._node.setLocalRotation(this.rotation);
    light.numCascades = this.numCascades;
    light.castShadows = this.castShadows;
  }
  startBake() {
    this.light.enabled = true;
    this.light._destroyShadowMap();
    this.light.beginFrame();
  }
  endBake(shadowMapCache) {
    const light = this.light;
    light.enabled = false;
    if (light.shadowMap) {
      if (light.shadowMap.cached) {
        shadowMapCache.add(light, light.shadowMap);
      }
      light.shadowMap = null;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/bake-light-simple.js
var _tempPoint = new Vec2();
var BakeLightSimple = class extends BakeLight {
  constructor(lightmapper, light) {
    super(lightmapper.scene, light, lightmapper.lightingParams);
  }
  get numVirtualLights() {
    if (this.light.type === LIGHTTYPE_DIRECTIONAL) {
      return this.light.bakeNumSamples;
    }
    return 1;
  }
  prepareVirtualLight(index, numVirtualLights) {
    const light = this.light;
    light._node.setLocalRotation(this.rotation);
    if (index > 0) {
      const directionalSpreadAngle = light.bakeArea;
      random.circlePointDeterministic(_tempPoint, index, numVirtualLights);
      _tempPoint.mulScalar(directionalSpreadAngle * 0.5);
      light._node.rotateLocal(_tempPoint.x, 0, _tempPoint.y);
    }
    light._node.getWorldTransform();
    const gamma = 2.2;
    const linearIntensity = Math.pow(this.intensity, gamma);
    light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/bake-light-ambient.js
var _tempPoint2 = new Vec3();
var BakeLightAmbient = class extends BakeLight {
  constructor(lightmapper) {
    const scene = lightmapper.scene;
    const lightEntity = new Entity("AmbientLight");
    lightEntity.addComponent("light", {
      type: "directional",
      affectDynamic: true,
      affectLightmapped: false,
      bake: true,
      bakeNumSamples: scene.ambientBakeNumSamples,
      castShadows: true,
      normalOffsetBias: 0.05,
      shadowBias: 0.2,
      shadowDistance: 1,
      shadowResolution: 2048,
      shadowType: SHADOW_PCF3,
      color: Color.WHITE,
      intensity: 1,
      bakeDir: false
    });
    super(scene, lightEntity.light.light, lightmapper.lightingParams);
  }
  get numVirtualLights() {
    return this.light.bakeNumSamples;
  }
  prepareVirtualLight(index, numVirtualLights) {
    random.spherePointDeterministic(_tempPoint2, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);
    this.light._node.lookAt(_tempPoint2.mulScalar(-1));
    this.light._node.rotateLocal(90, 0, 0);
    const gamma = 2.2;
    const fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;
    const linearIntensity = Math.pow(fullIntensity, gamma);
    this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/bake-mesh-node.js
var BakeMeshNode = class {
  constructor(node, meshInstances = null) {
    this.node = node;
    this.component = node.render || node.model;
    meshInstances = meshInstances || this.component.meshInstances;
    this.store();
    this.meshInstances = meshInstances;
    this.bounds = null;
    this.renderTargets = [];
  }
  store() {
    this.castShadows = this.component.castShadows;
  }
  restore() {
    this.component.castShadows = this.castShadows;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/lightmap-filters.js
var DENOISE_FILTER_SIZE = 15;
var LightmapFilters = class {
  constructor(device) {
    this.device = device;
    this.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.dilatePS, "lmDilate");
    this.constantTexSource = device.scope.resolve("source");
    this.constantPixelOffset = device.scope.resolve("pixelOffset");
    this.pixelOffset = new Float32Array(2);
    this.shaderDenoise = null;
    this.sigmas = null;
    this.constantSigmas = null;
    this.kernel = null;
  }
  setSourceTexture(texture) {
    this.constantTexSource.setValue(texture);
  }
  prepare(textureWidth, textureHeight) {
    this.pixelOffset[0] = 1 / textureWidth;
    this.pixelOffset[1] = 1 / textureHeight;
    this.constantPixelOffset.setValue(this.pixelOffset);
  }
  prepareDenoise(filterRange, filterSmoothness) {
    if (!this.shaderDenoise) {
      this.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.bilateralDeNoisePS, "lmBilateralDeNoise");
      this.sigmas = new Float32Array(2);
      this.constantSigmas = this.device.scope.resolve("sigmas");
      this.constantKernel = this.device.scope.resolve("kernel[0]");
      this.bZnorm = this.device.scope.resolve("bZnorm");
    }
    this.sigmas[0] = filterRange;
    this.sigmas[1] = filterSmoothness;
    this.constantSigmas.setValue(this.sigmas);
    this.evaluateDenoiseUniforms(filterRange, filterSmoothness);
  }
  evaluateDenoiseUniforms(filterRange, filterSmoothness) {
    function normpdf(x2, sigma) {
      return 0.39894 * Math.exp(-0.5 * x2 * x2 / (sigma * sigma)) / sigma;
    }
    this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);
    const kernel = this.kernel;
    const kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);
    for (let j = 0; j <= kSize; ++j) {
      const value = normpdf(j, filterRange);
      kernel[kSize + j] = value;
      kernel[kSize - j] = value;
    }
    this.constantKernel.setValue(this.kernel);
    const bZnorm = 1 / normpdf(0, filterSmoothness);
    this.bZnorm.setValue(bZnorm);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/render-pass-lightmapper.js
var RenderPassLightmapper = class extends RenderPass {
  constructor(device, renderer, camera, worldClusters, receivers, lightArray) {
    super(device);
    this.viewBindGroups = [];
    this.renderer = renderer;
    this.camera = camera;
    this.worldClusters = worldClusters;
    this.receivers = receivers;
    this.lightArray = lightArray;
  }
  destroy() {
    this.viewBindGroups.forEach((bg) => {
      bg.defaultUniformBuffer.destroy();
      bg.destroy();
    });
    this.viewBindGroups.length = 0;
  }
  execute() {
    this.device;
    const {
      renderer,
      camera,
      receivers,
      renderTarget,
      worldClusters,
      lightArray
    } = this;
    renderer.renderForwardLayer(camera, renderTarget, null, void 0, SHADER_FORWARD, this.viewBindGroups, {
      meshInstances: receivers,
      splitLights: lightArray,
      lightClusters: worldClusters
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/lightmapper.js
var MAX_LIGHTMAP_SIZE = 2048;
var PASS_COLOR = 0;
var PASS_DIR = 1;
var tempVec = new Vec3();
var Lightmapper = class {
  constructor(device, root, scene, renderer, assets) {
    this.device = device;
    this.root = root;
    this.scene = scene;
    this.renderer = renderer;
    this.assets = assets;
    this.shadowMapCache = renderer.shadowMapCache;
    this._tempSet = /* @__PURE__ */ new Set();
    this._initCalled = false;
    this.passMaterials = [];
    this.ambientAOMaterial = null;
    this.fog = "";
    this.ambientLight = new Color();
    this.renderTargets = /* @__PURE__ */ new Map();
    this.stats = {
      renderPasses: 0,
      lightmapCount: 0,
      totalRenderTime: 0,
      forwardTime: 0,
      fboTime: 0,
      shadowMapTime: 0,
      compileTime: 0,
      shadersLinked: 0
    };
  }
  destroy() {
    var _this$camera;
    LightmapCache.decRef(this.blackTex);
    this.blackTex = null;
    LightmapCache.destroy();
    this.device = null;
    this.root = null;
    this.scene = null;
    this.renderer = null;
    this.assets = null;
    (_this$camera = this.camera) == null || _this$camera.destroy();
    this.camera = null;
  }
  initBake(device) {
    if (!this._initCalled) {
      this._initCalled = true;
      this.lightmapFilters = new LightmapFilters(device);
      this.constantBakeDir = device.scope.resolve("bakeDir");
      this.materials = [];
      this.blackTex = new Texture(this.device, {
        width: 4,
        height: 4,
        format: PIXELFORMAT_RGBA8,
        type: TEXTURETYPE_RGBM,
        name: "lightmapBlack"
      });
      LightmapCache.incRef(this.blackTex);
      const camera = new Camera();
      camera.clearColor.set(0, 0, 0, 0);
      camera.clearColorBuffer = true;
      camera.clearDepthBuffer = false;
      camera.clearStencilBuffer = false;
      camera.frustumCulling = false;
      camera.projection = PROJECTION_ORTHOGRAPHIC;
      camera.aspectRatio = 1;
      camera.node = new GraphNode();
      this.camera = camera;
      const rp = new RenderingParams();
      rp.gammaCorrection = GAMMA_NONE;
      rp.toneMapping = TONEMAP_LINEAR;
      this.camera.renderingParams = rp;
    }
    if (this.scene.clusteredLightingEnabled) {
      const lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, () => {
      });
      this.lightingParams = lightingParams;
      const srcParams = this.scene.lighting;
      lightingParams.shadowsEnabled = srcParams.shadowsEnabled;
      lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;
      lightingParams.cookiesEnabled = srcParams.cookiesEnabled;
      lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;
      lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;
      lightingParams.cells = new Vec3(3, 3, 3);
      lightingParams.maxLightsPerCell = 4;
      this.worldClusters = new WorldClusters(device);
      this.worldClusters.name = "ClusterLightmapper";
    }
  }
  finishBake(bakeNodes) {
    this.materials = [];
    function destroyRT(rt) {
      LightmapCache.decRef(rt.colorBuffer);
      rt.destroy();
    }
    this.renderTargets.forEach((rt) => {
      destroyRT(rt);
    });
    this.renderTargets.clear();
    bakeNodes.forEach((node) => {
      node.renderTargets.forEach((rt) => {
        destroyRT(rt);
      });
      node.renderTargets.length = 0;
    });
    this.ambientAOMaterial = null;
    if (this.worldClusters) {
      this.worldClusters.destroy();
      this.worldClusters = null;
    }
  }
  createMaterialForPass(device, scene, pass, addAmbient) {
    const material = new StandardMaterial();
    material.name = `lmMaterial-pass:${pass}-ambient:${addAmbient}`;
    material.chunks.APIVersion = CHUNKAPI_1_65;
    const transformDefines = "#define UV1LAYOUT\n";
    material.chunks.transformVS = transformDefines + shaderChunks.transformVS;
    if (pass === PASS_COLOR) {
      let bakeLmEndChunk = shaderChunksLightmapper.bakeLmEndPS;
      if (addAmbient) {
        bakeLmEndChunk = `
										dDiffuseLight = ((dDiffuseLight - 0.5) * max(${scene.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;
										dDiffuseLight += vec3(${scene.ambientBakeOcclusionBrightness.toFixed(1)});
										dDiffuseLight = saturate(dDiffuseLight);
										dDiffuseLight *= dAmbientLight;
								${bakeLmEndChunk}`;
      } else {
        material.ambient = new Color(0, 0, 0);
      }
      material.chunks.basePS = shaderChunks.basePS + (scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? "\n#define LIGHTMAP_RGBM\n" : "");
      material.chunks.endPS = bakeLmEndChunk;
      material.lightMap = this.blackTex;
    } else {
      material.chunks.basePS = `${shaderChunks.basePS}
uniform sampler2D texture_dirLightMap;
uniform float bakeDir;
`;
      material.chunks.endPS = shaderChunksLightmapper.bakeDirLmEndPS;
    }
    material.chunks.outputAlphaPS = "\n";
    material.chunks.outputAlphaOpaquePS = "\n";
    material.chunks.outputAlphaPremulPS = "\n";
    material.cull = CULLFACE_NONE;
    material.forceUv1 = true;
    material.update();
    return material;
  }
  createMaterials(device, scene, passCount) {
    for (let pass = 0; pass < passCount; pass++) {
      if (!this.passMaterials[pass]) {
        this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);
      }
    }
    if (!this.ambientAOMaterial) {
      this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);
      this.ambientAOMaterial.onUpdateShader = function(options2) {
        options2.litOptions.lightMapWithoutAmbient = true;
        options2.litOptions.separateAmbient = true;
        return options2;
      };
    }
  }
  createTexture(size, name) {
    return new Texture(this.device, {
      width: size,
      height: size,
      format: this.scene.lightmapPixelFormat,
      mipmaps: false,
      type: this.scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name
    });
  }
  collectModels(node, bakeNodes, allNodes) {
    var _node$model, _node$model2, _node$render;
    if (!node.enabled) return;
    let meshInstances;
    if ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {
      if (allNodes) allNodes.push(new BakeMeshNode(node));
      if (node.model.lightmapped) {
        if (bakeNodes) {
          meshInstances = node.model.model.meshInstances;
        }
      }
    }
    if ((_node$render = node.render) != null && _node$render.enabled) {
      if (allNodes) allNodes.push(new BakeMeshNode(node));
      if (node.render.lightmapped) {
        if (bakeNodes) {
          meshInstances = node.render.meshInstances;
        }
      }
    }
    if (meshInstances) {
      let hasUv1 = true;
      for (let i = 0; i < meshInstances.length; i++) {
        if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
          hasUv1 = false;
          break;
        }
      }
      if (hasUv1) {
        const notInstancedMeshInstances = [];
        for (let i = 0; i < meshInstances.length; i++) {
          const mesh = meshInstances[i].mesh;
          if (this._tempSet.has(mesh)) {
            bakeNodes.push(new BakeMeshNode(node, [meshInstances[i]]));
          } else {
            notInstancedMeshInstances.push(meshInstances[i]);
          }
          this._tempSet.add(mesh);
        }
        this._tempSet.clear();
        if (notInstancedMeshInstances.length > 0) {
          bakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));
        }
      }
    }
    for (let i = 0; i < node._children.length; i++) {
      this.collectModels(node._children[i], bakeNodes, allNodes);
    }
  }
  prepareShadowCasters(nodes) {
    const casters = [];
    for (let n = 0; n < nodes.length; n++) {
      const component = nodes[n].component;
      component.castShadows = component.castShadowsLightmap;
      if (component.castShadowsLightmap) {
        const meshes = nodes[n].meshInstances;
        for (let i = 0; i < meshes.length; i++) {
          meshes[i].visibleThisFrame = true;
          casters.push(meshes[i]);
        }
      }
    }
    return casters;
  }
  updateTransforms(nodes) {
    for (let i = 0; i < nodes.length; i++) {
      const meshInstances = nodes[i].meshInstances;
      for (let j = 0; j < meshInstances.length; j++) {
        meshInstances[j].node.getWorldTransform();
      }
    }
  }
  calculateLightmapSize(node) {
    let data2;
    const sizeMult = this.scene.lightmapSizeMultiplier || 16;
    const scale2 = tempVec;
    let srcArea, lightmapSizeMultiplier;
    if (node.model) {
      lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;
      if (node.model.asset) {
        data2 = this.assets.get(node.model.asset).data;
        if (data2.area) {
          srcArea = data2.area;
        }
      } else if (node.model._area) {
        data2 = node.model;
        if (data2._area) {
          srcArea = data2._area;
        }
      }
    } else if (node.render) {
      lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;
      if (node.render.type !== "asset") {
        if (node.render._area) {
          data2 = node.render;
          if (data2._area) {
            srcArea = data2._area;
          }
        }
      }
    }
    const area = {
      x: 1,
      y: 1,
      z: 1,
      uv: 1
    };
    if (srcArea) {
      area.x = srcArea.x;
      area.y = srcArea.y;
      area.z = srcArea.z;
      area.uv = srcArea.uv;
    }
    const areaMult = lightmapSizeMultiplier || 1;
    area.x *= areaMult;
    area.y *= areaMult;
    area.z *= areaMult;
    const component = node.render || node.model;
    const bounds = this.computeNodeBounds(component.meshInstances);
    scale2.copy(bounds.halfExtents);
    let totalArea = area.x * scale2.y * scale2.z + area.y * scale2.x * scale2.z + area.z * scale2.x * scale2.y;
    totalArea /= area.uv;
    totalArea = Math.sqrt(totalArea);
    const lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);
    return lightmapSize;
  }
  setLightmapping(nodes, value, passCount, shaderDefs) {
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const meshInstances = node.meshInstances;
      for (let j = 0; j < meshInstances.length; j++) {
        const meshInstance = meshInstances[j];
        meshInstance.setLightmapped(value);
        if (value) {
          if (shaderDefs) {
            meshInstance._shaderDefs |= shaderDefs;
          }
          meshInstance.mask = MASK_AFFECT_LIGHTMAPPED;
          for (let pass = 0; pass < passCount; pass++) {
            const tex = node.renderTargets[pass].colorBuffer;
            tex.minFilter = FILTER_LINEAR;
            tex.magFilter = FILTER_LINEAR;
            meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);
          }
        }
      }
    }
  }
  bake(nodes, mode = BAKE_COLORDIR) {
    const device = this.device;
    const startTime = now();
    this.scene._updateSkyMesh();
    this.stats.renderPasses = 0;
    this.stats.shadowMapTime = 0;
    this.stats.forwardTime = 0;
    const startShaders = device._shaderStats.linked;
    const startFboTime = device._renderTargetCreationTime;
    const startCompileTime = device._shaderStats.compileTime;
    const bakeNodes = [];
    const allNodes = [];
    if (nodes) {
      for (let i = 0; i < nodes.length; i++) {
        this.collectModels(nodes[i], bakeNodes, null);
      }
      this.collectModels(this.root, null, allNodes);
    } else {
      this.collectModels(this.root, bakeNodes, allNodes);
    }
    if (bakeNodes.length > 0) {
      this.renderer.shadowRenderer.frameUpdate();
      const passCount = mode === BAKE_COLORDIR ? 2 : 1;
      this.setLightmapping(bakeNodes, false, passCount);
      this.initBake(device);
      this.bakeInternal(passCount, bakeNodes, allNodes);
      let shaderDefs = SHADERDEF_LM;
      if (mode === BAKE_COLORDIR) {
        shaderDefs |= SHADERDEF_DIRLM;
      }
      if (this.scene.ambientBake) {
        shaderDefs |= SHADERDEF_LMAMBIENT;
      }
      this.setLightmapping(bakeNodes, true, passCount, shaderDefs);
      this.finishBake(bakeNodes);
    }
    const nowTime = now();
    this.stats.totalRenderTime = nowTime - startTime;
    this.stats.shadersLinked = device._shaderStats.linked - startShaders;
    this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;
    this.stats.fboTime = device._renderTargetCreationTime - startFboTime;
    this.stats.lightmapCount = bakeNodes.length;
  }
  allocateTextures(bakeNodes, passCount) {
    for (let i = 0; i < bakeNodes.length; i++) {
      const bakeNode = bakeNodes[i];
      const size = this.calculateLightmapSize(bakeNode.node);
      for (let pass = 0; pass < passCount; pass++) {
        const tex = this.createTexture(size, `lightmapper_lightmap_${i}`);
        LightmapCache.incRef(tex);
        bakeNode.renderTargets[pass] = new RenderTarget({
          colorBuffer: tex,
          depth: false
        });
      }
      if (!this.renderTargets.has(size)) {
        const tex = this.createTexture(size, `lightmapper_temp_lightmap_${size}`);
        LightmapCache.incRef(tex);
        this.renderTargets.set(size, new RenderTarget({
          colorBuffer: tex,
          depth: false
        }));
      }
    }
  }
  prepareLightsToBake(allLights, bakeLights) {
    if (this.scene.ambientBake) {
      const ambientLight = new BakeLightAmbient(this);
      bakeLights.push(ambientLight);
    }
    const sceneLights = this.renderer.lights;
    for (let i = 0; i < sceneLights.length; i++) {
      const light = sceneLights[i];
      const bakeLight = new BakeLightSimple(this, light);
      allLights.push(bakeLight);
      if (light.enabled && (light.mask & MASK_BAKE) !== 0) {
        light.mask = MASK_BAKE | MASK_AFFECT_LIGHTMAPPED | MASK_AFFECT_DYNAMIC;
        light.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
        bakeLights.push(bakeLight);
      }
    }
    bakeLights.sort();
  }
  restoreLights(allLights) {
    for (let i = 0; i < allLights.length; i++) {
      allLights[i].restore();
    }
  }
  setupScene() {
    this.fog = this.scene.fog;
    this.ambientLight.copy(this.scene.ambientLight);
    this.scene.fog = FOG_NONE;
    if (!this.scene.ambientBake) {
      this.scene.ambientLight.set(0, 0, 0);
    }
    this.renderer.setSceneConstants();
  }
  restoreScene() {
    this.scene.fog = this.fog;
    this.scene.ambientLight.copy(this.ambientLight);
  }
  computeNodeBounds(meshInstances) {
    const bounds = new BoundingBox();
    if (meshInstances.length > 0) {
      bounds.copy(meshInstances[0].aabb);
      for (let m = 1; m < meshInstances.length; m++) {
        bounds.add(meshInstances[m].aabb);
      }
    }
    return bounds;
  }
  computeNodesBounds(nodes) {
    for (let i = 0; i < nodes.length; i++) {
      const meshInstances = nodes[i].meshInstances;
      nodes[i].bounds = this.computeNodeBounds(meshInstances);
    }
  }
  computeBounds(meshInstances) {
    const bounds = new BoundingBox();
    for (let i = 0; i < meshInstances.length; i++) {
      bounds.copy(meshInstances[0].aabb);
      for (let m = 1; m < meshInstances.length; m++) {
        bounds.add(meshInstances[m].aabb);
      }
    }
    return bounds;
  }
  backupMaterials(meshInstances) {
    for (let i = 0; i < meshInstances.length; i++) {
      this.materials[i] = meshInstances[i].material;
    }
  }
  restoreMaterials(meshInstances) {
    for (let i = 0; i < meshInstances.length; i++) {
      meshInstances[i].material = this.materials[i];
    }
  }
  lightCameraPrepare(device, bakeLight) {
    const light = bakeLight.light;
    let shadowCam;
    if (light.type === LIGHTTYPE_SPOT) {
      const lightRenderData = light.getRenderData(null, 0);
      shadowCam = lightRenderData.shadowCamera;
      shadowCam._node.setPosition(light._node.getPosition());
      shadowCam._node.setRotation(light._node.getRotation());
      shadowCam._node.rotateLocal(-90, 0, 0);
      shadowCam.projection = PROJECTION_PERSPECTIVE;
      shadowCam.nearClip = light.attenuationEnd / 1e3;
      shadowCam.farClip = light.attenuationEnd;
      shadowCam.aspectRatio = 1;
      shadowCam.fov = light._outerConeAngle * 2;
      this.renderer.updateCameraFrustum(shadowCam);
    }
    return shadowCam;
  }
  lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {
    const light = bakeLight.light;
    let lightAffectsNode = true;
    if (light.type === LIGHTTYPE_DIRECTIONAL) {
      tempVec.copy(casterBounds.center);
      tempVec.y += casterBounds.halfExtents.y;
      this.camera.node.setPosition(tempVec);
      this.camera.node.setEulerAngles(-90, 0, 0);
      this.camera.nearClip = 0;
      this.camera.farClip = casterBounds.halfExtents.y * 2;
      const frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);
      this.camera.orthoHeight = frustumSize;
    } else {
      if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {
        lightAffectsNode = false;
      }
    }
    if (light.type === LIGHTTYPE_SPOT) {
      let nodeVisible = false;
      const meshInstances = bakeNode.meshInstances;
      for (let i = 0; i < meshInstances.length; i++) {
        if (meshInstances[i]._isVisible(shadowCam)) {
          nodeVisible = true;
          break;
        }
      }
      if (!nodeVisible) {
        lightAffectsNode = false;
      }
    }
    return lightAffectsNode;
  }
  setupLightArray(lightArray, light) {
    lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
    lightArray[LIGHTTYPE_OMNI].length = 0;
    lightArray[LIGHTTYPE_SPOT].length = 0;
    lightArray[light.type][0] = light;
    light.visibleThisFrame = true;
  }
  renderShadowMap(comp, shadowMapRendered, casters, bakeLight) {
    const light = bakeLight.light;
    const isClustered = this.scene.clusteredLightingEnabled;
    const castShadow = light.castShadows && (!isClustered || this.scene.lighting.shadowsEnabled);
    if (!shadowMapRendered && castShadow) {
      if (!light.shadowMap && !isClustered) {
        light.shadowMap = this.shadowMapCache.get(this.device, light);
      }
      if (light.type === LIGHTTYPE_DIRECTIONAL) {
        this.renderer._shadowRendererDirectional.cull(light, comp, this.camera, casters);
        const shadowPass = this.renderer._shadowRendererDirectional.getLightRenderPass(light, this.camera);
        shadowPass == null || shadowPass.render();
      } else {
        if (this.device.isWebGPU) {
          return true;
        }
        this.renderer._shadowRendererLocal.cull(light, comp, casters);
        const insideRenderPass = false;
        this.renderer.shadowRenderer.render(light, this.camera, insideRenderPass);
      }
    }
    return true;
  }
  postprocessTextures(device, bakeNodes, passCount) {
    const numDilates2x = 1;
    const dilateShader = this.lightmapFilters.shaderDilate;
    const filterLightmap = this.scene.lightmapFilterEnabled;
    if (filterLightmap) {
      this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);
    }
    device.setBlendState(BlendState.NOBLEND);
    device.setDepthState(DepthState.NODEPTH);
    device.setStencilState(null, null);
    for (let node = 0; node < bakeNodes.length; node++) {
      const bakeNode = bakeNodes[node];
      for (let pass = 0; pass < passCount; pass++) {
        const nodeRT = bakeNode.renderTargets[pass];
        const lightmap = nodeRT.colorBuffer;
        const tempRT = this.renderTargets.get(lightmap.width);
        const tempTex = tempRT.colorBuffer;
        this.lightmapFilters.prepare(lightmap.width, lightmap.height);
        for (let i = 0; i < numDilates2x; i++) {
          this.lightmapFilters.setSourceTexture(lightmap);
          const bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;
          drawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);
          this.lightmapFilters.setSourceTexture(tempTex);
          drawQuadWithShader(device, nodeRT, dilateShader);
        }
      }
    }
  }
  bakeInternal(passCount, bakeNodes, allNodes) {
    const scene = this.scene;
    const comp = scene.layers;
    const device = this.device;
    const clusteredLightingEnabled = scene.clusteredLightingEnabled;
    this.createMaterials(device, scene, passCount);
    this.setupScene();
    comp._update();
    this.computeNodesBounds(bakeNodes);
    this.allocateTextures(bakeNodes, passCount);
    this.renderer.collectLights(comp);
    const allLights = [], bakeLights = [];
    this.prepareLightsToBake(allLights, bakeLights);
    this.updateTransforms(allNodes);
    const casters = this.prepareShadowCasters(allNodes);
    this.renderer.updateCpuSkinMatrices(casters);
    this.renderer.gpuUpdate(casters);
    const casterBounds = this.computeBounds(casters);
    let i, j, rcv, m;
    for (i = 0; i < bakeNodes.length; i++) {
      const bakeNode = bakeNodes[i];
      rcv = bakeNode.meshInstances;
      for (j = 0; j < rcv.length; j++) {
        m = rcv[j];
        m.setLightmapped(false);
        m.mask = MASK_BAKE;
        m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex);
        m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);
      }
    }
    for (j = 0; j < bakeLights.length; j++) {
      bakeLights[j].light.enabled = false;
    }
    const lightArray = [[], [], []];
    let pass, node;
    let shadersUpdatedOn1stPass = false;
    for (i = 0; i < bakeLights.length; i++) {
      const bakeLight = bakeLights[i];
      const isAmbientLight = bakeLight instanceof BakeLightAmbient;
      const isDirectional = bakeLight.light.type === LIGHTTYPE_DIRECTIONAL;
      let numVirtualLights = bakeLight.numVirtualLights;
      if (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {
        numVirtualLights = 1;
      }
      for (let virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {
        if (numVirtualLights > 1) {
          bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);
        }
        bakeLight.startBake();
        let shadowMapRendered = false;
        const shadowCam = this.lightCameraPrepare(device, bakeLight);
        for (node = 0; node < bakeNodes.length; node++) {
          const bakeNode = bakeNodes[node];
          rcv = bakeNode.meshInstances;
          const lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds);
          if (!lightAffectsNode) {
            continue;
          }
          this.setupLightArray(lightArray, bakeLight.light);
          const clusterLights = isDirectional ? [] : [bakeLight.light];
          if (clusteredLightingEnabled) {
            this.renderer.lightTextureAtlas.update(clusterLights, this.lightingParams);
          }
          shadowMapRendered = this.renderShadowMap(comp, shadowMapRendered, casters, bakeLight);
          if (clusteredLightingEnabled) {
            this.worldClusters.update(clusterLights, this.lightingParams);
          }
          this.backupMaterials(rcv);
          for (pass = 0; pass < passCount; pass++) {
            if (pass > 0 && virtualLightIndex > 0) {
              break;
            }
            if (isAmbientLight && pass > 0) {
              break;
            }
            const nodeRT = bakeNode.renderTargets[pass];
            const lightmapSize = bakeNode.renderTargets[pass].colorBuffer.width;
            const tempRT = this.renderTargets.get(lightmapSize);
            const tempTex = tempRT.colorBuffer;
            if (pass === 0) {
              shadersUpdatedOn1stPass = scene.updateShaders;
            } else if (shadersUpdatedOn1stPass) {
              scene.updateShaders = true;
            }
            let passMaterial = this.passMaterials[pass];
            if (isAmbientLight) {
              const lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;
              if (lastVirtualLightForPass && pass === 0) {
                passMaterial = this.ambientAOMaterial;
              }
            }
            for (j = 0; j < rcv.length; j++) {
              rcv[j].material = passMaterial;
            }
            this.renderer.updateShaders(rcv);
            if (pass === PASS_DIR) {
              this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);
            }
            if (device.isWebGPU) {
              const renderPass = new RenderPassLightmapper(device, this.renderer, this.camera, clusteredLightingEnabled ? this.worldClusters : null, rcv, lightArray);
              renderPass.init(tempRT);
              renderPass.render();
              renderPass.destroy();
            } else {
              this.renderer.setCamera(this.camera, tempRT, true);
              if (clusteredLightingEnabled) {
                this.worldClusters.activate();
              }
              this.renderer._forwardTime = 0;
              this.renderer._shadowMapTime = 0;
              this.renderer.renderForward(this.camera, tempRT, rcv, lightArray, SHADER_FORWARD);
              device.updateEnd();
            }
            bakeNode.renderTargets[pass] = tempRT;
            this.renderTargets.set(lightmapSize, nodeRT);
            for (j = 0; j < rcv.length; j++) {
              m = rcv[j];
              m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);
              m._shaderDefs |= SHADERDEF_LM;
            }
          }
          this.restoreMaterials(rcv);
        }
        bakeLight.endBake(this.shadowMapCache);
      }
    }
    this.postprocessTextures(device, bakeNodes, passCount);
    for (node = 0; node < allNodes.length; node++) {
      allNodes[node].restore();
    }
    this.restoreLights(allLights);
    this.restoreScene();
    if (!clusteredLightingEnabled) {
      this.shadowMapCache.clear();
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/component.js
var Component = class _Component extends EventHandler {
  constructor(system, entity) {
    super();
    this.system = void 0;
    this.entity = void 0;
    this.system = system;
    this.entity = entity;
    if (this.system.schema && !this._accessorsBuilt) {
      this.buildAccessors(this.system.schema);
    }
    this.on("set", function(name, oldValue, newValue) {
      this.fire(`set_${name}`, name, oldValue, newValue);
    });
    this.on("set_enabled", this.onSetEnabled, this);
  }
  static _buildAccessors(obj, schema) {
    schema.forEach((descriptor) => {
      const name = typeof descriptor === "object" ? descriptor.name : descriptor;
      Object.defineProperty(obj, name, {
        get: function() {
          return this.data[name];
        },
        set: function(value) {
          const data2 = this.data;
          const oldValue = data2[name];
          data2[name] = value;
          this.fire("set", name, oldValue, value);
        },
        configurable: true
      });
    });
    obj._accessorsBuilt = true;
  }
  buildAccessors(schema) {
    _Component._buildAccessors(this, schema);
  }
  onSetEnabled(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (this.entity.enabled) {
        if (newValue) {
          this.onEnable();
        } else {
          this.onDisable();
        }
      }
    }
  }
  onEnable() {
  }
  onDisable() {
  }
  onPostStateChange() {
  }
  get data() {
    const record = this.system.store[this.entity.getGuid()];
    return record ? record.data : null;
  }
  set enabled(arg) {
  }
  get enabled() {
    return true;
  }
};
Component.order = 0;

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/system.js
var ComponentSystem = class extends EventHandler {
  constructor(app2) {
    super();
    this.app = app2;
    this.store = {};
    this.schema = [];
  }
  addComponent(entity, data2 = {}) {
    const component = new this.ComponentType(this, entity);
    const componentData = new this.DataType();
    this.store[entity.getGuid()] = {
      entity,
      data: componentData
    };
    entity[this.id] = component;
    entity.c[this.id] = component;
    this.initializeComponentData(component, data2, []);
    this.fire("add", entity, component);
    return component;
  }
  removeComponent(entity) {
    const id13 = this.id;
    const record = this.store[entity.getGuid()];
    const component = entity.c[id13];
    this.fire("beforeremove", entity, component);
    delete this.store[entity.getGuid()];
    entity[id13] = void 0;
    delete entity.c[id13];
    this.fire("remove", entity, record.data);
  }
  cloneComponent(entity, clone) {
    const src = this.store[entity.getGuid()];
    return this.addComponent(clone, src.data);
  }
  initializeComponentData(component, data2 = {}, properties3) {
    for (let i = 0, len = properties3.length; i < len; i++) {
      const descriptor = properties3[i];
      let name, type;
      if (typeof descriptor === "object") {
        name = descriptor.name;
        type = descriptor.type;
      } else {
        name = descriptor;
        type = void 0;
      }
      let value = data2[name];
      if (value !== void 0) {
        if (type !== void 0) {
          value = convertValue(value, type);
        }
        component[name] = value;
      } else {
        component[name] = component.data[name];
      }
    }
    if (component.enabled && component.entity.enabled) {
      component.onEnable();
    }
  }
  getPropertiesOfType(type) {
    const matchingProperties = [];
    const schema = this.schema || [];
    schema.forEach((descriptor) => {
      if (descriptor && typeof descriptor === "object" && descriptor.type === type) {
        matchingProperties.push(descriptor);
      }
    });
    return matchingProperties;
  }
  destroy() {
    this.off();
  }
};
function convertValue(value, type) {
  if (!value) {
    return value;
  }
  switch (type) {
    case "rgb":
      if (value instanceof Color) {
        return value.clone();
      }
      return new Color(value[0], value[1], value[2]);
    case "rgba":
      if (value instanceof Color) {
        return value.clone();
      }
      return new Color(value[0], value[1], value[2], value[3]);
    case "vec2":
      if (value instanceof Vec2) {
        return value.clone();
      }
      return new Vec2(value[0], value[1]);
    case "vec3":
      if (value instanceof Vec3) {
        return value.clone();
      }
      return new Vec3(value[0], value[1], value[2]);
    case "vec4":
      if (value instanceof Vec4) {
        return value.clone();
      }
      return new Vec4(value[0], value[1], value[2], value[3]);
    case "boolean":
    case "number":
    case "string":
      return value;
    case "entity":
      return value;
    default:
      throw new Error(`Could not convert unhandled type: ${type}`);
  }
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/constants.js
var INTERPOLATION_STEP = 0;
var INTERPOLATION_LINEAR = 1;
var INTERPOLATION_CUBIC = 2;

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-cache.js
var AnimCache = class {
  constructor() {
    this._left = Infinity;
    this._right = -Infinity;
    this._len = 0;
    this._recip = 0;
    this._p0 = 0;
    this._p1 = 0;
    this._t = 0;
    this._hermite = {
      valid: false,
      p0: 0,
      m0: 0,
      p1: 0,
      m1: 0
    };
  }
  update(time, input) {
    if (time < this._left || time >= this._right) {
      const len = input.length;
      if (!len) {
        this._left = -Infinity;
        this._right = Infinity;
        this._len = 0;
        this._recip = 0;
        this._p0 = this._p1 = 0;
      } else {
        if (time < input[0]) {
          this._left = -Infinity;
          this._right = input[0];
          this._len = 0;
          this._recip = 0;
          this._p0 = this._p1 = 0;
        } else if (time >= input[len - 1]) {
          this._left = input[len - 1];
          this._right = Infinity;
          this._len = 0;
          this._recip = 0;
          this._p0 = this._p1 = len - 1;
        } else {
          const index = this._findKey(time, input);
          this._left = input[index];
          this._right = input[index + 1];
          this._len = this._right - this._left;
          const diff = 1 / this._len;
          this._recip = isFinite(diff) ? diff : 0;
          this._p0 = index;
          this._p1 = index + 1;
        }
      }
    }
    this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
    this._hermite.valid = false;
  }
  _findKey(time, input) {
    let index = 0;
    while (time >= input[index + 1]) {
      index++;
    }
    return index;
  }
  eval(result, interpolation, output) {
    const data2 = output._data;
    const comp = output._components;
    const idx0 = this._p0 * comp;
    if (interpolation === INTERPOLATION_STEP) {
      for (let i = 0; i < comp; ++i) {
        result[i] = data2[idx0 + i];
      }
    } else {
      const t = this._t;
      const idx1 = this._p1 * comp;
      switch (interpolation) {
        case INTERPOLATION_LINEAR:
          for (let i = 0; i < comp; ++i) {
            result[i] = math.lerp(data2[idx0 + i], data2[idx1 + i], t);
          }
          break;
        case INTERPOLATION_CUBIC: {
          const hermite = this._hermite;
          if (!hermite.valid) {
            const t2 = t * t;
            const twot = t + t;
            const omt = 1 - t;
            const omt2 = omt * omt;
            hermite.valid = true;
            hermite.p0 = (1 + twot) * omt2;
            hermite.m0 = t * omt2;
            hermite.p1 = t2 * (3 - twot);
            hermite.m1 = t2 * (t - 1);
          }
          const p0 = (this._p0 * 3 + 1) * comp;
          const m0 = (this._p0 * 3 + 2) * comp;
          const p12 = (this._p1 * 3 + 1) * comp;
          const m1 = (this._p1 * 3 + 0) * comp;
          for (let i = 0; i < comp; ++i) {
            result[i] = hermite.p0 * data2[p0 + i] + hermite.m0 * data2[m0 + i] * this._len + hermite.p1 * data2[p12 + i] + hermite.m1 * data2[m1 + i] * this._len;
          }
          break;
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-snapshot.js
var AnimSnapshot = class {
  constructor(animTrack) {
    this._name = `${animTrack.name}Snapshot`;
    this._time = -1;
    this._cache = [];
    this._results = [];
    for (let i = 0; i < animTrack._inputs.length; ++i) {
      this._cache[i] = new AnimCache();
    }
    const curves = animTrack._curves;
    const outputs = animTrack._outputs;
    for (let i = 0; i < curves.length; ++i) {
      const curve = curves[i];
      const output = outputs[curve._output];
      const storage = [];
      for (let j = 0; j < output._components; ++j) {
        storage[j] = 0;
      }
      this._results[i] = storage;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-clip.js
var AnimClip = class _AnimClip {
  constructor(track, time, speed, playing, loop, eventHandler) {
    this._name = track.name;
    this._track = track;
    this._snapshot = new AnimSnapshot(track);
    this._playing = playing;
    this._time = time;
    this._speed = speed;
    this._loop = loop;
    this._blendWeight = 1;
    this._blendOrder = 0;
    this._eventHandler = eventHandler;
    this.alignCursorToCurrentTime();
  }
  set name(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  set track(track) {
    this._track = track;
    this._snapshot = new AnimSnapshot(track);
  }
  get track() {
    return this._track;
  }
  get snapshot() {
    return this._snapshot;
  }
  set time(time) {
    this._time = time;
    this.alignCursorToCurrentTime();
  }
  get time() {
    return this._time;
  }
  set speed(speed) {
    const signChanged = Math.sign(speed) !== Math.sign(this._speed);
    this._speed = speed;
    if (signChanged) {
      this.alignCursorToCurrentTime();
    }
  }
  get speed() {
    return this._speed;
  }
  set loop(loop) {
    this._loop = loop;
  }
  get loop() {
    return this._loop;
  }
  set blendWeight(blendWeight) {
    this._blendWeight = blendWeight;
  }
  get blendWeight() {
    return this._blendWeight;
  }
  set blendOrder(blendOrder) {
    this._blendOrder = blendOrder;
  }
  get blendOrder() {
    return this._blendOrder;
  }
  set eventCursor(value) {
    this._eventCursor = value;
  }
  get eventCursor() {
    return this._eventCursor;
  }
  get eventCursorEnd() {
    return this.isReverse ? 0 : this._track.events.length - 1;
  }
  get nextEvent() {
    return this._track.events[this._eventCursor];
  }
  get isReverse() {
    return this._speed < 0;
  }
  nextEventAheadOfTime(time) {
    if (!this.nextEvent) return false;
    return this.isReverse ? this.nextEvent.time <= time : this.nextEvent.time >= time;
  }
  nextEventBehindTime(time) {
    if (!this.nextEvent) return false;
    if (time === this.track.duration) {
      return this.isReverse ? this.nextEvent.time >= time : this.nextEvent.time <= time;
    }
    return this.isReverse ? this.nextEvent.time > time : this.nextEvent.time < time;
  }
  resetEventCursor() {
    this._eventCursor = this.isReverse ? this._track.events.length - 1 : 0;
  }
  moveEventCursor() {
    this._eventCursor += this.isReverse ? -1 : 1;
    if (this._eventCursor >= this.track.events.length) {
      this._eventCursor = 0;
    } else if (this._eventCursor < 0) {
      this._eventCursor = this.track.events.length - 1;
    }
  }
  clipFrameTime(frameEndTime) {
    const eventFrame = _AnimClip.eventFrame;
    eventFrame.start = 0;
    eventFrame.end = frameEndTime;
    eventFrame.residual = 0;
    if (this.isReverse) {
      if (frameEndTime < 0) {
        eventFrame.start = this.track.duration;
        eventFrame.end = 0;
        eventFrame.residual = frameEndTime + this.track.duration;
      }
    } else {
      if (frameEndTime > this.track.duration) {
        eventFrame.start = 0;
        eventFrame.end = this.track.duration;
        eventFrame.residual = frameEndTime - this.track.duration;
      }
    }
  }
  alignCursorToCurrentTime() {
    this.resetEventCursor();
    while (this.nextEventBehindTime(this._time) && this._eventCursor !== this.eventCursorEnd) {
      this.moveEventCursor();
    }
  }
  fireNextEvent() {
    this._eventHandler.fire(this.nextEvent.name, _extends({
      track: this.track
    }, this.nextEvent));
    this.moveEventCursor();
  }
  fireNextEventInFrame(frameStartTime, frameEndTime) {
    if (this.nextEventAheadOfTime(frameStartTime) && this.nextEventBehindTime(frameEndTime)) {
      this.fireNextEvent();
      return true;
    }
    return false;
  }
  activeEventsForFrame(frameStartTime, frameEndTime) {
    const eventFrame = _AnimClip.eventFrame;
    this.clipFrameTime(frameEndTime);
    const initialCursor = this.eventCursor;
    while (this.fireNextEventInFrame(frameStartTime, eventFrame.end)) {
      if (initialCursor === this.eventCursor) {
        break;
      }
    }
    if (this.loop && Math.abs(eventFrame.residual) > 0) {
      this.activeEventsForFrame(eventFrame.start, eventFrame.residual);
    }
  }
  progressForTime(time) {
    return time * this._speed / this._track.duration;
  }
  _update(deltaTime) {
    if (this._playing) {
      let time = this._time;
      const duration = this._track.duration;
      const speed = this._speed;
      const loop = this._loop;
      if (this._track.events.length > 0 && duration > 0) {
        this.activeEventsForFrame(time, time + speed * deltaTime);
      }
      time += speed * deltaTime;
      if (speed >= 0) {
        if (time > duration) {
          if (loop) {
            time = time % duration || 0;
          } else {
            time = this._track.duration;
            this.pause();
          }
        }
      } else {
        if (time < 0) {
          if (loop) {
            time = duration + (time % duration || 0);
          } else {
            time = 0;
            this.pause();
          }
        }
      }
      this._time = time;
    }
    if (this._time !== this._snapshot._time) {
      this._track.eval(this._time, this._snapshot);
    }
  }
  play() {
    this._playing = true;
    this._time = 0;
  }
  stop() {
    this._playing = false;
    this._time = 0;
  }
  pause() {
    this._playing = false;
  }
  resume() {
    this._playing = true;
  }
  reset() {
    this._time = 0;
  }
};
AnimClip.eventFrame = {
  start: 0,
  end: 0,
  residual: 0
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/constants.js
var ANIM_INTERRUPTION_NONE = "NONE";
var ANIM_INTERRUPTION_PREV = "PREV_STATE";
var ANIM_INTERRUPTION_NEXT = "NEXT_STATE";
var ANIM_INTERRUPTION_PREV_NEXT = "PREV_STATE_NEXT_STATE";
var ANIM_INTERRUPTION_NEXT_PREV = "NEXT_STATE_PREV_STATE";
var ANIM_GREATER_THAN = "GREATER_THAN";
var ANIM_LESS_THAN = "LESS_THAN";
var ANIM_GREATER_THAN_EQUAL_TO = "GREATER_THAN_EQUAL_TO";
var ANIM_LESS_THAN_EQUAL_TO = "LESS_THAN_EQUAL_TO";
var ANIM_EQUAL_TO = "EQUAL_TO";
var ANIM_NOT_EQUAL_TO = "NOT_EQUAL_TO";
var ANIM_PARAMETER_INTEGER = "INTEGER";
var ANIM_PARAMETER_FLOAT = "FLOAT";
var ANIM_PARAMETER_BOOLEAN = "BOOLEAN";
var ANIM_PARAMETER_TRIGGER = "TRIGGER";
var ANIM_BLEND_1D = "1D";
var ANIM_BLEND_2D_DIRECTIONAL = "2D_DIRECTIONAL";
var ANIM_BLEND_2D_CARTESIAN = "2D_CARTESIAN";
var ANIM_BLEND_DIRECT = "DIRECT";
var ANIM_STATE_START = "START";
var ANIM_STATE_END = "END";
var ANIM_STATE_ANY = "ANY";
var ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];
var ANIM_LAYER_OVERWRITE = "OVERWRITE";
var ANIM_LAYER_ADDITIVE = "ADDITIVE";

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-blend.js
var AnimBlend = class _AnimBlend {
  static dot(a, b) {
    const len = a.length;
    let result = 0;
    for (let i = 0; i < len; ++i) {
      result += a[i] * b[i];
    }
    return result;
  }
  static normalize(a) {
    let l = _AnimBlend.dot(a, a);
    if (l > 0) {
      l = 1 / Math.sqrt(l);
      const len = a.length;
      for (let i = 0; i < len; ++i) {
        a[i] *= l;
      }
    }
  }
  static set(a, b, type) {
    const len = a.length;
    if (type === "quaternion") {
      let l = _AnimBlend.dot(b, b);
      if (l > 0) {
        l = 1 / Math.sqrt(l);
      }
      for (let i = 0; i < len; ++i) {
        a[i] = b[i] * l;
      }
    } else {
      for (let i = 0; i < len; ++i) {
        a[i] = b[i];
      }
    }
  }
  static blendVec(a, b, t, additive) {
    const it = additive ? 1 : 1 - t;
    const len = a.length;
    for (let i = 0; i < len; ++i) {
      a[i] = a[i] * it + b[i] * t;
    }
  }
  static blendQuat(a, b, t, additive) {
    const len = a.length;
    const it = additive ? 1 : 1 - t;
    if (_AnimBlend.dot(a, b) < 0) {
      t = -t;
    }
    for (let i = 0; i < len; ++i) {
      a[i] = a[i] * it + b[i] * t;
    }
    if (!additive) {
      _AnimBlend.normalize(a);
    }
  }
  static blend(a, b, t, type, additive) {
    if (type === "quaternion") {
      _AnimBlend.blendQuat(a, b, t, additive);
    } else {
      _AnimBlend.blendVec(a, b, t, additive);
    }
  }
  static stableSort(a, lessFunc) {
    const len = a.length;
    for (let i = 0; i < len - 1; ++i) {
      for (let j = i + 1; j < len; ++j) {
        if (lessFunc(a[j], a[i])) {
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-target-value.js
var AnimTargetValue = class _AnimTargetValue {
  constructor(component, type) {
    this._component = component;
    this.mask = new Int8Array(component.layers.length);
    this.weights = new Float32Array(component.layers.length);
    this.totalWeight = 0;
    this.counter = 0;
    this.layerCounter = 0;
    this.valueType = type;
    this.dirty = true;
    this.value = type === _AnimTargetValue.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0];
    this.baseValue = null;
    this.setter = null;
  }
  get _normalizeWeights() {
    return this._component.normalizeWeights;
  }
  getWeight(index) {
    if (this.dirty) this.updateWeights();
    if (this._normalizeWeights && this.totalWeight === 0 || !this.mask[index]) {
      return 0;
    } else if (this._normalizeWeights) {
      return this.weights[index] / this.totalWeight;
    }
    return math.clamp(this.weights[index], 0, 1);
  }
  _layerBlendType(index) {
    return this._component.layers[index].blendType;
  }
  setMask(index, value) {
    this.mask[index] = value;
    if (this._normalizeWeights) {
      if (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {
        this.mask = this.mask.fill(0, 0, index);
      }
      this.dirty = true;
    }
  }
  updateWeights() {
    this.totalWeight = 0;
    for (let i = 0; i < this.weights.length; i++) {
      this.weights[i] = this._component.layers[i].weight;
      this.totalWeight += this.mask[i] * this.weights[i];
    }
    this.dirty = false;
  }
  updateValue(index, value) {
    if (this.counter === 0) {
      AnimBlend.set(this.value, _AnimTargetValue.IDENTITY_QUAT_ARR, this.valueType);
      if (!this._normalizeWeights) {
        AnimBlend.blend(this.value, this.baseValue, 1, this.valueType);
      }
    }
    if (!this.mask[index] || this.getWeight(index) === 0) return;
    if (this._layerBlendType(index) === ANIM_LAYER_ADDITIVE && !this._normalizeWeights) {
      if (this.valueType === _AnimTargetValue.TYPE_QUAT) {
        const v = _AnimTargetValue.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]);
        const aV1 = _AnimTargetValue.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]);
        const aV2 = _AnimTargetValue.q3.set(value[0], value[1], value[2], value[3]);
        const aV = aV1.invert().mul(aV2);
        aV.slerp(Quat.IDENTITY, aV, this.getWeight(index));
        v.mul(aV);
        _AnimTargetValue.quatArr[0] = v.x;
        _AnimTargetValue.quatArr[1] = v.y;
        _AnimTargetValue.quatArr[2] = v.z;
        _AnimTargetValue.quatArr[3] = v.w;
        AnimBlend.set(this.value, _AnimTargetValue.quatArr, this.valueType);
      } else {
        _AnimTargetValue.vecArr[0] = value[0] - this.baseValue[0];
        _AnimTargetValue.vecArr[1] = value[1] - this.baseValue[1];
        _AnimTargetValue.vecArr[2] = value[2] - this.baseValue[2];
        AnimBlend.blend(this.value, _AnimTargetValue.vecArr, this.getWeight(index), this.valueType, true);
      }
    } else {
      AnimBlend.blend(this.value, value, this.getWeight(index), this.valueType);
    }
    if (this.setter) this.setter(this.value);
  }
  unbind() {
    if (this.setter) {
      this.setter(this.baseValue);
    }
  }
};
AnimTargetValue.TYPE_QUAT = "quaternion";
AnimTargetValue.TYPE_VEC3 = "vector3";
AnimTargetValue.q1 = new Quat();
AnimTargetValue.q2 = new Quat();
AnimTargetValue.q3 = new Quat();
AnimTargetValue.quatArr = [0, 0, 0, 1];
AnimTargetValue.vecArr = [0, 0, 0];
AnimTargetValue.IDENTITY_QUAT_ARR = [0, 0, 0, 1];

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-evaluator.js
var AnimEvaluator = class {
  constructor(binder) {
    this._binder = binder;
    this._clips = [];
    this._inputs = [];
    this._outputs = [];
    this._targets = {};
  }
  get clips() {
    return this._clips;
  }
  addClip(clip) {
    const targets = this._targets;
    const binder = this._binder;
    const curves = clip.track.curves;
    const snapshot = clip.snapshot;
    const inputs = [];
    const outputs = [];
    for (let i = 0; i < curves.length; ++i) {
      const curve = curves[i];
      const paths = curve.paths;
      for (let j = 0; j < paths.length; ++j) {
        const path2 = paths[j];
        const resolved = binder.resolve(path2);
        let target2 = targets[resolved && resolved.targetPath || null];
        if (!target2 && resolved) {
          target2 = {
            target: resolved,
            value: [],
            curves: 0,
            blendCounter: 0
          };
          for (let k = 0; k < target2.target.components; ++k) {
            target2.value.push(0);
          }
          targets[resolved.targetPath] = target2;
          if (binder.animComponent) {
            if (!binder.animComponent.targets[resolved.targetPath]) {
              let type;
              if (resolved.targetPath.substring(resolved.targetPath.length - 13) === "localRotation") {
                type = AnimTargetValue.TYPE_QUAT;
              } else {
                type = AnimTargetValue.TYPE_VEC3;
              }
              binder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);
            }
            binder.animComponent.targets[resolved.targetPath].layerCounter++;
            binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);
          }
        }
        if (target2) {
          target2.curves++;
          inputs.push(snapshot._results[i]);
          outputs.push(target2);
        }
      }
    }
    this._clips.push(clip);
    this._inputs.push(inputs);
    this._outputs.push(outputs);
  }
  removeClip(index) {
    const targets = this._targets;
    const binder = this._binder;
    const clips = this._clips;
    const clip = clips[index];
    const curves = clip.track.curves;
    for (let i = 0; i < curves.length; ++i) {
      const curve = curves[i];
      const paths = curve.paths;
      for (let j = 0; j < paths.length; ++j) {
        const path2 = paths[j];
        const target2 = this._binder.resolve(path2);
        if (target2) {
          target2.curves--;
          if (target2.curves === 0) {
            binder.unresolve(path2);
            delete targets[target2.targetPath];
            if (binder.animComponent) {
              binder.animComponent.targets[target2.targetPath].layerCounter--;
            }
          }
        }
      }
    }
    clips.splice(index, 1);
    this._inputs.splice(index, 1);
    this._outputs.splice(index, 1);
  }
  removeClips() {
    while (this._clips.length > 0) {
      this.removeClip(0);
    }
  }
  updateClipTrack(name, animTrack) {
    this._clips.forEach((clip) => {
      if (clip.name.includes(name)) {
        clip.track = animTrack;
      }
    });
    this.rebind();
  }
  findClip(name) {
    const clips = this._clips;
    for (let i = 0; i < clips.length; ++i) {
      const clip = clips[i];
      if (clip.name === name) {
        return clip;
      }
    }
    return null;
  }
  rebind() {
    this._binder.rebind();
    this._targets = {};
    const clips = [...this.clips];
    this.removeClips();
    clips.forEach((clip) => {
      this.addClip(clip);
    });
  }
  assignMask(mask) {
    return this._binder.assignMask(mask);
  }
  update(deltaTime, outputAnimation = true) {
    const clips = this._clips;
    const order = clips.map((c2, i) => {
      return i;
    });
    AnimBlend.stableSort(order, (a, b) => {
      return clips[a].blendOrder < clips[b].blendOrder;
    });
    for (let i = 0; i < order.length; ++i) {
      const index = order[i];
      const clip = clips[index];
      const inputs = this._inputs[index];
      const outputs = this._outputs[index];
      const blendWeight = clip.blendWeight;
      if (blendWeight > 0) {
        clip._update(deltaTime);
      }
      if (!outputAnimation) break;
      let input;
      let output;
      let value;
      if (blendWeight >= 1) {
        for (let j = 0; j < inputs.length; ++j) {
          input = inputs[j];
          output = outputs[j];
          value = output.value;
          AnimBlend.set(value, input, output.target.type);
          output.blendCounter++;
        }
      } else if (blendWeight > 0) {
        for (let j = 0; j < inputs.length; ++j) {
          input = inputs[j];
          output = outputs[j];
          value = output.value;
          if (output.blendCounter === 0) {
            AnimBlend.set(value, input, output.target.type);
          } else {
            AnimBlend.blend(value, input, blendWeight, output.target.type);
          }
          output.blendCounter++;
        }
      }
    }
    const targets = this._targets;
    const binder = this._binder;
    for (const path2 in targets) {
      if (targets.hasOwnProperty(path2)) {
        const target2 = targets[path2];
        if (binder.animComponent && target2.target.isTransform) {
          const animTarget = binder.animComponent.targets[path2];
          if (animTarget.counter === animTarget.layerCounter) {
            animTarget.counter = 0;
          }
          if (!animTarget.path) {
            animTarget.path = path2;
            animTarget.baseValue = target2.target.get();
            animTarget.setter = target2.target.set;
          }
          animTarget.updateValue(binder.layerIndex, target2.value);
          animTarget.counter++;
        } else {
          target2.target.set(target2.value);
        }
        target2.blendCounter = 0;
      }
    }
    this._binder.update(deltaTime);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-events.js
var AnimEvents = class {
  constructor(events) {
    this._events = [...events];
    this._events.sort((a, b) => a.time - b.time);
  }
  get events() {
    return this._events;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-track.js
var _AnimTrack;
var AnimTrack = class {
  constructor(name, duration, inputs, outputs, curves, animEvents = new AnimEvents([])) {
    this._name = name;
    this._duration = duration;
    this._inputs = inputs;
    this._outputs = outputs;
    this._curves = curves;
    this._animEvents = animEvents;
  }
  get name() {
    return this._name;
  }
  get duration() {
    return this._duration;
  }
  get inputs() {
    return this._inputs;
  }
  get outputs() {
    return this._outputs;
  }
  get curves() {
    return this._curves;
  }
  set events(animEvents) {
    this._animEvents = animEvents;
  }
  get events() {
    return this._animEvents.events;
  }
  eval(time, snapshot) {
    snapshot._time = time;
    const inputs = this._inputs;
    const outputs = this._outputs;
    const curves = this._curves;
    const cache = snapshot._cache;
    const results = snapshot._results;
    for (let i = 0; i < inputs.length; ++i) {
      cache[i].update(time, inputs[i]._data);
    }
    for (let i = 0; i < curves.length; ++i) {
      const curve = curves[i];
      const output = outputs[curve._output];
      const result = results[i];
      cache[curve._input].eval(result, curve._interpolation, output);
    }
  }
};
_AnimTrack = AnimTrack;
AnimTrack.EMPTY = Object.freeze(new _AnimTrack("empty", Number.MAX_VALUE, [], [], []));

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/binder/anim-binder.js
var AnimBinder = class {
  static joinPath(pathSegments, character) {
    character = character || ".";
    const escape2 = function escape3(string2) {
      return string2.replace(/\\/g, "\\\\").replace(new RegExp(`\\${character}`, "g"), `\\${character}`);
    };
    return pathSegments.map(escape2).join(character);
  }
  static splitPath(path2, character) {
    character = character || ".";
    const result = [];
    let curr = "";
    let i = 0;
    while (i < path2.length) {
      let c2 = path2[i++];
      if (c2 === "\\" && i < path2.length) {
        c2 = path2[i++];
        if (c2 === "\\" || c2 === character) {
          curr += c2;
        } else {
          curr += `\\${c2}`;
        }
      } else if (c2 === character) {
        result.push(curr);
        curr = "";
      } else {
        curr += c2;
      }
    }
    if (curr.length > 0) {
      result.push(curr);
    }
    return result;
  }
  static encode(entityPath, component, propertyPath) {
    return `${Array.isArray(entityPath) ? entityPath.join("/") : entityPath}/${component}/${Array.isArray(propertyPath) ? propertyPath.join("/") : propertyPath}`;
  }
  resolve(path2) {
    return null;
  }
  unresolve(path2) {
  }
  update(deltaTime) {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-target.js
var AnimTarget = class {
  constructor(func, type, components2, targetPath) {
    if (func.set) {
      this._set = func.set;
      this._get = func.get;
    } else {
      this._set = func;
    }
    this._type = type;
    this._components = components2;
    this._targetPath = targetPath;
    this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === "localRotation" || this._targetPath.substring(this._targetPath.length - 13) === "localPosition" || this._targetPath.substring(this._targetPath.length - 10) === "localScale";
  }
  get set() {
    return this._set;
  }
  get get() {
    return this._get;
  }
  get type() {
    return this._type;
  }
  get components() {
    return this._components;
  }
  get targetPath() {
    return this._targetPath;
  }
  get isTransform() {
    return this._isTransform;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/binder/default-anim-binder.js
var DefaultAnimBinder = class _DefaultAnimBinder {
  constructor(graph) {
    this._isPathInMask = (path2, checkMaskValue) => {
      const maskItem = this._mask[path2];
      if (!maskItem) return false;
      else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;
      return false;
    };
    this.graph = graph;
    if (!graph) return;
    this._mask = null;
    const nodes = {};
    const flatten = function flatten2(node) {
      nodes[node.name] = node;
      for (let i = 0; i < node.children.length; ++i) {
        flatten2(node.children[i]);
      }
    };
    flatten(graph);
    this.nodes = nodes;
    this.targetCache = {};
    const findMeshInstances = function findMeshInstances2(node) {
      let object = node;
      while (object && !(object instanceof Entity)) {
        object = object.parent;
      }
      let meshInstances;
      if (object) {
        if (object.render) {
          meshInstances = object.render.meshInstances;
        } else if (object.model) {
          meshInstances = object.model.meshInstances;
        }
      }
      return meshInstances;
    };
    this.nodeCounts = {};
    this.activeNodes = [];
    this.handlers = {
      "localPosition": function(node) {
        const object = node.localPosition;
        const func = function func2(value) {
          object.set(...value);
        };
        return _DefaultAnimBinder.createAnimTarget(func, "vector", 3, node, "localPosition");
      },
      "localRotation": function(node) {
        const object = node.localRotation;
        const func = function func2(value) {
          object.set(...value);
        };
        return _DefaultAnimBinder.createAnimTarget(func, "quaternion", 4, node, "localRotation");
      },
      "localScale": function(node) {
        const object = node.localScale;
        const func = function func2(value) {
          object.set(...value);
        };
        return _DefaultAnimBinder.createAnimTarget(func, "vector", 3, node, "localScale");
      },
      "weight": function(node, weightName) {
        if (weightName.indexOf("name.") === 0) {
          weightName = weightName.replace("name.", "");
        } else {
          weightName = Number(weightName);
        }
        const meshInstances = findMeshInstances(node);
        let setters;
        if (meshInstances) {
          for (let i = 0; i < meshInstances.length; ++i) {
            if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {
              const morphInstance = meshInstances[i].morphInstance;
              const func = (value) => {
                morphInstance.setWeight(weightName, value[0]);
              };
              if (!setters) setters = [];
              setters.push(func);
            }
          }
        }
        if (setters) {
          const callSetters = (value) => {
            for (let i = 0; i < setters.length; ++i) {
              setters[i](value);
            }
          };
          return _DefaultAnimBinder.createAnimTarget(callSetters, "number", 1, node, `weight.${weightName}`);
        }
        return null;
      },
      "materialTexture": (node, textureName) => {
        const meshInstances = findMeshInstances(node);
        if (meshInstances) {
          let meshInstance;
          for (let i = 0; i < meshInstances.length; ++i) {
            if (meshInstances[i].node.name === node.name) {
              meshInstance = meshInstances[i];
              break;
            }
          }
          if (meshInstance) {
            const func = (value) => {
              const textureAsset = this.animComponent.system.app.assets.get(value[0]);
              if (textureAsset && textureAsset.resource && textureAsset.type === "texture") {
                meshInstance.material[textureName] = textureAsset.resource;
                meshInstance.material.update();
              }
            };
            return _DefaultAnimBinder.createAnimTarget(func, "vector", 1, node, "materialTexture", "material");
          }
        }
        return null;
      }
    };
  }
  _isPathActive(path2) {
    if (!this._mask) return true;
    const rootNodeNames = [path2.entityPath[0], this.graph.name];
    for (let j = 0; j < rootNodeNames.length; ++j) {
      let currEntityPath = rootNodeNames[j];
      if (this._isPathInMask(currEntityPath, path2.entityPath.length === 1)) return true;
      for (let i = 1; i < path2.entityPath.length; i++) {
        currEntityPath += `/${path2.entityPath[i]}`;
        if (this._isPathInMask(currEntityPath, i === path2.entityPath.length - 1)) return true;
      }
    }
    return false;
  }
  findNode(path2) {
    if (!this._isPathActive(path2)) {
      return null;
    }
    let node;
    if (this.graph) {
      node = this.graph.findByPath(path2.entityPath);
      if (!node) {
        node = this.graph.findByPath(path2.entityPath.slice(1));
      }
    }
    if (!node) {
      node = this.nodes[path2.entityPath[path2.entityPath.length - 1] || ""];
    }
    return node;
  }
  static createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {
    const targetPath = AnimBinder.encode(node.path, componentType ? componentType : "entity", propertyPath);
    return new AnimTarget(func, type, valueCount, targetPath);
  }
  resolve(path2) {
    const encodedPath = AnimBinder.encode(path2.entityPath, path2.component, path2.propertyPath);
    let target2 = this.targetCache[encodedPath];
    if (target2) return target2;
    const node = this.findNode(path2);
    if (!node) {
      return null;
    }
    const handler = this.handlers[path2.propertyPath];
    if (!handler) {
      return null;
    }
    target2 = handler(node);
    if (!target2) {
      return null;
    }
    this.targetCache[encodedPath] = target2;
    if (!this.nodeCounts[node.path]) {
      this.activeNodes.push(node);
      this.nodeCounts[node.path] = 1;
    } else {
      this.nodeCounts[node.path]++;
    }
    return target2;
  }
  unresolve(path2) {
    if (path2.component !== "graph") {
      return;
    }
    const node = this.nodes[path2.entityPath[path2.entityPath.length - 1] || ""];
    this.nodeCounts[node.path]--;
    if (this.nodeCounts[node.path] === 0) {
      const activeNodes = this.activeNodes;
      const i = activeNodes.indexOf(node.node);
      const len = activeNodes.length;
      if (i < len - 1) {
        activeNodes[i] = activeNodes[len - 1];
      }
      activeNodes.pop();
    }
  }
  update(deltaTime) {
    const activeNodes = this.activeNodes;
    for (let i = 0; i < activeNodes.length; ++i) {
      activeNodes[i]._dirtifyLocal();
    }
  }
  assignMask(mask) {
    if (mask !== this._mask) {
      this._mask = mask;
      return true;
    }
    return false;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/animation/component.js
var AnimationComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._animations = {};
    this._assets = [];
    this._loop = true;
    this.animEvaluator = null;
    this.model = null;
    this.skeleton = null;
    this.fromSkel = null;
    this.toSkel = null;
    this.animationsIndex = {};
    this.prevAnim = null;
    this.currAnim = null;
    this.blend = 0;
    this.blending = false;
    this.blendSpeed = 0;
    this.activate = true;
    this.speed = 1;
  }
  set animations(value) {
    this._animations = value;
    this.onSetAnimations();
  }
  get animations() {
    return this._animations;
  }
  set assets(value) {
    const assets = this._assets;
    if (assets && assets.length) {
      for (let i = 0; i < assets.length; i++) {
        if (assets[i]) {
          const asset = this.system.app.assets.get(assets[i]);
          if (asset) {
            asset.off("change", this.onAssetChanged, this);
            asset.off("remove", this.onAssetRemoved, this);
            const animName = this.animationsIndex[asset.id];
            if (this.currAnim === animName) {
              this._stopCurrentAnimation();
            }
            delete this.animations[animName];
            delete this.animationsIndex[asset.id];
          }
        }
      }
    }
    this._assets = value;
    const assetIds = value.map((value2) => {
      return value2 instanceof Asset ? value2.id : value2;
    });
    this.loadAnimationAssets(assetIds);
  }
  get assets() {
    return this._assets;
  }
  set currentTime(currentTime) {
    if (this.skeleton) {
      this.skeleton.currentTime = currentTime;
      this.skeleton.addTime(0);
      this.skeleton.updateGraph();
    }
    if (this.animEvaluator) {
      const clips = this.animEvaluator.clips;
      for (let i = 0; i < clips.length; ++i) {
        clips[i].time = currentTime;
      }
    }
  }
  get currentTime() {
    if (this.skeleton) {
      return this.skeleton._time;
    }
    if (this.animEvaluator) {
      const clips = this.animEvaluator.clips;
      if (clips.length > 0) {
        return clips[clips.length - 1].time;
      }
    }
    return 0;
  }
  get duration() {
    if (this.currAnim) {
      return this.animations[this.currAnim].duration;
    }
    return 0;
  }
  set loop(value) {
    this._loop = value;
    if (this.skeleton) {
      this.skeleton.looping = value;
    }
    if (this.animEvaluator) {
      for (let i = 0; i < this.animEvaluator.clips.length; ++i) {
        this.animEvaluator.clips[i].loop = value;
      }
    }
  }
  get loop() {
    return this._loop;
  }
  play(name, blendTime = 0) {
    if (!this.enabled || !this.entity.enabled) {
      return;
    }
    if (!this.animations[name]) {
      return;
    }
    this.prevAnim = this.currAnim;
    this.currAnim = name;
    if (this.model) {
      if (!this.skeleton && !this.animEvaluator) {
        this._createAnimationController();
      }
      const prevAnim = this.animations[this.prevAnim];
      const currAnim = this.animations[this.currAnim];
      this.blending = blendTime > 0 && !!this.prevAnim;
      if (this.blending) {
        this.blend = 0;
        this.blendSpeed = 1 / blendTime;
      }
      if (this.skeleton) {
        if (this.blending) {
          this.fromSkel.animation = prevAnim;
          this.fromSkel.addTime(this.skeleton._time);
          this.toSkel.animation = currAnim;
        } else {
          this.skeleton.animation = currAnim;
        }
      }
      if (this.animEvaluator) {
        const animEvaluator = this.animEvaluator;
        if (this.blending) {
          while (animEvaluator.clips.length > 1) {
            animEvaluator.removeClip(0);
          }
        } else {
          this.animEvaluator.removeClips();
        }
        const clip = new AnimClip(this.animations[this.currAnim], 0, 1, true, this.loop);
        clip.name = this.currAnim;
        clip.blendWeight = this.blending ? 0 : 1;
        clip.reset();
        this.animEvaluator.addClip(clip);
      }
    }
    this.playing = true;
  }
  getAnimation(name) {
    return this.animations[name];
  }
  setModel(model) {
    if (model !== this.model) {
      this._resetAnimationController();
      this.model = model;
      if (this.animations && this.currAnim && this.animations[this.currAnim]) {
        this.play(this.currAnim);
      }
    }
  }
  onSetAnimations() {
    const modelComponent = this.entity.model;
    if (modelComponent) {
      const m = modelComponent.model;
      if (m && m !== this.model) {
        this.setModel(m);
      }
    }
    if (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {
      const animationNames = Object.keys(this._animations);
      if (animationNames.length > 0) {
        this.play(animationNames[0]);
      }
    }
  }
  _resetAnimationController() {
    this.skeleton = null;
    this.fromSkel = null;
    this.toSkel = null;
    this.animEvaluator = null;
  }
  _createAnimationController() {
    const model = this.model;
    const animations = this.animations;
    let hasJson = false;
    let hasGlb = false;
    for (const animation in animations) {
      if (animations.hasOwnProperty(animation)) {
        const anim = animations[animation];
        if (anim.constructor === AnimTrack) {
          hasGlb = true;
        } else {
          hasJson = true;
        }
      }
    }
    const graph = model.getGraph();
    if (hasJson) {
      this.fromSkel = new Skeleton(graph);
      this.toSkel = new Skeleton(graph);
      this.skeleton = new Skeleton(graph);
      this.skeleton.looping = this.loop;
      this.skeleton.setGraph(graph);
    } else if (hasGlb) {
      this.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));
    }
  }
  loadAnimationAssets(ids3) {
    if (!ids3 || !ids3.length) {
      return;
    }
    const assets = this.system.app.assets;
    const onAssetReady = (asset) => {
      if (asset.resources.length > 1) {
        for (let i = 0; i < asset.resources.length; i++) {
          this.animations[asset.resources[i].name] = asset.resources[i];
          this.animationsIndex[asset.id] = asset.resources[i].name;
        }
      } else {
        this.animations[asset.name] = asset.resource;
        this.animationsIndex[asset.id] = asset.name;
      }
      this.animations = this.animations;
    };
    const onAssetAdd = (asset) => {
      asset.off("change", this.onAssetChanged, this);
      asset.on("change", this.onAssetChanged, this);
      asset.off("remove", this.onAssetRemoved, this);
      asset.on("remove", this.onAssetRemoved, this);
      if (asset.resource) {
        onAssetReady(asset);
      } else {
        asset.once("load", onAssetReady, this);
        if (this.enabled && this.entity.enabled) {
          assets.load(asset);
        }
      }
    };
    for (let i = 0, l = ids3.length; i < l; i++) {
      const asset = assets.get(ids3[i]);
      if (asset) {
        onAssetAdd(asset);
      } else {
        assets.on(`add:${ids3[i]}`, onAssetAdd);
      }
    }
  }
  onAssetChanged(asset, attribute, newValue, oldValue) {
    if (attribute === "resource" || attribute === "resources") {
      if (attribute === "resources" && newValue && newValue.length === 0) {
        newValue = null;
      }
      if (newValue) {
        let restarted = false;
        if (newValue.length > 1) {
          if (oldValue && oldValue.length > 1) {
            for (let i = 0; i < oldValue.length; i++) {
              delete this.animations[oldValue[i].name];
            }
          } else {
            delete this.animations[asset.name];
          }
          restarted = false;
          for (let i = 0; i < newValue.length; i++) {
            this.animations[newValue[i].name] = newValue[i];
            if (!restarted && this.currAnim === newValue[i].name) {
              if (this.playing && this.enabled && this.entity.enabled) {
                restarted = true;
                this.play(newValue[i].name);
              }
            }
          }
          if (!restarted) {
            this._stopCurrentAnimation();
            this.onSetAnimations();
          }
        } else {
          if (oldValue && oldValue.length > 1) {
            for (let i = 0; i < oldValue.length; i++) {
              delete this.animations[oldValue[i].name];
            }
          }
          this.animations[asset.name] = newValue[0] || newValue;
          restarted = false;
          if (this.currAnim === asset.name) {
            if (this.playing && this.enabled && this.entity.enabled) {
              restarted = true;
              this.play(asset.name);
            }
          }
          if (!restarted) {
            this._stopCurrentAnimation();
            this.onSetAnimations();
          }
        }
        this.animationsIndex[asset.id] = asset.name;
      } else {
        if (oldValue.length > 1) {
          for (let i = 0; i < oldValue.length; i++) {
            delete this.animations[oldValue[i].name];
            if (this.currAnim === oldValue[i].name) {
              this._stopCurrentAnimation();
            }
          }
        } else {
          delete this.animations[asset.name];
          if (this.currAnim === asset.name) {
            this._stopCurrentAnimation();
          }
        }
        delete this.animationsIndex[asset.id];
      }
    }
  }
  onAssetRemoved(asset) {
    asset.off("remove", this.onAssetRemoved, this);
    if (this.animations) {
      if (asset.resources.length > 1) {
        for (let i = 0; i < asset.resources.length; i++) {
          delete this.animations[asset.resources[i].name];
          if (this.currAnim === asset.resources[i].name) {
            this._stopCurrentAnimation();
          }
        }
      } else {
        delete this.animations[asset.name];
        if (this.currAnim === asset.name) {
          this._stopCurrentAnimation();
        }
      }
      delete this.animationsIndex[asset.id];
    }
  }
  _stopCurrentAnimation() {
    this.currAnim = null;
    this.playing = false;
    if (this.skeleton) {
      this.skeleton.currentTime = 0;
      this.skeleton.animation = null;
    }
    if (this.animEvaluator) {
      for (let i = 0; i < this.animEvaluator.clips.length; ++i) {
        this.animEvaluator.clips[i].stop();
      }
      this.animEvaluator.update(0);
      this.animEvaluator.removeClips();
    }
  }
  onEnable() {
    super.onEnable();
    const assets = this.assets;
    const registry = this.system.app.assets;
    if (assets) {
      for (let i = 0, len = assets.length; i < len; i++) {
        let asset = assets[i];
        if (!(asset instanceof Asset)) {
          asset = registry.get(asset);
        }
        if (asset && !asset.resource) {
          registry.load(asset);
        }
      }
    }
    if (this.activate && !this.currAnim) {
      const animationNames = Object.keys(this.animations);
      if (animationNames.length > 0) {
        this.play(animationNames[0]);
      }
    }
  }
  onBeforeRemove() {
    for (let i = 0; i < this.assets.length; i++) {
      let asset = this.assets[i];
      if (typeof asset === "number") {
        asset = this.system.app.assets.get(asset);
      }
      if (!asset) continue;
      asset.off("change", this.onAssetChanged, this);
      asset.off("remove", this.onAssetRemoved, this);
    }
    this.skeleton = null;
    this.fromSkel = null;
    this.toSkel = null;
    this.animEvaluator = null;
  }
  update(dt) {
    if (this.blending) {
      this.blend += dt * this.blendSpeed;
      if (this.blend >= 1) {
        this.blend = 1;
      }
    }
    if (this.playing) {
      const skeleton = this.skeleton;
      if (skeleton !== null && this.model !== null) {
        if (this.blending) {
          skeleton.blend(this.fromSkel, this.toSkel, this.blend);
        } else {
          const delta = dt * this.speed;
          skeleton.addTime(delta);
          if (this.speed > 0 && skeleton._time === skeleton.animation.duration && !this.loop) {
            this.playing = false;
          } else if (this.speed < 0 && skeleton._time === 0 && !this.loop) {
            this.playing = false;
          }
        }
        if (this.blending && this.blend === 1) {
          skeleton.animation = this.toSkel.animation;
        }
        skeleton.updateGraph();
      }
    }
    const animEvaluator = this.animEvaluator;
    if (animEvaluator) {
      for (let i = 0; i < animEvaluator.clips.length; ++i) {
        const clip = animEvaluator.clips[i];
        clip.speed = this.speed;
        if (!this.playing) {
          clip.pause();
        } else {
          clip.resume();
        }
      }
      if (this.blending && animEvaluator.clips.length > 1) {
        animEvaluator.clips[1].blendWeight = this.blend;
      }
      animEvaluator.update(dt);
    }
    if (this.blending && this.blend === 1) {
      this.blending = false;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/animation/data.js
var AnimationComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/animation/system.js
var _schema = ["enabled"];
var AnimationComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "animation";
    this.ComponentType = AnimationComponent;
    this.DataType = AnimationComponentData;
    this.schema = _schema;
    this.on("beforeremove", this.onBeforeRemove, this);
    this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(component, data2, properties3) {
    properties3 = ["activate", "enabled", "loop", "speed", "assets"];
    for (const property of properties3) {
      if (data2.hasOwnProperty(property)) {
        component[property] = data2[property];
      }
    }
    super.initializeComponentData(component, data2, _schema);
  }
  cloneComponent(entity, clone) {
    this.addComponent(clone, {});
    clone.animation.assets = entity.animation.assets.slice();
    clone.animation.speed = entity.animation.speed;
    clone.animation.loop = entity.animation.loop;
    clone.animation.activate = entity.animation.activate;
    clone.animation.enabled = entity.animation.enabled;
    const clonedAnimations = {};
    const animations = entity.animation.animations;
    for (const key in animations) {
      if (animations.hasOwnProperty(key)) {
        clonedAnimations[key] = animations[key];
      }
    }
    clone.animation.animations = clonedAnimations;
    const clonedAnimationsIndex = {};
    const animationsIndex = entity.animation.animationsIndex;
    for (const key in animationsIndex) {
      if (animationsIndex.hasOwnProperty(key)) {
        clonedAnimationsIndex[key] = animationsIndex[key];
      }
    }
    clone.animation.animationsIndex = clonedAnimationsIndex;
    return clone.animation;
  }
  onBeforeRemove(entity, component) {
    component.onBeforeRemove();
  }
  onUpdate(dt) {
    const components2 = this.store;
    for (const id13 in components2) {
      if (components2.hasOwnProperty(id13)) {
        const component = components2[id13];
        if (component.data.enabled && component.entity.enabled) {
          component.entity.animation.update(dt);
        }
      }
    }
  }
  destroy() {
    super.destroy();
    this.app.systems.off("update", this.onUpdate, this);
  }
};
Component._buildAccessors(AnimationComponent.prototype, _schema);

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-node.js
var AnimNode = class {
  constructor(state, parent, name, point, speed = 1) {
    this._state = state;
    this._parent = parent;
    this._name = name;
    if (Array.isArray(point)) {
      this._point = new Vec2(point[0], point[1]);
      this._pointLength = this._point.length();
    } else {
      this._point = point;
      this._pointLength = point;
    }
    this._speed = speed;
    this._weightedSpeed = 1;
    this._weight = 1;
    this._animTrack = null;
  }
  get parent() {
    return this._parent;
  }
  get name() {
    return this._name;
  }
  get path() {
    return this._parent ? `${this._parent.path}.${this._name}` : this._name;
  }
  get point() {
    return this._point;
  }
  get pointLength() {
    return this._pointLength;
  }
  set weight(value) {
    this._weight = value;
  }
  get weight() {
    return this._parent ? this._parent.weight * this._weight : this._weight;
  }
  get normalizedWeight() {
    const totalWeight = this._state.totalWeight;
    if (totalWeight === 0) return 0;
    return this.weight / totalWeight;
  }
  get speed() {
    return this._weightedSpeed * this._speed;
  }
  get absoluteSpeed() {
    return Math.abs(this._speed);
  }
  set weightedSpeed(weightedSpeed) {
    this._weightedSpeed = weightedSpeed;
  }
  get weightedSpeed() {
    return this._weightedSpeed;
  }
  set animTrack(value) {
    this._animTrack = value;
  }
  get animTrack() {
    return this._animTrack;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree.js
var AnimBlendTree = class _AnimBlendTree extends AnimNode {
  constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
    super(state, parent, name, point);
    this._parameters = parameters;
    this._parameterValues = new Array(parameters.length);
    this._children = [];
    this._findParameter = findParameter;
    this._syncAnimations = syncAnimations !== false;
    this._pointCache = {};
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.children) {
        this._children.push(createTree(child.type, state, this, child.name, 1, child.parameter ? [child.parameter] : child.parameters, child.children, child.syncAnimations, createTree, findParameter));
      } else {
        this._children.push(new AnimNode(state, this, child.name, child.point, child.speed));
      }
    }
  }
  get weight() {
    this.calculateWeights();
    return this._parent ? this._parent.weight * this._weight : this._weight;
  }
  get syncAnimations() {
    return this._syncAnimations;
  }
  getChild(name) {
    for (let i = 0; i < this._children.length; i++) {
      if (this._children[i].name === name) return this._children[i];
    }
    return null;
  }
  updateParameterValues() {
    let paramsEqual = true;
    for (let i = 0; i < this._parameterValues.length; i++) {
      const updatedParameter = this._findParameter(this._parameters[i]).value;
      if (this._parameterValues[i] !== updatedParameter) {
        this._parameterValues[i] = updatedParameter;
        paramsEqual = false;
      }
    }
    return paramsEqual;
  }
  getNodeWeightedDuration(i) {
    return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;
  }
  getNodeCount() {
    let count = 0;
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      if (child.constructor === _AnimBlendTree) {
        count += this._children[i].getNodeCount();
      } else {
        count++;
      }
    }
    return count;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree-1d.js
var AnimBlendTree1D = class extends AnimBlendTree {
  constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
    children.sort((a, b) => a.point - b.point);
    super(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
  }
  calculateWeights() {
    if (this.updateParameterValues()) return;
    let weightedDurationSum = 0;
    this._children[0].weight = 0;
    for (let i = 0; i < this._children.length; i++) {
      const c1 = this._children[i];
      if (i !== this._children.length - 1) {
        const c2 = this._children[i + 1];
        if (c1.point === c2.point) {
          c1.weight = 0.5;
          c2.weight = 0.5;
        } else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {
          const child2Distance = Math.abs(c1.point - c2.point);
          const parameterDistance = Math.abs(c1.point - this._parameterValues[0]);
          const weight = (child2Distance - parameterDistance) / child2Distance;
          c1.weight = weight;
          c2.weight = 1 - weight;
        } else {
          c2.weight = 0;
        }
      }
      if (this._syncAnimations) {
        weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;
      }
    }
    if (this._syncAnimations) {
      for (let i = 0; i < this._children.length; i++) {
        const child = this._children[i];
        child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree-2d-cartesian.js
var AnimBlendTreeCartesian2D = class _AnimBlendTreeCartesian2D extends AnimBlendTree {
  pointDistanceCache(i, j) {
    const pointKey = `${i}${j}`;
    if (!this._pointCache[pointKey]) {
      this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);
    }
    return this._pointCache[pointKey];
  }
  calculateWeights() {
    if (this.updateParameterValues()) return;
    let weightSum, weightedDurationSum;
    _AnimBlendTreeCartesian2D._p.set(...this._parameterValues);
    weightSum = 0;
    weightedDurationSum = 0;
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      const pi = child.point;
      _AnimBlendTreeCartesian2D._pip.set(_AnimBlendTreeCartesian2D._p.x, _AnimBlendTreeCartesian2D._p.y).sub(pi);
      let minj = Number.MAX_VALUE;
      for (let j = 0; j < this._children.length; j++) {
        if (i === j) continue;
        const pipj = this.pointDistanceCache(i, j);
        const result = math.clamp(1 - _AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0, 1);
        if (result < minj) minj = result;
      }
      child.weight = minj;
      weightSum += minj;
      if (this._syncAnimations) {
        weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
      }
    }
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      child.weight = child._weight / weightSum;
      if (this._syncAnimations) {
        child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
      }
    }
  }
};
AnimBlendTreeCartesian2D._p = new Vec2();
AnimBlendTreeCartesian2D._pip = new Vec2();

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree-2d-directional.js
var AnimBlendTreeDirectional2D = class _AnimBlendTreeDirectional2D extends AnimBlendTree {
  pointCache(i, j) {
    const pointKey = `${i}${j}`;
    if (!this._pointCache[pointKey]) {
      this._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2);
    }
    return this._pointCache[pointKey];
  }
  calculateWeights() {
    if (this.updateParameterValues()) return;
    let weightSum, weightedDurationSum;
    _AnimBlendTreeDirectional2D._p.set(...this._parameterValues);
    const pLength = _AnimBlendTreeDirectional2D._p.length();
    weightSum = 0;
    weightedDurationSum = 0;
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      const pi = child.point;
      const piLength = child.pointLength;
      let minj = Number.MAX_VALUE;
      for (let j = 0; j < this._children.length; j++) {
        if (i === j) continue;
        const pipj = this.pointCache(i, j);
        const pjLength = this._children[j].pointLength;
        _AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, _AnimBlendTreeDirectional2D._p) * 2);
        const result = math.clamp(1 - Math.abs(_AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0, 1);
        if (result < minj) minj = result;
      }
      child.weight = minj;
      weightSum += minj;
      if (this._syncAnimations) {
        weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
      }
    }
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      child.weight = child._weight / weightSum;
      if (this._syncAnimations) {
        const weightedChildDuration = child.animTrack.duration / weightedDurationSum * weightSum;
        child.weightedSpeed = child.absoluteSpeed * weightedChildDuration;
      }
    }
  }
};
AnimBlendTreeDirectional2D._p = new Vec2();
AnimBlendTreeDirectional2D._pip = new Vec2();

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree-direct.js
var AnimBlendTreeDirect = class extends AnimBlendTree {
  calculateWeights() {
    if (this.updateParameterValues()) return;
    let weightSum = 0;
    let weightedDurationSum = 0;
    for (let i = 0; i < this._children.length; i++) {
      weightSum += Math.max(this._parameterValues[i], 0);
      if (this._syncAnimations) {
        const child = this._children[i];
        weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
      }
    }
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      const weight = Math.max(this._parameterValues[i], 0);
      if (weightSum) {
        child.weight = weight / weightSum;
        if (this._syncAnimations) {
          child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
        }
      } else {
        child.weight = 0;
        if (this._syncAnimations) {
          child.weightedSpeed = 0;
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-state.js
var AnimState = class {
  constructor(controller, name, speed = 1, loop = true, blendTree) {
    this._animations = {};
    this._animationList = [];
    this._controller = controller;
    this._name = name;
    this._speed = speed;
    this._loop = loop;
    this._hasAnimations = false;
    if (blendTree) {
      this._blendTree = this._createTree(blendTree.type, this, null, name, 1, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, this._controller.findParameter);
    } else {
      this._blendTree = new AnimNode(this, null, name, 1, speed);
    }
  }
  _createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
    switch (type) {
      case ANIM_BLEND_1D:
        return new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
      case ANIM_BLEND_2D_CARTESIAN:
        return new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
      case ANIM_BLEND_2D_DIRECTIONAL:
        return new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
      case ANIM_BLEND_DIRECT:
        return new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
    }
    return void 0;
  }
  _getNodeFromPath(path2) {
    let currNode = this._blendTree;
    for (let i = 1; i < path2.length; i++) {
      currNode = currNode.getChild(path2[i]);
    }
    return currNode;
  }
  addAnimation(path2, animTrack) {
    const pathString = path2.join(".");
    const indexOfAnimation = this._animationList.findIndex((animation) => {
      return animation.path === pathString;
    });
    if (indexOfAnimation >= 0) {
      this._animationList[indexOfAnimation].animTrack = animTrack;
    } else {
      const node = this._getNodeFromPath(path2);
      node.animTrack = animTrack;
      this._animationList.push(node);
    }
    this._updateHasAnimations();
  }
  _updateHasAnimations() {
    this._hasAnimations = this._animationList.length > 0 && this._animationList.every((animation) => animation.animTrack && animation.animTrack !== AnimTrack.EMPTY);
  }
  get name() {
    return this._name;
  }
  set animations(value) {
    this._animationList = value;
    this._updateHasAnimations();
  }
  get animations() {
    return this._animationList;
  }
  get hasAnimations() {
    return this._hasAnimations;
  }
  set speed(value) {
    this._speed = value;
  }
  get speed() {
    return this._speed;
  }
  set loop(value) {
    this._loop = value;
  }
  get loop() {
    return this._loop;
  }
  get nodeCount() {
    if (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;
    return this._blendTree.getNodeCount();
  }
  get playable() {
    return ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
  }
  get looping() {
    if (this.animations.length > 0) {
      const trackClipName = `${this.name}.${this.animations[0].animTrack.name}`;
      const trackClip = this._controller.animEvaluator.findClip(trackClipName);
      if (trackClip) {
        return trackClip.loop;
      }
    }
    return false;
  }
  get totalWeight() {
    let sum = 0;
    for (let i = 0; i < this.animations.length; i++) {
      sum += this.animations[i].weight;
    }
    return sum;
  }
  get timelineDuration() {
    let duration = 0;
    for (let i = 0; i < this.animations.length; i++) {
      const animation = this.animations[i];
      if (animation.animTrack.duration > duration) {
        duration = animation.animTrack.duration;
      }
    }
    return duration;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-transition.js
var AnimTransition = class {
  constructor({
    from,
    to,
    time = 0,
    priority = 0,
    conditions = [],
    exitTime = null,
    transitionOffset = null,
    interruptionSource = ANIM_INTERRUPTION_NONE
  }) {
    this._from = from;
    this._to = to;
    this._time = time;
    this._priority = priority;
    this._conditions = conditions;
    this._exitTime = exitTime;
    this._transitionOffset = transitionOffset;
    this._interruptionSource = interruptionSource;
  }
  get from() {
    return this._from;
  }
  set to(value) {
    this._to = value;
  }
  get to() {
    return this._to;
  }
  get time() {
    return this._time;
  }
  get priority() {
    return this._priority;
  }
  get conditions() {
    return this._conditions;
  }
  get exitTime() {
    return this._exitTime;
  }
  get transitionOffset() {
    return this._transitionOffset;
  }
  get interruptionSource() {
    return this._interruptionSource;
  }
  get hasExitTime() {
    return !!this.exitTime;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-controller.js
var AnimController = class {
  constructor(animEvaluator, states, transitions, activate, eventHandler, findParameter, consumeTrigger) {
    this._states = {};
    this._stateNames = [];
    this._findTransitionsFromStateCache = {};
    this._findTransitionsBetweenStatesCache = {};
    this._previousStateName = null;
    this._activeStateName = ANIM_STATE_START;
    this._activeStateDuration = 0;
    this._activeStateDurationDirty = true;
    this._playing = false;
    this._activate = void 0;
    this._transitions = void 0;
    this._currTransitionTime = 1;
    this._totalTransitionTime = 1;
    this._isTransitioning = false;
    this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
    this._transitionPreviousStates = [];
    this._timeInState = 0;
    this._timeInStateBefore = 0;
    this.findParameter = (name) => {
      return this._findParameter(name);
    };
    this._animEvaluator = animEvaluator;
    this._eventHandler = eventHandler;
    this._findParameter = findParameter;
    this._consumeTrigger = consumeTrigger;
    for (let i = 0; i < states.length; i++) {
      this._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);
      this._stateNames.push(states[i].name);
    }
    this._transitions = transitions.map((transition) => {
      return new AnimTransition(_extends({}, transition));
    });
    this._activate = activate;
  }
  get animEvaluator() {
    return this._animEvaluator;
  }
  set activeState(stateName) {
    this._activeStateName = stateName;
  }
  get activeState() {
    return this._findState(this._activeStateName);
  }
  get activeStateName() {
    return this._activeStateName;
  }
  get activeStateAnimations() {
    return this.activeState.animations;
  }
  set previousState(stateName) {
    this._previousStateName = stateName;
  }
  get previousState() {
    return this._findState(this._previousStateName);
  }
  get previousStateName() {
    return this._previousStateName;
  }
  get playable() {
    let playable = true;
    for (let i = 0; i < this._stateNames.length; i++) {
      if (!this._states[this._stateNames[i]].playable) {
        playable = false;
      }
    }
    return playable;
  }
  set playing(value) {
    this._playing = value;
  }
  get playing() {
    return this._playing;
  }
  get activeStateProgress() {
    return this._getActiveStateProgressForTime(this._timeInState);
  }
  get activeStateDuration() {
    if (this._activeStateDurationDirty) {
      let maxDuration = 0;
      for (let i = 0; i < this.activeStateAnimations.length; i++) {
        const activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);
        if (activeClip) {
          maxDuration = Math.max(maxDuration, activeClip.track.duration);
        }
      }
      this._activeStateDuration = maxDuration;
      this._activeStateDurationDirty = false;
    }
    return this._activeStateDuration;
  }
  set activeStateCurrentTime(time) {
    this._timeInStateBefore = time;
    this._timeInState = time;
    for (let i = 0; i < this.activeStateAnimations.length; i++) {
      const clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);
      if (clip) {
        clip.time = time;
      }
    }
  }
  get activeStateCurrentTime() {
    return this._timeInState;
  }
  get transitioning() {
    return this._isTransitioning;
  }
  get transitionProgress() {
    return this._currTransitionTime / this._totalTransitionTime;
  }
  get states() {
    return this._stateNames;
  }
  assignMask(mask) {
    return this._animEvaluator.assignMask(mask);
  }
  _findState(stateName) {
    return this._states[stateName];
  }
  _getActiveStateProgressForTime(time) {
    if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) {
      return 1;
    }
    const activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
    if (activeClip) {
      return activeClip.progressForTime(time);
    }
    return null;
  }
  _findTransitionsFromState(stateName) {
    let transitions = this._findTransitionsFromStateCache[stateName];
    if (!transitions) {
      transitions = this._transitions.filter((transition) => {
        return transition.from === stateName;
      });
      sortPriority(transitions);
      this._findTransitionsFromStateCache[stateName] = transitions;
    }
    return transitions;
  }
  _findTransitionsBetweenStates(sourceStateName, destinationStateName) {
    let transitions = this._findTransitionsBetweenStatesCache[`${sourceStateName}->${destinationStateName}`];
    if (!transitions) {
      transitions = this._transitions.filter((transition) => {
        return transition.from === sourceStateName && transition.to === destinationStateName;
      });
      sortPriority(transitions);
      this._findTransitionsBetweenStatesCache[`${sourceStateName}->${destinationStateName}`] = transitions;
    }
    return transitions;
  }
  _transitionHasConditionsMet(transition) {
    const conditions = transition.conditions;
    for (let i = 0; i < conditions.length; i++) {
      const condition = conditions[i];
      const parameter = this._findParameter(condition.parameterName);
      switch (condition.predicate) {
        case ANIM_GREATER_THAN:
          if (!(parameter.value > condition.value)) return false;
          break;
        case ANIM_LESS_THAN:
          if (!(parameter.value < condition.value)) return false;
          break;
        case ANIM_GREATER_THAN_EQUAL_TO:
          if (!(parameter.value >= condition.value)) return false;
          break;
        case ANIM_LESS_THAN_EQUAL_TO:
          if (!(parameter.value <= condition.value)) return false;
          break;
        case ANIM_EQUAL_TO:
          if (!(parameter.value === condition.value)) return false;
          break;
        case ANIM_NOT_EQUAL_TO:
          if (!(parameter.value !== condition.value)) return false;
          break;
      }
    }
    return true;
  }
  _findTransition(from, to) {
    let transitions = [];
    if (from && to) {
      transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));
    } else {
      if (!this._isTransitioning) {
        transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
        transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
      } else {
        switch (this._transitionInterruptionSource) {
          case ANIM_INTERRUPTION_PREV:
            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
            transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
            break;
          case ANIM_INTERRUPTION_NEXT:
            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
            transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
            break;
          case ANIM_INTERRUPTION_PREV_NEXT:
            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
            transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
            break;
          case ANIM_INTERRUPTION_NEXT_PREV:
            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
            transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
            break;
        }
      }
    }
    transitions = transitions.filter((transition) => {
      if (transition.to === this.activeStateName) {
        return false;
      }
      if (transition.hasExitTime) {
        let progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);
        let progress = this._getActiveStateProgressForTime(this._timeInState);
        if (transition.exitTime < 1 && this.activeState.loop) {
          progressBefore -= Math.floor(progressBefore);
          progress -= Math.floor(progress);
        }
        if (progress === progressBefore) {
          if (progress !== transition.exitTime) {
            return null;
          }
        } else if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
          return null;
        }
      }
      return this._transitionHasConditionsMet(transition);
    });
    if (transitions.length > 0) {
      const transition = transitions[0];
      if (transition.to === ANIM_STATE_END) {
        const startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];
        transition.to = startTransition.to;
      }
      return transition;
    }
    return null;
  }
  updateStateFromTransition(transition) {
    let state;
    let animation;
    let clip;
    this.previousState = transition.from ? this.activeStateName : null;
    this.activeState = transition.to;
    this._activeStateDurationDirty = true;
    for (let i = 0; i < transition.conditions.length; i++) {
      const condition = transition.conditions[i];
      const parameter = this._findParameter(condition.parameterName);
      if (parameter.type === ANIM_PARAMETER_TRIGGER) {
        this._consumeTrigger(condition.parameterName);
      }
    }
    if (this.previousState) {
      if (!this._isTransitioning) {
        this._transitionPreviousStates = [];
      }
      this._transitionPreviousStates.push({
        name: this._previousStateName,
        weight: 1
      });
      const interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1);
      for (let i = 0; i < this._transitionPreviousStates.length; i++) {
        if (!this._isTransitioning) {
          this._transitionPreviousStates[i].weight = 1;
        } else if (i !== this._transitionPreviousStates.length - 1) {
          this._transitionPreviousStates[i].weight *= 1 - interpolatedTime;
        } else {
          this._transitionPreviousStates[i].weight = interpolatedTime;
        }
        state = this._findState(this._transitionPreviousStates[i].name);
        for (let j = 0; j < state.animations.length; j++) {
          animation = state.animations[j];
          clip = this._animEvaluator.findClip(`${animation.name}.previous.${i}`);
          if (!clip) {
            clip = this._animEvaluator.findClip(animation.name);
            clip.name = `${animation.name}.previous.${i}`;
          }
          if (i !== this._transitionPreviousStates.length - 1) {
            clip.pause();
          }
        }
      }
    }
    this._isTransitioning = true;
    this._totalTransitionTime = transition.time;
    this._currTransitionTime = 0;
    this._transitionInterruptionSource = transition.interruptionSource;
    const activeState = this.activeState;
    const hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0 && transition.transitionOffset < 1;
    let timeInState = 0;
    let timeInStateBefore = 0;
    if (hasTransitionOffset) {
      const offsetTime = activeState.timelineDuration * transition.transitionOffset;
      timeInState = offsetTime;
      timeInStateBefore = offsetTime;
    }
    this._timeInState = timeInState;
    this._timeInStateBefore = timeInStateBefore;
    for (let i = 0; i < activeState.animations.length; i++) {
      clip = this._animEvaluator.findClip(activeState.animations[i].name);
      if (!clip) {
        const speed = Number.isFinite(activeState.animations[i].speed) ? activeState.animations[i].speed : activeState.speed;
        clip = new AnimClip(activeState.animations[i].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);
        clip.name = activeState.animations[i].name;
        this._animEvaluator.addClip(clip);
      } else {
        clip.reset();
      }
      if (transition.time > 0) {
        clip.blendWeight = 0;
      } else {
        clip.blendWeight = activeState.animations[i].normalizedWeight;
      }
      clip.play();
      if (hasTransitionOffset) {
        clip.time = activeState.timelineDuration * transition.transitionOffset;
      } else {
        const startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
        clip.time = startTime;
      }
    }
  }
  _transitionToState(newStateName) {
    if (!this._findState(newStateName)) {
      return;
    }
    let transition = this._findTransition(this._activeStateName, newStateName);
    if (!transition) {
      this._animEvaluator.removeClips();
      transition = new AnimTransition({
        from: null,
        to: newStateName
      });
    }
    this.updateStateFromTransition(transition);
  }
  assignAnimation(pathString, animTrack, speed, loop) {
    const path2 = pathString.split(".");
    let state = this._findState(path2[0]);
    if (!state) {
      state = new AnimState(this, path2[0], speed);
      this._states[path2[0]] = state;
      this._stateNames.push(path2[0]);
    }
    state.addAnimation(path2, animTrack);
    this._animEvaluator.updateClipTrack(state.name, animTrack);
    if (speed !== void 0) {
      state.speed = speed;
    }
    if (loop !== void 0) {
      state.loop = loop;
    }
    if (!this._playing && this._activate && this.playable) {
      this.play();
    }
    this._activeStateDurationDirty = true;
  }
  removeNodeAnimations(nodeName) {
    if (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {
      return false;
    }
    const state = this._findState(nodeName);
    if (!state) {
      return false;
    }
    state.animations = [];
    return true;
  }
  play(stateName) {
    if (stateName) {
      this._transitionToState(stateName);
    }
    this._playing = true;
  }
  pause() {
    this._playing = false;
  }
  reset() {
    this._previousStateName = null;
    this._activeStateName = ANIM_STATE_START;
    this._playing = false;
    this._currTransitionTime = 1;
    this._totalTransitionTime = 1;
    this._isTransitioning = false;
    this._timeInState = 0;
    this._timeInStateBefore = 0;
    this._animEvaluator.removeClips();
  }
  rebind() {
    this._animEvaluator.rebind();
  }
  update(dt) {
    if (!this._playing) {
      return;
    }
    let state;
    let animation;
    let clip;
    if (this.activeState.loop || this._timeInState < this.activeStateDuration) {
      this._timeInStateBefore = this._timeInState;
      this._timeInState += dt * this.activeState.speed;
      if (!this.activeState.loop && this._timeInState > this.activeStateDuration) {
        this._timeInState = this.activeStateDuration;
        dt = this.activeStateDuration - this._timeInStateBefore;
      }
    }
    const transition = this._findTransition(this._activeStateName);
    if (transition) {
      this.updateStateFromTransition(transition);
    }
    if (this._isTransitioning) {
      this._currTransitionTime += dt;
      if (this._currTransitionTime <= this._totalTransitionTime) {
        const interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;
        for (let i = 0; i < this._transitionPreviousStates.length; i++) {
          state = this._findState(this._transitionPreviousStates[i].name);
          const stateWeight = this._transitionPreviousStates[i].weight;
          for (let j = 0; j < state.animations.length; j++) {
            animation = state.animations[j];
            clip = this._animEvaluator.findClip(`${animation.name}.previous.${i}`);
            if (clip) {
              clip.blendWeight = (1 - interpolatedTime) * animation.normalizedWeight * stateWeight;
            }
          }
        }
        state = this.activeState;
        for (let i = 0; i < state.animations.length; i++) {
          animation = state.animations[i];
          this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;
        }
      } else {
        this._isTransitioning = false;
        const activeClips = this.activeStateAnimations.length;
        const totalClips = this._animEvaluator.clips.length;
        for (let i = 0; i < totalClips - activeClips; i++) {
          this._animEvaluator.removeClip(0);
        }
        this._transitionPreviousStates = [];
        state = this.activeState;
        for (let i = 0; i < state.animations.length; i++) {
          animation = state.animations[i];
          clip = this._animEvaluator.findClip(animation.name);
          if (clip) {
            clip.blendWeight = animation.normalizedWeight;
          }
        }
      }
    } else {
      if (this.activeState._blendTree.constructor !== AnimNode) {
        state = this.activeState;
        for (let i = 0; i < state.animations.length; i++) {
          animation = state.animations[i];
          clip = this._animEvaluator.findClip(animation.name);
          if (clip) {
            clip.blendWeight = animation.normalizedWeight;
            if (animation.parent.syncAnimations) {
              clip.speed = animation.speed;
            }
          }
        }
      }
    }
    this._animEvaluator.update(dt, this.activeState.hasAnimations);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/anim/component-binder.js
var v2 = new Vec2();
var v3 = new Vec3();
var v4 = new Vec4();
var c = new Color();
var q2 = new Quat();
var AnimComponentBinder = class _AnimComponentBinder extends DefaultAnimBinder {
  constructor(animComponent, graph, layerName, mask, layerIndex) {
    super(graph);
    this.animComponent = animComponent;
    this._mask = mask;
    this.layerName = layerName;
    this.layerIndex = layerIndex;
  }
  static _packFloat(values) {
    return values[0];
  }
  static _packBoolean(values) {
    return !!values[0];
  }
  static _packVec2(values) {
    v2.x = values[0];
    v2.y = values[1];
    return v2;
  }
  static _packVec3(values) {
    v3.x = values[0];
    v3.y = values[1];
    v3.z = values[2];
    return v3;
  }
  static _packVec4(values) {
    v4.x = values[0];
    v4.y = values[1];
    v4.z = values[2];
    v4.w = values[3];
    return v4;
  }
  static _packColor(values) {
    c.r = values[0];
    c.g = values[1];
    c.b = values[2];
    c.a = values[3];
    return c;
  }
  static _packQuat(values) {
    q2.x = values[0];
    q2.y = values[1];
    q2.z = values[2];
    q2.w = values[3];
    return q2;
  }
  resolve(path2) {
    const encodedPath = AnimBinder.encode(path2.entityPath, path2.component, path2.propertyPath);
    let target2 = this.targetCache[encodedPath];
    if (target2) return target2;
    let entity;
    let propertyComponent;
    let targetPath;
    switch (path2.component) {
      case "entity":
        entity = this._getEntityFromHierarchy(path2.entityPath);
        targetPath = AnimBinder.encode(entity.path, "entity", path2.propertyPath);
        propertyComponent = entity;
        break;
      case "graph":
        propertyComponent = this.findNode(path2);
        if (!propertyComponent) return null;
        targetPath = AnimBinder.encode(propertyComponent.path, "graph", path2.propertyPath);
        break;
      default:
        entity = this._getEntityFromHierarchy(path2.entityPath);
        propertyComponent = entity.findComponent(path2.component);
        if (!propertyComponent) {
          return null;
        }
        targetPath = AnimBinder.encode(entity.path, path2.component, path2.propertyPath);
        break;
    }
    target2 = this._createAnimTargetForProperty(propertyComponent, path2.propertyPath, targetPath);
    this.targetCache[encodedPath] = target2;
    return target2;
  }
  update(deltaTime) {
    const activeNodes = this.activeNodes;
    if (activeNodes) {
      for (let i = 0; i < activeNodes.length; i++) {
        activeNodes[i]._dirtifyLocal();
      }
    }
  }
  _getEntityFromHierarchy(entityHierarchy) {
    if (!this.animComponent.entity.name === entityHierarchy[0]) {
      return null;
    }
    const currEntity = this.animComponent.entity;
    if (entityHierarchy.length === 1) {
      return currEntity;
    }
    return currEntity._parent.findByPath(entityHierarchy);
  }
  _resolvePath(object, path2, resolveLeaf) {
    const steps = path2.length - (resolveLeaf ? 0 : 1);
    for (let i = 0; i < steps; i++) {
      object = object[path2[i]];
    }
    return object;
  }
  _setter(object, path2, packFunc) {
    const obj = this._resolvePath(object, path2);
    const key = path2[path2.length - 1];
    const setterFuncName = `set${key.substring(0, 1).toUpperCase()}${key.substring(1)}`;
    if (obj[setterFuncName]) {
      const getterFunc = obj[`get${key.substring(0, 1).toUpperCase()}${key.substring(1)}`].bind(obj);
      let baseValues = getterFunc();
      baseValues = [baseValues.x, baseValues.y, baseValues.z, baseValues.w];
      const setterFunc = obj[setterFuncName].bind(obj);
      return {
        set: (values) => {
          setterFunc(packFunc(values));
        },
        get: () => baseValues
      };
    }
    const prop = obj[key];
    if (typeof prop === "object" && prop.hasOwnProperty("copy")) {
      return function(values) {
        prop.copy(packFunc(values));
      };
    }
    if ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path2.length > 1) {
      const parent = path2.length > 2 ? this._resolvePath(object, path2.slice(0, -1)) : object;
      const objKey = path2[path2.length - 2];
      return function(values) {
        obj[key] = packFunc(values);
        parent[objKey] = obj;
      };
    }
    return function(values) {
      obj[key] = packFunc(values);
    };
  }
  _createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {
    if (this.handlers && propertyHierarchy[0].startsWith("weight.")) {
      return this.handlers.weight(propertyComponent, propertyHierarchy[0].replace("weight.", ""));
    } else if (this.handlers && propertyHierarchy[0] === "material" && propertyHierarchy.length === 2) {
      const materialPropertyName = propertyHierarchy[1];
      if (materialPropertyName.endsWith("Map")) {
        return this.handlers.materialTexture(propertyComponent, materialPropertyName);
      }
    }
    const property = this._resolvePath(propertyComponent, propertyHierarchy, true);
    if (typeof property === "undefined") {
      return null;
    }
    let setter;
    let animDataType;
    let animDataComponents;
    if (typeof property === "number") {
      setter = this._setter(propertyComponent, propertyHierarchy, _AnimComponentBinder._packFloat);
      animDataType = "vector";
      animDataComponents = 1;
    } else if (typeof property === "boolean") {
      setter = this._setter(propertyComponent, propertyHierarchy, _AnimComponentBinder._packBoolean);
      animDataType = "vector";
      animDataComponents = 1;
    } else if (typeof property === "object") {
      switch (property.constructor) {
        case Vec2:
          setter = this._setter(propertyComponent, propertyHierarchy, _AnimComponentBinder._packVec2);
          animDataType = "vector";
          animDataComponents = 2;
          break;
        case Vec3:
          setter = this._setter(propertyComponent, propertyHierarchy, _AnimComponentBinder._packVec3);
          animDataType = "vector";
          animDataComponents = 3;
          break;
        case Vec4:
          setter = this._setter(propertyComponent, propertyHierarchy, _AnimComponentBinder._packVec4);
          animDataType = "vector";
          animDataComponents = 4;
          break;
        case Color:
          setter = this._setter(propertyComponent, propertyHierarchy, _AnimComponentBinder._packColor);
          animDataType = "vector";
          animDataComponents = 4;
          break;
        case Quat:
          setter = this._setter(propertyComponent, propertyHierarchy, _AnimComponentBinder._packQuat);
          animDataType = "quaternion";
          animDataComponents = 4;
          break;
        default:
          return null;
      }
    }
    if (propertyHierarchy.indexOf("material") !== -1) {
      return new AnimTarget((values) => {
        setter(values);
        propertyComponent.material.update();
      }, animDataType, animDataComponents, targetPath);
    }
    return new AnimTarget(setter, animDataType, animDataComponents, targetPath);
  }
  rebind() {
    this.targetCache = {};
    if (this.animComponent.rootBone) {
      this.graph = this.animComponent.rootBone;
    } else {
      this.graph = this.animComponent.entity;
    }
    const nodes = {};
    const flatten = function flatten2(node) {
      nodes[node.name] = node;
      for (let i = 0; i < node.children.length; ++i) {
        flatten2(node.children[i]);
      }
    };
    flatten(this.graph);
    this.nodes = nodes;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/anim/component-layer.js
var AnimComponentLayer = class {
  constructor(name, controller, component, weight = 1, blendType = ANIM_LAYER_OVERWRITE) {
    this._name = void 0;
    this._controller = void 0;
    this._component = void 0;
    this._weight = void 0;
    this._blendType = void 0;
    this._mask = null;
    this._blendTime = 0;
    this._blendTimeElapsed = 0;
    this._startingWeight = 0;
    this._targetWeight = 0;
    this._name = name;
    this._controller = controller;
    this._component = component;
    this._weight = weight;
    this._blendType = blendType;
  }
  get name() {
    return this._name;
  }
  set playing(value) {
    this._controller.playing = value;
  }
  get playing() {
    return this._controller.playing;
  }
  get playable() {
    return this._controller.playable;
  }
  get activeState() {
    return this._controller.activeStateName;
  }
  get previousState() {
    return this._controller.previousStateName;
  }
  get activeStateProgress() {
    return this._controller.activeStateProgress;
  }
  get activeStateDuration() {
    return this._controller.activeStateDuration;
  }
  set activeStateCurrentTime(time) {
    const controller = this._controller;
    const layerPlaying = controller.playing;
    controller.playing = true;
    controller.activeStateCurrentTime = time;
    if (!layerPlaying) {
      controller.update(0);
    }
    controller.playing = layerPlaying;
  }
  get activeStateCurrentTime() {
    return this._controller.activeStateCurrentTime;
  }
  get transitioning() {
    return this._controller.transitioning;
  }
  get transitionProgress() {
    if (this.transitioning) {
      return this._controller.transitionProgress;
    }
    return null;
  }
  get states() {
    return this._controller.states;
  }
  set weight(value) {
    this._weight = value;
    this._component.dirtifyTargets();
  }
  get weight() {
    return this._weight;
  }
  set blendType(value) {
    if (value !== this._blendType) {
      this._blendType = value;
      if (this._controller.normalizeWeights) {
        this._component.rebind();
      }
    }
  }
  get blendType() {
    return this._blendType;
  }
  set mask(value) {
    if (this._controller.assignMask(value)) {
      this._component.rebind();
    }
    this._mask = value;
  }
  get mask() {
    return this._mask;
  }
  play(name) {
    this._controller.play(name);
  }
  pause() {
    this._controller.pause();
  }
  reset() {
    this._controller.reset();
  }
  rebind() {
    this._controller.rebind();
  }
  update(dt) {
    if (this._blendTime) {
      if (this._blendTimeElapsed < this._blendTime) {
        this.weight = math.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime);
        this._blendTimeElapsed += dt;
      } else {
        this.weight = this._targetWeight;
        this._blendTime = 0;
        this._blendTimeElapsed = 0;
        this._startingWeight = 0;
        this._targetWeight = 0;
      }
    }
    this._controller.update(dt);
  }
  blendToWeight(weight, time) {
    this._startingWeight = this.weight;
    this._targetWeight = weight;
    this._blendTime = Math.max(0, time);
    this._blendTimeElapsed = 0;
  }
  assignAnimation(nodePath, animTrack, speed, loop) {
    if (!(animTrack instanceof AnimTrack)) {
      return;
    }
    this._controller.assignAnimation(nodePath, animTrack, speed, loop);
    if (this._controller._transitions.length === 0) {
      this._controller._transitions.push(new AnimTransition({
        from: "START",
        to: nodePath
      }));
    }
    if (this._component.activate && this._component.playable) {
      this._component.playing = true;
    }
  }
  removeNodeAnimations(nodeName) {
    if (this._controller.removeNodeAnimations(nodeName)) {
      this._component.playing = false;
    }
  }
  getAnimationAsset(stateName) {
    return this._component.animationAssets[`${this.name}:${stateName}`];
  }
  transition(to, time = 0, transitionOffset = null) {
    this._controller.updateStateFromTransition(new AnimTransition({
      from: this._controller.activeStateName,
      to,
      time,
      transitionOffset
    }));
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/state-graph/anim-state-graph.js
var AnimStateGraph = class {
  constructor(data2) {
    this._layers = [];
    this._parameters = {};
    if (!Array.isArray(data2.layers)) {
      for (const layerId in data2.layers) {
        const dataLayer = data2.layers[layerId];
        const layer = {
          name: dataLayer.name,
          blendType: dataLayer.blendType,
          weight: dataLayer.weight,
          states: [],
          transitions: []
        };
        for (let i = 0; i < dataLayer.states.length; i++) {
          layer.states.push(data2.states[dataLayer.states[i]]);
        }
        for (let i = 0; i < dataLayer.transitions.length; i++) {
          const dataLayerTransition = data2.transitions[dataLayer.transitions[i]];
          if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
            const conditionKeys = Object.keys(dataLayerTransition.conditions);
            const conditions = [];
            for (let j = 0; j < conditionKeys.length; j++) {
              const condition = dataLayerTransition.conditions[conditionKeys[j]];
              if (condition.parameterName) {
                conditions.push(condition);
              }
            }
            dataLayerTransition.conditions = conditions;
          }
          if (Number.isInteger(dataLayerTransition.from)) {
            dataLayerTransition.from = data2.states[dataLayerTransition.from].name;
          }
          if (Number.isInteger(dataLayerTransition.to)) {
            dataLayerTransition.to = data2.states[dataLayerTransition.to].name;
          }
          layer.transitions.push(dataLayerTransition);
        }
        this._layers.push(layer);
      }
    } else {
      this._layers = data2.layers;
    }
    for (const paramId in data2.parameters) {
      const param = data2.parameters[paramId];
      this._parameters[param.name] = {
        type: param.type,
        value: param.value
      };
    }
  }
  get parameters() {
    return Object.assign({}, this._parameters);
  }
  get layers() {
    return this._layers;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/anim/component.js
var AnimComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this.findParameter = (name) => {
      return this._parameters[name];
    };
    this.consumeTrigger = (name) => {
      this._consumedTriggers.add(name);
    };
    this._stateGraphAsset = null;
    this._animationAssets = {};
    this._speed = 1;
    this._activate = true;
    this._playing = false;
    this._rootBone = null;
    this._stateGraph = null;
    this._layers = [];
    this._layerIndices = {};
    this._parameters = {};
    this._targets = {};
    this._consumedTriggers = /* @__PURE__ */ new Set();
    this._normalizeWeights = false;
  }
  set stateGraphAsset(value) {
    if (value === null) {
      this.removeStateGraph();
      return;
    }
    if (this._stateGraphAsset) {
      const stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
      stateGraphAsset.off("change", this._onStateGraphAssetChangeEvent, this);
    }
    let _id;
    let _asset;
    if (value instanceof Asset) {
      _id = value.id;
      _asset = this.system.app.assets.get(_id);
      if (!_asset) {
        this.system.app.assets.add(value);
        _asset = this.system.app.assets.get(_id);
      }
    } else {
      _id = value;
      _asset = this.system.app.assets.get(_id);
    }
    if (!_asset || this._stateGraphAsset === _id) {
      return;
    }
    if (_asset.resource) {
      this._stateGraph = _asset.resource;
      this.loadStateGraph(this._stateGraph);
      _asset.on("change", this._onStateGraphAssetChangeEvent, this);
    } else {
      _asset.once("load", (asset) => {
        this._stateGraph = asset.resource;
        this.loadStateGraph(this._stateGraph);
      });
      _asset.on("change", this._onStateGraphAssetChangeEvent, this);
      this.system.app.assets.load(_asset);
    }
    this._stateGraphAsset = _id;
  }
  get stateGraphAsset() {
    return this._stateGraphAsset;
  }
  set normalizeWeights(value) {
    this._normalizeWeights = value;
    this.unbind();
  }
  get normalizeWeights() {
    return this._normalizeWeights;
  }
  set animationAssets(value) {
    this._animationAssets = value;
    this.loadAnimationAssets();
  }
  get animationAssets() {
    return this._animationAssets;
  }
  set speed(value) {
    this._speed = value;
  }
  get speed() {
    return this._speed;
  }
  set activate(value) {
    this._activate = value;
  }
  get activate() {
    return this._activate;
  }
  set playing(value) {
    this._playing = value;
  }
  get playing() {
    return this._playing;
  }
  set rootBone(value) {
    if (typeof value === "string") {
      const entity = this.entity.root.findByGuid(value);
      this._rootBone = entity;
    } else if (value instanceof Entity) {
      this._rootBone = value;
    } else {
      this._rootBone = null;
    }
    this.rebind();
  }
  get rootBone() {
    return this._rootBone;
  }
  set stateGraph(value) {
    this._stateGraph = value;
  }
  get stateGraph() {
    return this._stateGraph;
  }
  get layers() {
    return this._layers;
  }
  set layerIndices(value) {
    this._layerIndices = value;
  }
  get layerIndices() {
    return this._layerIndices;
  }
  set parameters(value) {
    this._parameters = value;
  }
  get parameters() {
    return this._parameters;
  }
  set targets(value) {
    this._targets = value;
  }
  get targets() {
    return this._targets;
  }
  get playable() {
    for (let i = 0; i < this._layers.length; i++) {
      if (!this._layers[i].playable) {
        return false;
      }
    }
    return true;
  }
  get baseLayer() {
    if (this._layers.length > 0) {
      return this._layers[0];
    }
    return null;
  }
  _onStateGraphAssetChangeEvent(asset) {
    const prevAnimationAssets = this.animationAssets;
    const prevMasks = this.layers.map((layer) => layer.mask);
    this.removeStateGraph();
    this._stateGraph = new AnimStateGraph(asset._data);
    this.loadStateGraph(this._stateGraph);
    this.animationAssets = prevAnimationAssets;
    this.loadAnimationAssets();
    this.layers.forEach((layer, i) => {
      layer.mask = prevMasks[i];
    });
    this.rebind();
  }
  dirtifyTargets() {
    const targets = Object.values(this._targets);
    for (let i = 0; i < targets.length; i++) {
      targets[i].dirty = true;
    }
  }
  _addLayer({
    name,
    states,
    transitions,
    weight,
    mask,
    blendType
  }) {
    let graph;
    if (this.rootBone) {
      graph = this.rootBone;
    } else {
      graph = this.entity;
    }
    const layerIndex = this._layers.length;
    const animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);
    const animEvaluator = new AnimEvaluator(animBinder);
    const controller = new AnimController(animEvaluator, states, transitions, this._activate, this, this.findParameter, this.consumeTrigger);
    this._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));
    this._layerIndices[name] = layerIndex;
    return this._layers[layerIndex];
  }
  addLayer(name, weight, mask, blendType) {
    const layer = this.findAnimationLayer(name);
    if (layer) return layer;
    const states = [{
      "name": "START",
      "speed": 1
    }];
    const transitions = [];
    return this._addLayer({
      name,
      states,
      transitions,
      weight,
      mask,
      blendType
    });
  }
  _assignParameters(stateGraph) {
    this._parameters = {};
    const paramKeys = Object.keys(stateGraph.parameters);
    for (let i = 0; i < paramKeys.length; i++) {
      const paramKey = paramKeys[i];
      this._parameters[paramKey] = {
        type: stateGraph.parameters[paramKey].type,
        value: stateGraph.parameters[paramKey].value
      };
    }
  }
  loadStateGraph(stateGraph) {
    this._stateGraph = stateGraph;
    this._assignParameters(stateGraph);
    this._layers = [];
    let containsBlendTree = false;
    for (let i = 0; i < stateGraph.layers.length; i++) {
      const layer = stateGraph.layers[i];
      this._addLayer(_extends({}, layer));
      if (layer.states.some((state) => state.blendTree)) {
        containsBlendTree = true;
      }
    }
    if (!containsBlendTree) {
      this.setupAnimationAssets();
    }
  }
  setupAnimationAssets() {
    for (let i = 0; i < this._layers.length; i++) {
      const layer = this._layers[i];
      const layerName = layer.name;
      for (let j = 0; j < layer.states.length; j++) {
        const stateName = layer.states[j];
        if (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {
          const stateKey = `${layerName}:${stateName}`;
          if (!this._animationAssets[stateKey]) {
            this._animationAssets[stateKey] = {
              asset: null
            };
          }
        }
      }
    }
    this.loadAnimationAssets();
  }
  loadAnimationAssets() {
    for (let i = 0; i < this._layers.length; i++) {
      const layer = this._layers[i];
      for (let j = 0; j < layer.states.length; j++) {
        const stateName = layer.states[j];
        if (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;
        const animationAsset = this._animationAssets[`${layer.name}:${stateName}`];
        if (!animationAsset || !animationAsset.asset) {
          this.findAnimationLayer(layer.name).assignAnimation(stateName, AnimTrack.EMPTY);
          continue;
        }
        const assetId = animationAsset.asset;
        const asset = this.system.app.assets.get(assetId);
        if (asset) {
          if (asset.resource) {
            this.onAnimationAssetLoaded(layer.name, stateName, asset);
          } else {
            asset.once("load", (function(layerName, stateName2) {
              return (function(asset2) {
                this.onAnimationAssetLoaded(layerName, stateName2, asset2);
              }).bind(this);
            }).bind(this)(layer.name, stateName));
            this.system.app.assets.load(asset);
          }
        }
      }
    }
  }
  onAnimationAssetLoaded(layerName, stateName, asset) {
    this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);
  }
  removeStateGraph() {
    this._stateGraph = null;
    this._stateGraphAsset = null;
    this._animationAssets = {};
    this._layers = [];
    this._layerIndices = {};
    this._parameters = {};
    this._playing = false;
    this.unbind();
    this._targets = {};
  }
  reset() {
    this._assignParameters(this._stateGraph);
    for (let i = 0; i < this._layers.length; i++) {
      const layerPlaying = this._layers[i].playing;
      this._layers[i].reset();
      this._layers[i].playing = layerPlaying;
    }
  }
  unbind() {
    if (!this._normalizeWeights) {
      Object.keys(this._targets).forEach((targetKey) => {
        this._targets[targetKey].unbind();
      });
    }
  }
  rebind() {
    this._targets = {};
    for (let i = 0; i < this._layers.length; i++) {
      this._layers[i].rebind();
    }
  }
  findAnimationLayer(name) {
    const layerIndex = this._layerIndices[name];
    return this._layers[layerIndex] || null;
  }
  addAnimationState(nodeName, animTrack, speed = 1, loop = true, layerName = "Base") {
    if (!this._stateGraph) {
      this.loadStateGraph(new AnimStateGraph({
        "layers": [{
          "name": layerName,
          "states": [{
            "name": "START",
            "speed": 1
          }, {
            "name": nodeName,
            "speed": speed,
            "loop": loop,
            "defaultState": true
          }],
          "transitions": [{
            "from": "START",
            "to": nodeName
          }]
        }],
        "parameters": {}
      }));
    }
    const layer = this.findAnimationLayer(layerName);
    if (layer) {
      layer.assignAnimation(nodeName, animTrack, speed, loop);
    } else {
      var _this$addLayer;
      (_this$addLayer = this.addLayer(layerName)) == null || _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);
    }
  }
  assignAnimation(nodePath, animTrack, layerName, speed = 1, loop = true) {
    if (!this._stateGraph && nodePath.indexOf(".") === -1) {
      this.loadStateGraph(new AnimStateGraph({
        "layers": [{
          "name": "Base",
          "states": [{
            "name": "START",
            "speed": 1
          }, {
            "name": nodePath,
            "speed": speed,
            "loop": loop,
            "defaultState": true
          }],
          "transitions": [{
            "from": "START",
            "to": nodePath
          }]
        }],
        "parameters": {}
      }));
      this.baseLayer.assignAnimation(nodePath, animTrack);
      return;
    }
    const layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
    if (!layer) {
      return;
    }
    layer.assignAnimation(nodePath, animTrack, speed, loop);
  }
  removeNodeAnimations(nodeName, layerName) {
    const layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
    if (!layer) {
      return;
    }
    layer.removeNodeAnimations(nodeName);
  }
  getParameterValue(name, type) {
    const param = this._parameters[name];
    if (param && param.type === type) {
      return param.value;
    }
    return void 0;
  }
  setParameterValue(name, type, value) {
    const param = this._parameters[name];
    if (param && param.type === type) {
      param.value = value;
      return;
    }
  }
  getFloat(name) {
    return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
  }
  setFloat(name, value) {
    this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
  }
  getInteger(name) {
    return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
  }
  setInteger(name, value) {
    if (typeof value === "number" && value % 1 === 0) {
      this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
    }
  }
  getBoolean(name) {
    return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
  }
  setBoolean(name, value) {
    this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
  }
  getTrigger(name) {
    return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
  }
  setTrigger(name, singleFrame = false) {
    this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);
    if (singleFrame) {
      this._consumedTriggers.add(name);
    }
  }
  resetTrigger(name) {
    this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
  }
  onBeforeRemove() {
    if (Number.isFinite(this._stateGraphAsset)) {
      const stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
      stateGraphAsset.off("change", this._onStateGraphAssetChangeEvent, this);
    }
  }
  update(dt) {
    for (let i = 0; i < this.layers.length; i++) {
      this.layers[i].update(dt * this.speed);
    }
    this._consumedTriggers.forEach((trigger) => {
      this.parameters[trigger].value = false;
    });
    this._consumedTriggers.clear();
  }
  resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {
    if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {
      this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];
    } else {
      this.rebind();
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/anim/data.js
var AnimComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/anim/system.js
var _schema2 = ["enabled"];
var AnimComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "anim";
    this.ComponentType = AnimComponent;
    this.DataType = AnimComponentData;
    this.schema = _schema2;
    this.on("beforeremove", this.onBeforeRemove, this);
    this.app.systems.on("animationUpdate", this.onAnimationUpdate, this);
  }
  initializeComponentData(component, data2, properties3) {
    super.initializeComponentData(component, data2, _schema2);
    const complexProperties = ["animationAssets", "stateGraph", "layers", "masks"];
    Object.keys(data2).forEach((key) => {
      if (complexProperties.includes(key)) return;
      component[key] = data2[key];
    });
    if (data2.stateGraph) {
      component.stateGraph = data2.stateGraph;
      component.loadStateGraph(component.stateGraph);
    }
    if (data2.layers) {
      data2.layers.forEach((layer, i) => {
        layer._controller.states.forEach((stateKey) => {
          layer._controller._states[stateKey]._animationList.forEach((node) => {
            if (!node.animTrack || node.animTrack === AnimTrack.EMPTY) {
              const animationAsset = this.app.assets.get(layer._component._animationAssets[`${layer.name}:${node.name}`].asset);
              if (animationAsset && !animationAsset.loaded) {
                animationAsset.once("load", () => {
                  component.layers[i].assignAnimation(node.name, animationAsset.resource);
                });
              }
            } else {
              component.layers[i].assignAnimation(node.name, node.animTrack);
            }
          });
        });
      });
    }
    if (data2.animationAssets) {
      component.animationAssets = Object.assign(component.animationAssets, data2.animationAssets);
    }
    if (data2.masks) {
      Object.keys(data2.masks).forEach((key) => {
        if (component.layers[key]) {
          const maskData = data2.masks[key].mask;
          const mask = {};
          Object.keys(maskData).forEach((maskKey) => {
            mask[decodeURI(maskKey)] = maskData[maskKey];
          });
          component.layers[key].mask = mask;
        }
      });
    }
  }
  onAnimationUpdate(dt) {
    const components2 = this.store;
    for (const id13 in components2) {
      if (components2.hasOwnProperty(id13)) {
        const component = components2[id13].entity.anim;
        const componentData = component.data;
        if (componentData.enabled && component.entity.enabled && component.playing) {
          component.update(dt);
        }
      }
    }
  }
  cloneComponent(entity, clone) {
    let masks;
    if (!entity.anim.rootBone || entity.anim.rootBone === entity) {
      masks = {};
      entity.anim.layers.forEach((layer, i) => {
        if (layer.mask) {
          const mask = {};
          Object.keys(layer.mask).forEach((path2) => {
            const pathArr = path2.split("/");
            pathArr.shift();
            const clonePath = [clone.name, ...pathArr].join("/");
            mask[clonePath] = layer.mask[path2];
          });
          masks[i] = {
            mask
          };
        }
      });
    }
    const data2 = {
      stateGraphAsset: entity.anim.stateGraphAsset,
      animationAssets: entity.anim.animationAssets,
      speed: entity.anim.speed,
      activate: entity.anim.activate,
      playing: entity.anim.playing,
      rootBone: entity.anim.rootBone,
      stateGraph: entity.anim.stateGraph,
      layers: entity.anim.layers,
      layerIndices: entity.anim.layerIndices,
      parameters: entity.anim.parameters,
      normalizeWeights: entity.anim.normalizeWeights,
      masks
    };
    return this.addComponent(clone, data2);
  }
  onBeforeRemove(entity, component) {
    component.onBeforeRemove();
  }
  destroy() {
    super.destroy();
    this.app.systems.off("animationUpdate", this.onAnimationUpdate, this);
  }
};
Component._buildAccessors(AnimComponent.prototype, _schema2);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/audio-listener/component.js
var AudioListenerComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
  }
  setCurrentListener() {
    if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
      this.system.current = this.entity;
      const position3 = this.system.current.getPosition();
      this.system.manager.listener.setPosition(position3);
    }
  }
  onEnable() {
    this.setCurrentListener();
  }
  onDisable() {
    if (this.system.current === this.entity) {
      this.system.current = null;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/audio-listener/data.js
var AudioListenerComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/audio-listener/system.js
var _schema3 = ["enabled"];
var AudioListenerComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "audiolistener";
    this.ComponentType = AudioListenerComponent;
    this.DataType = AudioListenerComponentData;
    this.schema = _schema3;
    this.manager = app2.soundManager;
    this.current = null;
    this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(component, data2, properties3) {
    properties3 = ["enabled"];
    super.initializeComponentData(component, data2, properties3);
  }
  onUpdate(dt) {
    if (this.current) {
      const position3 = this.current.getPosition();
      this.manager.listener.setPosition(position3);
      const wtm = this.current.getWorldTransform();
      this.manager.listener.setOrientation(wtm);
    }
  }
  destroy() {
    super.destroy();
    this.app.systems.off("update", this.onUpdate, this);
  }
};
Component._buildAccessors(AudioListenerComponent.prototype, _schema3);

// ../node_modules/playcanvas/build/playcanvas/src/framework/utils/entity-reference.js
var EntityReference = class extends EventHandler {
  constructor(parentComponent, entityPropertyName, eventConfig) {
    super();
    if (!parentComponent || !(parentComponent instanceof Component)) {
      throw new Error("The parentComponent argument is required and must be a Component");
    } else if (!entityPropertyName || typeof entityPropertyName !== "string") {
      throw new Error("The propertyName argument is required and must be a string");
    } else if (eventConfig && typeof eventConfig !== "object") {
      throw new Error("If provided, the eventConfig argument must be an object");
    }
    this._parentComponent = parentComponent;
    this._entityPropertyName = entityPropertyName;
    this._entity = null;
    this._app = parentComponent.system.app;
    this._configureEventListeners(eventConfig || {}, {
      "entity#destroy": this._onEntityDestroy
    });
    this._toggleLifecycleListeners("on");
  }
  _configureEventListeners(externalEventConfig, internalEventConfig) {
    const externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, "external", this._parentComponent);
    const internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, "internal", this);
    this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
    this._listenerStatusFlags = {};
    this._gainListeners = {};
    this._loseListeners = {};
  }
  _parseEventListenerConfig(eventConfig, prefix, scope) {
    return Object.keys(eventConfig).map((listenerDescription, index) => {
      const listenerDescriptionParts = listenerDescription.split("#");
      const sourceName = listenerDescriptionParts[0];
      const eventName = listenerDescriptionParts[1];
      const callback = eventConfig[listenerDescription];
      if (listenerDescriptionParts.length !== 2 || typeof sourceName !== "string" || sourceName.length === 0 || typeof eventName !== "string" || eventName.length === 0) {
        throw new Error(`Invalid event listener description: \`${listenerDescription}\``);
      }
      if (typeof callback !== "function") {
        throw new Error(`Invalid or missing callback for event listener \`${listenerDescription}\``);
      }
      return {
        id: `${prefix}_${index}_${listenerDescription}`,
        sourceName,
        eventName,
        callback,
        scope
      };
    }, this);
  }
  _toggleLifecycleListeners(onOrOff) {
    this._parentComponent[onOrOff](`set_${this._entityPropertyName}`, this._onSetEntity, this);
    this._parentComponent.system[onOrOff]("beforeremove", this._onParentComponentRemove, this);
    this._app.systems[onOrOff]("postPostInitialize", this._updateEntityReference, this);
    this._app[onOrOff]("tools:sceneloaded", this._onSceneLoaded, this);
    const allComponentSystems = [];
    for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
      const config = this._eventListenerConfigs[i];
      const componentSystem = this._app.systems[config.sourceName];
      if (componentSystem) {
        if (allComponentSystems.indexOf(componentSystem) === -1) {
          allComponentSystems.push(componentSystem);
        }
        if (componentSystem && config.eventName === "gain") {
          this._gainListeners[config.sourceName] = config;
        }
        if (componentSystem && config.eventName === "lose") {
          this._loseListeners[config.sourceName] = config;
        }
      }
    }
    for (let i = 0; i < allComponentSystems.length; ++i) {
      allComponentSystems[i][onOrOff]("add", this._onComponentAdd, this);
      allComponentSystems[i][onOrOff]("beforeremove", this._onComponentRemove, this);
    }
  }
  _onSetEntity(name, oldValue, newValue) {
    if (newValue instanceof Entity) {
      this._updateEntityReference();
    } else {
      if (newValue !== null && newValue !== void 0 && typeof newValue !== "string") {
        console.warn(`Entity field \`${this._entityPropertyName}\` was set to unexpected type '${typeof newValue}'`);
        return;
      }
      if (oldValue !== newValue) {
        this._updateEntityReference();
      }
    }
  }
  onParentComponentEnable() {
    if (!this._entity) {
      this._updateEntityReference();
    }
  }
  _onSceneLoaded() {
    this._updateEntityReference();
  }
  _updateEntityReference() {
    let nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
    let nextEntity;
    if (nextEntityGuid instanceof Entity) {
      nextEntity = nextEntityGuid;
      nextEntityGuid = nextEntity.getGuid();
      this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
    } else {
      const root = this._parentComponent.system.app.root;
      const isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);
      nextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;
    }
    const hasChanged = this._entity !== nextEntity;
    if (hasChanged) {
      if (this._entity) {
        this._onBeforeEntityChange();
      }
      this._entity = nextEntity;
      if (this._entity) {
        this._onAfterEntityChange();
      }
      this.fire("set:entity", this._entity);
    }
  }
  _onBeforeEntityChange() {
    this._toggleEntityListeners("off");
    this._callAllGainOrLoseListeners(this._loseListeners);
  }
  _onAfterEntityChange() {
    this._toggleEntityListeners("on");
    this._callAllGainOrLoseListeners(this._gainListeners);
  }
  _onComponentAdd(entity, component) {
    const componentName = component.system.id;
    if (entity === this._entity) {
      this._callGainOrLoseListener(componentName, this._gainListeners);
      this._toggleComponentListeners("on", componentName);
    }
  }
  _onComponentRemove(entity, component) {
    const componentName = component.system.id;
    if (entity === this._entity) {
      this._callGainOrLoseListener(componentName, this._loseListeners);
      this._toggleComponentListeners("off", componentName, true);
    }
  }
  _callAllGainOrLoseListeners(listenerMap) {
    for (const componentName in this._entity.c) {
      this._callGainOrLoseListener(componentName, listenerMap);
    }
  }
  _callGainOrLoseListener(componentName, listenerMap) {
    if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
      const config = listenerMap[componentName];
      config.callback.call(config.scope);
    }
  }
  _toggleEntityListeners(onOrOff, isDestroying) {
    if (this._entity) {
      for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
        this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
      }
    }
  }
  _toggleComponentListeners(onOrOff, componentName, isDestroying) {
    for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
      const config = this._eventListenerConfigs[i];
      if (config.sourceName === componentName) {
        this._safeToggleListener(onOrOff, config, isDestroying);
      }
    }
  }
  _safeToggleListener(onOrOff, config, isDestroying) {
    const isAdding = onOrOff === "on";
    if (isAdding && this._listenerStatusFlags[config.id]) {
      return;
    }
    const source = this._getEventSource(config.sourceName, isDestroying);
    if (source) {
      source[onOrOff](config.eventName, config.callback, config.scope);
      this._listenerStatusFlags[config.id] = isAdding;
    }
  }
  _getEventSource(sourceName, isDestroying) {
    if (sourceName === "entity") {
      return this._entity;
    }
    const component = this._entity[sourceName];
    if (component) {
      return component;
    }
    if (!isDestroying) {
      console.warn(`Entity has no component with name ${sourceName}`);
    }
    return null;
  }
  _onEntityDestroy(entity) {
    if (this._entity === entity) {
      this._toggleEntityListeners("off", true);
      this._entity = null;
    }
  }
  _onParentComponentRemove(entity, component) {
    if (component === this._parentComponent) {
      this._toggleLifecycleListeners("off");
      this._toggleEntityListeners("off", true);
    }
  }
  hasComponent(componentName) {
    return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;
  }
  get entity() {
    return this._entity;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/button/constants.js
var BUTTON_TRANSITION_MODE_TINT = 0;
var BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/element/constants.js
var ELEMENTTYPE_GROUP = "group";
var ELEMENTTYPE_IMAGE = "image";
var ELEMENTTYPE_TEXT = "text";
var FITMODE_STRETCH = "stretch";
var FITMODE_CONTAIN = "contain";
var FITMODE_COVER = "cover";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/button/component.js
var VisualState = {
  DEFAULT: "DEFAULT",
  HOVER: "HOVER",
  PRESSED: "PRESSED",
  INACTIVE: "INACTIVE"
};
var STATES_TO_TINT_NAMES = {};
STATES_TO_TINT_NAMES[VisualState.DEFAULT] = "_defaultTint";
STATES_TO_TINT_NAMES[VisualState.HOVER] = "hoverTint";
STATES_TO_TINT_NAMES[VisualState.PRESSED] = "pressedTint";
STATES_TO_TINT_NAMES[VisualState.INACTIVE] = "inactiveTint";
var STATES_TO_SPRITE_ASSET_NAMES = {};
STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = "_defaultSpriteAsset";
STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = "hoverSpriteAsset";
STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = "pressedSpriteAsset";
STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = "inactiveSpriteAsset";
var STATES_TO_SPRITE_FRAME_NAMES = {};
STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = "_defaultSpriteFrame";
STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = "hoverSpriteFrame";
STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = "pressedSpriteFrame";
STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = "inactiveSpriteFrame";
var ButtonComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._visualState = VisualState.DEFAULT;
    this._isHovering = false;
    this._hoveringCounter = 0;
    this._isPressed = false;
    this._defaultTint = new Color(1, 1, 1, 1);
    this._defaultSpriteAsset = null;
    this._defaultSpriteFrame = 0;
    this._imageReference = new EntityReference(this, "imageEntity", {
      "element#gain": this._onImageElementGain,
      "element#lose": this._onImageElementLose,
      "element#set:color": this._onSetColor,
      "element#set:opacity": this._onSetOpacity,
      "element#set:spriteAsset": this._onSetSpriteAsset,
      "element#set:spriteFrame": this._onSetSpriteFrame
    });
    this._toggleLifecycleListeners("on", system);
  }
  get data() {
    const record = this.system.store[this.entity.getGuid()];
    return record ? record.data : null;
  }
  set enabled(arg) {
    this._setValue("enabled", arg);
  }
  get enabled() {
    return this.data.enabled;
  }
  set active(arg) {
    this._setValue("active", arg);
  }
  get active() {
    return this.data.active;
  }
  set imageEntity(arg) {
    this._setValue("imageEntity", arg);
  }
  get imageEntity() {
    return this.data.imageEntity;
  }
  set hitPadding(arg) {
    this._setValue("hitPadding", arg);
  }
  get hitPadding() {
    return this.data.hitPadding;
  }
  set transitionMode(arg) {
    this._setValue("transitionMode", arg);
  }
  get transitionMode() {
    return this.data.transitionMode;
  }
  set hoverTint(arg) {
    this._setValue("hoverTint", arg);
  }
  get hoverTint() {
    return this.data.hoverTint;
  }
  set pressedTint(arg) {
    this._setValue("pressedTint", arg);
  }
  get pressedTint() {
    return this.data.pressedTint;
  }
  set inactiveTint(arg) {
    this._setValue("inactiveTint", arg);
  }
  get inactiveTint() {
    return this.data.inactiveTint;
  }
  set fadeDuration(arg) {
    this._setValue("fadeDuration", arg);
  }
  get fadeDuration() {
    return this.data.fadeDuration;
  }
  set hoverSpriteAsset(arg) {
    this._setValue("hoverSpriteAsset", arg);
  }
  get hoverSpriteAsset() {
    return this.data.hoverSpriteAsset;
  }
  set hoverSpriteFrame(arg) {
    this._setValue("hoverSpriteFrame", arg);
  }
  get hoverSpriteFrame() {
    return this.data.hoverSpriteFrame;
  }
  set pressedSpriteAsset(arg) {
    this._setValue("pressedSpriteAsset", arg);
  }
  get pressedSpriteAsset() {
    return this.data.pressedSpriteAsset;
  }
  set pressedSpriteFrame(arg) {
    this._setValue("pressedSpriteFrame", arg);
  }
  get pressedSpriteFrame() {
    return this.data.pressedSpriteFrame;
  }
  set inactiveSpriteAsset(arg) {
    this._setValue("inactiveSpriteAsset", arg);
  }
  get inactiveSpriteAsset() {
    return this.data.inactiveSpriteAsset;
  }
  set inactiveSpriteFrame(arg) {
    this._setValue("inactiveSpriteFrame", arg);
  }
  get inactiveSpriteFrame() {
    return this.data.inactiveSpriteFrame;
  }
  _setValue(name, value) {
    const data2 = this.data;
    const oldValue = data2[name];
    data2[name] = value;
    this.fire("set", name, oldValue, value);
  }
  _toggleLifecycleListeners(onOrOff, system) {
    this[onOrOff]("set_active", this._onSetActive, this);
    this[onOrOff]("set_transitionMode", this._onSetTransitionMode, this);
    this[onOrOff]("set_hoverTint", this._onSetTransitionValue, this);
    this[onOrOff]("set_pressedTint", this._onSetTransitionValue, this);
    this[onOrOff]("set_inactiveTint", this._onSetTransitionValue, this);
    this[onOrOff]("set_hoverSpriteAsset", this._onSetTransitionValue, this);
    this[onOrOff]("set_hoverSpriteFrame", this._onSetTransitionValue, this);
    this[onOrOff]("set_pressedSpriteAsset", this._onSetTransitionValue, this);
    this[onOrOff]("set_pressedSpriteFrame", this._onSetTransitionValue, this);
    this[onOrOff]("set_inactiveSpriteAsset", this._onSetTransitionValue, this);
    this[onOrOff]("set_inactiveSpriteFrame", this._onSetTransitionValue, this);
    system.app.systems.element[onOrOff]("add", this._onElementComponentAdd, this);
    system.app.systems.element[onOrOff]("beforeremove", this._onElementComponentRemove, this);
  }
  _onSetActive(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this._updateVisualState();
    }
  }
  _onSetTransitionMode(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this._cancelTween();
      this._resetToDefaultVisualState(oldValue);
      this._forceReapplyVisualState();
    }
  }
  _onSetTransitionValue(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this._forceReapplyVisualState();
    }
  }
  _onElementComponentRemove(entity) {
    if (this.entity === entity) {
      this._toggleHitElementListeners("off");
    }
  }
  _onElementComponentAdd(entity) {
    if (this.entity === entity) {
      this._toggleHitElementListeners("on");
    }
  }
  _onImageElementLose() {
    this._cancelTween();
    this._resetToDefaultVisualState(this.transitionMode);
  }
  _onImageElementGain() {
    this._storeDefaultVisualState();
    this._forceReapplyVisualState();
  }
  _toggleHitElementListeners(onOrOff) {
    if (this.entity.element) {
      const isAdding = onOrOff === "on";
      if (isAdding && this._hasHitElementListeners) {
        return;
      }
      this.entity.element[onOrOff]("mouseenter", this._onMouseEnter, this);
      this.entity.element[onOrOff]("mouseleave", this._onMouseLeave, this);
      this.entity.element[onOrOff]("mousedown", this._onMouseDown, this);
      this.entity.element[onOrOff]("mouseup", this._onMouseUp, this);
      this.entity.element[onOrOff]("touchstart", this._onTouchStart, this);
      this.entity.element[onOrOff]("touchend", this._onTouchEnd, this);
      this.entity.element[onOrOff]("touchleave", this._onTouchLeave, this);
      this.entity.element[onOrOff]("touchcancel", this._onTouchCancel, this);
      this.entity.element[onOrOff]("selectstart", this._onSelectStart, this);
      this.entity.element[onOrOff]("selectend", this._onSelectEnd, this);
      this.entity.element[onOrOff]("selectenter", this._onSelectEnter, this);
      this.entity.element[onOrOff]("selectleave", this._onSelectLeave, this);
      this.entity.element[onOrOff]("click", this._onClick, this);
      this._hasHitElementListeners = isAdding;
    }
  }
  _storeDefaultVisualState() {
    if (this._imageReference.hasComponent("element")) {
      const element = this._imageReference.entity.element;
      if (element.type !== ELEMENTTYPE_GROUP) {
        this._storeDefaultColor(element.color);
        this._storeDefaultOpacity(element.opacity);
        this._storeDefaultSpriteAsset(element.spriteAsset);
        this._storeDefaultSpriteFrame(element.spriteFrame);
      }
    }
  }
  _storeDefaultColor(color) {
    this._defaultTint.r = color.r;
    this._defaultTint.g = color.g;
    this._defaultTint.b = color.b;
  }
  _storeDefaultOpacity(opacity) {
    this._defaultTint.a = opacity;
  }
  _storeDefaultSpriteAsset(spriteAsset) {
    this._defaultSpriteAsset = spriteAsset;
  }
  _storeDefaultSpriteFrame(spriteFrame) {
    this._defaultSpriteFrame = spriteFrame;
  }
  _onSetColor(color) {
    if (!this._isApplyingTint) {
      this._storeDefaultColor(color);
      this._forceReapplyVisualState();
    }
  }
  _onSetOpacity(opacity) {
    if (!this._isApplyingTint) {
      this._storeDefaultOpacity(opacity);
      this._forceReapplyVisualState();
    }
  }
  _onSetSpriteAsset(spriteAsset) {
    if (!this._isApplyingSprite) {
      this._storeDefaultSpriteAsset(spriteAsset);
      this._forceReapplyVisualState();
    }
  }
  _onSetSpriteFrame(spriteFrame) {
    if (!this._isApplyingSprite) {
      this._storeDefaultSpriteFrame(spriteFrame);
      this._forceReapplyVisualState();
    }
  }
  _onMouseEnter(event) {
    this._isHovering = true;
    this._updateVisualState();
    this._fireIfActive("mouseenter", event);
  }
  _onMouseLeave(event) {
    this._isHovering = false;
    this._isPressed = false;
    this._updateVisualState();
    this._fireIfActive("mouseleave", event);
  }
  _onMouseDown(event) {
    this._isPressed = true;
    this._updateVisualState();
    this._fireIfActive("mousedown", event);
  }
  _onMouseUp(event) {
    this._isPressed = false;
    this._updateVisualState();
    this._fireIfActive("mouseup", event);
  }
  _onTouchStart(event) {
    this._isPressed = true;
    this._updateVisualState();
    this._fireIfActive("touchstart", event);
  }
  _onTouchEnd(event) {
    event.event.preventDefault();
    this._isPressed = false;
    this._updateVisualState();
    this._fireIfActive("touchend", event);
  }
  _onTouchLeave(event) {
    this._isPressed = false;
    this._updateVisualState();
    this._fireIfActive("touchleave", event);
  }
  _onTouchCancel(event) {
    this._isPressed = false;
    this._updateVisualState();
    this._fireIfActive("touchcancel", event);
  }
  _onSelectStart(event) {
    this._isPressed = true;
    this._updateVisualState();
    this._fireIfActive("selectstart", event);
  }
  _onSelectEnd(event) {
    this._isPressed = false;
    this._updateVisualState();
    this._fireIfActive("selectend", event);
  }
  _onSelectEnter(event) {
    this._hoveringCounter++;
    if (this._hoveringCounter === 1) {
      this._isHovering = true;
      this._updateVisualState();
    }
    this._fireIfActive("selectenter", event);
  }
  _onSelectLeave(event) {
    this._hoveringCounter--;
    if (this._hoveringCounter === 0) {
      this._isHovering = false;
      this._isPressed = false;
      this._updateVisualState();
    }
    this._fireIfActive("selectleave", event);
  }
  _onClick(event) {
    this._fireIfActive("click", event);
  }
  _fireIfActive(name, event) {
    if (this.data.active) {
      this.fire(name, event);
    }
  }
  _updateVisualState(force) {
    const oldVisualState = this._visualState;
    const newVisualState = this._determineVisualState();
    if ((oldVisualState !== newVisualState || force) && this.enabled) {
      this._visualState = newVisualState;
      if (oldVisualState === VisualState.HOVER) {
        this._fireIfActive("hoverend");
      }
      if (oldVisualState === VisualState.PRESSED) {
        this._fireIfActive("pressedend");
      }
      if (newVisualState === VisualState.HOVER) {
        this._fireIfActive("hoverstart");
      }
      if (newVisualState === VisualState.PRESSED) {
        this._fireIfActive("pressedstart");
      }
      switch (this.transitionMode) {
        case BUTTON_TRANSITION_MODE_TINT: {
          const tintName = STATES_TO_TINT_NAMES[this._visualState];
          const tintColor = this[tintName];
          this._applyTint(tintColor);
          break;
        }
        case BUTTON_TRANSITION_MODE_SPRITE_CHANGE: {
          const spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
          const spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
          const spriteAsset = this[spriteAssetName];
          const spriteFrame = this[spriteFrameName];
          this._applySprite(spriteAsset, spriteFrame);
          break;
        }
      }
    }
  }
  _forceReapplyVisualState() {
    this._updateVisualState(true);
  }
  _resetToDefaultVisualState(transitionMode) {
    if (this._imageReference.hasComponent("element")) {
      switch (transitionMode) {
        case BUTTON_TRANSITION_MODE_TINT:
          this._cancelTween();
          this._applyTintImmediately(this._defaultTint);
          break;
        case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
          this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
          break;
      }
    }
  }
  _determineVisualState() {
    if (!this.active) {
      return VisualState.INACTIVE;
    } else if (this._isPressed) {
      return VisualState.PRESSED;
    } else if (this._isHovering) {
      return VisualState.HOVER;
    }
    return VisualState.DEFAULT;
  }
  _applySprite(spriteAsset, spriteFrame) {
    spriteFrame = spriteFrame || 0;
    if (this._imageReference.hasComponent("element")) {
      this._isApplyingSprite = true;
      if (this._imageReference.entity.element.spriteAsset !== spriteAsset) {
        this._imageReference.entity.element.spriteAsset = spriteAsset;
      }
      if (this._imageReference.entity.element.spriteFrame !== spriteFrame) {
        this._imageReference.entity.element.spriteFrame = spriteFrame;
      }
      this._isApplyingSprite = false;
    }
  }
  _applyTint(tintColor) {
    this._cancelTween();
    if (this.fadeDuration === 0) {
      this._applyTintImmediately(tintColor);
    } else {
      this._applyTintWithTween(tintColor);
    }
  }
  _applyTintImmediately(tintColor) {
    if (!tintColor || !this._imageReference.hasComponent("element") || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) {
      return;
    }
    const color3 = toColor3(tintColor);
    this._isApplyingTint = true;
    if (!color3.equals(this._imageReference.entity.element.color)) {
      this._imageReference.entity.element.color = color3;
    }
    if (this._imageReference.entity.element.opacity !== tintColor.a) {
      this._imageReference.entity.element.opacity = tintColor.a;
    }
    this._isApplyingTint = false;
  }
  _applyTintWithTween(tintColor) {
    if (!tintColor || !this._imageReference.hasComponent("element") || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) {
      return;
    }
    const color3 = toColor3(tintColor);
    const color = this._imageReference.entity.element.color;
    const opacity = this._imageReference.entity.element.opacity;
    if (color3.equals(color) && tintColor.a === opacity) return;
    this._tweenInfo = {
      startTime: now(),
      from: new Color(color.r, color.g, color.b, opacity),
      to: tintColor.clone(),
      lerpColor: new Color()
    };
  }
  _updateTintTween() {
    const elapsedTime = now() - this._tweenInfo.startTime;
    let elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
    elapsedProportion = math.clamp(elapsedProportion, 0, 1);
    if (Math.abs(elapsedProportion - 1) > 1e-5) {
      const lerpColor = this._tweenInfo.lerpColor;
      lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);
      this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
    } else {
      this._applyTintImmediately(this._tweenInfo.to);
      this._cancelTween();
    }
  }
  _cancelTween() {
    delete this._tweenInfo;
  }
  onUpdate() {
    if (this._tweenInfo) {
      this._updateTintTween();
    }
  }
  onEnable() {
    this._isHovering = false;
    this._hoveringCounter = 0;
    this._isPressed = false;
    this._imageReference.onParentComponentEnable();
    this._toggleHitElementListeners("on");
    this._forceReapplyVisualState();
  }
  onDisable() {
    this._toggleHitElementListeners("off");
    this._resetToDefaultVisualState(this.transitionMode);
  }
  onRemove() {
    this._toggleLifecycleListeners("off", this.system);
    this.onDisable();
  }
};
ButtonComponent.EVENT_MOUSEDOWN = "mousedown";
ButtonComponent.EVENT_MOUSEUP = "mouseup";
ButtonComponent.EVENT_MOUSEENTER = "mouseenter";
ButtonComponent.EVENT_MOUSELEAVE = "mouseleave";
ButtonComponent.EVENT_CLICK = "click";
ButtonComponent.EVENT_TOUCHSTART = "touchstart";
ButtonComponent.EVENT_TOUCHEND = "touchend";
ButtonComponent.EVENT_TOUCHCANCEL = "touchcancel";
ButtonComponent.EVENT_TOUCHLEAVE = "touchleave";
ButtonComponent.EVENT_SELECTSTART = "selectstart";
ButtonComponent.EVENT_SELECTEND = "selectend";
ButtonComponent.EVENT_SELECTENTER = "selectenter";
ButtonComponent.EVENT_SELECTLEAVE = "selectleave";
ButtonComponent.EVENT_HOVERSTART = "hoverstart";
ButtonComponent.EVENT_HOVEREND = "hoverend";
ButtonComponent.EVENT_PRESSEDSTART = "pressedstart";
ButtonComponent.EVENT_PRESSEDEND = "pressedend";
function toColor3(color4) {
  return new Color(color4.r, color4.g, color4.b);
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/button/data.js
var ButtonComponentData = class {
  constructor() {
    this.enabled = true;
    this.active = true;
    this.imageEntity = null;
    this.hitPadding = new Vec4();
    this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
    this.hoverTint = new Color(0.75, 0.75, 0.75);
    this.pressedTint = new Color(0.5, 0.5, 0.5);
    this.inactiveTint = new Color(0.25, 0.25, 0.25);
    this.fadeDuration = 0;
    this.hoverSpriteAsset = null;
    this.hoverSpriteFrame = 0;
    this.pressedSpriteAsset = null;
    this.pressedSpriteFrame = 0;
    this.inactiveSpriteAsset = null;
    this.inactiveSpriteFrame = 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/button/system.js
var _schema4 = ["enabled", "active", {
  name: "imageEntity",
  type: "entity"
}, {
  name: "hitPadding",
  type: "vec4"
}, "transitionMode", {
  name: "hoverTint",
  type: "rgba"
}, {
  name: "pressedTint",
  type: "rgba"
}, {
  name: "inactiveTint",
  type: "rgba"
}, "fadeDuration", "hoverSpriteAsset", "hoverSpriteFrame", "pressedSpriteAsset", "pressedSpriteFrame", "inactiveSpriteAsset", "inactiveSpriteFrame"];
var ButtonComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "button";
    this.ComponentType = ButtonComponent;
    this.DataType = ButtonComponentData;
    this.schema = _schema4;
    this.on("beforeremove", this._onRemoveComponent, this);
    this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(component, data2, properties3) {
    super.initializeComponentData(component, data2, _schema4);
  }
  onUpdate(dt) {
    const components2 = this.store;
    for (const id13 in components2) {
      const entity = components2[id13].entity;
      const component = entity.button;
      if (component.enabled && entity.enabled) {
        component.onUpdate();
      }
    }
  }
  _onRemoveComponent(entity, component) {
    component.onRemove();
  }
  destroy() {
    super.destroy();
    this.app.systems.off("update", this.onUpdate, this);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/collision/component.js
var _vec3 = new Vec3();
var _quat = new Quat();
var CollisionComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._compoundParent = null;
    this._hasOffset = false;
    this.entity.on("insert", this._onInsert, this);
    this.on("set_type", this.onSetType, this);
    this.on("set_convexHull", this.onSetModel, this);
    this.on("set_halfExtents", this.onSetHalfExtents, this);
    this.on("set_linearOffset", this.onSetOffset, this);
    this.on("set_angularOffset", this.onSetOffset, this);
    this.on("set_radius", this.onSetRadius, this);
    this.on("set_height", this.onSetHeight, this);
    this.on("set_axis", this.onSetAxis, this);
    this.on("set_asset", this.onSetAsset, this);
    this.on("set_renderAsset", this.onSetRenderAsset, this);
    this.on("set_model", this.onSetModel, this);
    this.on("set_render", this.onSetRender, this);
  }
  get data() {
    const record = this.system.store[this.entity.getGuid()];
    return record ? record.data : null;
  }
  set enabled(arg) {
    this._setValue("enabled", arg);
  }
  get enabled() {
    return this.data.enabled;
  }
  set type(arg) {
    this._setValue("type", arg);
  }
  get type() {
    return this.data.type;
  }
  set halfExtents(arg) {
    this._setValue("halfExtents", arg);
  }
  get halfExtents() {
    return this.data.halfExtents;
  }
  set linearOffset(arg) {
    this._setValue("linearOffset", arg);
  }
  get linearOffset() {
    return this.data.linearOffset;
  }
  set angularOffset(arg) {
    this._setValue("angularOffset", arg);
  }
  get angularOffset() {
    return this.data.angularOffset;
  }
  set radius(arg) {
    this._setValue("radius", arg);
  }
  get radius() {
    return this.data.radius;
  }
  set axis(arg) {
    this._setValue("axis", arg);
  }
  get axis() {
    return this.data.axis;
  }
  set height(arg) {
    this._setValue("height", arg);
  }
  get height() {
    return this.data.height;
  }
  set asset(arg) {
    this._setValue("asset", arg);
  }
  get asset() {
    return this.data.asset;
  }
  set renderAsset(arg) {
    this._setValue("renderAsset", arg);
  }
  get renderAsset() {
    return this.data.renderAsset;
  }
  set convexHull(arg) {
    this._setValue("convexHull", arg);
  }
  get convexHull() {
    return this.data.convexHull;
  }
  set shape(arg) {
    this._setValue("shape", arg);
  }
  get shape() {
    return this.data.shape;
  }
  set model(arg) {
    this._setValue("model", arg);
  }
  get model() {
    return this.data.model;
  }
  set render(arg) {
    this._setValue("render", arg);
  }
  get render() {
    return this.data.render;
  }
  set checkVertexDuplicates(arg) {
    this._setValue("checkVertexDuplicates", arg);
  }
  get checkVertexDuplicates() {
    return this.data.checkVertexDuplicates;
  }
  _setValue(name, value) {
    const data2 = this.data;
    const oldValue = data2[name];
    data2[name] = value;
    this.fire("set", name, oldValue, value);
  }
  onSetType(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.system.changeType(this, oldValue, newValue);
    }
  }
  onSetHalfExtents(name, oldValue, newValue) {
    const t = this.data.type;
    if (this.data.initialized && t === "box") {
      this.system.recreatePhysicalShapes(this);
    }
  }
  onSetOffset(name, oldValue, newValue) {
    this._hasOffset = !this.data.linearOffset.equals(Vec3.ZERO) || !this.data.angularOffset.equals(Quat.IDENTITY);
    if (this.data.initialized) {
      this.system.recreatePhysicalShapes(this);
    }
  }
  onSetRadius(name, oldValue, newValue) {
    const t = this.data.type;
    if (this.data.initialized && (t === "sphere" || t === "capsule" || t === "cylinder" || t === "cone")) {
      this.system.recreatePhysicalShapes(this);
    }
  }
  onSetHeight(name, oldValue, newValue) {
    const t = this.data.type;
    if (this.data.initialized && (t === "capsule" || t === "cylinder" || t === "cone")) {
      this.system.recreatePhysicalShapes(this);
    }
  }
  onSetAxis(name, oldValue, newValue) {
    const t = this.data.type;
    if (this.data.initialized && (t === "capsule" || t === "cylinder" || t === "cone")) {
      this.system.recreatePhysicalShapes(this);
    }
  }
  onSetAsset(name, oldValue, newValue) {
    const assets = this.system.app.assets;
    if (oldValue) {
      const asset = assets.get(oldValue);
      if (asset) {
        asset.off("remove", this.onAssetRemoved, this);
      }
    }
    if (newValue) {
      if (newValue instanceof Asset) {
        this.data.asset = newValue.id;
      }
      const asset = assets.get(this.data.asset);
      if (asset) {
        asset.off("remove", this.onAssetRemoved, this);
        asset.on("remove", this.onAssetRemoved, this);
      }
    }
    if (this.data.initialized && this.data.type === "mesh") {
      if (!newValue) {
        this.data.model = null;
      }
      this.system.recreatePhysicalShapes(this);
    }
  }
  onSetRenderAsset(name, oldValue, newValue) {
    const assets = this.system.app.assets;
    if (oldValue) {
      const asset = assets.get(oldValue);
      if (asset) {
        asset.off("remove", this.onRenderAssetRemoved, this);
      }
    }
    if (newValue) {
      if (newValue instanceof Asset) {
        this.data.renderAsset = newValue.id;
      }
      const asset = assets.get(this.data.renderAsset);
      if (asset) {
        asset.off("remove", this.onRenderAssetRemoved, this);
        asset.on("remove", this.onRenderAssetRemoved, this);
      }
    }
    if (this.data.initialized && this.data.type === "mesh") {
      if (!newValue) {
        this.data.render = null;
      }
      this.system.recreatePhysicalShapes(this);
    }
  }
  onSetModel(name, oldValue, newValue) {
    if (this.data.initialized && this.data.type === "mesh") {
      this.system.implementations.mesh.doRecreatePhysicalShape(this);
    }
  }
  onSetRender(name, oldValue, newValue) {
    this.onSetModel(name, oldValue, newValue);
  }
  onAssetRemoved(asset) {
    asset.off("remove", this.onAssetRemoved, this);
    if (this.data.asset === asset.id) {
      this.asset = null;
    }
  }
  onRenderAssetRemoved(asset) {
    asset.off("remove", this.onRenderAssetRemoved, this);
    if (this.data.renderAsset === asset.id) {
      this.renderAsset = null;
    }
  }
  _getCompoundChildShapeIndex(shape) {
    const compound = this.data.shape;
    const shapes = compound.getNumChildShapes();
    for (let i = 0; i < shapes; i++) {
      const childShape = compound.getChildShape(i);
      if (childShape.ptr === shape.ptr) {
        return i;
      }
    }
    return null;
  }
  _onInsert(parent) {
    if (typeof Ammo === "undefined") {
      return;
    }
    if (this._compoundParent) {
      this.system.recreatePhysicalShapes(this);
    } else if (!this.entity.rigidbody) {
      let ancestor = this.entity.parent;
      while (ancestor) {
        if (ancestor.collision && ancestor.collision.type === "compound") {
          if (ancestor.collision.shape.getNumChildShapes() === 0) {
            this.system.recreatePhysicalShapes(ancestor.collision);
          } else {
            this.system.recreatePhysicalShapes(this);
          }
          break;
        }
        ancestor = ancestor.parent;
      }
    }
  }
  _updateCompound() {
    const entity = this.entity;
    if (entity._dirtyWorld) {
      let dirty = entity._dirtyLocal;
      let parent = entity;
      while (parent && !dirty) {
        if (parent.collision && parent.collision === this._compoundParent) {
          break;
        }
        if (parent._dirtyLocal) {
          dirty = true;
        }
        parent = parent.parent;
      }
      if (dirty) {
        entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
        const bodyComponent = this._compoundParent.entity.rigidbody;
        if (bodyComponent) {
          bodyComponent.activate();
        }
      }
    }
  }
  getShapePosition() {
    const pos = this.entity.getPosition();
    if (this._hasOffset) {
      const rot = this.entity.getRotation();
      const lo = this.data.linearOffset;
      _quat.copy(rot).transformVector(lo, _vec3);
      return _vec3.add(pos);
    }
    return pos;
  }
  getShapeRotation() {
    const rot = this.entity.getRotation();
    if (this._hasOffset) {
      return _quat.copy(rot).mul(this.data.angularOffset);
    }
    return rot;
  }
  onEnable() {
    if (this.data.type === "mesh" && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
      const asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);
      if (asset && (!asset.resource || !this.data.shape)) {
        this.system.recreatePhysicalShapes(this);
        return;
      }
    }
    if (this.entity.rigidbody) {
      if (this.entity.rigidbody.enabled) {
        this.entity.rigidbody.enableSimulation();
      }
    } else if (this._compoundParent && this !== this._compoundParent) {
      if (this._compoundParent.shape.getNumChildShapes() === 0) {
        this.system.recreatePhysicalShapes(this._compoundParent);
      } else {
        const transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);
        this._compoundParent.shape.addChildShape(transform, this.data.shape);
        Ammo.destroy(transform);
        if (this._compoundParent.entity.rigidbody) {
          this._compoundParent.entity.rigidbody.activate();
        }
      }
    } else if (this.entity.trigger) {
      this.entity.trigger.enable();
    }
  }
  onDisable() {
    if (this.entity.rigidbody) {
      this.entity.rigidbody.disableSimulation();
    } else if (this._compoundParent && this !== this._compoundParent) {
      if (!this._compoundParent.entity._destroying) {
        this.system._removeCompoundChild(this._compoundParent, this.data.shape);
        if (this._compoundParent.entity.rigidbody) {
          this._compoundParent.entity.rigidbody.activate();
        }
      }
    } else if (this.entity.trigger) {
      this.entity.trigger.disable();
    }
  }
  onBeforeRemove() {
    if (this.asset) {
      this.asset = null;
    }
    if (this.renderAsset) {
      this.renderAsset = null;
    }
    this.entity.off("insert", this._onInsert, this);
    this.off();
  }
};
CollisionComponent.EVENT_CONTACT = "contact";
CollisionComponent.EVENT_COLLISIONSTART = "collisionstart";
CollisionComponent.EVENT_COLLISIONEND = "collisionend";
CollisionComponent.EVENT_TRIGGERENTER = "triggerenter";
CollisionComponent.EVENT_TRIGGERLEAVE = "triggerleave";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/collision/data.js
var CollisionComponentData = class {
  constructor() {
    this.enabled = true;
    this.type = "box";
    this.halfExtents = new Vec3(0.5, 0.5, 0.5);
    this.linearOffset = new Vec3();
    this.angularOffset = new Quat();
    this.radius = 0.5;
    this.axis = 1;
    this.height = 2;
    this.convexHull = false;
    this.asset = null;
    this.renderAsset = null;
    this.checkVertexDuplicates = true;
    this.shape = null;
    this.model = null;
    this.render = null;
    this.initialized = false;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/rigid-body/constants.js
var BODYTYPE_STATIC = "static";
var BODYTYPE_DYNAMIC = "dynamic";
var BODYTYPE_KINEMATIC = "kinematic";
var BODYFLAG_STATIC_OBJECT = 1;
var BODYFLAG_KINEMATIC_OBJECT = 2;
var BODYFLAG_NORESPONSE_OBJECT = 4;
var BODYSTATE_ACTIVE_TAG = 1;
var BODYSTATE_ISLAND_SLEEPING = 2;
var BODYSTATE_WANTS_DEACTIVATION = 3;
var BODYSTATE_DISABLE_DEACTIVATION = 4;
var BODYSTATE_DISABLE_SIMULATION = 5;
var BODYGROUP_NONE = 0;
var BODYGROUP_DEFAULT = 1;
var BODYGROUP_DYNAMIC = 1;
var BODYGROUP_STATIC = 2;
var BODYGROUP_KINEMATIC = 4;
var BODYGROUP_ENGINE_1 = 8;
var BODYGROUP_TRIGGER = 16;
var BODYGROUP_ENGINE_2 = 32;
var BODYGROUP_ENGINE_3 = 64;
var BODYGROUP_USER_1 = 128;
var BODYGROUP_USER_2 = 256;
var BODYGROUP_USER_3 = 512;
var BODYGROUP_USER_4 = 1024;
var BODYGROUP_USER_5 = 2048;
var BODYGROUP_USER_6 = 4096;
var BODYGROUP_USER_7 = 8192;
var BODYGROUP_USER_8 = 16384;
var BODYMASK_NONE = 0;
var BODYMASK_ALL = 65535;
var BODYMASK_STATIC = 2;
var BODYMASK_NOT_STATIC = 65535 ^ 2;
var BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/collision/trigger.js
var _ammoVec1;
var _ammoQuat;
var _ammoTransform;
var Trigger = class {
  constructor(app2, component, data2) {
    this.entity = component.entity;
    this.component = component;
    this.app = app2;
    if (typeof Ammo !== "undefined" && !_ammoVec1) {
      _ammoVec1 = new Ammo.btVector3();
      _ammoQuat = new Ammo.btQuaternion();
      _ammoTransform = new Ammo.btTransform();
    }
    this.initialize(data2);
  }
  initialize(data2) {
    const entity = this.entity;
    const shape = data2.shape;
    if (shape && typeof Ammo !== "undefined") {
      if (entity.trigger) {
        entity.trigger.destroy();
      }
      const mass = 1;
      const component = this.component;
      if (component) {
        const bodyPos = component.getShapePosition();
        const bodyRot = component.getShapeRotation();
        _ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
        _ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
      } else {
        const pos = entity.getPosition();
        const rot = entity.getRotation();
        _ammoVec1.setValue(pos.x, pos.y, pos.z);
        _ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
      }
      _ammoTransform.setOrigin(_ammoVec1);
      _ammoTransform.setRotation(_ammoQuat);
      const body = this.app.systems.rigidbody.createBody(mass, shape, _ammoTransform);
      body.setRestitution(0);
      body.setFriction(0);
      body.setDamping(0, 0);
      _ammoVec1.setValue(0, 0, 0);
      body.setLinearFactor(_ammoVec1);
      body.setAngularFactor(_ammoVec1);
      body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
      body.entity = entity;
      this.body = body;
      if (this.component.enabled && entity.enabled) {
        this.enable();
      }
    }
  }
  destroy() {
    if (!this.body) return;
    this.disable();
    this.app.systems.rigidbody.destroyBody(this.body);
    this.body = null;
  }
  _getEntityTransform(transform) {
    const component = this.component;
    if (component) {
      const bodyPos = component.getShapePosition();
      const bodyRot = component.getShapeRotation();
      _ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
      _ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
    } else {
      const pos = this.entity.getPosition();
      const rot = this.entity.getRotation();
      _ammoVec1.setValue(pos.x, pos.y, pos.z);
      _ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
    }
    transform.setOrigin(_ammoVec1);
    transform.setRotation(_ammoQuat);
  }
  updateTransform() {
    this._getEntityTransform(_ammoTransform);
    const body = this.body;
    body.setWorldTransform(_ammoTransform);
    body.activate();
  }
  enable() {
    const body = this.body;
    if (!body) return;
    const systems = this.app.systems;
    systems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);
    systems.rigidbody._triggers.push(this);
    body.forceActivationState(BODYSTATE_ACTIVE_TAG);
    this.updateTransform();
  }
  disable() {
    const body = this.body;
    if (!body) return;
    const systems = this.app.systems;
    const idx = systems.rigidbody._triggers.indexOf(this);
    if (idx > -1) {
      systems.rigidbody._triggers.splice(idx, 1);
    }
    systems.rigidbody.removeBody(body);
    body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/collision/system.js
var mat42 = new Mat4();
var p1 = new Vec3();
var p2 = new Vec3();
var quat3 = new Quat();
var tempGraphNode = new GraphNode();
var _schema5 = ["enabled", "type", "halfExtents", "linearOffset", "angularOffset", "radius", "axis", "height", "convexHull", "asset", "renderAsset", "shape", "model", "render", "checkVertexDuplicates"];
var CollisionSystemImpl = class {
  constructor(system) {
    this.system = system;
  }
  beforeInitialize(component, data2) {
    data2.shape = null;
    data2.model = new Model();
    data2.model.graph = new GraphNode();
  }
  afterInitialize(component, data2) {
    this.recreatePhysicalShapes(component);
    component.data.initialized = true;
  }
  reset(component, data2) {
    this.beforeInitialize(component, data2);
    this.afterInitialize(component, data2);
  }
  recreatePhysicalShapes(component) {
    const entity = component.entity;
    const data2 = component.data;
    if (typeof Ammo !== "undefined") {
      if (entity.trigger) {
        entity.trigger.destroy();
        delete entity.trigger;
      }
      if (data2.shape) {
        if (component._compoundParent) {
          this.system._removeCompoundChild(component._compoundParent, data2.shape);
          if (component._compoundParent.entity.rigidbody) {
            component._compoundParent.entity.rigidbody.activate();
          }
        }
        this.destroyShape(data2);
      }
      data2.shape = this.createPhysicalShape(component.entity, data2);
      const firstCompoundChild = !component._compoundParent;
      if (data2.type === "compound" && (!component._compoundParent || component === component._compoundParent)) {
        component._compoundParent = component;
        entity.forEach(this._addEachDescendant, component);
      } else if (data2.type !== "compound") {
        if (component._compoundParent && component === component._compoundParent) {
          entity.forEach(this.system.implementations.compound._updateEachDescendant, component);
        }
        if (!component.rigidbody) {
          component._compoundParent = null;
          let parent = entity.parent;
          while (parent) {
            if (parent.collision && parent.collision.type === "compound") {
              component._compoundParent = parent.collision;
              break;
            }
            parent = parent.parent;
          }
        }
      }
      if (component._compoundParent) {
        if (component !== component._compoundParent) {
          if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
            this.system.recreatePhysicalShapes(component._compoundParent);
          } else {
            this.system.updateCompoundChildTransform(entity);
            if (component._compoundParent.entity.rigidbody) {
              component._compoundParent.entity.rigidbody.activate();
            }
          }
        }
      }
      if (entity.rigidbody) {
        entity.rigidbody.disableSimulation();
        entity.rigidbody.createBody();
        if (entity.enabled && entity.rigidbody.enabled) {
          entity.rigidbody.enableSimulation();
        }
      } else if (!component._compoundParent) {
        if (!entity.trigger) {
          entity.trigger = new Trigger(this.system.app, component, data2);
        } else {
          entity.trigger.initialize(data2);
        }
      }
    }
  }
  createPhysicalShape(entity, data2) {
    return void 0;
  }
  updateTransform(component, position3, rotation2, scale2) {
    if (component.entity.trigger) {
      component.entity.trigger.updateTransform();
    }
  }
  destroyShape(data2) {
    if (data2.shape) {
      Ammo.destroy(data2.shape);
      data2.shape = null;
    }
  }
  beforeRemove(entity, component) {
    if (component.data.shape) {
      if (component._compoundParent && !component._compoundParent.entity._destroying) {
        this.system._removeCompoundChild(component._compoundParent, component.data.shape);
        if (component._compoundParent.entity.rigidbody) {
          component._compoundParent.entity.rigidbody.activate();
        }
      }
      component._compoundParent = null;
      this.destroyShape(component.data);
    }
  }
  remove(entity, data2) {
    if (entity.rigidbody && entity.rigidbody.body) {
      entity.rigidbody.disableSimulation();
    }
    if (entity.trigger) {
      entity.trigger.destroy();
      delete entity.trigger;
    }
  }
  clone(entity, clone) {
    const src = this.system.store[entity.getGuid()];
    const data2 = {
      enabled: src.data.enabled,
      type: src.data.type,
      halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],
      linearOffset: [src.data.linearOffset.x, src.data.linearOffset.y, src.data.linearOffset.z],
      angularOffset: [src.data.angularOffset.x, src.data.angularOffset.y, src.data.angularOffset.z, src.data.angularOffset.w],
      radius: src.data.radius,
      axis: src.data.axis,
      height: src.data.height,
      convexHull: src.data.convexHull,
      asset: src.data.asset,
      renderAsset: src.data.renderAsset,
      model: src.data.model,
      render: src.data.render,
      checkVertexDuplicates: src.data.checkVertexDuplicates
    };
    return this.system.addComponent(clone, data2);
  }
};
var CollisionBoxSystemImpl = class extends CollisionSystemImpl {
  createPhysicalShape(entity, data2) {
    if (typeof Ammo !== "undefined") {
      const he = data2.halfExtents;
      const ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
      const shape = new Ammo.btBoxShape(ammoHe);
      Ammo.destroy(ammoHe);
      return shape;
    }
    return void 0;
  }
};
var CollisionSphereSystemImpl = class extends CollisionSystemImpl {
  createPhysicalShape(entity, data2) {
    if (typeof Ammo !== "undefined") {
      return new Ammo.btSphereShape(data2.radius);
    }
    return void 0;
  }
};
var CollisionCapsuleSystemImpl = class extends CollisionSystemImpl {
  createPhysicalShape(entity, data2) {
    var _data$axis, _data$radius, _data$height;
    const axis = (_data$axis = data2.axis) != null ? _data$axis : 1;
    const radius = (_data$radius = data2.radius) != null ? _data$radius : 0.5;
    const height = Math.max(((_data$height = data2.height) != null ? _data$height : 2) - 2 * radius, 0);
    let shape = null;
    if (typeof Ammo !== "undefined") {
      switch (axis) {
        case 0:
          shape = new Ammo.btCapsuleShapeX(radius, height);
          break;
        case 1:
          shape = new Ammo.btCapsuleShape(radius, height);
          break;
        case 2:
          shape = new Ammo.btCapsuleShapeZ(radius, height);
          break;
      }
    }
    return shape;
  }
};
var CollisionCylinderSystemImpl = class extends CollisionSystemImpl {
  createPhysicalShape(entity, data2) {
    var _data$axis2, _data$radius2, _data$height2;
    const axis = (_data$axis2 = data2.axis) != null ? _data$axis2 : 1;
    const radius = (_data$radius2 = data2.radius) != null ? _data$radius2 : 0.5;
    const height = (_data$height2 = data2.height) != null ? _data$height2 : 1;
    let halfExtents = null;
    let shape = null;
    if (typeof Ammo !== "undefined") {
      switch (axis) {
        case 0:
          halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
          shape = new Ammo.btCylinderShapeX(halfExtents);
          break;
        case 1:
          halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
          shape = new Ammo.btCylinderShape(halfExtents);
          break;
        case 2:
          halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
          shape = new Ammo.btCylinderShapeZ(halfExtents);
          break;
      }
    }
    if (halfExtents) {
      Ammo.destroy(halfExtents);
    }
    return shape;
  }
};
var CollisionConeSystemImpl = class extends CollisionSystemImpl {
  createPhysicalShape(entity, data2) {
    var _data$axis3, _data$radius3, _data$height3;
    const axis = (_data$axis3 = data2.axis) != null ? _data$axis3 : 1;
    const radius = (_data$radius3 = data2.radius) != null ? _data$radius3 : 0.5;
    const height = (_data$height3 = data2.height) != null ? _data$height3 : 1;
    let shape = null;
    if (typeof Ammo !== "undefined") {
      switch (axis) {
        case 0:
          shape = new Ammo.btConeShapeX(radius, height);
          break;
        case 1:
          shape = new Ammo.btConeShape(radius, height);
          break;
        case 2:
          shape = new Ammo.btConeShapeZ(radius, height);
          break;
      }
    }
    return shape;
  }
};
var CollisionMeshSystemImpl = class extends CollisionSystemImpl {
  beforeInitialize(component, data2) {
  }
  createAmmoHull(mesh, node, shape, scale2) {
    const hull = new Ammo.btConvexHullShape();
    const point = new Ammo.btVector3();
    const positions = [];
    mesh.getPositions(positions);
    for (let i = 0; i < positions.length; i += 3) {
      point.setValue(positions[i] * scale2.x, positions[i + 1] * scale2.y, positions[i + 2] * scale2.z);
      hull.addPoint(point, false);
    }
    Ammo.destroy(point);
    hull.recalcLocalAabb();
    hull.setMargin(0.01);
    const transform = this.system._getNodeTransform(node);
    shape.addChildShape(transform, hull);
    Ammo.destroy(transform);
  }
  createAmmoMesh(mesh, node, shape, scale2, checkDupes = true) {
    const system = this.system;
    let triMesh;
    if (system._triMeshCache[mesh.id]) {
      triMesh = system._triMeshCache[mesh.id];
    } else {
      const vb = mesh.vertexBuffer;
      const format = vb.getFormat();
      let stride, positions;
      for (let i = 0; i < format.elements.length; i++) {
        const element = format.elements[i];
        if (element.name === SEMANTIC_POSITION) {
          positions = new Float32Array(vb.lock(), element.offset);
          stride = element.stride / 4;
          break;
        }
      }
      const indices = [];
      mesh.getIndices(indices);
      const numTriangles = mesh.primitive[0].count / 3;
      const v1 = new Ammo.btVector3();
      let i1, i2, i3;
      const base = mesh.primitive[0].base;
      triMesh = new Ammo.btTriangleMesh();
      system._triMeshCache[mesh.id] = triMesh;
      const vertexCache = /* @__PURE__ */ new Map();
      const indexedArray = triMesh.getIndexedMeshArray();
      indexedArray.at(0).m_numTriangles = numTriangles;
      const sx = scale2 ? scale2.x : 1;
      const sy = scale2 ? scale2.y : 1;
      const sz = scale2 ? scale2.z : 1;
      const addVertex = (index) => {
        const x2 = positions[index * stride] * sx;
        const y2 = positions[index * stride + 1] * sy;
        const z2 = positions[index * stride + 2] * sz;
        let idx;
        if (checkDupes) {
          const str = `${x2}:${y2}:${z2}`;
          idx = vertexCache.get(str);
          if (idx !== void 0) {
            return idx;
          }
          v1.setValue(x2, y2, z2);
          idx = triMesh.findOrAddVertex(v1, false);
          vertexCache.set(str, idx);
        } else {
          v1.setValue(x2, y2, z2);
          idx = triMesh.findOrAddVertex(v1, false);
        }
        return idx;
      };
      for (let i = 0; i < numTriangles; i++) {
        i1 = addVertex(indices[base + i * 3]);
        i2 = addVertex(indices[base + i * 3 + 1]);
        i3 = addVertex(indices[base + i * 3 + 2]);
        triMesh.addIndex(i1);
        triMesh.addIndex(i2);
        triMesh.addIndex(i3);
      }
      Ammo.destroy(v1);
    }
    const triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, true);
    if (!scale2) {
      const scaling = system._getNodeScaling(node);
      triMeshShape.setLocalScaling(scaling);
      Ammo.destroy(scaling);
    }
    const transform = system._getNodeTransform(node);
    shape.addChildShape(transform, triMeshShape);
    Ammo.destroy(transform);
  }
  createPhysicalShape(entity, data2) {
    if (typeof Ammo === "undefined") return void 0;
    if (data2.model || data2.render) {
      const shape = new Ammo.btCompoundShape();
      const entityTransform = entity.getWorldTransform();
      const scale2 = entityTransform.getScale();
      if (data2.render) {
        const meshes = data2.render.meshes;
        for (let i = 0; i < meshes.length; i++) {
          if (data2.convexHull) {
            this.createAmmoHull(meshes[i], tempGraphNode, shape, scale2);
          } else {
            this.createAmmoMesh(meshes[i], tempGraphNode, shape, scale2, data2.checkVertexDuplicates);
          }
        }
      } else if (data2.model) {
        const meshInstances = data2.model.meshInstances;
        for (let i = 0; i < meshInstances.length; i++) {
          this.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape, null, data2.checkVertexDuplicates);
        }
        const vec2 = new Ammo.btVector3(scale2.x, scale2.y, scale2.z);
        shape.setLocalScaling(vec2);
        Ammo.destroy(vec2);
      }
      return shape;
    }
    return void 0;
  }
  recreatePhysicalShapes(component) {
    const data2 = component.data;
    if (data2.renderAsset || data2.asset) {
      if (component.enabled && component.entity.enabled) {
        this.loadAsset(component, data2.renderAsset || data2.asset, data2.renderAsset ? "render" : "model");
        return;
      }
    }
    this.doRecreatePhysicalShape(component);
  }
  loadAsset(component, id13, property) {
    const data2 = component.data;
    const assets = this.system.app.assets;
    const previousPropertyValue = data2[property];
    const onAssetFullyReady = (asset2) => {
      if (data2[property] !== previousPropertyValue) {
        return;
      }
      data2[property] = asset2.resource;
      this.doRecreatePhysicalShape(component);
    };
    const loadAndHandleAsset = (asset2) => {
      asset2.ready((asset3) => {
        if (asset3.data.containerAsset) {
          const containerAsset = assets.get(asset3.data.containerAsset);
          if (containerAsset.loaded) {
            onAssetFullyReady(asset3);
          } else {
            containerAsset.ready(() => {
              onAssetFullyReady(asset3);
            });
            assets.load(containerAsset);
          }
        } else {
          onAssetFullyReady(asset3);
        }
      });
      assets.load(asset2);
    };
    const asset = assets.get(id13);
    if (asset) {
      loadAndHandleAsset(asset);
    } else {
      assets.once(`add:${id13}`, loadAndHandleAsset);
    }
  }
  doRecreatePhysicalShape(component) {
    const entity = component.entity;
    const data2 = component.data;
    if (data2.model || data2.render) {
      this.destroyShape(data2);
      data2.shape = this.createPhysicalShape(entity, data2);
      if (entity.rigidbody) {
        entity.rigidbody.disableSimulation();
        entity.rigidbody.createBody();
        if (entity.enabled && entity.rigidbody.enabled) {
          entity.rigidbody.enableSimulation();
        }
      } else {
        if (!entity.trigger) {
          entity.trigger = new Trigger(this.system.app, component, data2);
        } else {
          entity.trigger.initialize(data2);
        }
      }
    } else {
      this.beforeRemove(entity, component);
      this.remove(entity, data2);
    }
  }
  updateTransform(component, position3, rotation2, scale2) {
    if (component.shape) {
      const entityTransform = component.entity.getWorldTransform();
      const worldScale = entityTransform.getScale();
      const previousScale = component.shape.getLocalScaling();
      if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
        this.doRecreatePhysicalShape(component);
      }
    }
    super.updateTransform(component, position3, rotation2, scale2);
  }
  destroyShape(data2) {
    if (!data2.shape) {
      return;
    }
    const numShapes = data2.shape.getNumChildShapes();
    for (let i = 0; i < numShapes; i++) {
      const shape = data2.shape.getChildShape(i);
      Ammo.destroy(shape);
    }
    Ammo.destroy(data2.shape);
    data2.shape = null;
  }
};
var CollisionCompoundSystemImpl = class extends CollisionSystemImpl {
  createPhysicalShape(entity, data2) {
    if (typeof Ammo !== "undefined") {
      return new Ammo.btCompoundShape();
    }
    return void 0;
  }
  _addEachDescendant(entity) {
    if (!entity.collision || entity.rigidbody) {
      return;
    }
    entity.collision._compoundParent = this;
    if (entity !== this.entity) {
      entity.collision.system.recreatePhysicalShapes(entity.collision);
    }
  }
  _updateEachDescendant(entity) {
    if (!entity.collision) {
      return;
    }
    if (entity.collision._compoundParent !== this) {
      return;
    }
    entity.collision._compoundParent = null;
    if (entity !== this.entity && !entity.rigidbody) {
      entity.collision.system.recreatePhysicalShapes(entity.collision);
    }
  }
  _updateEachDescendantTransform(entity) {
    if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) {
      return;
    }
    this.collision.system.updateCompoundChildTransform(entity);
  }
};
var CollisionComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "collision";
    this.ComponentType = CollisionComponent;
    this.DataType = CollisionComponentData;
    this.schema = _schema5;
    this.implementations = {};
    this._triMeshCache = {};
    this.on("beforeremove", this.onBeforeRemove, this);
    this.on("remove", this.onRemove, this);
  }
  initializeComponentData(component, _data, properties3) {
    properties3 = ["type", "halfExtents", "radius", "axis", "height", "convexHull", "shape", "model", "asset", "render", "renderAsset", "enabled", "linearOffset", "angularOffset", "checkVertexDuplicates"];
    const data2 = {};
    for (let i = 0, len = properties3.length; i < len; i++) {
      const property = properties3[i];
      data2[property] = _data[property];
    }
    let idx;
    if (_data.hasOwnProperty("asset")) {
      idx = properties3.indexOf("model");
      if (idx !== -1) {
        properties3.splice(idx, 1);
      }
      idx = properties3.indexOf("render");
      if (idx !== -1) {
        properties3.splice(idx, 1);
      }
    } else if (_data.hasOwnProperty("model")) {
      idx = properties3.indexOf("asset");
      if (idx !== -1) {
        properties3.splice(idx, 1);
      }
    }
    if (!data2.type) {
      data2.type = component.data.type;
    }
    component.data.type = data2.type;
    if (Array.isArray(data2.halfExtents)) {
      data2.halfExtents = new Vec3(data2.halfExtents);
    }
    if (Array.isArray(data2.linearOffset)) {
      data2.linearOffset = new Vec3(data2.linearOffset);
    }
    if (Array.isArray(data2.angularOffset)) {
      const values = data2.angularOffset;
      if (values.length === 3) {
        data2.angularOffset = new Quat().setFromEulerAngles(values[0], values[1], values[2]);
      } else {
        data2.angularOffset = new Quat(data2.angularOffset);
      }
    }
    const impl = this._createImplementation(data2.type);
    impl.beforeInitialize(component, data2);
    super.initializeComponentData(component, data2, properties3);
    impl.afterInitialize(component, data2);
  }
  _createImplementation(type) {
    if (this.implementations[type] === void 0) {
      let impl;
      switch (type) {
        case "box":
          impl = new CollisionBoxSystemImpl(this);
          break;
        case "sphere":
          impl = new CollisionSphereSystemImpl(this);
          break;
        case "capsule":
          impl = new CollisionCapsuleSystemImpl(this);
          break;
        case "cylinder":
          impl = new CollisionCylinderSystemImpl(this);
          break;
        case "cone":
          impl = new CollisionConeSystemImpl(this);
          break;
        case "mesh":
          impl = new CollisionMeshSystemImpl(this);
          break;
        case "compound":
          impl = new CollisionCompoundSystemImpl(this);
          break;
      }
      this.implementations[type] = impl;
    }
    return this.implementations[type];
  }
  _getImplementation(entity) {
    return this.implementations[entity.collision.data.type];
  }
  cloneComponent(entity, clone) {
    return this._getImplementation(entity).clone(entity, clone);
  }
  onBeforeRemove(entity, component) {
    this.implementations[component.data.type].beforeRemove(entity, component);
    component.onBeforeRemove();
  }
  onRemove(entity, data2) {
    this.implementations[data2.type].remove(entity, data2);
  }
  updateCompoundChildTransform(entity) {
    this._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);
    if (entity.enabled && entity.collision.enabled) {
      const transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);
      entity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);
      Ammo.destroy(transform);
    }
  }
  _removeCompoundChild(collision, shape) {
    if (collision.shape.removeChildShape) {
      collision.shape.removeChildShape(shape);
    } else {
      const ind = collision._getCompoundChildShapeIndex(shape);
      if (ind !== null) {
        collision.shape.removeChildShapeByIndex(ind);
      }
    }
  }
  onTransformChanged(component, position3, rotation2, scale2) {
    this.implementations[component.data.type].updateTransform(component, position3, rotation2, scale2);
  }
  changeType(component, previousType, newType) {
    this.implementations[previousType].beforeRemove(component.entity, component);
    this.implementations[previousType].remove(component.entity, component.data);
    this._createImplementation(newType).reset(component, component.data);
  }
  recreatePhysicalShapes(component) {
    this.implementations[component.data.type].recreatePhysicalShapes(component);
  }
  _calculateNodeRelativeTransform(node, relative) {
    if (node === relative) {
      const scale2 = node.getWorldTransform().getScale();
      mat42.setScale(scale2.x, scale2.y, scale2.z);
    } else {
      this._calculateNodeRelativeTransform(node.parent, relative);
      mat42.mul(node.getLocalTransform());
    }
  }
  _getNodeScaling(node) {
    const wtm = node.getWorldTransform();
    const scl = wtm.getScale();
    return new Ammo.btVector3(scl.x, scl.y, scl.z);
  }
  _getNodeTransform(node, relative) {
    let pos, rot;
    if (relative) {
      this._calculateNodeRelativeTransform(node, relative);
      pos = p1;
      rot = quat3;
      mat42.getTranslation(pos);
      rot.setFromMat4(mat42);
    } else {
      pos = node.getPosition();
      rot = node.getRotation();
    }
    const ammoQuat = new Ammo.btQuaternion();
    const transform = new Ammo.btTransform();
    transform.setIdentity();
    const origin = transform.getOrigin();
    const component = node.collision;
    if (component && component._hasOffset) {
      const lo = component.data.linearOffset;
      const ao = component.data.angularOffset;
      const newOrigin = p2;
      quat3.copy(rot).transformVector(lo, newOrigin);
      newOrigin.add(pos);
      quat3.copy(rot).mul(ao);
      origin.setValue(newOrigin.x, newOrigin.y, newOrigin.z);
      ammoQuat.setValue(quat3.x, quat3.y, quat3.z, quat3.w);
    } else {
      origin.setValue(pos.x, pos.y, pos.z);
      ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
    }
    transform.setRotation(ammoQuat);
    Ammo.destroy(ammoQuat);
    Ammo.destroy(origin);
    return transform;
  }
  destroy() {
    for (const key in this._triMeshCache) {
      Ammo.destroy(this._triMeshCache[key]);
    }
    this._triMeshCache = null;
    super.destroy();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/element/image-element.js
var _tempColor2 = new Color();
var _vertexFormatDeviceCache = new DeviceCache();
var ImageRenderable = class {
  constructor(entity, mesh, material) {
    this._entity = entity;
    this._element = entity.element;
    this.model = new Model();
    this.node = new GraphNode();
    this.model.graph = this.node;
    this.mesh = mesh;
    this.meshInstance = new MeshInstance(this.mesh, material, this.node);
    this.meshInstance.name = `ImageElement: ${entity.name}`;
    this.meshInstance.castShadow = false;
    this.meshInstance.receiveShadow = false;
    this._meshDirty = false;
    this.model.meshInstances.push(this.meshInstance);
    this._entity.addChild(this.model.graph);
    this.model._entity = this._entity;
    this.unmaskMeshInstance = null;
  }
  destroy() {
    this.setMaterial(null);
    this._element.removeModelFromLayers(this.model);
    this.model.destroy();
    this.model = null;
    this.node = null;
    this.mesh = null;
    this.meshInstance = null;
    this._entity = null;
    this._element = null;
  }
  setMesh(mesh) {
    if (!this.meshInstance) return;
    this.mesh = mesh;
    this.meshInstance.mesh = mesh;
    this.meshInstance.visible = !!mesh;
    if (this.unmaskMeshInstance) {
      this.unmaskMeshInstance.mesh = mesh;
    }
    this.forceUpdateAabb();
  }
  setMask(mask) {
    if (!this.meshInstance) return;
    if (mask) {
      this.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);
      this.unmaskMeshInstance.name = `Unmask: ${this._entity.name}`;
      this.unmaskMeshInstance.castShadow = false;
      this.unmaskMeshInstance.receiveShadow = false;
      this.unmaskMeshInstance.pick = false;
      this.model.meshInstances.push(this.unmaskMeshInstance);
      for (const name in this.meshInstance.parameters) {
        this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
      }
    } else {
      const idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);
      if (idx >= 0) {
        this.model.meshInstances.splice(idx, 1);
      }
      this.unmaskMeshInstance = null;
    }
    if (this._entity.enabled && this._element.enabled) {
      this._element.removeModelFromLayers(this.model);
      this._element.addModelToLayers(this.model);
    }
  }
  setMaterial(material) {
    if (!this.meshInstance) return;
    this.meshInstance.material = material;
    if (this.unmaskMeshInstance) {
      this.unmaskMeshInstance.material = material;
    }
  }
  setParameter(name, value) {
    if (!this.meshInstance) return;
    this.meshInstance.setParameter(name, value);
    if (this.unmaskMeshInstance) {
      this.unmaskMeshInstance.setParameter(name, value);
    }
  }
  deleteParameter(name) {
    if (!this.meshInstance) return;
    this.meshInstance.deleteParameter(name);
    if (this.unmaskMeshInstance) {
      this.unmaskMeshInstance.deleteParameter(name);
    }
  }
  setUnmaskDrawOrder() {
    if (!this.meshInstance) return;
    const getLastChild = function getLastChild2(e) {
      let last;
      const c2 = e.children;
      const l = c2.length;
      if (l) {
        for (let i = 0; i < l; i++) {
          if (c2[i].element) {
            last = c2[i];
          }
        }
        if (!last) return null;
        const child = getLastChild2(last);
        if (child) {
          return child;
        }
        return last;
      }
      return null;
    };
    if (this.unmaskMeshInstance) {
      const lastChild = getLastChild(this._entity);
      if (lastChild && lastChild.element) {
        this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
      } else {
        this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
      }
    }
  }
  setDrawOrder(drawOrder) {
    if (!this.meshInstance) {
      return;
    }
    this.meshInstance.drawOrder = drawOrder;
  }
  setCull(cull) {
    if (!this.meshInstance) return;
    const element = this._element;
    let visibleFn = null;
    if (cull && element._isScreenSpace()) {
      visibleFn = function(camera) {
        return element.isVisibleForCamera(camera);
      };
    }
    this.meshInstance.cull = cull;
    this.meshInstance.isVisibleFunc = visibleFn;
    if (this.unmaskMeshInstance) {
      this.unmaskMeshInstance.cull = cull;
      this.unmaskMeshInstance.isVisibleFunc = visibleFn;
    }
  }
  setScreenSpace(screenSpace) {
    if (!this.meshInstance) return;
    this.meshInstance.screenSpace = screenSpace;
    if (this.unmaskMeshInstance) {
      this.unmaskMeshInstance.screenSpace = screenSpace;
    }
  }
  setLayer(layer) {
    if (!this.meshInstance) return;
    this.meshInstance.layer = layer;
    if (this.unmaskMeshInstance) {
      this.unmaskMeshInstance.layer = layer;
    }
  }
  forceUpdateAabb(mask) {
    if (!this.meshInstance) return;
    this.meshInstance._aabbVer = -1;
    if (this.unmaskMeshInstance) {
      this.unmaskMeshInstance._aabbVer = -1;
    }
  }
  setAabbFunc(fn) {
    if (!this.meshInstance) return;
    this.meshInstance._updateAabbFunc = fn;
    if (this.unmaskMeshInstance) {
      this.unmaskMeshInstance._updateAabbFunc = fn;
    }
  }
};
var ImageElement = class {
  constructor(element) {
    this._element = element;
    this._entity = element.entity;
    this._system = element.system;
    this._textureAsset = null;
    this._texture = null;
    this._materialAsset = null;
    this._material = null;
    this._spriteAsset = null;
    this._sprite = null;
    this._spriteFrame = 0;
    this._pixelsPerUnit = null;
    this._targetAspectRatio = -1;
    this._rect = new Vec4(0, 0, 1, 1);
    this._mask = false;
    this._maskRef = 0;
    this._outerScale = new Vec2();
    this._outerScaleUniform = new Float32Array(2);
    this._innerOffset = new Vec4();
    this._innerOffsetUniform = new Float32Array(4);
    this._atlasRect = new Vec4();
    this._atlasRectUniform = new Float32Array(4);
    this._defaultMesh = this._createMesh();
    this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
    this._color = new Color(1, 1, 1, 1);
    this._colorUniform = new Float32Array([1, 1, 1]);
    this._updateRenderableEmissive();
    this._renderable.setParameter("material_opacity", 1);
    this._updateAabbFunc = this._updateAabb.bind(this);
    this._onScreenChange(this._element.screen);
    this._element.on("resize", this._onParentResizeOrPivotChange, this);
    this._element.on("set:pivot", this._onParentResizeOrPivotChange, this);
    this._element.on("screen:set:screenspace", this._onScreenSpaceChange, this);
    this._element.on("set:screen", this._onScreenChange, this);
    this._element.on("set:draworder", this._onDrawOrderChange, this);
    this._element.on("screen:set:resolution", this._onResolutionChange, this);
  }
  destroy() {
    this.textureAsset = null;
    this.spriteAsset = null;
    this.materialAsset = null;
    this._renderable.setMesh(this._defaultMesh);
    this._renderable.destroy();
    this._defaultMesh = null;
    this._element.off("resize", this._onParentResizeOrPivotChange, this);
    this._element.off("set:pivot", this._onParentResizeOrPivotChange, this);
    this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this);
    this._element.off("set:screen", this._onScreenChange, this);
    this._element.off("set:draworder", this._onDrawOrderChange, this);
    this._element.off("screen:set:resolution", this._onResolutionChange, this);
  }
  _onResolutionChange(res) {
  }
  _onParentResizeOrPivotChange() {
    if (this._renderable.mesh) {
      this._updateMesh(this._renderable.mesh);
    }
  }
  _onScreenSpaceChange(value) {
    this._updateMaterial(value);
  }
  _onScreenChange(screen, previous) {
    if (screen) {
      this._updateMaterial(screen.screen.screenSpace);
    } else {
      this._updateMaterial(false);
    }
  }
  _onDrawOrderChange(order) {
    this._renderable.setDrawOrder(order);
    if (this.mask && this._element.screen) {
      this._element.screen.screen.once("syncdraworder", function() {
        this._renderable.setUnmaskDrawOrder();
      }, this);
    }
  }
  _hasUserMaterial() {
    return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
  }
  _use9Slicing() {
    return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
  }
  _updateMaterial(screenSpace) {
    const mask = !!this._mask;
    const nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
    const nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
    if (!this._hasUserMaterial()) {
      this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
    }
    if (this._renderable) {
      this._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled());
      this._renderable.setMaterial(this._material);
      this._renderable.setScreenSpace(screenSpace);
      this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
    }
  }
  _createMesh() {
    const element = this._element;
    const w = element.calculatedWidth;
    const h2 = element.calculatedHeight;
    const r = this._rect;
    const device = this._system.app.graphicsDevice;
    const vertexData = new Float32Array([w, 0, 0, 0, 0, 1, r.x + r.z, 1 - r.y, w, h2, 0, 0, 0, 1, r.x + r.z, 1 - (r.y + r.w), 0, 0, 0, 0, 0, 1, r.x, 1 - r.y, 0, h2, 0, 0, 0, 1, r.x, 1 - (r.y + r.w)]);
    const vertexFormat = _vertexFormatDeviceCache.get(device, () => {
      return new VertexFormat(device, [{
        semantic: SEMANTIC_POSITION,
        components: 3,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_NORMAL,
        components: 3,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_TEXCOORD0,
        components: 2,
        type: TYPE_FLOAT32
      }]);
    });
    const vertexBuffer = new VertexBuffer(device, vertexFormat, 4, {
      data: vertexData.buffer
    });
    const mesh = new Mesh(device);
    mesh.vertexBuffer = vertexBuffer;
    mesh.primitive[0].type = PRIMITIVE_TRISTRIP;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = 4;
    mesh.primitive[0].indexed = false;
    mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h2, 0));
    this._updateMesh(mesh);
    return mesh;
  }
  _updateMesh(mesh) {
    const element = this._element;
    let w = element.calculatedWidth;
    let h2 = element.calculatedHeight;
    if (element.fitMode !== FITMODE_STRETCH && this._targetAspectRatio > 0) {
      const actualRatio = element.calculatedWidth / element.calculatedHeight;
      if (element.fitMode === FITMODE_CONTAIN && actualRatio > this._targetAspectRatio || element.fitMode === FITMODE_COVER && actualRatio < this._targetAspectRatio) {
        w = element.calculatedHeight * this._targetAspectRatio;
      } else {
        h2 = element.calculatedWidth / this._targetAspectRatio;
      }
    }
    const screenSpace = element._isScreenSpace();
    this._updateMaterial(screenSpace);
    if (this._renderable) this._renderable.forceUpdateAabb();
    if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
      const frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
      const borderWidthScale = 2 / frameData.rect.z;
      const borderHeightScale = 2 / frameData.rect.w;
      this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
      const tex = this.sprite.atlas.texture;
      this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
      const ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
      const scaleMulX = frameData.rect.z / ppu;
      const scaleMulY = frameData.rect.w / ppu;
      this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h2, this._innerOffset.y * scaleMulY));
      let scaleX = scaleMulX;
      let scaleY = scaleMulY;
      this._outerScale.x /= scaleMulX;
      this._outerScale.y /= scaleMulY;
      scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 1e-4, 1);
      scaleY *= math.clamp(h2 / (this._innerOffset.y * scaleMulY), 1e-4, 1);
      if (this._renderable) {
        this._innerOffsetUniform[0] = this._innerOffset.x;
        this._innerOffsetUniform[1] = this._innerOffset.y;
        this._innerOffsetUniform[2] = this._innerOffset.z;
        this._innerOffsetUniform[3] = this._innerOffset.w;
        this._renderable.setParameter("innerOffset", this._innerOffsetUniform);
        this._atlasRectUniform[0] = this._atlasRect.x;
        this._atlasRectUniform[1] = this._atlasRect.y;
        this._atlasRectUniform[2] = this._atlasRect.z;
        this._atlasRectUniform[3] = this._atlasRect.w;
        this._renderable.setParameter("atlasRect", this._atlasRectUniform);
        this._outerScaleUniform[0] = this._outerScale.x;
        this._outerScaleUniform[1] = this._outerScale.y;
        this._renderable.setParameter("outerScale", this._outerScaleUniform);
        this._renderable.setAabbFunc(this._updateAabbFunc);
        this._renderable.node.setLocalScale(scaleX, scaleY, 1);
        this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h2, 0);
      }
    } else {
      const vb = mesh.vertexBuffer;
      const vertexDataF32 = new Float32Array(vb.lock());
      const hp = element.pivot.x;
      const vp = element.pivot.y;
      vertexDataF32[0] = w - hp * w;
      vertexDataF32[1] = 0 - vp * h2;
      vertexDataF32[8] = w - hp * w;
      vertexDataF32[9] = h2 - vp * h2;
      vertexDataF32[16] = 0 - hp * w;
      vertexDataF32[17] = 0 - vp * h2;
      vertexDataF32[24] = 0 - hp * w;
      vertexDataF32[25] = h2 - vp * h2;
      let atlasTextureWidth = 1;
      let atlasTextureHeight = 1;
      let rect = this._rect;
      if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
        const frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
        if (frame) {
          rect = frame.rect;
          atlasTextureWidth = this._sprite.atlas.texture.width;
          atlasTextureHeight = this._sprite.atlas.texture.height;
        }
      }
      vertexDataF32[6] = (rect.x + rect.z) / atlasTextureWidth;
      vertexDataF32[7] = 1 - rect.y / atlasTextureHeight;
      vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
      vertexDataF32[15] = 1 - (rect.y + rect.w) / atlasTextureHeight;
      vertexDataF32[22] = rect.x / atlasTextureWidth;
      vertexDataF32[23] = 1 - rect.y / atlasTextureHeight;
      vertexDataF32[30] = rect.x / atlasTextureWidth;
      vertexDataF32[31] = 1 - (rect.y + rect.w) / atlasTextureHeight;
      vb.unlock();
      const min = new Vec3(0 - hp * w, 0 - vp * h2, 0);
      const max = new Vec3(w - hp * w, h2 - vp * h2, 0);
      mesh.aabb.setMinMax(min, max);
      if (this._renderable) {
        this._renderable.node.setLocalScale(1, 1, 1);
        this._renderable.node.setLocalPosition(0, 0, 0);
        this._renderable.setAabbFunc(null);
      }
    }
    this._meshDirty = false;
  }
  _updateSprite() {
    let nineSlice = false;
    let mesh = null;
    this._targetAspectRatio = -1;
    if (this._sprite && this._sprite.atlas) {
      mesh = this._sprite.meshes[this.spriteFrame];
      nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
      const frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
      if ((frameData == null ? void 0 : frameData.rect.w) > 0) {
        this._targetAspectRatio = frameData.rect.z / frameData.rect.w;
      }
    }
    this.mesh = nineSlice ? mesh : this._defaultMesh;
    this.refreshMesh();
  }
  refreshMesh() {
    if (this.mesh) {
      if (!this._element._beingInitialized) {
        this._updateMesh(this.mesh);
      } else {
        this._meshDirty = true;
      }
    }
  }
  _updateAabb(aabb3) {
    aabb3.center.set(0, 0, 0);
    aabb3.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 1e-3);
    aabb3.setFromTransformedAabb(aabb3, this._renderable.node.getWorldTransform());
    return aabb3;
  }
  _toggleMask() {
    this._element._dirtifyMask();
    const screenSpace = this._element._isScreenSpace();
    this._updateMaterial(screenSpace);
    this._renderable.setMask(!!this._mask);
  }
  _onMaterialLoad(asset) {
    this.material = asset.resource;
  }
  _onMaterialAdded(asset) {
    this._system.app.assets.off(`add:${asset.id}`, this._onMaterialAdded, this);
    if (this._materialAsset === asset.id) {
      this._bindMaterialAsset(asset);
    }
  }
  _bindMaterialAsset(asset) {
    if (!this._entity.enabled) return;
    asset.on("load", this._onMaterialLoad, this);
    asset.on("change", this._onMaterialChange, this);
    asset.on("remove", this._onMaterialRemove, this);
    if (asset.resource) {
      this._onMaterialLoad(asset);
    } else {
      this._system.app.assets.load(asset);
    }
  }
  _unbindMaterialAsset(asset) {
    asset.off("load", this._onMaterialLoad, this);
    asset.off("change", this._onMaterialChange, this);
    asset.off("remove", this._onMaterialRemove, this);
  }
  _onMaterialChange() {
  }
  _onMaterialRemove() {
  }
  _onTextureAdded(asset) {
    this._system.app.assets.off(`add:${asset.id}`, this._onTextureAdded, this);
    if (this._textureAsset === asset.id) {
      this._bindTextureAsset(asset);
    }
  }
  _bindTextureAsset(asset) {
    if (!this._entity.enabled) return;
    asset.on("load", this._onTextureLoad, this);
    asset.on("change", this._onTextureChange, this);
    asset.on("remove", this._onTextureRemove, this);
    if (asset.resource) {
      this._onTextureLoad(asset);
    } else {
      this._system.app.assets.load(asset);
    }
  }
  _unbindTextureAsset(asset) {
    asset.off("load", this._onTextureLoad, this);
    asset.off("change", this._onTextureChange, this);
    asset.off("remove", this._onTextureRemove, this);
  }
  _onTextureLoad(asset) {
    this.texture = asset.resource;
  }
  _onTextureChange(asset) {
  }
  _onTextureRemove(asset) {
  }
  _onSpriteAssetAdded(asset) {
    this._system.app.assets.off(`add:${asset.id}`, this._onSpriteAssetAdded, this);
    if (this._spriteAsset === asset.id) {
      this._bindSpriteAsset(asset);
    }
  }
  _bindSpriteAsset(asset) {
    if (!this._entity.enabled) return;
    asset.on("load", this._onSpriteAssetLoad, this);
    asset.on("change", this._onSpriteAssetChange, this);
    asset.on("remove", this._onSpriteAssetRemove, this);
    if (asset.resource) {
      this._onSpriteAssetLoad(asset);
    } else {
      this._system.app.assets.load(asset);
    }
  }
  _unbindSpriteAsset(asset) {
    asset.off("load", this._onSpriteAssetLoad, this);
    asset.off("change", this._onSpriteAssetChange, this);
    asset.off("remove", this._onSpriteAssetRemove, this);
    if (asset.data.textureAtlasAsset) {
      this._system.app.assets.off(`load:${asset.data.textureAtlasAsset}`, this._onTextureAtlasLoad, this);
    }
  }
  _onSpriteAssetLoad(asset) {
    if (!asset || !asset.resource) {
      this.sprite = null;
    } else {
      if (!asset.resource.atlas) {
        const atlasAssetId = asset.data.textureAtlasAsset;
        if (atlasAssetId) {
          const assets = this._system.app.assets;
          assets.off(`load:${atlasAssetId}`, this._onTextureAtlasLoad, this);
          assets.once(`load:${atlasAssetId}`, this._onTextureAtlasLoad, this);
        }
      } else {
        this.sprite = asset.resource;
      }
    }
  }
  _onSpriteAssetChange(asset) {
    this._onSpriteAssetLoad(asset);
  }
  _onSpriteAssetRemove(asset) {
  }
  _bindSprite(sprite) {
    sprite.on("set:meshes", this._onSpriteMeshesChange, this);
    sprite.on("set:pixelsPerUnit", this._onSpritePpuChange, this);
    sprite.on("set:atlas", this._onAtlasTextureChange, this);
    if (sprite.atlas) {
      sprite.atlas.on("set:texture", this._onAtlasTextureChange, this);
    }
  }
  _unbindSprite(sprite) {
    sprite.off("set:meshes", this._onSpriteMeshesChange, this);
    sprite.off("set:pixelsPerUnit", this._onSpritePpuChange, this);
    sprite.off("set:atlas", this._onAtlasTextureChange, this);
    if (sprite.atlas) {
      sprite.atlas.off("set:texture", this._onAtlasTextureChange, this);
    }
  }
  _onSpriteMeshesChange() {
    if (this._sprite) {
      this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
    }
    this._updateSprite();
  }
  _onSpritePpuChange() {
    if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
      this._updateSprite();
    }
  }
  _onAtlasTextureChange() {
    if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
      this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture);
      this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture);
    } else {
      this._renderable.deleteParameter("texture_emissiveMap");
      this._renderable.deleteParameter("texture_opacityMap");
    }
  }
  _onTextureAtlasLoad(atlasAsset) {
    const spriteAsset = this._spriteAsset;
    if (spriteAsset instanceof Asset) {
      this._onSpriteAssetLoad(spriteAsset);
    } else {
      this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
    }
  }
  onEnable() {
    if (this._materialAsset) {
      const asset = this._system.app.assets.get(this._materialAsset);
      if (asset && asset.resource !== this._material) {
        this._bindMaterialAsset(asset);
      }
    }
    if (this._textureAsset) {
      const asset = this._system.app.assets.get(this._textureAsset);
      if (asset && asset.resource !== this._texture) {
        this._bindTextureAsset(asset);
      }
    }
    if (this._spriteAsset) {
      const asset = this._system.app.assets.get(this._spriteAsset);
      if (asset && asset.resource !== this._sprite) {
        this._bindSpriteAsset(asset);
      }
    }
    this._element.addModelToLayers(this._renderable.model);
  }
  onDisable() {
    this._element.removeModelFromLayers(this._renderable.model);
  }
  _setStencil(stencilParams) {
    this._renderable.meshInstance.stencilFront = stencilParams;
    this._renderable.meshInstance.stencilBack = stencilParams;
    let ref = 0;
    if (this._element.maskedBy) {
      ref = this._element.maskedBy.element._image._maskRef;
    }
    if (this._renderable.unmaskMeshInstance) {
      const sp = new StencilParameters({
        ref: ref + 1,
        func: FUNC_EQUAL,
        zpass: STENCILOP_DECREMENT
      });
      this._renderable.unmaskMeshInstance.stencilFront = sp;
      this._renderable.unmaskMeshInstance.stencilBack = sp;
    }
  }
  _updateRenderableEmissive() {
    _tempColor2.linear(this._color);
    this._colorUniform[0] = _tempColor2.r;
    this._colorUniform[1] = _tempColor2.g;
    this._colorUniform[2] = _tempColor2.b;
    this._renderable.setParameter("material_emissive", this._colorUniform);
  }
  set color(value) {
    const {
      r,
      g,
      b
    } = value;
    if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
      this._color.r = r;
      this._color.g = g;
      this._color.b = b;
      this._updateRenderableEmissive();
    }
    if (this._element) {
      this._element.fire("set:color", this._color);
    }
  }
  get color() {
    return this._color;
  }
  set opacity(value) {
    if (value !== this._color.a) {
      this._color.a = value;
      this._renderable.setParameter("material_opacity", value);
    }
    if (this._element) {
      this._element.fire("set:opacity", value);
    }
  }
  get opacity() {
    return this._color.a;
  }
  set rect(value) {
    let x2, y2, z2, w;
    if (value instanceof Vec4) {
      x2 = value.x;
      y2 = value.y;
      z2 = value.z;
      w = value.w;
    } else {
      x2 = value[0];
      y2 = value[1];
      z2 = value[2];
      w = value[3];
    }
    if (x2 === this._rect.x && y2 === this._rect.y && z2 === this._rect.z && w === this._rect.w) {
      return;
    }
    this._rect.set(x2, y2, z2, w);
    if (this._renderable.mesh) {
      if (!this._element._beingInitialized) {
        this._updateMesh(this._renderable.mesh);
      } else {
        this._meshDirty = true;
      }
    }
  }
  get rect() {
    return this._rect;
  }
  _removeMaterialAssetEvents() {
    if (this._materialAsset) {
      const assets = this._system.app.assets;
      assets.off(`add:${this._materialAsset}`, this._onMaterialAdded, this);
      const asset = assets.get(this._materialAsset);
      if (asset) {
        asset.off("load", this._onMaterialLoad, this);
        asset.off("change", this._onMaterialChange, this);
        asset.off("remove", this._onMaterialRemove, this);
      }
    }
  }
  set material(value) {
    if (this._material === value) return;
    if (!value) {
      const screenSpace = this._element._isScreenSpace();
      if (this.mask) {
        value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
      } else {
        value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
      }
    }
    this._material = value;
    if (this._materialAsset) {
      const asset = this._system.app.assets.get(this._materialAsset);
      if (!asset || asset.resource !== value) {
        this._removeMaterialAssetEvents();
        this._materialAsset = null;
      }
    }
    if (value) {
      this._renderable.setMaterial(value);
      if (this._hasUserMaterial()) {
        this._renderable.deleteParameter("material_opacity");
        this._renderable.deleteParameter("material_emissive");
      } else {
        this._updateRenderableEmissive();
        this._renderable.setParameter("material_opacity", this._color.a);
      }
    }
  }
  get material() {
    return this._material;
  }
  set materialAsset(value) {
    const assets = this._system.app.assets;
    let _id = value;
    if (value instanceof Asset) {
      _id = value.id;
    }
    if (this._materialAsset !== _id) {
      this._removeMaterialAssetEvents();
      this._materialAsset = _id;
      if (this._materialAsset) {
        const asset = assets.get(this._materialAsset);
        if (!asset) {
          this._materialAsset = null;
          this.material = null;
          this._materialAsset = _id;
          assets.on(`add:${this._materialAsset}`, this._onMaterialAdded, this);
        } else {
          this._bindMaterialAsset(asset);
        }
      } else {
        this._materialAsset = null;
        this.material = null;
        this._materialAsset = _id;
      }
    }
  }
  get materialAsset() {
    return this._materialAsset;
  }
  set texture(value) {
    if (this._texture === value) return;
    if (this._textureAsset) {
      const textureAsset = this._system.app.assets.get(this._textureAsset);
      if (textureAsset && textureAsset.resource !== value) {
        this.textureAsset = null;
      }
    }
    this._texture = value;
    if (value) {
      if (this._spriteAsset) {
        this.spriteAsset = null;
      }
      this._renderable.setParameter("texture_emissiveMap", this._texture);
      this._renderable.setParameter("texture_opacityMap", this._texture);
      this._updateRenderableEmissive();
      this._renderable.setParameter("material_opacity", this._color.a);
      const newAspectRatio = this._texture.width / this._texture.height;
      if (newAspectRatio !== this._targetAspectRatio) {
        this._targetAspectRatio = newAspectRatio;
        if (this._element.fitMode !== FITMODE_STRETCH) {
          this.refreshMesh();
        }
      }
    } else {
      this._renderable.deleteParameter("texture_emissiveMap");
      this._renderable.deleteParameter("texture_opacityMap");
      this._targetAspectRatio = -1;
      if (this._element.fitMode !== FITMODE_STRETCH) {
        this.refreshMesh();
      }
    }
  }
  get texture() {
    return this._texture;
  }
  set textureAsset(value) {
    const assets = this._system.app.assets;
    let _id = value;
    if (value instanceof Asset) {
      _id = value.id;
    }
    if (this._textureAsset !== _id) {
      if (this._textureAsset) {
        assets.off(`add:${this._textureAsset}`, this._onTextureAdded, this);
        const _prev = assets.get(this._textureAsset);
        if (_prev) {
          _prev.off("load", this._onTextureLoad, this);
          _prev.off("change", this._onTextureChange, this);
          _prev.off("remove", this._onTextureRemove, this);
        }
      }
      this._textureAsset = _id;
      if (this._textureAsset) {
        const asset = assets.get(this._textureAsset);
        if (!asset) {
          this.texture = null;
          assets.on(`add:${this._textureAsset}`, this._onTextureAdded, this);
        } else {
          this._bindTextureAsset(asset);
        }
      } else {
        this.texture = null;
      }
    }
  }
  get textureAsset() {
    return this._textureAsset;
  }
  set spriteAsset(value) {
    const assets = this._system.app.assets;
    let _id = value;
    if (value instanceof Asset) {
      _id = value.id;
    }
    if (this._spriteAsset !== _id) {
      if (this._spriteAsset) {
        assets.off(`add:${this._spriteAsset}`, this._onSpriteAssetAdded, this);
        const _prev = assets.get(this._spriteAsset);
        if (_prev) {
          this._unbindSpriteAsset(_prev);
        }
      }
      this._spriteAsset = _id;
      if (this._spriteAsset) {
        const asset = assets.get(this._spriteAsset);
        if (!asset) {
          this.sprite = null;
          assets.on(`add:${this._spriteAsset}`, this._onSpriteAssetAdded, this);
        } else {
          this._bindSpriteAsset(asset);
        }
      } else {
        this.sprite = null;
      }
    }
    if (this._element) {
      this._element.fire("set:spriteAsset", _id);
    }
  }
  get spriteAsset() {
    return this._spriteAsset;
  }
  set sprite(value) {
    if (this._sprite === value) return;
    if (this._sprite) {
      this._unbindSprite(this._sprite);
    }
    if (this._spriteAsset) {
      const spriteAsset = this._system.app.assets.get(this._spriteAsset);
      if (spriteAsset && spriteAsset.resource !== value) {
        this.spriteAsset = null;
      }
    }
    this._sprite = value;
    if (this._sprite) {
      this._bindSprite(this._sprite);
      if (this._textureAsset) {
        this.textureAsset = null;
      }
    }
    if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
      this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture);
      this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture);
    } else {
      this._renderable.deleteParameter("texture_emissiveMap");
      this._renderable.deleteParameter("texture_opacityMap");
    }
    if (this._sprite) {
      this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
    }
    this._updateSprite();
  }
  get sprite() {
    return this._sprite;
  }
  set spriteFrame(value) {
    const oldValue = this._spriteFrame;
    if (this._sprite) {
      this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
    } else {
      this._spriteFrame = value;
    }
    if (this._spriteFrame !== oldValue) {
      this._updateSprite();
    }
    if (this._element) {
      this._element.fire("set:spriteFrame", value);
    }
  }
  get spriteFrame() {
    return this._spriteFrame;
  }
  set mesh(value) {
    this._renderable.setMesh(value);
    if (this._defaultMesh === value) {
      this._renderable.setAabbFunc(null);
    } else {
      this._renderable.setAabbFunc(this._updateAabbFunc);
    }
  }
  get mesh() {
    return this._renderable.mesh;
  }
  set mask(value) {
    if (this._mask !== value) {
      this._mask = value;
      this._toggleMask();
    }
  }
  get mask() {
    return this._mask;
  }
  set pixelsPerUnit(value) {
    if (this._pixelsPerUnit === value) return;
    this._pixelsPerUnit = value;
    if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
      this._updateSprite();
    }
  }
  get pixelsPerUnit() {
    return this._pixelsPerUnit;
  }
  get aabb() {
    if (this._renderable.meshInstance) {
      return this._renderable.meshInstance.aabb;
    }
    return null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/asset/asset-localized.js
var LocalizedAsset = class extends EventHandler {
  constructor(app2) {
    super();
    this._app = app2;
    app2.i18n.on("set:locale", this._onSetLocale, this);
    this._autoLoad = false;
    this._disableLocalization = false;
    this._defaultAsset = null;
    this._localizedAsset = null;
  }
  set defaultAsset(value) {
    const id13 = value instanceof Asset ? value.id : value;
    if (this._defaultAsset === id13) return;
    if (this._defaultAsset) {
      this._unbindDefaultAsset();
    }
    this._defaultAsset = id13;
    if (this._defaultAsset) {
      this._bindDefaultAsset();
    }
    this._onSetLocale(this._app.i18n.locale);
  }
  get defaultAsset() {
    return this._defaultAsset;
  }
  set localizedAsset(value) {
    const id13 = value instanceof Asset ? value.id : value;
    if (this._localizedAsset === id13) {
      return;
    }
    if (this._localizedAsset) {
      this._app.assets.off(`add:${this._localizedAsset}`, this._onLocalizedAssetAdd, this);
      this._unbindLocalizedAsset();
    }
    this._localizedAsset = id13;
    if (this._localizedAsset) {
      const asset = this._app.assets.get(this._localizedAsset);
      if (!asset) {
        this._app.assets.once(`add:${this._localizedAsset}`, this._onLocalizedAssetAdd, this);
      } else {
        this._bindLocalizedAsset();
      }
    }
  }
  get localizedAsset() {
    return this._localizedAsset;
  }
  set autoLoad(value) {
    if (this._autoLoad === value) return;
    this._autoLoad = value;
    if (this._autoLoad && this._localizedAsset) {
      this._unbindLocalizedAsset();
      this._bindLocalizedAsset();
    }
  }
  get autoLoad() {
    return this._autoLoad;
  }
  set disableLocalization(value) {
    if (this._disableLocalization === value) return;
    this._disableLocalization = value;
    this._onSetLocale(this._app.i18n.locale);
  }
  get disableLocalization() {
    return this._disableLocalization;
  }
  _bindDefaultAsset() {
    const asset = this._app.assets.get(this._defaultAsset);
    if (!asset) {
      this._app.assets.once(`add:${this._defaultAsset}`, this._onDefaultAssetAdd, this);
    } else {
      this._onDefaultAssetAdd(asset);
    }
  }
  _unbindDefaultAsset() {
    if (!this._defaultAsset) return;
    this._app.assets.off(`add:${this._defaultAsset}`, this._onDefaultAssetAdd, this);
    const asset = this._app.assets.get(this._defaultAsset);
    if (!asset) return;
    asset.off("add:localized", this._onLocaleAdd, this);
    asset.off("remove:localized", this._onLocaleRemove, this);
    asset.off("remove", this._onDefaultAssetRemove, this);
  }
  _onDefaultAssetAdd(asset) {
    if (this._defaultAsset !== asset.id) return;
    asset.on("add:localized", this._onLocaleAdd, this);
    asset.on("remove:localized", this._onLocaleRemove, this);
    asset.once("remove", this._onDefaultAssetRemove, this);
  }
  _onDefaultAssetRemove(asset) {
    if (this._defaultAsset !== asset.id) return;
    asset.off("add:localized", this._onLocaleAdd, this);
    asset.off("remove:localized", this._onLocaleAdd, this);
    this._app.assets.once(`add:${this._defaultAsset}`, this._onDefaultAssetAdd, this);
  }
  _bindLocalizedAsset() {
    if (!this._autoLoad) return;
    const asset = this._app.assets.get(this._localizedAsset);
    if (!asset) return;
    asset.on("load", this._onLocalizedAssetLoad, this);
    asset.on("change", this._onLocalizedAssetChange, this);
    asset.on("remove", this._onLocalizedAssetRemove, this);
    if (asset.resource) {
      this._onLocalizedAssetLoad(asset);
    } else {
      this._app.assets.load(asset);
    }
  }
  _unbindLocalizedAsset() {
    const asset = this._app.assets.get(this._localizedAsset);
    if (!asset) return;
    asset.off("load", this._onLocalizedAssetLoad, this);
    asset.off("change", this._onLocalizedAssetChange, this);
    asset.off("remove", this._onLocalizedAssetRemove, this);
  }
  _onLocalizedAssetAdd(asset) {
    if (this._localizedAsset !== asset.id) return;
    this._bindLocalizedAsset();
  }
  _onLocalizedAssetLoad(asset) {
    this.fire("load", asset);
  }
  _onLocalizedAssetChange(asset, name, newValue, oldValue) {
    this.fire("change", asset, name, newValue, oldValue);
  }
  _onLocalizedAssetRemove(asset) {
    if (this._localizedAsset === asset.id) {
      this.localizedAsset = this._defaultAsset;
    }
    this.fire("remove", asset);
  }
  _onLocaleAdd(locale, assetId) {
    if (this._app.i18n.locale !== locale) return;
    this._onSetLocale(locale);
  }
  _onLocaleRemove(locale, assetId) {
    if (this._app.i18n.locale !== locale) return;
    this._onSetLocale(locale);
  }
  _onSetLocale(locale) {
    if (!this._defaultAsset) {
      this.localizedAsset = null;
      return;
    }
    const asset = this._app.assets.get(this._defaultAsset);
    if (!asset || this._disableLocalization) {
      this.localizedAsset = this._defaultAsset;
      return;
    }
    const localizedAssetId = asset.getLocalizedAssetId(locale);
    if (!localizedAssetId) {
      this.localizedAsset = this._defaultAsset;
      return;
    }
    this.localizedAsset = localizedAssetId;
  }
  destroy() {
    this.defaultAsset = null;
    this._app.i18n.off("set:locale", this._onSetLocale, this);
    this.off();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/font/constants.js
var FONT_MSDF = "msdf";
var FONT_BITMAP = "bitmap";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/element/markup.js
var EOF_TOKEN = 0;
var ERROR_TOKEN = 1;
var TEXT_TOKEN = 2;
var OPEN_BRACKET_TOKEN = 3;
var CLOSE_BRACKET_TOKEN = 4;
var EQUALS_TOKEN = 5;
var STRING_TOKEN = 6;
var IDENTIFIER_TOKEN = 7;
var WHITESPACE_TOKEN = 8;
var WHITESPACE_CHARS = " 	\n\r\v\f";
var IDENTIFIER_REGEX = /[\w|/]/;
var Scanner = class {
  constructor(symbols) {
    this._symbols = symbols;
    this._index = 0;
    this._last = 0;
    this._cur = this._symbols.length > 0 ? this._symbols[0] : null;
    this._buf = [];
    this._mode = "text";
    this._error = null;
  }
  read() {
    let token = this._read();
    while (token === WHITESPACE_TOKEN) {
      token = this._read();
    }
    if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {
      this._last = this._index;
    }
    return token;
  }
  buf() {
    return this._buf;
  }
  last() {
    return this._last;
  }
  error() {
    return this._error;
  }
  debugPrint() {
    const tokenStrings = ["EOF", "ERROR", "TEXT", "OPEN_BRACKET", "CLOSE_BRACKET", "EQUALS", "STRING", "IDENTIFIER", "WHITESPACE"];
    let token = this.read();
    let result = "";
    while (true) {
      result += `${(result.length > 0 ? "\n" : "") + tokenStrings[token]} '${this.buf().join("")}'`;
      if (token === EOF_TOKEN || token === ERROR_TOKEN) {
        break;
      }
      token = this.read();
    }
    return result;
  }
  _read() {
    this._buf = [];
    if (this._eof()) {
      return EOF_TOKEN;
    }
    return this._mode === "text" ? this._text() : this._tag();
  }
  _text() {
    while (true) {
      switch (this._cur) {
        case null:
          return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;
        case "[":
          this._mode = "tag";
          return this._buf.length > 0 ? TEXT_TOKEN : this._tag();
        case "\\":
          this._next();
          switch (this._cur) {
            case "[":
              this._store();
              break;
            default:
              this._output("\\");
              break;
          }
          break;
        default:
          this._store();
          break;
      }
    }
  }
  _tag() {
    switch (this._cur) {
      case null:
        this._error = "unexpected end of input reading tag";
        return ERROR_TOKEN;
      case "[":
        this._store();
        return OPEN_BRACKET_TOKEN;
      case "]":
        this._store();
        this._mode = "text";
        return CLOSE_BRACKET_TOKEN;
      case "=":
        this._store();
        return EQUALS_TOKEN;
      case " ":
      case "	":
      case "\n":
      case "\r":
      case "\v":
      case "\f":
        return this._whitespace();
      case '"':
        return this._string();
      default:
        if (!this._isIdentifierSymbol(this._cur)) {
          this._error = "unrecognized character";
          return ERROR_TOKEN;
        }
        return this._identifier();
    }
  }
  _whitespace() {
    this._store();
    while (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {
      this._store();
    }
    return WHITESPACE_TOKEN;
  }
  _string() {
    this._next();
    while (true) {
      switch (this._cur) {
        case null:
          this._error = "unexpected end of input reading string";
          return ERROR_TOKEN;
        case '"':
          this._next();
          return STRING_TOKEN;
        default:
          this._store();
          break;
      }
    }
  }
  _identifier() {
    this._store();
    while (this._cur !== null && this._isIdentifierSymbol(this._cur)) {
      this._store();
    }
    return IDENTIFIER_TOKEN;
  }
  _isIdentifierSymbol(s2) {
    return s2.length === 1 && s2.match(IDENTIFIER_REGEX) !== null;
  }
  _eof() {
    return this._cur === null;
  }
  _next() {
    if (!this._eof()) {
      this._index++;
      this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;
    }
    return this._cur;
  }
  _store() {
    this._buf.push(this._cur);
    return this._next();
  }
  _output(c2) {
    this._buf.push(c2);
  }
};
var Parser = class {
  constructor(symbols) {
    this._scanner = new Scanner(symbols);
    this._error = null;
  }
  parse(symbols, tags) {
    while (true) {
      const token = this._scanner.read();
      switch (token) {
        case EOF_TOKEN:
          return true;
        case ERROR_TOKEN:
          return false;
        case TEXT_TOKEN:
          Array.prototype.push.apply(symbols, this._scanner.buf());
          break;
        case OPEN_BRACKET_TOKEN:
          if (!this._parseTag(symbols, tags)) {
            return false;
          }
          break;
        default:
          return false;
      }
    }
  }
  error() {
    return `Error evaluating markup at #${this._scanner.last().toString()} (${this._scanner.error() || this._error})`;
  }
  _parseTag(symbols, tags) {
    let token = this._scanner.read();
    if (token !== IDENTIFIER_TOKEN) {
      this._error = "expected identifier";
      return false;
    }
    const name = this._scanner.buf().join("");
    if (name[0] === "/") {
      for (let index = tags.length - 1; index >= 0; --index) {
        if (name === `/${tags[index].name}` && tags[index].end === null) {
          tags[index].end = symbols.length;
          token = this._scanner.read();
          if (token !== CLOSE_BRACKET_TOKEN) {
            this._error = "expected close bracket";
            return false;
          }
          return true;
        }
      }
      this._error = "failed to find matching tag";
      return false;
    }
    const tag = {
      name,
      value: null,
      attributes: {},
      start: symbols.length,
      end: null
    };
    token = this._scanner.read();
    if (token === EQUALS_TOKEN) {
      token = this._scanner.read();
      if (token !== STRING_TOKEN) {
        this._error = "expected string";
        return false;
      }
      tag.value = this._scanner.buf().join("");
      token = this._scanner.read();
    }
    while (true) {
      switch (token) {
        case CLOSE_BRACKET_TOKEN:
          tags.push(tag);
          return true;
        case IDENTIFIER_TOKEN: {
          const identifier = this._scanner.buf().join("");
          token = this._scanner.read();
          if (token !== EQUALS_TOKEN) {
            this._error = "expected equals";
            return false;
          }
          token = this._scanner.read();
          if (token !== STRING_TOKEN) {
            this._error = "expected string";
            return false;
          }
          const value = this._scanner.buf().join("");
          tag.attributes[identifier] = value;
          break;
        }
        default:
          this._error = "expected close bracket or identifier";
          return false;
      }
      token = this._scanner.read();
    }
  }
};
function merge(target2, source) {
  for (const key in source) {
    if (!source.hasOwnProperty(key)) {
      continue;
    }
    const value = source[key];
    if (value instanceof Object) {
      if (!target2.hasOwnProperty(key)) {
        target2[key] = {};
      }
      merge(target2[key], source[key]);
    } else {
      target2[key] = value;
    }
  }
}
function combineTags(tags) {
  if (tags.length === 0) {
    return null;
  }
  const result = {};
  for (let index = 0; index < tags.length; ++index) {
    const tag = tags[index];
    const tmp = {};
    tmp[tag.name] = {
      value: tag.value,
      attributes: tag.attributes
    };
    merge(result, tmp);
  }
  return result;
}
function resolveMarkupTags(tags, numSymbols) {
  if (tags.length === 0) {
    return null;
  }
  const edges = {};
  for (let index = 0; index < tags.length; ++index) {
    const tag = tags[index];
    if (!edges.hasOwnProperty(tag.start)) {
      edges[tag.start] = {
        open: [tag],
        close: null
      };
    } else {
      if (edges[tag.start].open === null) {
        edges[tag.start].open = [tag];
      } else {
        edges[tag.start].open.push(tag);
      }
    }
    if (!edges.hasOwnProperty(tag.end)) {
      edges[tag.end] = {
        open: null,
        close: [tag]
      };
    } else {
      if (edges[tag.end].close === null) {
        edges[tag.end].close = [tag];
      } else {
        edges[tag.end].close.push(tag);
      }
    }
  }
  let tagStack = [];
  function removeTags(tags2) {
    tagStack = tagStack.filter((tag) => {
      return tags2.find((t) => {
        return t === tag;
      }) === void 0;
    });
  }
  function addTags(tags2) {
    for (let index = 0; index < tags2.length; ++index) {
      tagStack.push(tags2[index]);
    }
  }
  const edgeKeys = Object.keys(edges).sort((a, b) => {
    return a - b;
  });
  const resolvedTags = [];
  for (let index = 0; index < edgeKeys.length; ++index) {
    const edge = edges[edgeKeys[index]];
    if (edge.close !== null) {
      removeTags(edge.close);
    }
    if (edge.open !== null) {
      addTags(edge.open);
    }
    resolvedTags.push({
      start: edgeKeys[index],
      tags: combineTags(tagStack)
    });
  }
  const result = [];
  let prevTag = null;
  for (let index = 0; index < resolvedTags.length; ++index) {
    const resolvedTag = resolvedTags[index];
    while (result.length < resolvedTag.start) {
      result.push(prevTag ? prevTag.tags : null);
    }
    prevTag = resolvedTag;
  }
  while (result.length < numSymbols) {
    result.push(null);
  }
  return result;
}
function evaluateMarkup(symbols) {
  const parser = new Parser(symbols);
  const stripped_symbols = [];
  const tags = [];
  if (!parser.parse(stripped_symbols, tags)) {
    console.warn(parser.error());
    return {
      symbols,
      tags: null
    };
  }
  const invalidTag = tags.find((t) => {
    return t.end === null;
  });
  if (invalidTag) {
    console.warn(`Markup error: found unclosed tag='${invalidTag.name}'`);
    return {
      symbols,
      tags: null
    };
  }
  const resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
  return {
    symbols: stripped_symbols,
    tags: resolved_tags
  };
}
var Markup = class {
  static evaluate(symbols) {
    return evaluateMarkup(symbols);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/element/text-element.js
var MeshInfo = class {
  constructor() {
    this.count = 0;
    this.quad = 0;
    this.lines = {};
    this.positions = [];
    this.normals = [];
    this.uvs = [];
    this.colors = [];
    this.indices = [];
    this.outlines = [];
    this.shadows = [];
    this.meshInstance = null;
  }
};
function createTextMesh(device, meshInfo) {
  const mesh = new Mesh(device);
  mesh.setPositions(meshInfo.positions);
  mesh.setNormals(meshInfo.normals);
  mesh.setColors32(meshInfo.colors);
  mesh.setUvs(0, meshInfo.uvs);
  mesh.setIndices(meshInfo.indices);
  mesh.setVertexStream(SEMANTIC_ATTR8, meshInfo.outlines, 3, void 0, TYPE_FLOAT32, false);
  mesh.setVertexStream(SEMANTIC_ATTR9, meshInfo.shadows, 3, void 0, TYPE_FLOAT32, false);
  mesh.update();
  return mesh;
}
var LINE_BREAK_CHAR = /^[\r\n]$/;
var WHITESPACE_CHAR = /^[ \t]$/;
var WORD_BOUNDARY_CHAR = /^[ \t\-]|\u200b$/;
var ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;
var CJK_CHAR = /^[\u1100-\u11ff]|[\u3000-\u9fff\ua960-\ua97f]|[\uac00-\ud7ff]$/;
var NO_LINE_BREAK_CJK_CHAR = /^[]$/;
var CONTROL_CHARS = ["", "", "", "", "", "", "", "", "", "", "", "", ""];
var CONTROL_GLYPH_DATA = {
  width: 0,
  height: 0,
  xadvance: 0,
  xoffset: 0,
  yoffset: 0
};
var colorTmp = new Color();
var vec2Tmp = new Vec2();
var _tempColor3 = new Color();
var TextElement = class {
  constructor(element) {
    this._element = element;
    this._system = element.system;
    this._entity = element.entity;
    this._text = "";
    this._symbols = [];
    this._colorPalette = [];
    this._outlinePalette = [];
    this._shadowPalette = [];
    this._symbolColors = null;
    this._symbolOutlineParams = null;
    this._symbolShadowParams = null;
    this._i18nKey = null;
    this._fontAsset = new LocalizedAsset(this._system.app);
    this._fontAsset.disableLocalization = true;
    this._fontAsset.on("load", this._onFontLoad, this);
    this._fontAsset.on("change", this._onFontChange, this);
    this._fontAsset.on("remove", this._onFontRemove, this);
    this._font = null;
    this._color = new Color(1, 1, 1, 1);
    this._colorUniform = new Float32Array(3);
    this._spacing = 1;
    this._fontSize = 32;
    this._fontMinY = 0;
    this._fontMaxY = 0;
    this._originalFontSize = 32;
    this._maxFontSize = 32;
    this._minFontSize = 8;
    this._autoFitWidth = false;
    this._autoFitHeight = false;
    this._maxLines = -1;
    this._lineHeight = 32;
    this._scaledLineHeight = 32;
    this._wrapLines = false;
    this._drawOrder = 0;
    this._alignment = new Vec2(0.5, 0.5);
    this._autoWidth = true;
    this._autoHeight = true;
    this.width = 0;
    this.height = 0;
    this._node = new GraphNode();
    this._model = new Model();
    this._model.graph = this._node;
    this._entity.addChild(this._node);
    this._meshInfo = [];
    this._material = null;
    this._aabbDirty = true;
    this._aabb = new BoundingBox();
    this._noResize = false;
    this._currentMaterialType = null;
    this._maskedMaterialSrc = null;
    this._rtlReorder = false;
    this._unicodeConverter = false;
    this._rtl = false;
    this._outlineColor = new Color(0, 0, 0, 1);
    this._outlineColorUniform = new Float32Array(4);
    this._outlineThicknessScale = 0.2;
    this._outlineThickness = 0;
    this._shadowColor = new Color(0, 0, 0, 1);
    this._shadowColorUniform = new Float32Array(4);
    this._shadowOffsetScale = 5e-3;
    this._shadowOffset = new Vec2(0, 0);
    this._shadowOffsetUniform = new Float32Array(2);
    this._enableMarkup = false;
    this._onScreenChange(this._element.screen);
    element.on("resize", this._onParentResize, this);
    element.on("set:screen", this._onScreenChange, this);
    element.on("screen:set:screenspace", this._onScreenSpaceChange, this);
    element.on("set:draworder", this._onDrawOrderChange, this);
    element.on("set:pivot", this._onPivotChange, this);
    this._system.app.i18n.on("set:locale", this._onLocaleSet, this);
    this._system.app.i18n.on("data:add", this._onLocalizationData, this);
    this._system.app.i18n.on("data:remove", this._onLocalizationData, this);
    this._rangeStart = 0;
    this._rangeEnd = 0;
  }
  destroy() {
    this._setMaterial(null);
    if (this._model) {
      this._element.removeModelFromLayers(this._model);
      this._model.destroy();
      this._model = null;
    }
    this._fontAsset.destroy();
    this.font = null;
    this._element.off("resize", this._onParentResize, this);
    this._element.off("set:screen", this._onScreenChange, this);
    this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this);
    this._element.off("set:draworder", this._onDrawOrderChange, this);
    this._element.off("set:pivot", this._onPivotChange, this);
    this._system.app.i18n.off("set:locale", this._onLocaleSet, this);
    this._system.app.i18n.off("data:add", this._onLocalizationData, this);
    this._system.app.i18n.off("data:remove", this._onLocalizationData, this);
  }
  _onParentResize(width, height) {
    if (this._noResize) return;
    if (this._font) this._updateText();
  }
  _onScreenChange(screen) {
    if (screen) {
      this._updateMaterial(screen.screen.screenSpace);
    } else {
      this._updateMaterial(false);
    }
  }
  _onScreenSpaceChange(value) {
    this._updateMaterial(value);
  }
  _onDrawOrderChange(order) {
    this._drawOrder = order;
    if (this._model) {
      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
        this._model.meshInstances[i].drawOrder = order;
      }
    }
  }
  _onPivotChange(pivot) {
    if (this._font) {
      this._updateText();
    }
  }
  _onLocaleSet(locale) {
    if (!this._i18nKey) return;
    if (this.fontAsset) {
      const asset = this._system.app.assets.get(this.fontAsset);
      if (!asset || !asset.resource || asset.resource !== this._font) {
        this.font = null;
      }
    }
    this._resetLocalizedText();
  }
  _onLocalizationData(locale, messages) {
    if (this._i18nKey && messages[this._i18nKey]) {
      this._resetLocalizedText();
    }
  }
  _resetLocalizedText() {
    this._setText(this._system.app.i18n.getText(this._i18nKey));
  }
  _setText(text) {
    if (this.unicodeConverter) {
      const unicodeConverterFunc = this._system.getUnicodeConverter();
      if (unicodeConverterFunc) {
        text = unicodeConverterFunc(text);
      } else {
        console.warn("Element created with unicodeConverter option but no unicodeConverter function registered");
      }
    }
    if (this._text !== text) {
      if (this._font) {
        this._updateText(text);
      }
      this._text = text;
    }
  }
  _updateText(text) {
    let tags;
    if (text === void 0) text = this._text;
    this._symbols = string.getSymbols(text.normalize ? text.normalize("NFC") : text);
    if (this._symbols.length === 0) {
      this._symbols = [" "];
    }
    if (this._enableMarkup) {
      const results = Markup.evaluate(this._symbols);
      this._symbols = results.symbols;
      tags = results.tags || [];
    }
    if (this._rtlReorder) {
      const rtlReorderFunc = this._system.app.systems.element.getRtlReorder();
      if (rtlReorderFunc) {
        const results = rtlReorderFunc(this._symbols);
        this._rtl = results.rtl;
        this._symbols = results.mapping.map(function(v) {
          return this._symbols[v];
        }, this);
        if (tags) {
          tags = results.mapping.map((v) => {
            return tags[v];
          });
        }
      } else {
        console.warn("Element created with rtlReorder option but no rtlReorder function registered");
      }
    } else {
      this._rtl = false;
    }
    const getColorThicknessHash = (color, thickness) => {
      return `${color.toString(true).toLowerCase()}:${thickness.toFixed(2)}`;
    };
    const getColorOffsetHash = (color, offset) => {
      return `${color.toString(true).toLowerCase()}:${offset.x.toFixed(2)}:${offset.y.toFixed(2)}`;
    };
    if (tags) {
      const paletteMap = {};
      const outlinePaletteMap = {};
      const shadowPaletteMap = {};
      this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];
      this._outlinePalette = [Math.round(this._outlineColor.r * 255), Math.round(this._outlineColor.g * 255), Math.round(this._outlineColor.b * 255), Math.round(this._outlineColor.a * 255), Math.round(this._outlineThickness * 255)];
      this._shadowPalette = [Math.round(this._shadowColor.r * 255), Math.round(this._shadowColor.g * 255), Math.round(this._shadowColor.b * 255), Math.round(this._shadowColor.a * 255), Math.round(this._shadowOffset.x * 127), Math.round(this._shadowOffset.y * 127)];
      this._symbolColors = [];
      this._symbolOutlineParams = [];
      this._symbolShadowParams = [];
      paletteMap[this._color.toString(false).toLowerCase()] = 0;
      outlinePaletteMap[getColorThicknessHash(this._outlineColor, this._outlineThickness)] = 0;
      shadowPaletteMap[getColorOffsetHash(this._shadowColor, this._shadowOffset)] = 0;
      for (let i = 0, len = this._symbols.length; i < len; ++i) {
        const tag = tags[i];
        let color = 0;
        if (tag && tag.color && tag.color.value) {
          const c2 = tag.color.value;
          if (c2.length === 7 && c2[0] === "#") {
            const hex = c2.substring(1).toLowerCase();
            if (paletteMap.hasOwnProperty(hex)) {
              color = paletteMap[hex];
            } else {
              if (/^[0-9a-f]{6}$/.test(hex)) {
                color = this._colorPalette.length / 3;
                paletteMap[hex] = color;
                this._colorPalette.push(parseInt(hex.substring(0, 2), 16));
                this._colorPalette.push(parseInt(hex.substring(2, 4), 16));
                this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
              }
            }
          }
        }
        this._symbolColors.push(color);
        let outline = 0;
        if (tag && tag.outline && (tag.outline.attributes.color || tag.outline.attributes.thickness)) {
          let _color = tag.outline.attributes.color ? colorTmp.fromString(tag.outline.attributes.color) : this._outlineColor;
          let thickness = Number(tag.outline.attributes.thickness);
          if (Number.isNaN(_color.r) || Number.isNaN(_color.g) || Number.isNaN(_color.b) || Number.isNaN(_color.a)) {
            _color = this._outlineColor;
          }
          if (Number.isNaN(thickness)) {
            thickness = this._outlineThickness;
          }
          const outlineHash = getColorThicknessHash(_color, thickness);
          if (outlinePaletteMap.hasOwnProperty(outlineHash)) {
            outline = outlinePaletteMap[outlineHash];
          } else {
            outline = this._outlinePalette.length / 5;
            outlinePaletteMap[outlineHash] = outline;
            this._outlinePalette.push(Math.round(_color.r * 255), Math.round(_color.g * 255), Math.round(_color.b * 255), Math.round(_color.a * 255), Math.round(thickness * 255));
          }
        }
        this._symbolOutlineParams.push(outline);
        let shadow = 0;
        if (tag && tag.shadow && (tag.shadow.attributes.color || tag.shadow.attributes.offset || tag.shadow.attributes.offsetX || tag.shadow.attributes.offsetY)) {
          let _color2 = tag.shadow.attributes.color ? colorTmp.fromString(tag.shadow.attributes.color) : this._shadowColor;
          const off = Number(tag.shadow.attributes.offset);
          const offX = Number(tag.shadow.attributes.offsetX);
          const offY = Number(tag.shadow.attributes.offsetY);
          if (Number.isNaN(_color2.r) || Number.isNaN(_color2.g) || Number.isNaN(_color2.b) || Number.isNaN(_color2.a)) {
            _color2 = this._shadowColor;
          }
          const offset = vec2Tmp.set(!Number.isNaN(offX) ? offX : !Number.isNaN(off) ? off : this._shadowOffset.x, !Number.isNaN(offY) ? offY : !Number.isNaN(off) ? off : this._shadowOffset.y);
          const shadowHash = getColorOffsetHash(_color2, offset);
          if (shadowPaletteMap.hasOwnProperty(shadowHash)) {
            shadow = shadowPaletteMap[shadowHash];
          } else {
            shadow = this._shadowPalette.length / 6;
            shadowPaletteMap[shadowHash] = shadow;
            this._shadowPalette.push(Math.round(_color2.r * 255), Math.round(_color2.g * 255), Math.round(_color2.b * 255), Math.round(_color2.a * 255), Math.round(offset.x * 127), Math.round(offset.y * 127));
          }
        }
        this._symbolShadowParams.push(shadow);
      }
    } else {
      this._colorPalette = [];
      this._symbolColors = null;
      this._symbolOutlineParams = null;
      this._symbolShadowParams = null;
    }
    this._updateMaterialEmissive();
    this._updateMaterialOutline();
    this._updateMaterialShadow();
    const charactersPerTexture = this._calculateCharsPerTexture();
    let removedModel = false;
    const element = this._element;
    const screenSpace = element._isScreenSpace();
    const screenCulled = element._isScreenCulled();
    const visibleFn = function visibleFn2(camera) {
      return element.isVisibleForCamera(camera);
    };
    for (let i = 0, len = this._meshInfo.length; i < len; i++) {
      const l = charactersPerTexture[i] || 0;
      const meshInfo = this._meshInfo[i];
      if (meshInfo.count !== l) {
        if (!removedModel) {
          element.removeModelFromLayers(this._model);
          removedModel = true;
        }
        meshInfo.count = l;
        meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
        meshInfo.indices.length = l * 3 * 2;
        meshInfo.uvs.length = l * 2 * 4;
        meshInfo.colors.length = l * 4 * 4;
        meshInfo.outlines.length = l * 4 * 3;
        meshInfo.shadows.length = l * 4 * 3;
        if (meshInfo.meshInstance) {
          this._removeMeshInstance(meshInfo.meshInstance);
        }
        if (l === 0) {
          meshInfo.meshInstance = null;
          continue;
        }
        for (let v = 0; v < l; v++) {
          meshInfo.indices[v * 3 * 2 + 0] = v * 4;
          meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
          meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
          meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
          meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
          meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
          meshInfo.normals[v * 4 * 3 + 0] = 0;
          meshInfo.normals[v * 4 * 3 + 1] = 0;
          meshInfo.normals[v * 4 * 3 + 2] = -1;
          meshInfo.normals[v * 4 * 3 + 3] = 0;
          meshInfo.normals[v * 4 * 3 + 4] = 0;
          meshInfo.normals[v * 4 * 3 + 5] = -1;
          meshInfo.normals[v * 4 * 3 + 6] = 0;
          meshInfo.normals[v * 4 * 3 + 7] = 0;
          meshInfo.normals[v * 4 * 3 + 8] = -1;
          meshInfo.normals[v * 4 * 3 + 9] = 0;
          meshInfo.normals[v * 4 * 3 + 10] = 0;
          meshInfo.normals[v * 4 * 3 + 11] = -1;
        }
        const mesh = createTextMesh(this._system.app.graphicsDevice, meshInfo);
        const mi = new MeshInstance(mesh, this._material, this._node);
        mi.name = `Text Element: ${this._entity.name}`;
        mi.castShadow = false;
        mi.receiveShadow = false;
        mi.cull = !screenSpace;
        mi.screenSpace = screenSpace;
        mi.drawOrder = this._drawOrder;
        if (screenCulled) {
          mi.cull = true;
          mi.isVisibleFunc = visibleFn;
        }
        this._setTextureParams(mi, this._font.textures[i]);
        mi.setParameter("material_emissive", this._colorUniform);
        mi.setParameter("material_opacity", this._color.a);
        mi.setParameter("font_sdfIntensity", this._font.intensity);
        mi.setParameter("font_pxrange", this._getPxRange(this._font));
        mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
        mi.setParameter("outline_color", this._outlineColorUniform);
        mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
        mi.setParameter("shadow_color", this._shadowColorUniform);
        if (this._symbolShadowParams) {
          this._shadowOffsetUniform[0] = 0;
          this._shadowOffsetUniform[1] = 0;
        } else {
          const ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
          this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
          this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
        }
        mi.setParameter("shadow_offset", this._shadowOffsetUniform);
        meshInfo.meshInstance = mi;
        this._model.meshInstances.push(mi);
      }
    }
    if (this._element.maskedBy) {
      this._element._setMaskedBy(this._element.maskedBy);
    }
    if (removedModel && this._element.enabled && this._entity.enabled) {
      this._element.addModelToLayers(this._model);
    }
    this._updateMeshes();
    this._rangeStart = 0;
    this._rangeEnd = this._symbols.length;
    this._updateRenderRange();
  }
  _removeMeshInstance(meshInstance) {
    meshInstance.destroy();
    const idx = this._model.meshInstances.indexOf(meshInstance);
    if (idx !== -1) {
      this._model.meshInstances.splice(idx, 1);
    }
  }
  _setMaterial(material) {
    this._material = material;
    if (this._model) {
      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
        const mi = this._model.meshInstances[i];
        mi.material = material;
      }
    }
  }
  _updateMaterial(screenSpace) {
    const element = this._element;
    const screenCulled = element._isScreenCulled();
    const visibleFn = function visibleFn2(camera) {
      return element.isVisibleForCamera(camera);
    };
    const msdf = this._font && this._font.type === FONT_MSDF;
    this._material = this._system.getTextElementMaterial(screenSpace, msdf, this._enableMarkup);
    if (this._model) {
      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
        const mi = this._model.meshInstances[i];
        mi.cull = !screenSpace;
        mi.material = this._material;
        mi.screenSpace = screenSpace;
        if (screenCulled) {
          mi.cull = true;
          mi.isVisibleFunc = visibleFn;
        } else {
          mi.isVisibleFunc = null;
        }
      }
    }
  }
  _updateMaterialEmissive() {
    if (this._symbolColors) {
      this._colorUniform[0] = 1;
      this._colorUniform[1] = 1;
      this._colorUniform[2] = 1;
    } else {
      _tempColor3.linear(this._color);
      this._colorUniform[0] = _tempColor3.r;
      this._colorUniform[1] = _tempColor3.g;
      this._colorUniform[2] = _tempColor3.b;
    }
  }
  _updateMaterialOutline() {
    if (this._symbolOutlineParams) {
      this._outlineColorUniform[0] = 0;
      this._outlineColorUniform[1] = 0;
      this._outlineColorUniform[2] = 0;
      this._outlineColorUniform[3] = 1;
    } else {
      _tempColor3.linear(this._outlineColor);
      this._outlineColorUniform[0] = _tempColor3.r;
      this._outlineColorUniform[1] = _tempColor3.g;
      this._outlineColorUniform[2] = _tempColor3.b;
      this._outlineColorUniform[3] = _tempColor3.a;
    }
  }
  _updateMaterialShadow() {
    if (this._symbolOutlineParams) {
      this._shadowColorUniform[0] = 0;
      this._shadowColorUniform[1] = 0;
      this._shadowColorUniform[2] = 0;
      this._shadowColorUniform[3] = 0;
    } else {
      _tempColor3.linear(this._shadowColor);
      this._shadowColorUniform[0] = _tempColor3.r;
      this._shadowColorUniform[1] = _tempColor3.g;
      this._shadowColorUniform[2] = _tempColor3.b;
      this._shadowColorUniform[3] = _tempColor3.a;
    }
  }
  _isWordBoundary(char) {
    return WORD_BOUNDARY_CHAR.test(char);
  }
  _isValidNextChar(nextchar) {
    return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);
  }
  _isNextCJKBoundary(char, nextchar) {
    return CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));
  }
  _isNextCJKWholeWord(nextchar) {
    return CJK_CHAR.test(nextchar);
  }
  _updateMeshes() {
    const json = this._font.data;
    const self2 = this;
    const minFont = Math.min(this._minFontSize, this._maxFontSize);
    const maxFont = this._maxFontSize;
    const autoFit = this._shouldAutoFit();
    if (autoFit) {
      this._fontSize = this._maxFontSize;
    }
    const MAGIC = 32;
    const l = this._symbols.length;
    let _x = 0;
    let _y = 0;
    let _z = 0;
    let _xMinusTrailingWhitespace = 0;
    let lines = 1;
    let wordStartX = 0;
    let wordStartIndex = 0;
    let lineStartIndex = 0;
    let numWordsThisLine = 0;
    let numCharsThisLine = 0;
    let numBreaksThisLine = 0;
    const splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 1e-4;
    let maxLineWidth = this._element.calculatedWidth;
    if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
      maxLineWidth = Number.POSITIVE_INFINITY;
    }
    let fontMinY = 0;
    let fontMaxY = 0;
    let char, data2, quad, nextchar;
    function breakLine(symbols, lineBreakIndex, lineBreakX) {
      self2._lineWidths.push(Math.abs(lineBreakX));
      const sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
      const sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
      const chars = symbols.slice(sliceStart, sliceEnd);
      if (numBreaksThisLine) {
        let i = chars.length;
        while (i-- && numBreaksThisLine > 0) {
          if (LINE_BREAK_CHAR.test(chars[i])) {
            chars.splice(i, 1);
            numBreaksThisLine--;
          }
        }
      }
      self2._lineContents.push(chars.join(""));
      _x = 0;
      _y -= self2._scaledLineHeight;
      lines++;
      numWordsThisLine = 0;
      numCharsThisLine = 0;
      numBreaksThisLine = 0;
      wordStartX = 0;
      lineStartIndex = lineBreakIndex;
    }
    let retryUpdateMeshes = true;
    while (retryUpdateMeshes) {
      retryUpdateMeshes = false;
      if (autoFit) {
        this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 1e-4);
      } else {
        this._scaledLineHeight = this._lineHeight;
      }
      this.width = 0;
      this.height = 0;
      this._lineWidths = [];
      this._lineContents = [];
      _x = 0;
      _y = 0;
      _z = 0;
      _xMinusTrailingWhitespace = 0;
      lines = 1;
      wordStartX = 0;
      wordStartIndex = 0;
      lineStartIndex = 0;
      numWordsThisLine = 0;
      numCharsThisLine = 0;
      numBreaksThisLine = 0;
      const scale2 = this._fontSize / MAGIC;
      fontMinY = this._fontMinY * scale2;
      fontMaxY = this._fontMaxY * scale2;
      for (let i = 0; i < this._meshInfo.length; i++) {
        this._meshInfo[i].quad = 0;
        this._meshInfo[i].lines = {};
      }
      let color_r = 255;
      let color_g = 255;
      let color_b = 255;
      let outline_color_rg = 255 + 255 * 256;
      let outline_color_ba = 255 + 255 * 256;
      let outline_thickness = 0;
      let shadow_color_rg = 255 + 255 * 256;
      let shadow_color_ba = 255 + 255 * 256;
      let shadow_offset_xy = 127 + 127 * 256;
      for (let i = 0; i < l; i++) {
        char = this._symbols[i];
        nextchar = i + 1 >= l ? null : this._symbols[i + 1];
        const isLineBreak = LINE_BREAK_CHAR.test(char);
        if (isLineBreak) {
          numBreaksThisLine++;
          if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {
            breakLine(this._symbols, i, _xMinusTrailingWhitespace);
            wordStartIndex = i + 1;
            lineStartIndex = i + 1;
          }
          continue;
        }
        let x2 = 0;
        let y2 = 0;
        let advance = 0;
        let quadsize = 1;
        let dataScale, size;
        data2 = json.chars[char];
        if (!data2) {
          if (CONTROL_CHARS.indexOf(char) !== -1) {
            data2 = CONTROL_GLYPH_DATA;
          } else {
            if (json.chars[" "]) {
              data2 = json.chars[" "];
            } else {
              for (const key in json.chars) {
                data2 = json.chars[key];
                break;
              }
            }
          }
        }
        if (data2) {
          let kerning = 0;
          if (numCharsThisLine > 0) {
            const kernTable = this._font.data.kerning;
            if (kernTable) {
              const kernLeft = kernTable[string.getCodePoint(this._symbols[i - 1]) || 0];
              if (kernLeft) {
                kerning = kernLeft[string.getCodePoint(this._symbols[i]) || 0] || 0;
              }
            }
          }
          dataScale = data2.scale || 1;
          size = (data2.width + data2.height) / 2;
          quadsize = scale2 * size / dataScale;
          advance = (data2.xadvance + kerning) * scale2;
          x2 = (data2.xoffset - kerning) * scale2;
          y2 = data2.yoffset * scale2;
        } else {
          console.error(`Couldn't substitute missing character: '${char}'`);
        }
        const isWhitespace = WHITESPACE_CHAR.test(char);
        const meshInfoId = data2 && data2.map || 0;
        const ratio = -this._font.data.info.maps[meshInfoId].width / this._font.data.info.maps[meshInfoId].height;
        const meshInfo = this._meshInfo[meshInfoId];
        const candidateLineWidth = _x + this._spacing * advance;
        if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
          if (this._maxLines < 0 || lines < this._maxLines) {
            if (numWordsThisLine === 0) {
              wordStartIndex = i;
              breakLine(this._symbols, i, _xMinusTrailingWhitespace);
            } else {
              const backtrack = Math.max(i - wordStartIndex, 0);
              if (this._meshInfo.length <= 1) {
                meshInfo.lines[lines - 1] -= backtrack;
                meshInfo.quad -= backtrack;
              } else {
                const backtrackStart = wordStartIndex;
                const backtrackEnd = i;
                for (let j = backtrackStart; j < backtrackEnd; j++) {
                  const backChar = this._symbols[j];
                  const backCharData = json.chars[backChar];
                  const backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];
                  backMeshInfo.lines[lines - 1] -= 1;
                  backMeshInfo.quad -= 1;
                }
              }
              i -= backtrack + 1;
              breakLine(this._symbols, wordStartIndex, wordStartX);
              continue;
            }
          }
        }
        quad = meshInfo.quad;
        meshInfo.lines[lines - 1] = quad;
        let left = _x - x2;
        let right = left + quadsize;
        const bottom = _y - y2;
        const top = bottom + quadsize;
        if (this._rtl) {
          const shift = quadsize - x2 - this._spacing * advance - x2;
          left -= shift;
          right -= shift;
        }
        meshInfo.positions[quad * 4 * 3 + 0] = left;
        meshInfo.positions[quad * 4 * 3 + 1] = bottom;
        meshInfo.positions[quad * 4 * 3 + 2] = _z;
        meshInfo.positions[quad * 4 * 3 + 3] = right;
        meshInfo.positions[quad * 4 * 3 + 4] = bottom;
        meshInfo.positions[quad * 4 * 3 + 5] = _z;
        meshInfo.positions[quad * 4 * 3 + 6] = right;
        meshInfo.positions[quad * 4 * 3 + 7] = top;
        meshInfo.positions[quad * 4 * 3 + 8] = _z;
        meshInfo.positions[quad * 4 * 3 + 9] = left;
        meshInfo.positions[quad * 4 * 3 + 10] = top;
        meshInfo.positions[quad * 4 * 3 + 11] = _z;
        this.width = Math.max(this.width, candidateLineWidth);
        let fontSize;
        if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
          fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 1e-4));
          fontSize = math.clamp(fontSize, minFont, maxFont);
          if (fontSize !== this._element.fontSize) {
            this._fontSize = fontSize;
            retryUpdateMeshes = true;
            break;
          }
        }
        this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));
        if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
          fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);
          if (fontSize !== this._element.fontSize) {
            this._fontSize = fontSize;
            retryUpdateMeshes = true;
            break;
          }
        }
        _x += this._spacing * advance;
        if (!isWhitespace) {
          _xMinusTrailingWhitespace = _x;
        }
        if (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {
          numWordsThisLine++;
          wordStartX = _xMinusTrailingWhitespace;
          wordStartIndex = i + 1;
        }
        numCharsThisLine++;
        const uv = this._getUv(char);
        meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
        meshInfo.uvs[quad * 4 * 2 + 1] = 1 - uv[1];
        meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
        meshInfo.uvs[quad * 4 * 2 + 3] = 1 - uv[1];
        meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
        meshInfo.uvs[quad * 4 * 2 + 5] = 1 - uv[3];
        meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
        meshInfo.uvs[quad * 4 * 2 + 7] = 1 - uv[3];
        if (this._symbolColors) {
          const colorIdx = this._symbolColors[i] * 3;
          color_r = this._colorPalette[colorIdx];
          color_g = this._colorPalette[colorIdx + 1];
          color_b = this._colorPalette[colorIdx + 2];
        }
        meshInfo.colors[quad * 4 * 4 + 0] = color_r;
        meshInfo.colors[quad * 4 * 4 + 1] = color_g;
        meshInfo.colors[quad * 4 * 4 + 2] = color_b;
        meshInfo.colors[quad * 4 * 4 + 3] = 255;
        meshInfo.colors[quad * 4 * 4 + 4] = color_r;
        meshInfo.colors[quad * 4 * 4 + 5] = color_g;
        meshInfo.colors[quad * 4 * 4 + 6] = color_b;
        meshInfo.colors[quad * 4 * 4 + 7] = 255;
        meshInfo.colors[quad * 4 * 4 + 8] = color_r;
        meshInfo.colors[quad * 4 * 4 + 9] = color_g;
        meshInfo.colors[quad * 4 * 4 + 10] = color_b;
        meshInfo.colors[quad * 4 * 4 + 11] = 255;
        meshInfo.colors[quad * 4 * 4 + 12] = color_r;
        meshInfo.colors[quad * 4 * 4 + 13] = color_g;
        meshInfo.colors[quad * 4 * 4 + 14] = color_b;
        meshInfo.colors[quad * 4 * 4 + 15] = 255;
        if (this._symbolOutlineParams) {
          const outlineIdx = this._symbolOutlineParams[i] * 5;
          outline_color_rg = this._outlinePalette[outlineIdx] + this._outlinePalette[outlineIdx + 1] * 256;
          outline_color_ba = this._outlinePalette[outlineIdx + 2] + this._outlinePalette[outlineIdx + 3] * 256;
          outline_thickness = this._outlinePalette[outlineIdx + 4];
        }
        meshInfo.outlines[quad * 4 * 3 + 0] = outline_color_rg;
        meshInfo.outlines[quad * 4 * 3 + 1] = outline_color_ba;
        meshInfo.outlines[quad * 4 * 3 + 2] = outline_thickness;
        meshInfo.outlines[quad * 4 * 3 + 3] = outline_color_rg;
        meshInfo.outlines[quad * 4 * 3 + 4] = outline_color_ba;
        meshInfo.outlines[quad * 4 * 3 + 5] = outline_thickness;
        meshInfo.outlines[quad * 4 * 3 + 6] = outline_color_rg;
        meshInfo.outlines[quad * 4 * 3 + 7] = outline_color_ba;
        meshInfo.outlines[quad * 4 * 3 + 8] = outline_thickness;
        meshInfo.outlines[quad * 4 * 3 + 9] = outline_color_rg;
        meshInfo.outlines[quad * 4 * 3 + 10] = outline_color_ba;
        meshInfo.outlines[quad * 4 * 3 + 11] = outline_thickness;
        if (this._symbolShadowParams) {
          const shadowIdx = this._symbolShadowParams[i] * 6;
          shadow_color_rg = this._shadowPalette[shadowIdx] + this._shadowPalette[shadowIdx + 1] * 256;
          shadow_color_ba = this._shadowPalette[shadowIdx + 2] + this._shadowPalette[shadowIdx + 3] * 256;
          shadow_offset_xy = this._shadowPalette[shadowIdx + 4] + 127 + Math.round(ratio * this._shadowPalette[shadowIdx + 5] + 127) * 256;
        }
        meshInfo.shadows[quad * 4 * 3 + 0] = shadow_color_rg;
        meshInfo.shadows[quad * 4 * 3 + 1] = shadow_color_ba;
        meshInfo.shadows[quad * 4 * 3 + 2] = shadow_offset_xy;
        meshInfo.shadows[quad * 4 * 3 + 3] = shadow_color_rg;
        meshInfo.shadows[quad * 4 * 3 + 4] = shadow_color_ba;
        meshInfo.shadows[quad * 4 * 3 + 5] = shadow_offset_xy;
        meshInfo.shadows[quad * 4 * 3 + 6] = shadow_color_rg;
        meshInfo.shadows[quad * 4 * 3 + 7] = shadow_color_ba;
        meshInfo.shadows[quad * 4 * 3 + 8] = shadow_offset_xy;
        meshInfo.shadows[quad * 4 * 3 + 9] = shadow_color_rg;
        meshInfo.shadows[quad * 4 * 3 + 10] = shadow_color_ba;
        meshInfo.shadows[quad * 4 * 3 + 11] = shadow_offset_xy;
        meshInfo.quad++;
      }
      if (retryUpdateMeshes) {
        continue;
      }
      if (lineStartIndex < l) {
        breakLine(this._symbols, l, _x);
      }
    }
    this._noResize = true;
    this.autoWidth = this._autoWidth;
    this.autoHeight = this._autoHeight;
    this._noResize = false;
    const hp = this._element.pivot.x;
    const vp = this._element.pivot.y;
    const ha = this._alignment.x;
    const va = this._alignment.y;
    for (let i = 0; i < this._meshInfo.length; i++) {
      if (this._meshInfo[i].count === 0) continue;
      let prevQuad = 0;
      for (const line in this._meshInfo[i].lines) {
        const index = this._meshInfo[i].lines[line];
        const lw = this._lineWidths[parseInt(line, 10)];
        const hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
        const voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);
        for (let _quad = prevQuad; _quad <= index; _quad++) {
          this._meshInfo[i].positions[_quad * 4 * 3] += hoffset;
          this._meshInfo[i].positions[_quad * 4 * 3 + 3] += hoffset;
          this._meshInfo[i].positions[_quad * 4 * 3 + 6] += hoffset;
          this._meshInfo[i].positions[_quad * 4 * 3 + 9] += hoffset;
          this._meshInfo[i].positions[_quad * 4 * 3 + 1] += voffset;
          this._meshInfo[i].positions[_quad * 4 * 3 + 4] += voffset;
          this._meshInfo[i].positions[_quad * 4 * 3 + 7] += voffset;
          this._meshInfo[i].positions[_quad * 4 * 3 + 10] += voffset;
        }
        if (this._rtl) {
          for (let _quad2 = prevQuad; _quad2 <= index; _quad2++) {
            const idx = _quad2 * 4 * 3;
            for (let vert = 0; vert < 4; ++vert) {
              this._meshInfo[i].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[i].positions[idx + vert * 3] + hoffset * 2;
            }
            const tmp0 = this._meshInfo[i].positions[idx + 3];
            const tmp1 = this._meshInfo[i].positions[idx + 6];
            this._meshInfo[i].positions[idx + 3] = this._meshInfo[i].positions[idx + 0];
            this._meshInfo[i].positions[idx + 6] = this._meshInfo[i].positions[idx + 9];
            this._meshInfo[i].positions[idx + 0] = tmp0;
            this._meshInfo[i].positions[idx + 9] = tmp1;
          }
        }
        prevQuad = index + 1;
      }
      const numVertices = this._meshInfo[i].count * 4;
      const vertMax = this._meshInfo[i].quad * 4;
      const it = new VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);
      for (let v = 0; v < numVertices; v++) {
        if (v >= vertMax) {
          it.element[SEMANTIC_POSITION].set(0, 0, 0);
          it.element[SEMANTIC_TEXCOORD0].set(0, 0);
          it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
          it.element[SEMANTIC_ATTR8].set(0, 0, 0, 0);
          it.element[SEMANTIC_ATTR9].set(0, 0, 0, 0);
        } else {
          it.element[SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);
          it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);
          it.element[SEMANTIC_COLOR].set(this._meshInfo[i].colors[v * 4 + 0], this._meshInfo[i].colors[v * 4 + 1], this._meshInfo[i].colors[v * 4 + 2], this._meshInfo[i].colors[v * 4 + 3]);
          it.element[SEMANTIC_ATTR8].set(this._meshInfo[i].outlines[v * 3 + 0], this._meshInfo[i].outlines[v * 3 + 1], this._meshInfo[i].outlines[v * 3 + 2]);
          it.element[SEMANTIC_ATTR9].set(this._meshInfo[i].shadows[v * 3 + 0], this._meshInfo[i].shadows[v * 3 + 1], this._meshInfo[i].shadows[v * 3 + 2]);
        }
        it.next();
      }
      it.end();
      this._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);
      this._meshInfo[i].meshInstance._aabbVer = -1;
    }
    this._aabbDirty = true;
  }
  _onFontRender() {
    this.font = this._font;
  }
  _onFontLoad(asset) {
    if (this.font !== asset.resource) {
      this.font = asset.resource;
    }
  }
  _onFontChange(asset, name, _new, _old) {
    if (name === "data") {
      this._font.data = _new;
      const maps = this._font.data.info.maps.length;
      for (let i = 0; i < maps; i++) {
        if (!this._meshInfo[i]) continue;
        const mi = this._meshInfo[i].meshInstance;
        if (mi) {
          mi.setParameter("font_sdfIntensity", this._font.intensity);
          mi.setParameter("font_pxrange", this._getPxRange(this._font));
          mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
        }
      }
    }
  }
  _onFontRemove(asset) {
  }
  _setTextureParams(mi, texture) {
    if (this._font) {
      if (this._font.type === FONT_MSDF) {
        mi.deleteParameter("texture_emissiveMap");
        mi.deleteParameter("texture_opacityMap");
        mi.setParameter("texture_msdfMap", texture);
      } else if (this._font.type === FONT_BITMAP) {
        mi.deleteParameter("texture_msdfMap");
        mi.setParameter("texture_emissiveMap", texture);
        mi.setParameter("texture_opacityMap", texture);
      }
    }
  }
  _getPxRange(font) {
    const keys = Object.keys(this._font.data.chars);
    for (let i = 0; i < keys.length; i++) {
      const char = this._font.data.chars[keys[i]];
      if (char.range) {
        return (char.scale || 1) * char.range;
      }
    }
    return 2;
  }
  _getUv(char) {
    const data2 = this._font.data;
    if (!data2.chars[char]) {
      const space = " ";
      if (data2.chars[space]) {
        return this._getUv(space);
      }
      return [0, 0, 0, 0];
    }
    const map = data2.chars[char].map;
    const width = data2.info.maps[map].width;
    const height = data2.info.maps[map].height;
    const x2 = data2.chars[char].x;
    const y2 = data2.chars[char].y;
    const x1 = x2;
    const y1 = y2;
    const x22 = x2 + data2.chars[char].width;
    const y22 = y2 - data2.chars[char].height;
    const edge = 1 - data2.chars[char].height / height;
    return [x1 / width, edge - y1 / height, x22 / width, edge - y22 / height];
  }
  onEnable() {
    this._fontAsset.autoLoad = true;
    if (this._model) {
      this._element.addModelToLayers(this._model);
    }
  }
  onDisable() {
    this._fontAsset.autoLoad = false;
    if (this._model) {
      this._element.removeModelFromLayers(this._model);
    }
  }
  _setStencil(stencilParams) {
    if (this._model) {
      const instances = this._model.meshInstances;
      for (let i = 0; i < instances.length; i++) {
        instances[i].stencilFront = stencilParams;
        instances[i].stencilBack = stencilParams;
      }
    }
  }
  _shouldAutoFitWidth() {
    return this._autoFitWidth && !this._autoWidth;
  }
  _shouldAutoFitHeight() {
    return this._autoFitHeight && !this._autoHeight;
  }
  _shouldAutoFit() {
    return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
  }
  _calculateCharsPerTexture(symbolIndex) {
    const charactersPerTexture = {};
    if (symbolIndex === void 0) {
      symbolIndex = this._symbols.length;
    }
    for (let i = 0, len = symbolIndex; i < len; i++) {
      const char = this._symbols[i];
      let info = this._font.data.chars[char];
      if (!info) {
        info = this._font.data.chars[" "];
        if (!info) {
          info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
        }
      }
      const map = info.map;
      if (!charactersPerTexture[map]) {
        charactersPerTexture[map] = 1;
      } else {
        charactersPerTexture[map]++;
      }
    }
    return charactersPerTexture;
  }
  _updateRenderRange() {
    const startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
    const endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);
    for (let i = 0, len = this._meshInfo.length; i < len; i++) {
      const start = startChars[i] || 0;
      const end = endChars[i] || 0;
      const instance = this._meshInfo[i].meshInstance;
      if (instance) {
        const mesh = instance.mesh;
        if (mesh) {
          mesh.primitive[0].base = start * 3 * 2;
          mesh.primitive[0].count = (end - start) * 3 * 2;
        }
      }
    }
  }
  set text(value) {
    this._i18nKey = null;
    const str = value != null && value.toString() || "";
    this._setText(str);
  }
  get text() {
    return this._text;
  }
  set key(value) {
    const str = value !== null ? value.toString() : null;
    if (this._i18nKey === str) {
      return;
    }
    this._i18nKey = str;
    if (str) {
      this._fontAsset.disableLocalization = false;
      this._resetLocalizedText();
    } else {
      this._fontAsset.disableLocalization = true;
    }
  }
  get key() {
    return this._i18nKey;
  }
  set color(value) {
    const r = value.r;
    const g = value.g;
    const b = value.b;
    if (this._color.r === r && this._color.g === g && this._color.b === b) {
      return;
    }
    this._color.r = r;
    this._color.g = g;
    this._color.b = b;
    if (!this._model) {
      return;
    }
    if (this._symbolColors) {
      if (this._font) {
        this._updateText();
      }
    } else {
      _tempColor3.linear(this._color);
      this._colorUniform[0] = _tempColor3.r;
      this._colorUniform[1] = _tempColor3.g;
      this._colorUniform[2] = _tempColor3.b;
      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
        const mi = this._model.meshInstances[i];
        mi.setParameter("material_emissive", this._colorUniform);
      }
    }
    if (this._element) {
      this._element.fire("set:color", this._color);
    }
  }
  get color() {
    return this._color;
  }
  set opacity(value) {
    if (this._color.a !== value) {
      this._color.a = value;
      if (this._model) {
        for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
          const mi = this._model.meshInstances[i];
          mi.setParameter("material_opacity", value);
        }
      }
    }
    if (this._element) {
      this._element.fire("set:opacity", value);
    }
  }
  get opacity() {
    return this._color.a;
  }
  set lineHeight(value) {
    const _prev = this._lineHeight;
    this._lineHeight = value;
    this._scaledLineHeight = value;
    if (_prev !== value && this._font) {
      this._updateText();
    }
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set wrapLines(value) {
    const _prev = this._wrapLines;
    this._wrapLines = value;
    if (_prev !== value && this._font) {
      this._updateText();
    }
  }
  get wrapLines() {
    return this._wrapLines;
  }
  get lines() {
    return this._lineContents;
  }
  set spacing(value) {
    const _prev = this._spacing;
    this._spacing = value;
    if (_prev !== value && this._font) {
      this._updateText();
    }
  }
  get spacing() {
    return this._spacing;
  }
  set fontSize(value) {
    const _prev = this._fontSize;
    this._fontSize = value;
    this._originalFontSize = value;
    if (_prev !== value && this._font) {
      this._updateText();
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontAsset(value) {
    this._fontAsset.defaultAsset = value;
  }
  get fontAsset() {
    return this._fontAsset.localizedAsset;
  }
  set font(value) {
    let previousFontType;
    if (this._font) {
      previousFontType = this._font.type;
      if (this._font.off) this._font.off("render", this._onFontRender, this);
    }
    this._font = value;
    this._fontMinY = 0;
    this._fontMaxY = 0;
    if (!value) return;
    const json = this._font.data;
    for (const charId in json.chars) {
      const data2 = json.chars[charId];
      if (data2.bounds) {
        this._fontMinY = Math.min(this._fontMinY, data2.bounds[1]);
        this._fontMaxY = Math.max(this._fontMaxY, data2.bounds[3]);
      }
    }
    if (this._font.on) this._font.on("render", this._onFontRender, this);
    if (this._fontAsset.localizedAsset) {
      const asset = this._system.app.assets.get(this._fontAsset.localizedAsset);
      if (asset.resource !== this._font) {
        this._fontAsset.defaultAsset = null;
      }
    }
    if (value.type !== previousFontType) {
      const screenSpace = this._element._isScreenSpace();
      this._updateMaterial(screenSpace);
    }
    for (let i = 0, len = this._font.textures.length; i < len; i++) {
      if (!this._meshInfo[i]) {
        this._meshInfo[i] = new MeshInfo();
      } else {
        const mi = this._meshInfo[i].meshInstance;
        if (mi) {
          mi.setParameter("font_sdfIntensity", this._font.intensity);
          mi.setParameter("font_pxrange", this._getPxRange(this._font));
          mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
          this._setTextureParams(mi, this._font.textures[i]);
        }
      }
    }
    let removedModel = false;
    for (let i = this._font.textures.length; i < this._meshInfo.length; i++) {
      if (this._meshInfo[i].meshInstance) {
        if (!removedModel) {
          this._element.removeModelFromLayers(this._model);
          removedModel = true;
        }
        this._removeMeshInstance(this._meshInfo[i].meshInstance);
      }
    }
    if (this._meshInfo.length > this._font.textures.length) {
      this._meshInfo.length = this._font.textures.length;
    }
    this._updateText();
  }
  get font() {
    return this._font;
  }
  set alignment(value) {
    if (value instanceof Vec2) {
      this._alignment.set(value.x, value.y);
    } else {
      this._alignment.set(value[0], value[1]);
    }
    if (this._font) {
      this._updateText();
    }
  }
  get alignment() {
    return this._alignment;
  }
  set autoWidth(value) {
    const old = this._autoWidth;
    this._autoWidth = value;
    if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 1e-4) {
      this._element.width = this.width;
    }
    if (old !== value) {
      const newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
      if (newFontSize !== this._fontSize) {
        this._fontSize = newFontSize;
        if (this._font) {
          this._updateText();
        }
      }
    }
  }
  get autoWidth() {
    return this._autoWidth;
  }
  set autoHeight(value) {
    const old = this._autoHeight;
    this._autoHeight = value;
    if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 1e-4) {
      this._element.height = this.height;
    }
    if (old !== value) {
      const newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
      if (newFontSize !== this._fontSize) {
        this._fontSize = newFontSize;
        if (this._font) {
          this._updateText();
        }
      }
    }
  }
  get autoHeight() {
    return this._autoHeight;
  }
  set rtlReorder(value) {
    if (this._rtlReorder !== value) {
      this._rtlReorder = value;
      if (this._font) {
        this._updateText();
      }
    }
  }
  get rtlReorder() {
    return this._rtlReorder;
  }
  set unicodeConverter(value) {
    if (this._unicodeConverter !== value) {
      this._unicodeConverter = value;
      this._setText(this._text);
    }
  }
  get unicodeConverter() {
    return this._unicodeConverter;
  }
  get aabb() {
    if (this._aabbDirty) {
      let initialized = false;
      for (let i = 0; i < this._meshInfo.length; i++) {
        if (!this._meshInfo[i].meshInstance) continue;
        if (!initialized) {
          this._aabb.copy(this._meshInfo[i].meshInstance.aabb);
          initialized = true;
        } else {
          this._aabb.add(this._meshInfo[i].meshInstance.aabb);
        }
      }
      this._aabbDirty = false;
    }
    return this._aabb;
  }
  set outlineColor(value) {
    const r = value instanceof Color ? value.r : value[0];
    const g = value instanceof Color ? value.g : value[1];
    const b = value instanceof Color ? value.b : value[2];
    const a = value instanceof Color ? value.a : value[3];
    if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {
      return;
    }
    this._outlineColor.r = r;
    this._outlineColor.g = g;
    this._outlineColor.b = b;
    this._outlineColor.a = a;
    if (!this._model) {
      return;
    }
    if (this._symbolOutlineParams) {
      if (this._font) {
        this._updateText();
      }
    } else {
      _tempColor3.linear(this._outlineColor);
      this._outlineColorUniform[0] = _tempColor3.r;
      this._outlineColorUniform[1] = _tempColor3.g;
      this._outlineColorUniform[2] = _tempColor3.b;
      this._outlineColorUniform[3] = _tempColor3.a;
      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
        const mi = this._model.meshInstances[i];
        mi.setParameter("outline_color", this._outlineColorUniform);
      }
    }
    if (this._element) {
      this._element.fire("set:outline", this._color);
    }
  }
  get outlineColor() {
    return this._outlineColor;
  }
  set outlineThickness(value) {
    const _prev = this._outlineThickness;
    this._outlineThickness = value;
    if (_prev !== value && this._font) {
      if (!this._model) {
        return;
      }
      if (this._symbolOutlineParams) {
        if (this._font) {
          this._updateText();
        }
      } else {
        for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
          const mi = this._model.meshInstances[i];
          mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
        }
      }
    }
  }
  get outlineThickness() {
    return this._outlineThickness;
  }
  set shadowColor(value) {
    const r = value instanceof Color ? value.r : value[0];
    const g = value instanceof Color ? value.g : value[1];
    const b = value instanceof Color ? value.b : value[2];
    const a = value instanceof Color ? value.a : value[3];
    if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {
      return;
    }
    this._shadowColor.r = r;
    this._shadowColor.g = g;
    this._shadowColor.b = b;
    this._shadowColor.a = a;
    if (!this._model) {
      return;
    }
    if (this._symbolShadowParams) {
      if (this._font) {
        this._updateText();
      }
    } else {
      _tempColor3.linear(this._shadowColor);
      this._shadowColorUniform[0] = _tempColor3.r;
      this._shadowColorUniform[1] = _tempColor3.g;
      this._shadowColorUniform[2] = _tempColor3.b;
      this._shadowColorUniform[3] = _tempColor3.a;
      for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
        const mi = this._model.meshInstances[i];
        mi.setParameter("shadow_color", this._shadowColorUniform);
      }
    }
  }
  get shadowColor() {
    return this._shadowColor;
  }
  set shadowOffset(value) {
    const x2 = value instanceof Vec2 ? value.x : value[0], y2 = value instanceof Vec2 ? value.y : value[1];
    if (this._shadowOffset.x === x2 && this._shadowOffset.y === y2) {
      return;
    }
    this._shadowOffset.set(x2, y2);
    if (this._font && this._model) {
      if (this._symbolShadowParams) {
        this._updateText();
      } else {
        for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
          const ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
          this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
          this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
          const mi = this._model.meshInstances[i];
          mi.setParameter("shadow_offset", this._shadowOffsetUniform);
        }
      }
    }
  }
  get shadowOffset() {
    return this._shadowOffset;
  }
  set minFontSize(value) {
    if (this._minFontSize === value) return;
    this._minFontSize = value;
    if (this.font && this._shouldAutoFit()) {
      this._updateText();
    }
  }
  get minFontSize() {
    return this._minFontSize;
  }
  set maxFontSize(value) {
    if (this._maxFontSize === value) return;
    this._maxFontSize = value;
    if (this.font && this._shouldAutoFit()) {
      this._updateText();
    }
  }
  get maxFontSize() {
    return this._maxFontSize;
  }
  set autoFitWidth(value) {
    if (this._autoFitWidth === value) return;
    this._autoFitWidth = value;
    this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
    if (this.font) {
      this._updateText();
    }
  }
  get autoFitWidth() {
    return this._autoFitWidth;
  }
  set autoFitHeight(value) {
    if (this._autoFitHeight === value) return;
    this._autoFitHeight = value;
    this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
    if (this.font) {
      this._updateText();
    }
  }
  get autoFitHeight() {
    return this._autoFitHeight;
  }
  set maxLines(value) {
    if (this._maxLines === value) return;
    if (value === null && this._maxLines === -1) return;
    this._maxLines = value === null ? -1 : value;
    if (this.font && this._wrapLines) {
      this._updateText();
    }
  }
  get maxLines() {
    return this._maxLines;
  }
  set enableMarkup(value) {
    value = !!value;
    if (this._enableMarkup === value) return;
    this._enableMarkup = value;
    if (this.font) {
      this._updateText();
    }
    const screenSpace = this._element._isScreenSpace();
    this._updateMaterial(screenSpace);
  }
  get enableMarkup() {
    return this._enableMarkup;
  }
  get symbols() {
    return this._symbols;
  }
  get symbolColors() {
    if (this._symbolColors === null) {
      return null;
    }
    return this._symbolColors.map(function(c2) {
      return this._colorPalette.slice(c2 * 3, c2 * 3 + 3);
    }, this);
  }
  get symbolOutlineParams() {
    if (this._symbolOutlineParams === null) {
      return null;
    }
    return this._symbolOutlineParams.map(function(paramId) {
      return this._outlinePalette.slice(paramId * 5, paramId * 5 + 5);
    }, this);
  }
  get symbolShadowParams() {
    if (this._symbolShadowParams === null) {
      return null;
    }
    return this._symbolShadowParams.map(function(paramId) {
      return this._shadowPalette.slice(paramId * 6, paramId * 6 + 6);
    }, this);
  }
  get rtl() {
    return this._rtl;
  }
  set rangeStart(rangeStart) {
    rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));
    if (rangeStart !== this._rangeStart) {
      this._rangeStart = rangeStart;
      this._updateRenderRange();
    }
  }
  get rangeStart() {
    return this._rangeStart;
  }
  set rangeEnd(rangeEnd) {
    rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));
    if (rangeEnd !== this._rangeEnd) {
      this._rangeEnd = rangeEnd;
      this._updateRenderRange();
    }
  }
  get rangeEnd() {
    return this._rangeEnd;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/element/component.js
var position2 = new Vec3();
var invParentWtm2 = new Mat4();
var vecA = new Vec3();
var vecB = new Vec3();
var matA = new Mat4();
var matB = new Mat4();
var matC = new Mat4();
var matD = new Mat4();
var ElementComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._beingInitialized = false;
    this._anchor = new Vec4();
    this._localAnchor = new Vec4();
    this._pivot = new Vec2();
    this._width = this._calculatedWidth = 32;
    this._height = this._calculatedHeight = 32;
    this._margin = new Vec4(0, 0, -32, -32);
    this._modelTransform = new Mat4();
    this._screenToWorld = new Mat4();
    this._anchorTransform = new Mat4();
    this._anchorDirty = true;
    this._parentWorldTransform = new Mat4();
    this._screenTransform = new Mat4();
    this._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
    this._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
    this._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
    this._cornersDirty = true;
    this._canvasCornersDirty = true;
    this._worldCornersDirty = true;
    this.entity.on("insert", this._onInsert, this);
    this._patch();
    this.screen = null;
    this._type = ELEMENTTYPE_GROUP;
    this._image = null;
    this._text = null;
    this._group = null;
    this._drawOrder = 0;
    this._fitMode = FITMODE_STRETCH;
    this._useInput = false;
    this._layers = [LAYERID_UI];
    this._addedModels = [];
    this._batchGroupId = -1;
    this._offsetReadAt = 0;
    this._maskOffset = 0.5;
    this._maskedBy = null;
  }
  get data() {
    const record = this.system.store[this.entity.getGuid()];
    return record ? record.data : null;
  }
  set enabled(value) {
    const data2 = this.data;
    const oldValue = data2.enabled;
    data2.enabled = value;
    this.fire("set", "enabled", oldValue, value);
  }
  get enabled() {
    return this.data.enabled;
  }
  get _absLeft() {
    return this._localAnchor.x + this._margin.x;
  }
  get _absRight() {
    return this._localAnchor.z - this._margin.z;
  }
  get _absTop() {
    return this._localAnchor.w - this._margin.w;
  }
  get _absBottom() {
    return this._localAnchor.y + this._margin.y;
  }
  get _hasSplitAnchorsX() {
    return Math.abs(this._anchor.x - this._anchor.z) > 1e-3;
  }
  get _hasSplitAnchorsY() {
    return Math.abs(this._anchor.y - this._anchor.w) > 1e-3;
  }
  get aabb() {
    if (this._image) {
      return this._image.aabb;
    }
    if (this._text) {
      return this._text.aabb;
    }
    return null;
  }
  set anchor(value) {
    if (value instanceof Vec4) {
      this._anchor.copy(value);
    } else {
      this._anchor.set(...value);
    }
    if (!this.entity._parent && !this.screen) {
      this._calculateLocalAnchors();
    } else {
      this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
    }
    this._anchorDirty = true;
    if (!this.entity._dirtyLocal) {
      this.entity._dirtifyLocal();
    }
    this.fire("set:anchor", this._anchor);
  }
  get anchor() {
    return this._anchor;
  }
  set batchGroupId(value) {
    if (this._batchGroupId === value) {
      return;
    }
    if (this.entity.enabled && this._batchGroupId >= 0) {
      var _this$system$app$batc;
      (_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
    }
    if (this.entity.enabled && value >= 0) {
      var _this$system$app$batc2;
      (_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.ELEMENT, value, this.entity);
    }
    if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
      if (this._image && this._image._renderable.model) {
        this.addModelToLayers(this._image._renderable.model);
      } else if (this._text && this._text._model) {
        this.addModelToLayers(this._text._model);
      }
    }
    this._batchGroupId = value;
  }
  get batchGroupId() {
    return this._batchGroupId;
  }
  set bottom(value) {
    this._margin.y = value;
    const p = this.entity.getLocalPosition();
    const wt = this._absTop;
    const wb = this._localAnchor.y + value;
    this._setHeight(wt - wb);
    p.y = value + this._calculatedHeight * this._pivot.y;
    this.entity.setLocalPosition(p);
  }
  get bottom() {
    return this._margin.y;
  }
  set calculatedWidth(value) {
    this._setCalculatedWidth(value, true);
  }
  get calculatedWidth() {
    return this._calculatedWidth;
  }
  set calculatedHeight(value) {
    this._setCalculatedHeight(value, true);
  }
  get calculatedHeight() {
    return this._calculatedHeight;
  }
  get canvasCorners() {
    if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) {
      return this._canvasCorners;
    }
    const device = this.system.app.graphicsDevice;
    const screenCorners = this.screenCorners;
    const sx = device.canvas.clientWidth / device.width;
    const sy = device.canvas.clientHeight / device.height;
    for (let i = 0; i < 4; i++) {
      this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
    }
    this._canvasCornersDirty = false;
    return this._canvasCorners;
  }
  set drawOrder(value) {
    let priority = 0;
    if (this.screen) {
      priority = this.screen.screen.priority;
    }
    if (value > 16777215) {
      value = 16777215;
    }
    this._drawOrder = (priority << 24) + value;
    this.fire("set:draworder", this._drawOrder);
  }
  get drawOrder() {
    return this._drawOrder;
  }
  set height(value) {
    this._height = value;
    if (!this._hasSplitAnchorsY) {
      this._setCalculatedHeight(value, true);
    }
    this.fire("set:height", this._height);
  }
  get height() {
    return this._height;
  }
  set layers(value) {
    if (this._addedModels.length) {
      for (let i = 0; i < this._layers.length; i++) {
        const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
        if (layer) {
          for (let j = 0; j < this._addedModels.length; j++) {
            layer.removeMeshInstances(this._addedModels[j].meshInstances);
          }
        }
      }
    }
    this._layers = value;
    if (!this.enabled || !this.entity.enabled || !this._addedModels.length) {
      return;
    }
    for (let i = 0; i < this._layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
      if (layer) {
        for (let j = 0; j < this._addedModels.length; j++) {
          layer.addMeshInstances(this._addedModels[j].meshInstances);
        }
      }
    }
  }
  get layers() {
    return this._layers;
  }
  set left(value) {
    this._margin.x = value;
    const p = this.entity.getLocalPosition();
    const wr = this._absRight;
    const wl = this._localAnchor.x + value;
    this._setWidth(wr - wl);
    p.x = value + this._calculatedWidth * this._pivot.x;
    this.entity.setLocalPosition(p);
  }
  get left() {
    return this._margin.x;
  }
  set margin(value) {
    this._margin.copy(value);
    this._calculateSize(true, true);
    this.fire("set:margin", this._margin);
  }
  get margin() {
    return this._margin;
  }
  get maskedBy() {
    return this._maskedBy;
  }
  set pivot(value) {
    const {
      pivot,
      margin
    } = this;
    const prevX = pivot.x;
    const prevY = pivot.y;
    if (value instanceof Vec2) {
      pivot.copy(value);
    } else {
      pivot.set(...value);
    }
    const mx = margin.x + margin.z;
    const dx = pivot.x - prevX;
    margin.x += mx * dx;
    margin.z -= mx * dx;
    const my = margin.y + margin.w;
    const dy = pivot.y - prevY;
    margin.y += my * dy;
    margin.w -= my * dy;
    this._anchorDirty = true;
    this._cornersDirty = true;
    this._worldCornersDirty = true;
    this._calculateSize(false, false);
    this._flagChildrenAsDirty();
    this.fire("set:pivot", pivot);
  }
  get pivot() {
    return this._pivot;
  }
  set right(value) {
    this._margin.z = value;
    const p = this.entity.getLocalPosition();
    const wl = this._absLeft;
    const wr = this._localAnchor.z - value;
    this._setWidth(wr - wl);
    p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);
    this.entity.setLocalPosition(p);
  }
  get right() {
    return this._margin.z;
  }
  get screenCorners() {
    if (!this._cornersDirty || !this.screen) {
      return this._screenCorners;
    }
    const parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
    this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
    this._screenCorners[1].set(this._absRight, this._absBottom, 0);
    this._screenCorners[2].set(this._absRight, this._absTop, 0);
    this._screenCorners[3].set(this._absLeft, this._absTop, 0);
    const screenSpace = this.screen.screen.screenSpace;
    for (let i = 0; i < 4; i++) {
      this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);
      if (screenSpace) {
        this._screenCorners[i].mulScalar(this.screen.screen.scale);
      }
      if (parentBottomLeft) {
        this._screenCorners[i].add(parentBottomLeft);
      }
    }
    this._cornersDirty = false;
    this._canvasCornersDirty = true;
    this._worldCornersDirty = true;
    return this._screenCorners;
  }
  get textWidth() {
    return this._text ? this._text.width : 0;
  }
  get textHeight() {
    return this._text ? this._text.height : 0;
  }
  set top(value) {
    this._margin.w = value;
    const p = this.entity.getLocalPosition();
    const wb = this._absBottom;
    const wt = this._localAnchor.w - value;
    this._setHeight(wt - wb);
    p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);
    this.entity.setLocalPosition(p);
  }
  get top() {
    return this._margin.w;
  }
  set type(value) {
    if (value !== this._type) {
      this._type = value;
      if (this._image) {
        this._image.destroy();
        this._image = null;
      }
      if (this._text) {
        this._text.destroy();
        this._text = null;
      }
      if (value === ELEMENTTYPE_IMAGE) {
        this._image = new ImageElement(this);
      } else if (value === ELEMENTTYPE_TEXT) {
        this._text = new TextElement(this);
      }
    }
  }
  get type() {
    return this._type;
  }
  set useInput(value) {
    if (this._useInput === value) {
      return;
    }
    this._useInput = value;
    if (this.system.app.elementInput) {
      if (value) {
        if (this.enabled && this.entity.enabled) {
          this.system.app.elementInput.addElement(this);
        }
      } else {
        this.system.app.elementInput.removeElement(this);
      }
    } else {
      if (this._useInput === true) ;
    }
    this.fire("set:useInput", value);
  }
  get useInput() {
    return this._useInput;
  }
  set fitMode(value) {
    this._fitMode = value;
    this._calculateSize(true, true);
    if (this._image) {
      this._image.refreshMesh();
    }
  }
  get fitMode() {
    return this._fitMode;
  }
  set width(value) {
    this._width = value;
    if (!this._hasSplitAnchorsX) {
      this._setCalculatedWidth(value, true);
    }
    this.fire("set:width", this._width);
  }
  get width() {
    return this._width;
  }
  get worldCorners() {
    if (!this._worldCornersDirty) {
      return this._worldCorners;
    }
    if (this.screen) {
      const screenCorners = this.screenCorners;
      if (!this.screen.screen.screenSpace) {
        matA.copy(this.screen.screen._screenMatrix);
        matA.data[13] = -matA.data[13];
        matA.mul2(this.screen.getWorldTransform(), matA);
        for (let i = 0; i < 4; i++) {
          matA.transformPoint(screenCorners[i], this._worldCorners[i]);
        }
      }
    } else {
      const localPos = this.entity.getLocalPosition();
      matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
      matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
      matC.setTranslate(localPos.x, localPos.y, localPos.z);
      const entity = this.entity.parent ? this.entity.parent : this.entity;
      matD.copy(entity.getWorldTransform());
      matD.mul(matC).mul(matB).mul(matA);
      vecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
      matD.transformPoint(vecA, this._worldCorners[0]);
      vecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
      matD.transformPoint(vecA, this._worldCorners[1]);
      vecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
      matD.transformPoint(vecA, this._worldCorners[2]);
      vecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
      matD.transformPoint(vecA, this._worldCorners[3]);
    }
    this._worldCornersDirty = false;
    return this._worldCorners;
  }
  set fontSize(arg) {
    this._setValue("fontSize", arg);
  }
  get fontSize() {
    if (this._text) {
      return this._text.fontSize;
    }
    return null;
  }
  set minFontSize(arg) {
    this._setValue("minFontSize", arg);
  }
  get minFontSize() {
    if (this._text) {
      return this._text.minFontSize;
    }
    return null;
  }
  set maxFontSize(arg) {
    this._setValue("maxFontSize", arg);
  }
  get maxFontSize() {
    if (this._text) {
      return this._text.maxFontSize;
    }
    return null;
  }
  set maxLines(arg) {
    this._setValue("maxLines", arg);
  }
  get maxLines() {
    if (this._text) {
      return this._text.maxLines;
    }
    return null;
  }
  set autoFitWidth(arg) {
    this._setValue("autoFitWidth", arg);
  }
  get autoFitWidth() {
    if (this._text) {
      return this._text.autoFitWidth;
    }
    return null;
  }
  set autoFitHeight(arg) {
    this._setValue("autoFitHeight", arg);
  }
  get autoFitHeight() {
    if (this._text) {
      return this._text.autoFitHeight;
    }
    return null;
  }
  set color(arg) {
    this._setValue("color", arg);
  }
  get color() {
    if (this._text) {
      return this._text.color;
    }
    if (this._image) {
      return this._image.color;
    }
    return null;
  }
  set font(arg) {
    this._setValue("font", arg);
  }
  get font() {
    if (this._text) {
      return this._text.font;
    }
    return null;
  }
  set fontAsset(arg) {
    this._setValue("fontAsset", arg);
  }
  get fontAsset() {
    if (this._text && typeof this._text.fontAsset === "number") {
      return this._text.fontAsset;
    }
    return null;
  }
  set spacing(arg) {
    this._setValue("spacing", arg);
  }
  get spacing() {
    if (this._text) {
      return this._text.spacing;
    }
    return null;
  }
  set lineHeight(arg) {
    this._setValue("lineHeight", arg);
  }
  get lineHeight() {
    if (this._text) {
      return this._text.lineHeight;
    }
    return null;
  }
  set wrapLines(arg) {
    this._setValue("wrapLines", arg);
  }
  get wrapLines() {
    if (this._text) {
      return this._text.wrapLines;
    }
    return null;
  }
  set lines(arg) {
    this._setValue("lines", arg);
  }
  get lines() {
    if (this._text) {
      return this._text.lines;
    }
    return null;
  }
  set alignment(arg) {
    this._setValue("alignment", arg);
  }
  get alignment() {
    if (this._text) {
      return this._text.alignment;
    }
    return null;
  }
  set autoWidth(arg) {
    this._setValue("autoWidth", arg);
  }
  get autoWidth() {
    if (this._text) {
      return this._text.autoWidth;
    }
    return null;
  }
  set autoHeight(arg) {
    this._setValue("autoHeight", arg);
  }
  get autoHeight() {
    if (this._text) {
      return this._text.autoHeight;
    }
    return null;
  }
  set rtlReorder(arg) {
    this._setValue("rtlReorder", arg);
  }
  get rtlReorder() {
    if (this._text) {
      return this._text.rtlReorder;
    }
    return null;
  }
  set unicodeConverter(arg) {
    this._setValue("unicodeConverter", arg);
  }
  get unicodeConverter() {
    if (this._text) {
      return this._text.unicodeConverter;
    }
    return null;
  }
  set text(arg) {
    this._setValue("text", arg);
  }
  get text() {
    if (this._text) {
      return this._text.text;
    }
    return null;
  }
  set key(arg) {
    this._setValue("key", arg);
  }
  get key() {
    if (this._text) {
      return this._text.key;
    }
    return null;
  }
  set texture(arg) {
    this._setValue("texture", arg);
  }
  get texture() {
    if (this._image) {
      return this._image.texture;
    }
    return null;
  }
  set textureAsset(arg) {
    this._setValue("textureAsset", arg);
  }
  get textureAsset() {
    if (this._image) {
      return this._image.textureAsset;
    }
    return null;
  }
  set material(arg) {
    this._setValue("material", arg);
  }
  get material() {
    if (this._image) {
      return this._image.material;
    }
    return null;
  }
  set materialAsset(arg) {
    this._setValue("materialAsset", arg);
  }
  get materialAsset() {
    if (this._image) {
      return this._image.materialAsset;
    }
    return null;
  }
  set sprite(arg) {
    this._setValue("sprite", arg);
  }
  get sprite() {
    if (this._image) {
      return this._image.sprite;
    }
    return null;
  }
  set spriteAsset(arg) {
    this._setValue("spriteAsset", arg);
  }
  get spriteAsset() {
    if (this._image) {
      return this._image.spriteAsset;
    }
    return null;
  }
  set spriteFrame(arg) {
    this._setValue("spriteFrame", arg);
  }
  get spriteFrame() {
    if (this._image) {
      return this._image.spriteFrame;
    }
    return null;
  }
  set pixelsPerUnit(arg) {
    this._setValue("pixelsPerUnit", arg);
  }
  get pixelsPerUnit() {
    if (this._image) {
      return this._image.pixelsPerUnit;
    }
    return null;
  }
  set opacity(arg) {
    this._setValue("opacity", arg);
  }
  get opacity() {
    if (this._text) {
      return this._text.opacity;
    }
    if (this._image) {
      return this._image.opacity;
    }
    return null;
  }
  set rect(arg) {
    this._setValue("rect", arg);
  }
  get rect() {
    if (this._image) {
      return this._image.rect;
    }
    return null;
  }
  set mask(arg) {
    this._setValue("mask", arg);
  }
  get mask() {
    if (this._image) {
      return this._image.mask;
    }
    return null;
  }
  set outlineColor(arg) {
    this._setValue("outlineColor", arg);
  }
  get outlineColor() {
    if (this._text) {
      return this._text.outlineColor;
    }
    return null;
  }
  set outlineThickness(arg) {
    this._setValue("outlineThickness", arg);
  }
  get outlineThickness() {
    if (this._text) {
      return this._text.outlineThickness;
    }
    return null;
  }
  set shadowColor(arg) {
    this._setValue("shadowColor", arg);
  }
  get shadowColor() {
    if (this._text) {
      return this._text.shadowColor;
    }
    return null;
  }
  set shadowOffset(arg) {
    this._setValue("shadowOffset", arg);
  }
  get shadowOffset() {
    if (this._text) {
      return this._text.shadowOffset;
    }
    return null;
  }
  set enableMarkup(arg) {
    this._setValue("enableMarkup", arg);
  }
  get enableMarkup() {
    if (this._text) {
      return this._text.enableMarkup;
    }
    return null;
  }
  set rangeStart(arg) {
    this._setValue("rangeStart", arg);
  }
  get rangeStart() {
    if (this._text) {
      return this._text.rangeStart;
    }
    return null;
  }
  set rangeEnd(arg) {
    this._setValue("rangeEnd", arg);
  }
  get rangeEnd() {
    if (this._text) {
      return this._text.rangeEnd;
    }
    return null;
  }
  _setValue(name, value) {
    if (this._text) {
      if (this._text[name] !== value) {
        this._dirtyBatch();
      }
      this._text[name] = value;
    } else if (this._image) {
      if (this._image[name] !== value) {
        this._dirtyBatch();
      }
      this._image[name] = value;
    }
  }
  _patch() {
    this.entity._sync = this._sync;
    this.entity.setPosition = this._setPosition;
    this.entity.setLocalPosition = this._setLocalPosition;
  }
  _unpatch() {
    this.entity._sync = Entity.prototype._sync;
    this.entity.setPosition = Entity.prototype.setPosition;
    this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
  }
  _setPosition(x2, y2, z2) {
    if (!this.element.screen) {
      Entity.prototype.setPosition.call(this, x2, y2, z2);
      return;
    }
    if (x2 instanceof Vec3) {
      position2.copy(x2);
    } else {
      position2.set(x2, y2, z2);
    }
    this.getWorldTransform();
    invParentWtm2.copy(this.element._screenToWorld).invert();
    invParentWtm2.transformPoint(position2, this.localPosition);
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  _setLocalPosition(x2, y2, z2) {
    if (x2 instanceof Vec3) {
      this.localPosition.copy(x2);
    } else {
      this.localPosition.set(x2, y2, z2);
    }
    const element = this.element;
    const p = this.localPosition;
    const pvt = element._pivot;
    element._margin.x = p.x - element._calculatedWidth * pvt.x;
    element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
    element._margin.y = p.y - element._calculatedHeight * pvt.y;
    element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
    if (!this._dirtyLocal) {
      this._dirtifyLocal();
    }
  }
  _sync() {
    const element = this.element;
    const screen = element.screen;
    if (screen) {
      if (element._anchorDirty) {
        let resx = 0;
        let resy = 0;
        let px = 0;
        let py = 1;
        if (this._parent && this._parent.element) {
          resx = this._parent.element.calculatedWidth;
          resy = this._parent.element.calculatedHeight;
          px = this._parent.element.pivot.x;
          py = this._parent.element.pivot.y;
        } else {
          const resolution = screen.screen.resolution;
          resx = resolution.x / screen.screen.scale;
          resy = resolution.y / screen.screen.scale;
        }
        element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);
        element._anchorDirty = false;
        element._calculateLocalAnchors();
      }
      if (element._sizeDirty) {
        element._calculateSize(false, false);
      }
    }
    if (this._dirtyLocal) {
      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
      const p = this.localPosition;
      const pvt = element._pivot;
      element._margin.x = p.x - element._calculatedWidth * pvt.x;
      element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
      element._margin.y = p.y - element._calculatedHeight * pvt.y;
      element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
      this._dirtyLocal = false;
    }
    if (!screen) {
      if (this._dirtyWorld) {
        element._cornersDirty = true;
        element._canvasCornersDirty = true;
        element._worldCornersDirty = true;
      }
      Entity.prototype._sync.call(this);
      return;
    }
    if (this._dirtyWorld) {
      if (this._parent === null) {
        this.worldTransform.copy(this.localTransform);
      } else {
        if (this._parent.element) {
          element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
        } else {
          element._screenToWorld.copy(element._anchorTransform);
        }
        element._modelTransform.mul2(element._screenToWorld, this.localTransform);
        if (screen) {
          element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);
          if (!screen.screen.screenSpace) {
            element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
          }
          this.worldTransform.mul2(element._screenToWorld, this.localTransform);
          const parentWorldTransform = element._parentWorldTransform;
          parentWorldTransform.setIdentity();
          const parent = this._parent;
          if (parent && parent.element && parent !== screen) {
            matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
            parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
          }
          const depthOffset = vecA;
          depthOffset.set(0, 0, this.localPosition.z);
          const pivotOffset = vecB;
          pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
          matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
          matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
          matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);
          element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);
          element._cornersDirty = true;
          element._canvasCornersDirty = true;
          element._worldCornersDirty = true;
        } else {
          this.worldTransform.copy(element._modelTransform);
        }
      }
      this._dirtyWorld = false;
    }
  }
  _onInsert(parent) {
    const result = this._parseUpToScreen();
    this.entity._dirtifyWorld();
    this._updateScreen(result.screen);
    this._dirtifyMask();
  }
  _dirtifyMask() {
    let current = this.entity;
    while (current) {
      const next = current.parent;
      if ((next === null || next.screen) && current.element) {
        if (!this.system._prerender || !this.system._prerender.length) {
          this.system._prerender = [];
          this.system.app.once("prerender", this._onPrerender, this);
        }
        const i = this.system._prerender.indexOf(this.entity);
        if (i >= 0) {
          this.system._prerender.splice(i, 1);
        }
        const j = this.system._prerender.indexOf(current);
        if (j < 0) {
          this.system._prerender.push(current);
        }
      }
      current = next;
    }
  }
  _onPrerender() {
    for (let i = 0; i < this.system._prerender.length; i++) {
      const mask = this.system._prerender[i];
      if (mask.element) {
        const depth = 1;
        mask.element.syncMask(depth);
      }
    }
    this.system._prerender.length = 0;
  }
  _bindScreen(screen) {
    screen._bindElement(this);
  }
  _unbindScreen(screen) {
    screen._unbindElement(this);
  }
  _updateScreen(screen) {
    if (this.screen && this.screen !== screen) {
      this._unbindScreen(this.screen.screen);
    }
    const previousScreen = this.screen;
    this.screen = screen;
    if (this.screen) {
      this._bindScreen(this.screen.screen);
    }
    this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
    this.fire("set:screen", this.screen, previousScreen);
    this._anchorDirty = true;
    const children = this.entity.children;
    for (let i = 0, l = children.length; i < l; i++) {
      if (children[i].element) {
        children[i].element._updateScreen(screen);
      }
    }
    if (this.screen) {
      this.screen.screen.syncDrawOrder();
    }
  }
  syncMask(depth) {
    const result = this._parseUpToScreen();
    this._updateMask(result.mask, depth);
  }
  _setMaskedBy(mask) {
    const renderableElement = this._image || this._text;
    if (mask) {
      const ref = mask.element._image._maskRef;
      renderableElement == null || renderableElement._setStencil(new StencilParameters({
        ref,
        func: FUNC_EQUAL
      }));
      this._maskedBy = mask;
    } else {
      renderableElement == null || renderableElement._setStencil(null);
      this._maskedBy = null;
    }
  }
  _updateMask(currentMask, depth) {
    if (currentMask) {
      this._setMaskedBy(currentMask);
      if (this.mask) {
        const ref = currentMask.element._image._maskRef;
        const sp = new StencilParameters({
          ref,
          func: FUNC_EQUAL,
          zpass: STENCILOP_INCREMENT
        });
        this._image._setStencil(sp);
        this._image._maskRef = depth;
        depth++;
        currentMask = this.entity;
      }
      const children = this.entity.children;
      for (let i = 0, l = children.length; i < l; i++) {
        var _children$i$element;
        (_children$i$element = children[i].element) == null || _children$i$element._updateMask(currentMask, depth);
      }
      if (this.mask) depth--;
    } else {
      this._setMaskedBy(null);
      if (this.mask) {
        const sp = new StencilParameters({
          ref: depth,
          func: FUNC_ALWAYS,
          zpass: STENCILOP_REPLACE
        });
        this._image._setStencil(sp);
        this._image._maskRef = depth;
        depth++;
        currentMask = this.entity;
      }
      const children = this.entity.children;
      for (let i = 0, l = children.length; i < l; i++) {
        var _children$i$element2;
        (_children$i$element2 = children[i].element) == null || _children$i$element2._updateMask(currentMask, depth);
      }
      if (this.mask) {
        depth--;
      }
    }
  }
  _parseUpToScreen() {
    const result = {
      screen: null,
      mask: null
    };
    let parent = this.entity._parent;
    while (parent && !parent.screen) {
      if (parent.element && parent.element.mask) {
        if (!result.mask) result.mask = parent;
      }
      parent = parent.parent;
    }
    if (parent && parent.screen) {
      result.screen = parent;
    }
    return result;
  }
  _onScreenResize(res) {
    this._anchorDirty = true;
    this._cornersDirty = true;
    this._worldCornersDirty = true;
    this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
    this.fire("screen:set:resolution", res);
  }
  _onScreenSpaceChange() {
    this.fire("screen:set:screenspace", this.screen.screen.screenSpace);
  }
  _onScreenRemove() {
    if (this.screen) {
      if (this.screen._destroying) {
        this.screen = null;
      } else {
        this._updateScreen(null);
      }
    }
  }
  _calculateLocalAnchors() {
    let resx = 1e3;
    let resy = 1e3;
    const parent = this.entity._parent;
    if (parent && parent.element) {
      resx = parent.element.calculatedWidth;
      resy = parent.element.calculatedHeight;
    } else if (this.screen) {
      const res = this.screen.screen.resolution;
      const scale2 = this.screen.screen.scale;
      resx = res.x / scale2;
      resy = res.y / scale2;
    }
    this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
  }
  getOffsetPosition(x2, y2) {
    const p = this.entity.getLocalPosition().clone();
    p.x += x2;
    p.y += y2;
    this._screenToWorld.transformPoint(p, p);
    return p;
  }
  onLayersChanged(oldComp, newComp) {
    this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    if (this._image) {
      layer.addMeshInstances(this._image._renderable.model.meshInstances);
    } else if (this._text) {
      layer.addMeshInstances(this._text._model.meshInstances);
    }
  }
  onLayerRemoved(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    if (this._image) {
      layer.removeMeshInstances(this._image._renderable.model.meshInstances);
    } else if (this._text) {
      layer.removeMeshInstances(this._text._model.meshInstances);
    }
  }
  onEnable() {
    if (this._image) {
      this._image.onEnable();
    }
    if (this._text) {
      this._text.onEnable();
    }
    if (this._group) {
      this._group.onEnable();
    }
    if (this.useInput && this.system.app.elementInput) {
      this.system.app.elementInput.addElement(this);
    }
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this._batchGroupId >= 0) {
      var _this$system$app$batc3;
      (_this$system$app$batc3 = this.system.app.batcher) == null || _this$system$app$batc3.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
    }
    this.fire("enableelement");
  }
  onDisable() {
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    if (this._image) this._image.onDisable();
    if (this._text) this._text.onDisable();
    if (this._group) this._group.onDisable();
    if (this.system.app.elementInput && this.useInput) {
      this.system.app.elementInput.removeElement(this);
    }
    if (this._batchGroupId >= 0) {
      var _this$system$app$batc4;
      (_this$system$app$batc4 = this.system.app.batcher) == null || _this$system$app$batc4.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
    }
    this.fire("disableelement");
  }
  onRemove() {
    this.entity.off("insert", this._onInsert, this);
    this._unpatch();
    if (this._image) {
      this._image.destroy();
    }
    if (this._text) {
      this._text.destroy();
    }
    if (this.system.app.elementInput && this.useInput) {
      this.system.app.elementInput.removeElement(this);
    }
    if (this.screen && this.screen.screen) {
      this._unbindScreen(this.screen.screen);
      this.screen.screen.syncDrawOrder();
    }
    this.off();
  }
  _calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {
    if (!this.entity._parent && !this.screen) {
      return;
    }
    this._calculateLocalAnchors();
    const newWidth = this._absRight - this._absLeft;
    const newHeight = this._absTop - this._absBottom;
    if (propagateCalculatedWidth) {
      this._setWidth(newWidth);
    } else {
      this._setCalculatedWidth(newWidth, false);
    }
    if (propagateCalculatedHeight) {
      this._setHeight(newHeight);
    } else {
      this._setCalculatedHeight(newHeight, false);
    }
    const p = this.entity.getLocalPosition();
    p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
    p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
    this.entity.setLocalPosition(p);
    this._sizeDirty = false;
  }
  _setWidth(w) {
    this._width = w;
    this._setCalculatedWidth(w, false);
    this.fire("set:width", this._width);
  }
  _setHeight(h2) {
    this._height = h2;
    this._setCalculatedHeight(h2, false);
    this.fire("set:height", this._height);
  }
  _setCalculatedWidth(value, updateMargins) {
    if (Math.abs(value - this._calculatedWidth) <= 1e-4) {
      return;
    }
    this._calculatedWidth = value;
    this.entity._dirtifyLocal();
    if (updateMargins) {
      const p = this.entity.getLocalPosition();
      const pvt = this._pivot;
      this._margin.x = p.x - this._calculatedWidth * pvt.x;
      this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
    }
    this._flagChildrenAsDirty();
    this.fire("set:calculatedWidth", this._calculatedWidth);
    this.fire("resize", this._calculatedWidth, this._calculatedHeight);
  }
  _setCalculatedHeight(value, updateMargins) {
    if (Math.abs(value - this._calculatedHeight) <= 1e-4) {
      return;
    }
    this._calculatedHeight = value;
    this.entity._dirtifyLocal();
    if (updateMargins) {
      const p = this.entity.getLocalPosition();
      const pvt = this._pivot;
      this._margin.y = p.y - this._calculatedHeight * pvt.y;
      this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
    }
    this._flagChildrenAsDirty();
    this.fire("set:calculatedHeight", this._calculatedHeight);
    this.fire("resize", this._calculatedWidth, this._calculatedHeight);
  }
  _flagChildrenAsDirty() {
    const c2 = this.entity._children;
    for (let i = 0, l = c2.length; i < l; i++) {
      if (c2[i].element) {
        c2[i].element._anchorDirty = true;
        c2[i].element._sizeDirty = true;
      }
    }
  }
  addModelToLayers(model) {
    this._addedModels.push(model);
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) continue;
      layer.addMeshInstances(model.meshInstances);
    }
  }
  removeModelFromLayers(model) {
    const idx = this._addedModels.indexOf(model);
    if (idx >= 0) {
      this._addedModels.splice(idx, 1);
    }
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) {
        continue;
      }
      layer.removeMeshInstances(model.meshInstances);
    }
  }
  getMaskOffset() {
    const frame = this.system.app.frame;
    if (this._offsetReadAt !== frame) {
      this._maskOffset = 0.5;
      this._offsetReadAt = frame;
    }
    const mo = this._maskOffset;
    this._maskOffset -= 1e-3;
    return mo;
  }
  isVisibleForCamera(camera) {
    let clipL, clipR, clipT, clipB;
    if (this.maskedBy) {
      const corners = this.maskedBy.element.screenCorners;
      clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
      clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
      clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
      clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
    } else {
      const sw = this.system.app.graphicsDevice.width;
      const sh = this.system.app.graphicsDevice.height;
      const cameraWidth = camera._rect.z * sw;
      const cameraHeight = camera._rect.w * sh;
      clipL = camera._rect.x * sw;
      clipR = clipL + cameraWidth;
      clipT = (1 - camera._rect.y) * sh;
      clipB = clipT - cameraHeight;
    }
    const hitCorners = this.screenCorners;
    const left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
    const right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
    const bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
    const top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));
    if (right < clipL || left > clipR || bottom > clipT || top < clipB) {
      return false;
    }
    return true;
  }
  _isScreenSpace() {
    if (this.screen && this.screen.screen) {
      return this.screen.screen.screenSpace;
    }
    return false;
  }
  _isScreenCulled() {
    if (this.screen && this.screen.screen) {
      return this.screen.screen.cull;
    }
    return false;
  }
  _dirtyBatch() {
    if (this.batchGroupId !== -1) {
      var _this$system$app$batc5;
      (_this$system$app$batc5 = this.system.app.batcher) == null || _this$system$app$batc5.markGroupDirty(this.batchGroupId);
    }
  }
};
ElementComponent.EVENT_MOUSEDOWN = "mousedown";
ElementComponent.EVENT_MOUSEUP = "mouseup";
ElementComponent.EVENT_MOUSEENTER = "mouseenter";
ElementComponent.EVENT_MOUSELEAVE = "mouseleave";
ElementComponent.EVENT_MOUSEMOVE = "mousemove";
ElementComponent.EVENT_MOUSEWHEEL = "mousewheel";
ElementComponent.EVENT_CLICK = "click";
ElementComponent.EVENT_TOUCHSTART = "touchstart";
ElementComponent.EVENT_TOUCHEND = "touchend";
ElementComponent.EVENT_TOUCHMOVE = "touchmove";
ElementComponent.EVENT_TOUCHCANCEL = "touchcancel";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/element/data.js
var ElementComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/element/system.js
var _schema6 = ["enabled"];
var ElementComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "element";
    this.ComponentType = ElementComponent;
    this.DataType = ElementComponentData;
    this.schema = _schema6;
    this._unicodeConverter = null;
    this._rtlReorder = null;
    this._defaultTexture = new Texture(app2.graphicsDevice, {
      width: 1,
      height: 1,
      format: PIXELFORMAT_RGBA8,
      name: "element-system"
    });
    const pixels = this._defaultTexture.lock();
    const pixelData = new Uint8Array(4);
    pixelData[0] = 255;
    pixelData[1] = 255;
    pixelData[2] = 255;
    pixelData[3] = 255;
    pixels.set(pixelData);
    this._defaultTexture.unlock();
    this.defaultImageMaterial = null;
    this.defaultImage9SlicedMaterial = null;
    this.defaultImage9TiledMaterial = null;
    this.defaultImageMaskMaterial = null;
    this.defaultImage9SlicedMaskMaterial = null;
    this.defaultImage9TiledMaskMaterial = null;
    this.defaultScreenSpaceImageMaterial = null;
    this.defaultScreenSpaceImage9SlicedMaterial = null;
    this.defaultScreenSpaceImage9TiledMaterial = null;
    this.defaultScreenSpaceImageMask9SlicedMaterial = null;
    this.defaultScreenSpaceImageMask9TiledMaterial = null;
    this.defaultScreenSpaceImageMaskMaterial = null;
    this._defaultTextMaterials = {};
    this.defaultImageMaterials = [];
    this.on("beforeremove", this.onRemoveComponent, this);
  }
  destroy() {
    super.destroy();
    this._defaultTexture.destroy();
  }
  initializeComponentData(component, data2, properties3) {
    component._beingInitialized = true;
    if (data2.anchor !== void 0) {
      if (data2.anchor instanceof Vec4) {
        component.anchor.copy(data2.anchor);
      } else {
        component.anchor.set(data2.anchor[0], data2.anchor[1], data2.anchor[2], data2.anchor[3]);
      }
    }
    if (data2.pivot !== void 0) {
      if (data2.pivot instanceof Vec2) {
        component.pivot.copy(data2.pivot);
      } else {
        component.pivot.set(data2.pivot[0], data2.pivot[1]);
      }
    }
    const splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 1e-3;
    const splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 1e-3;
    let _marginChange = false;
    let color;
    if (data2.margin !== void 0) {
      if (data2.margin instanceof Vec4) {
        component.margin.copy(data2.margin);
      } else {
        component._margin.set(data2.margin[0], data2.margin[1], data2.margin[2], data2.margin[3]);
      }
      _marginChange = true;
    }
    if (data2.left !== void 0) {
      component._margin.x = data2.left;
      _marginChange = true;
    }
    if (data2.bottom !== void 0) {
      component._margin.y = data2.bottom;
      _marginChange = true;
    }
    if (data2.right !== void 0) {
      component._margin.z = data2.right;
      _marginChange = true;
    }
    if (data2.top !== void 0) {
      component._margin.w = data2.top;
      _marginChange = true;
    }
    if (_marginChange) {
      component.margin = component._margin;
    }
    let shouldForceSetAnchor = false;
    if (data2.width !== void 0 && !splitHorAnchors) {
      component.width = data2.width;
    } else if (splitHorAnchors) {
      shouldForceSetAnchor = true;
    }
    if (data2.height !== void 0 && !splitVerAnchors) {
      component.height = data2.height;
    } else if (splitVerAnchors) {
      shouldForceSetAnchor = true;
    }
    if (shouldForceSetAnchor) {
      component.anchor = component.anchor;
    }
    if (data2.enabled !== void 0) {
      component.enabled = data2.enabled;
    }
    if (data2.useInput !== void 0) {
      component.useInput = data2.useInput;
    }
    if (data2.fitMode !== void 0) {
      component.fitMode = data2.fitMode;
    }
    component.batchGroupId = data2.batchGroupId === void 0 || data2.batchGroupId === null ? -1 : data2.batchGroupId;
    if (data2.layers && Array.isArray(data2.layers)) {
      component.layers = data2.layers.slice(0);
    }
    if (data2.type !== void 0) {
      component.type = data2.type;
    }
    if (component.type === ELEMENTTYPE_IMAGE) {
      if (data2.rect !== void 0) {
        component.rect = data2.rect;
      }
      if (data2.color !== void 0) {
        color = data2.color;
        if (!(color instanceof Color)) {
          color = new Color(data2.color[0], data2.color[1], data2.color[2]);
        }
        component.color = color;
      }
      if (data2.opacity !== void 0) component.opacity = data2.opacity;
      if (data2.textureAsset !== void 0) component.textureAsset = data2.textureAsset;
      if (data2.texture) component.texture = data2.texture;
      if (data2.spriteAsset !== void 0) component.spriteAsset = data2.spriteAsset;
      if (data2.sprite) component.sprite = data2.sprite;
      if (data2.spriteFrame !== void 0) component.spriteFrame = data2.spriteFrame;
      if (data2.pixelsPerUnit !== void 0 && data2.pixelsPerUnit !== null) component.pixelsPerUnit = data2.pixelsPerUnit;
      if (data2.materialAsset !== void 0) component.materialAsset = data2.materialAsset;
      if (data2.material) component.material = data2.material;
      if (data2.mask !== void 0) {
        component.mask = data2.mask;
      }
    } else if (component.type === ELEMENTTYPE_TEXT) {
      if (data2.autoWidth !== void 0) component.autoWidth = data2.autoWidth;
      if (data2.autoHeight !== void 0) component.autoHeight = data2.autoHeight;
      if (data2.rtlReorder !== void 0) component.rtlReorder = data2.rtlReorder;
      if (data2.unicodeConverter !== void 0) component.unicodeConverter = data2.unicodeConverter;
      if (data2.text !== null && data2.text !== void 0) {
        component.text = data2.text;
      } else if (data2.key !== null && data2.key !== void 0) {
        component.key = data2.key;
      }
      if (data2.color !== void 0) {
        color = data2.color;
        if (!(color instanceof Color)) {
          color = new Color(color[0], color[1], color[2]);
        }
        component.color = color;
      }
      if (data2.opacity !== void 0) {
        component.opacity = data2.opacity;
      }
      if (data2.spacing !== void 0) component.spacing = data2.spacing;
      if (data2.fontSize !== void 0) {
        component.fontSize = data2.fontSize;
        if (!data2.lineHeight) component.lineHeight = data2.fontSize;
      }
      if (data2.lineHeight !== void 0) component.lineHeight = data2.lineHeight;
      if (data2.maxLines !== void 0) component.maxLines = data2.maxLines;
      if (data2.wrapLines !== void 0) component.wrapLines = data2.wrapLines;
      if (data2.minFontSize !== void 0) component.minFontSize = data2.minFontSize;
      if (data2.maxFontSize !== void 0) component.maxFontSize = data2.maxFontSize;
      if (data2.autoFitWidth) component.autoFitWidth = data2.autoFitWidth;
      if (data2.autoFitHeight) component.autoFitHeight = data2.autoFitHeight;
      if (data2.fontAsset !== void 0) component.fontAsset = data2.fontAsset;
      if (data2.font !== void 0) component.font = data2.font;
      if (data2.alignment !== void 0) component.alignment = data2.alignment;
      if (data2.outlineColor !== void 0) component.outlineColor = data2.outlineColor;
      if (data2.outlineThickness !== void 0) component.outlineThickness = data2.outlineThickness;
      if (data2.shadowColor !== void 0) component.shadowColor = data2.shadowColor;
      if (data2.shadowOffset !== void 0) component.shadowOffset = data2.shadowOffset;
      if (data2.enableMarkup !== void 0) component.enableMarkup = data2.enableMarkup;
    }
    const result = component._parseUpToScreen();
    if (result.screen) {
      component._updateScreen(result.screen);
    }
    super.initializeComponentData(component, data2, properties3);
    component._beingInitialized = false;
    if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
      component._image._updateMesh(component._image.mesh);
    }
  }
  onRemoveComponent(entity, component) {
    component.onRemove();
  }
  cloneComponent(entity, clone) {
    const source = entity.element;
    const data2 = {
      enabled: source.enabled,
      width: source.width,
      height: source.height,
      anchor: source.anchor.clone(),
      pivot: source.pivot.clone(),
      margin: source.margin.clone(),
      alignment: source.alignment && source.alignment.clone() || source.alignment,
      autoWidth: source.autoWidth,
      autoHeight: source.autoHeight,
      type: source.type,
      rect: source.rect && source.rect.clone() || source.rect,
      rtlReorder: source.rtlReorder,
      unicodeConverter: source.unicodeConverter,
      materialAsset: source.materialAsset,
      material: source.material,
      color: source.color && source.color.clone() || source.color,
      opacity: source.opacity,
      textureAsset: source.textureAsset,
      texture: source.texture,
      spriteAsset: source.spriteAsset,
      sprite: source.sprite,
      spriteFrame: source.spriteFrame,
      pixelsPerUnit: source.pixelsPerUnit,
      spacing: source.spacing,
      lineHeight: source.lineHeight,
      wrapLines: source.wrapLines,
      layers: source.layers,
      fontSize: source.fontSize,
      minFontSize: source.minFontSize,
      maxFontSize: source.maxFontSize,
      autoFitWidth: source.autoFitWidth,
      autoFitHeight: source.autoFitHeight,
      maxLines: source.maxLines,
      fontAsset: source.fontAsset,
      font: source.font,
      useInput: source.useInput,
      fitMode: source.fitMode,
      batchGroupId: source.batchGroupId,
      mask: source.mask,
      outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
      outlineThickness: source.outlineThickness,
      shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
      shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
      enableMarkup: source.enableMarkup
    };
    if (source.key !== void 0 && source.key !== null) {
      data2.key = source.key;
    } else {
      data2.text = source.text;
    }
    return this.addComponent(clone, data2);
  }
  getTextElementMaterial(screenSpace, msdf, textAttibutes) {
    const hash = (screenSpace && 1 << 0) | (msdf && 1 << 1) | (textAttibutes && 1 << 2);
    let material = this._defaultTextMaterials[hash];
    if (material) {
      return material;
    }
    let name = "TextMaterial";
    material = new StandardMaterial();
    if (msdf) {
      material.msdfMap = this._defaultTexture;
      material.msdfTextAttribute = textAttibutes;
      material.emissive.set(1, 1, 1);
    } else {
      name = `Bitmap${name}`;
      material.emissive.set(1, 1, 1);
      material.emissiveMap = this._defaultTexture;
      material.opacityMap = this._defaultTexture;
      material.opacityMapChannel = "a";
    }
    if (screenSpace) {
      name = `ScreenSpace${name}`;
      material.depthTest = false;
    }
    material.name = `default${name}`;
    material.useLighting = false;
    material.useTonemap = false;
    material.useFog = false;
    material.useSkybox = false;
    material.diffuse.set(0, 0, 0);
    material.opacity = 0.5;
    material.blendType = BLEND_PREMULTIPLIED;
    material.depthWrite = false;
    material.emissiveVertexColor = true;
    material.update();
    this._defaultTextMaterials[hash] = material;
    return material;
  }
  _createBaseImageMaterial() {
    const material = new StandardMaterial();
    material.diffuse.set(0, 0, 0);
    material.emissive.set(1, 1, 1);
    material.emissiveMap = this._defaultTexture;
    material.opacityMap = this._defaultTexture;
    material.opacityMapChannel = "a";
    material.useLighting = false;
    material.useTonemap = false;
    material.useFog = false;
    material.useSkybox = false;
    material.blendType = BLEND_PREMULTIPLIED;
    material.depthWrite = false;
    return material;
  }
  getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {
    if (screenSpace) {
      if (mask) {
        if (nineSliced) {
          if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
            this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
            this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial";
            this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
            this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
            this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
            this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
            this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
            this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
            this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
            this.defaultScreenSpaceImageMask9SlicedMaterial.update();
            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
          }
          return this.defaultScreenSpaceImageMask9SlicedMaterial;
        } else if (nineSliceTiled) {
          if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
            this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
            this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial";
            this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
            this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
            this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
            this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
            this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
            this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
            this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
            this.defaultScreenSpaceImageMask9TiledMaterial.update();
            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
          }
          return this.defaultScreenSpaceImageMask9TiledMaterial;
        } else {
          if (!this.defaultScreenSpaceImageMaskMaterial) {
            this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
            this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial";
            this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
            this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
            this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
            this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
            this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
            this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
            this.defaultScreenSpaceImageMaskMaterial.update();
            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
          }
          return this.defaultScreenSpaceImageMaskMaterial;
        }
      } else {
        if (nineSliced) {
          if (!this.defaultScreenSpaceImage9SlicedMaterial) {
            this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
            this.defaultScreenSpaceImage9SlicedMaterial.name = "defaultScreenSpaceImage9SlicedMaterial";
            this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
            this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
            this.defaultScreenSpaceImage9SlicedMaterial.update();
            this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
          }
          return this.defaultScreenSpaceImage9SlicedMaterial;
        } else if (nineSliceTiled) {
          if (!this.defaultScreenSpaceImage9TiledMaterial) {
            this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
            this.defaultScreenSpaceImage9TiledMaterial.name = "defaultScreenSpaceImage9TiledMaterial";
            this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
            this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
            this.defaultScreenSpaceImage9TiledMaterial.update();
            this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
          }
          return this.defaultScreenSpaceImage9TiledMaterial;
        } else {
          if (!this.defaultScreenSpaceImageMaterial) {
            this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
            this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial";
            this.defaultScreenSpaceImageMaterial.depthTest = false;
            this.defaultScreenSpaceImageMaterial.update();
            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
          }
          return this.defaultScreenSpaceImageMaterial;
        }
      }
    } else {
      if (mask) {
        if (nineSliced) {
          if (!this.defaultImage9SlicedMaskMaterial) {
            this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
            this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial";
            this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
            this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
            this.defaultImage9SlicedMaskMaterial.redWrite = false;
            this.defaultImage9SlicedMaskMaterial.greenWrite = false;
            this.defaultImage9SlicedMaskMaterial.blueWrite = false;
            this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
            this.defaultImage9SlicedMaskMaterial.update();
            this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
          }
          return this.defaultImage9SlicedMaskMaterial;
        } else if (nineSliceTiled) {
          if (!this.defaultImage9TiledMaskMaterial) {
            this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
            this.defaultImage9TiledMaskMaterial.name = "defaultImage9TiledMaskMaterial";
            this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
            this.defaultImage9TiledMaskMaterial.alphaTest = 1;
            this.defaultImage9TiledMaskMaterial.redWrite = false;
            this.defaultImage9TiledMaskMaterial.greenWrite = false;
            this.defaultImage9TiledMaskMaterial.blueWrite = false;
            this.defaultImage9TiledMaskMaterial.alphaWrite = false;
            this.defaultImage9TiledMaskMaterial.update();
            this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
          }
          return this.defaultImage9TiledMaskMaterial;
        } else {
          if (!this.defaultImageMaskMaterial) {
            this.defaultImageMaskMaterial = this._createBaseImageMaterial();
            this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial";
            this.defaultImageMaskMaterial.alphaTest = 1;
            this.defaultImageMaskMaterial.redWrite = false;
            this.defaultImageMaskMaterial.greenWrite = false;
            this.defaultImageMaskMaterial.blueWrite = false;
            this.defaultImageMaskMaterial.alphaWrite = false;
            this.defaultImageMaskMaterial.update();
            this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
          }
          return this.defaultImageMaskMaterial;
        }
      } else {
        if (nineSliced) {
          if (!this.defaultImage9SlicedMaterial) {
            this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
            this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial";
            this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
            this.defaultImage9SlicedMaterial.update();
            this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
          }
          return this.defaultImage9SlicedMaterial;
        } else if (nineSliceTiled) {
          if (!this.defaultImage9TiledMaterial) {
            this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
            this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial";
            this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
            this.defaultImage9TiledMaterial.update();
            this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
          }
          return this.defaultImage9TiledMaterial;
        } else {
          if (!this.defaultImageMaterial) {
            this.defaultImageMaterial = this._createBaseImageMaterial();
            this.defaultImageMaterial.name = "defaultImageMaterial";
            this.defaultImageMaterial.update();
            this.defaultImageMaterials.push(this.defaultImageMaterial);
          }
          return this.defaultImageMaterial;
        }
      }
    }
  }
  registerUnicodeConverter(func) {
    this._unicodeConverter = func;
  }
  registerRtlReorder(func) {
    this._rtlReorder = func;
  }
  getUnicodeConverter() {
    return this._unicodeConverter;
  }
  getRtlReorder() {
    return this._rtlReorder;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/joint/constants.js
var MOTION_FREE = "free";
var MOTION_LIMITED = "limited";
var MOTION_LOCKED = "locked";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/joint/component.js
var properties = ["angularDampingX", "angularDampingY", "angularDampingZ", "angularEquilibriumX", "angularEquilibriumY", "angularEquilibriumZ", "angularLimitsX", "angularLimitsY", "angularLimitsZ", "angularMotionX", "angularMotionY", "angularMotionZ", "angularSpringX", "angularSpringY", "angularSpringZ", "angularStiffnessX", "angularStiffnessY", "angularStiffnessZ", "breakForce", "enableCollision", "enabled", "entityA", "entityB", "linearDampingX", "linearDampingY", "linearDampingZ", "linearEquilibriumX", "linearEquilibriumY", "linearEquilibriumZ", "linearLimitsX", "linearLimitsY", "linearLimitsZ", "linearMotionX", "linearMotionY", "linearMotionZ", "linearSpringX", "linearSpringY", "linearSpringZ", "linearStiffnessX", "linearStiffnessY", "linearStiffnessZ"];
var JointComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._constraint = null;
    this._entityA = null;
    this._entityB = null;
    this._breakForce = 34e37;
    this._enableCollision = true;
    this._linearMotionX = MOTION_LOCKED;
    this._linearLimitsX = new Vec2(0, 0);
    this._linearSpringX = false;
    this._linearStiffnessX = 0;
    this._linearDampingX = 1;
    this._linearEquilibriumX = 0;
    this._linearMotionY = MOTION_LOCKED;
    this._linearLimitsY = new Vec2(0, 0);
    this._linearSpringY = false;
    this._linearStiffnessY = 0;
    this._linearDampingY = 1;
    this._linearEquilibriumY = 0;
    this._linearMotionZ = MOTION_LOCKED;
    this._linearLimitsZ = new Vec2(0, 0);
    this._linearSpringZ = false;
    this._linearStiffnessZ = 0;
    this._linearDampingZ = 1;
    this._linearEquilibriumZ = 0;
    this._angularMotionX = MOTION_LOCKED;
    this._angularLimitsX = new Vec2(0, 0);
    this._angularSpringX = false;
    this._angularStiffnessX = 0;
    this._angularDampingX = 1;
    this._angularEquilibriumX = 0;
    this._angularMotionY = MOTION_LOCKED;
    this._angularLimitsY = new Vec2(0, 0);
    this._angularSpringY = false;
    this._angularStiffnessY = 0;
    this._angularDampingY = 1;
    this._angularEquilibriumY = 0;
    this._angularMotionZ = MOTION_LOCKED;
    this._angularLimitsZ = new Vec2(0, 0);
    this._angularSpringZ = false;
    this._angularEquilibriumZ = 0;
    this._angularDampingZ = 1;
    this._angularStiffnessZ = 0;
    this.on("set_enabled", this._onSetEnabled, this);
  }
  set entityA(body) {
    this._destroyConstraint();
    this._entityA = body;
    this._createConstraint();
  }
  get entityA() {
    return this._entityA;
  }
  set entityB(body) {
    this._destroyConstraint();
    this._entityB = body;
    this._createConstraint();
  }
  get entityB() {
    return this._entityB;
  }
  set breakForce(force) {
    if (this._constraint && this._breakForce !== force) {
      this._constraint.setBreakingImpulseThreshold(force);
      this._breakForce = force;
    }
  }
  get breakForce() {
    return this._breakForce;
  }
  set enableCollision(enableCollision) {
    this._destroyConstraint();
    this._enableCollision = enableCollision;
    this._createConstraint();
  }
  get enableCollision() {
    return this._enableCollision;
  }
  set angularLimitsX(limits) {
    if (!this._angularLimitsX.equals(limits)) {
      this._angularLimitsX.copy(limits);
      this._updateAngularLimits();
    }
  }
  get angularLimitsX() {
    return this._angularLimitsX;
  }
  set angularMotionX(value) {
    if (this._angularMotionX !== value) {
      this._angularMotionX = value;
      this._updateAngularLimits();
    }
  }
  get angularMotionX() {
    return this._angularMotionX;
  }
  set angularLimitsY(limits) {
    if (!this._angularLimitsY.equals(limits)) {
      this._angularLimitsY.copy(limits);
      this._updateAngularLimits();
    }
  }
  get angularLimitsY() {
    return this._angularLimitsY;
  }
  set angularMotionY(value) {
    if (this._angularMotionY !== value) {
      this._angularMotionY = value;
      this._updateAngularLimits();
    }
  }
  get angularMotionY() {
    return this._angularMotionY;
  }
  set angularLimitsZ(limits) {
    if (!this._angularLimitsZ.equals(limits)) {
      this._angularLimitsZ.copy(limits);
      this._updateAngularLimits();
    }
  }
  get angularLimitsZ() {
    return this._angularLimitsZ;
  }
  set angularMotionZ(value) {
    if (this._angularMotionZ !== value) {
      this._angularMotionZ = value;
      this._updateAngularLimits();
    }
  }
  get angularMotionZ() {
    return this._angularMotionZ;
  }
  set linearLimitsX(limits) {
    if (!this._linearLimitsX.equals(limits)) {
      this._linearLimitsX.copy(limits);
      this._updateLinearLimits();
    }
  }
  get linearLimitsX() {
    return this._linearLimitsX;
  }
  set linearMotionX(value) {
    if (this._linearMotionX !== value) {
      this._linearMotionX = value;
      this._updateLinearLimits();
    }
  }
  get linearMotionX() {
    return this._linearMotionX;
  }
  set linearLimitsY(limits) {
    if (!this._linearLimitsY.equals(limits)) {
      this._linearLimitsY.copy(limits);
      this._updateLinearLimits();
    }
  }
  get linearLimitsY() {
    return this._linearLimitsY;
  }
  set linearMotionY(value) {
    if (this._linearMotionY !== value) {
      this._linearMotionY = value;
      this._updateLinearLimits();
    }
  }
  get linearMotionY() {
    return this._linearMotionY;
  }
  set linearLimitsZ(limits) {
    if (!this._linearLimitsZ.equals(limits)) {
      this._linearLimitsZ.copy(limits);
      this._updateLinearLimits();
    }
  }
  get linearLimitsZ() {
    return this._linearLimitsZ;
  }
  set linearMotionZ(value) {
    if (this._linearMotionZ !== value) {
      this._linearMotionZ = value;
      this._updateLinearLimits();
    }
  }
  get linearMotionZ() {
    return this._linearMotionZ;
  }
  _convertTransform(pcTransform, ammoTransform) {
    const pos = pcTransform.getTranslation();
    const rot = new Quat();
    rot.setFromMat4(pcTransform);
    const ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);
    const ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);
    ammoTransform.setOrigin(ammoVec);
    ammoTransform.setRotation(ammoQuat);
    Ammo.destroy(ammoVec);
    Ammo.destroy(ammoQuat);
  }
  _updateAngularLimits() {
    const constraint = this._constraint;
    if (constraint) {
      let lx, ly, lz, ux, uy, uz;
      if (this._angularMotionX === MOTION_LIMITED) {
        lx = this._angularLimitsX.x * math.DEG_TO_RAD;
        ux = this._angularLimitsX.y * math.DEG_TO_RAD;
      } else if (this._angularMotionX === MOTION_FREE) {
        lx = 1;
        ux = 0;
      } else {
        lx = ux = 0;
      }
      if (this._angularMotionY === MOTION_LIMITED) {
        ly = this._angularLimitsY.x * math.DEG_TO_RAD;
        uy = this._angularLimitsY.y * math.DEG_TO_RAD;
      } else if (this._angularMotionY === MOTION_FREE) {
        ly = 1;
        uy = 0;
      } else {
        ly = uy = 0;
      }
      if (this._angularMotionZ === MOTION_LIMITED) {
        lz = this._angularLimitsZ.x * math.DEG_TO_RAD;
        uz = this._angularLimitsZ.y * math.DEG_TO_RAD;
      } else if (this._angularMotionZ === MOTION_FREE) {
        lz = 1;
        uz = 0;
      } else {
        lz = uz = 0;
      }
      const limits = new Ammo.btVector3(lx, ly, lz);
      constraint.setAngularLowerLimit(limits);
      limits.setValue(ux, uy, uz);
      constraint.setAngularUpperLimit(limits);
      Ammo.destroy(limits);
    }
  }
  _updateLinearLimits() {
    const constraint = this._constraint;
    if (constraint) {
      let lx, ly, lz, ux, uy, uz;
      if (this._linearMotionX === MOTION_LIMITED) {
        lx = this._linearLimitsX.x;
        ux = this._linearLimitsX.y;
      } else if (this._linearMotionX === MOTION_FREE) {
        lx = 1;
        ux = 0;
      } else {
        lx = ux = 0;
      }
      if (this._linearMotionY === MOTION_LIMITED) {
        ly = this._linearLimitsY.x;
        uy = this._linearLimitsY.y;
      } else if (this._linearMotionY === MOTION_FREE) {
        ly = 1;
        uy = 0;
      } else {
        ly = uy = 0;
      }
      if (this._linearMotionZ === MOTION_LIMITED) {
        lz = this._linearLimitsZ.x;
        uz = this._linearLimitsZ.y;
      } else if (this._linearMotionZ === MOTION_FREE) {
        lz = 1;
        uz = 0;
      } else {
        lz = uz = 0;
      }
      const limits = new Ammo.btVector3(lx, ly, lz);
      constraint.setLinearLowerLimit(limits);
      limits.setValue(ux, uy, uz);
      constraint.setLinearUpperLimit(limits);
      Ammo.destroy(limits);
    }
  }
  _createConstraint() {
    if (this._entityA && this._entityA.rigidbody) {
      this._destroyConstraint();
      const mat2 = new Mat4();
      const bodyA = this._entityA.rigidbody.body;
      bodyA.activate();
      const jointWtm = this.entity.getWorldTransform();
      const entityAWtm = this._entityA.getWorldTransform();
      const invEntityAWtm = entityAWtm.clone().invert();
      mat2.mul2(invEntityAWtm, jointWtm);
      const frameA = new Ammo.btTransform();
      this._convertTransform(mat2, frameA);
      if (this._entityB && this._entityB.rigidbody) {
        const bodyB = this._entityB.rigidbody.body;
        bodyB.activate();
        const entityBWtm = this._entityB.getWorldTransform();
        const invEntityBWtm = entityBWtm.clone().invert();
        mat2.mul2(invEntityBWtm, jointWtm);
        const frameB = new Ammo.btTransform();
        this._convertTransform(mat2, frameB);
        this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);
        Ammo.destroy(frameB);
      } else {
        this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);
      }
      Ammo.destroy(frameA);
      const axis = ["X", "Y", "Z", "X", "Y", "Z"];
      for (let i = 0; i < 6; i++) {
        const type = i < 3 ? "_linear" : "_angular";
        this._constraint.enableSpring(i, this[`${type}Spring${axis[i]}`]);
        this._constraint.setDamping(i, this[`${type}Damping${axis[i]}`]);
        this._constraint.setEquilibriumPoint(i, this[`${type}Equilibrium${axis[i]}`]);
        this._constraint.setStiffness(i, this[`${type}Stiffness${axis[i]}`]);
      }
      this._constraint.setBreakingImpulseThreshold(this._breakForce);
      this._updateLinearLimits();
      this._updateAngularLimits();
      const app2 = this.system.app;
      const dynamicsWorld = app2.systems.rigidbody.dynamicsWorld;
      dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
    }
  }
  _destroyConstraint() {
    if (this._constraint) {
      const app2 = this.system.app;
      const dynamicsWorld = app2.systems.rigidbody.dynamicsWorld;
      dynamicsWorld.removeConstraint(this._constraint);
      Ammo.destroy(this._constraint);
      this._constraint = null;
    }
  }
  initFromData(data2) {
    for (const prop of properties) {
      if (data2.hasOwnProperty(prop)) {
        if (data2[prop] instanceof Vec2) {
          this[`_${prop}`].copy(data2[prop]);
        } else {
          this[`_${prop}`] = data2[prop];
        }
      }
    }
    this._createConstraint();
  }
  onEnable() {
    this._createConstraint();
  }
  onDisable() {
    this._destroyConstraint();
  }
  _onSetEnabled(prop, old, value) {
  }
  _onBeforeRemove() {
    this.fire("remove");
  }
};
var functionMap = {
  Damping: "setDamping",
  Equilibrium: "setEquilibriumPoint",
  Spring: "enableSpring",
  Stiffness: "setStiffness"
};
["linear", "angular"].forEach((type) => {
  ["Damping", "Equilibrium", "Spring", "Stiffness"].forEach((name) => {
    ["X", "Y", "Z"].forEach((axis) => {
      const prop = type + name + axis;
      const propInternal = `_${prop}`;
      let index = type === "linear" ? 0 : 3;
      if (axis === "Y") index += 1;
      if (axis === "Z") index += 2;
      Object.defineProperty(JointComponent.prototype, prop, {
        get: function() {
          return this[propInternal];
        },
        set: function(value) {
          if (this[propInternal] !== value) {
            this[propInternal] = value;
            this._constraint[functionMap[name]](index, value);
          }
        }
      });
    });
  });
});

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/joint/data.js
var JointComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/joint/system.js
var _schema7 = ["enabled"];
var JointComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "joint";
    this.app = app2;
    this.ComponentType = JointComponent;
    this.DataType = JointComponentData;
    this.schema = _schema7;
  }
  initializeComponentData(component, data2, properties3) {
    component.initFromData(data2);
  }
};
Component._buildAccessors(JointComponent.prototype, _schema7);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/layout-child/component.js
var LayoutChildComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._minWidth = 0;
    this._minHeight = 0;
    this._maxWidth = null;
    this._maxHeight = null;
    this._fitWidthProportion = 0;
    this._fitHeightProportion = 0;
    this._excludeFromLayout = false;
  }
  set minWidth(value) {
    if (value !== this._minWidth) {
      this._minWidth = value;
      this.fire("resize");
    }
  }
  get minWidth() {
    return this._minWidth;
  }
  set minHeight(value) {
    if (value !== this._minHeight) {
      this._minHeight = value;
      this.fire("resize");
    }
  }
  get minHeight() {
    return this._minHeight;
  }
  set maxWidth(value) {
    if (value !== this._maxWidth) {
      this._maxWidth = value;
      this.fire("resize");
    }
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxHeight(value) {
    if (value !== this._maxHeight) {
      this._maxHeight = value;
      this.fire("resize");
    }
  }
  get maxHeight() {
    return this._maxHeight;
  }
  set fitWidthProportion(value) {
    if (value !== this._fitWidthProportion) {
      this._fitWidthProportion = value;
      this.fire("resize");
    }
  }
  get fitWidthProportion() {
    return this._fitWidthProportion;
  }
  set fitHeightProportion(value) {
    if (value !== this._fitHeightProportion) {
      this._fitHeightProportion = value;
      this.fire("resize");
    }
  }
  get fitHeightProportion() {
    return this._fitHeightProportion;
  }
  set excludeFromLayout(value) {
    if (value !== this._excludeFromLayout) {
      this._excludeFromLayout = value;
      this.fire("resize");
    }
  }
  get excludeFromLayout() {
    return this._excludeFromLayout;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/layout-child/data.js
var LayoutChildComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/layout-child/system.js
var _schema8 = ["enabled"];
var LayoutChildComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "layoutchild";
    this.ComponentType = LayoutChildComponent;
    this.DataType = LayoutChildComponentData;
    this.schema = _schema8;
  }
  initializeComponentData(component, data2, properties3) {
    if (data2.enabled !== void 0) component.enabled = data2.enabled;
    if (data2.minWidth !== void 0) component.minWidth = data2.minWidth;
    if (data2.minHeight !== void 0) component.minHeight = data2.minHeight;
    if (data2.maxWidth !== void 0) component.maxWidth = data2.maxWidth;
    if (data2.maxHeight !== void 0) component.maxHeight = data2.maxHeight;
    if (data2.fitWidthProportion !== void 0) component.fitWidthProportion = data2.fitWidthProportion;
    if (data2.fitHeightProportion !== void 0) component.fitHeightProportion = data2.fitHeightProportion;
    if (data2.excludeFromLayout !== void 0) component.excludeFromLayout = data2.excludeFromLayout;
    super.initializeComponentData(component, data2, properties3);
  }
  cloneComponent(entity, clone) {
    const layoutChild = entity.layoutchild;
    return this.addComponent(clone, {
      enabled: layoutChild.enabled,
      minWidth: layoutChild.minWidth,
      minHeight: layoutChild.minHeight,
      maxWidth: layoutChild.maxWidth,
      maxHeight: layoutChild.maxHeight,
      fitWidthProportion: layoutChild.fitWidthProportion,
      fitHeightProportion: layoutChild.fitHeightProportion,
      excludeFromLayout: layoutChild.excludeFromLayout
    });
  }
};
Component._buildAccessors(LayoutChildComponent.prototype, _schema8);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/constants.js
var FITTING_NONE = 0;
var FITTING_STRETCH = 1;
var FITTING_SHRINK = 2;
var FITTING_BOTH = 3;

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/layout-calculator.js
var AXIS_MAPPINGS = {};
AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
  axis: "x",
  size: "width",
  calculatedSize: "calculatedWidth",
  minSize: "minWidth",
  maxSize: "maxWidth",
  fitting: "widthFitting",
  fittingProportion: "fitWidthProportion"
};
AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
  axis: "y",
  size: "height",
  calculatedSize: "calculatedHeight",
  minSize: "minHeight",
  maxSize: "maxHeight",
  fitting: "heightFitting",
  fittingProportion: "fitHeightProportion"
};
var OPPOSITE_ORIENTATION = {};
OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
var PROPERTY_DEFAULTS = {
  minWidth: 0,
  minHeight: 0,
  maxWidth: Number.POSITIVE_INFINITY,
  maxHeight: Number.POSITIVE_INFINITY,
  width: null,
  height: null,
  fitWidthProportion: 0,
  fitHeightProportion: 0
};
var FITTING_ACTION = {
  NONE: "NONE",
  APPLY_STRETCHING: "APPLY_STRETCHING",
  APPLY_SHRINKING: "APPLY_SHRINKING"
};
var availableSpace = new Vec2();
function createCalculator(orientation) {
  let options2;
  const a = AXIS_MAPPINGS[orientation];
  const b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];
  function minExtentA(element, size) {
    return -size[a.size] * element.pivot[a.axis];
  }
  function minExtentB(element, size) {
    return -size[b.size] * element.pivot[b.axis];
  }
  function maxExtentA(element, size) {
    return size[a.size] * (1 - element.pivot[a.axis]);
  }
  function calculateAll(allElements, layoutOptions) {
    allElements = allElements.filter(shouldIncludeInLayout);
    options2 = layoutOptions;
    availableSpace.x = options2.containerSize.x - options2.padding.x - options2.padding.z;
    availableSpace.y = options2.containerSize.y - options2.padding.y - options2.padding.w;
    resetAnchors(allElements);
    const lines = reverseLinesIfRequired(splitLines(allElements));
    const sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
    const positions = calculateBasePositions(lines, sizes);
    applyAlignmentAndPadding(lines, sizes, positions);
    applySizesAndPositions(lines, sizes, positions);
    return createLayoutInfo(lines);
  }
  function shouldIncludeInLayout(element) {
    const layoutChildComponent = element.entity.layoutchild;
    return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
  }
  function resetAnchors(allElements) {
    for (let i = 0; i < allElements.length; ++i) {
      const element = allElements[i];
      const anchor = element.anchor;
      if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
        element.anchor = Vec4.ZERO;
      }
    }
  }
  function splitLines(allElements) {
    if (!options2.wrap) {
      return [allElements];
    }
    const lines = [[]];
    const sizes = getElementSizeProperties(allElements);
    let runningSize = 0;
    const allowOverrun = options2[a.fitting] === FITTING_SHRINK;
    for (let i = 0; i < allElements.length; ++i) {
      if (lines[lines.length - 1].length > 0) {
        runningSize += options2.spacing[a.axis];
      }
      const idealElementSize = sizes[i][a.size];
      runningSize += idealElementSize;
      if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
        runningSize = idealElementSize;
        lines.push([]);
      }
      lines[lines.length - 1].push(allElements[i]);
      if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
        runningSize = 0;
        lines.push([]);
      }
    }
    return lines;
  }
  function reverseLinesIfRequired(lines) {
    const reverseAxisA = options2.orientation === ORIENTATION_HORIZONTAL && options2.reverseX || options2.orientation === ORIENTATION_VERTICAL && options2.reverseY;
    const reverseAxisB = options2.orientation === ORIENTATION_HORIZONTAL && options2.reverseY || options2.orientation === ORIENTATION_VERTICAL && options2.reverseX;
    if (reverseAxisA) {
      for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
        if (reverseAxisA) {
          lines[lineIndex].reverse();
        }
      }
    }
    if (reverseAxisB) {
      lines.reverse();
    }
    return lines;
  }
  function calculateSizesOnAxisA(lines) {
    const sizesAllLines = [];
    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
      const line = lines[lineIndex];
      const sizesThisLine = getElementSizeProperties(line);
      const idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
      const fittingAction = determineFittingAction(options2[a.fitting], idealRequiredSpace, availableSpace[a.axis]);
      if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
        stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
      } else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
        shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
      }
      sizesAllLines.push(sizesThisLine);
    }
    return sizesAllLines;
  }
  function calculateSizesOnAxisB(lines, sizesAllLines) {
    const largestElementsForEachLine = [];
    const largestSizesForEachLine = [];
    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
      const line = lines[lineIndex];
      line.largestElement = null;
      line.largestSize = {
        width: Number.NEGATIVE_INFINITY,
        height: Number.NEGATIVE_INFINITY
      };
      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
        const sizesThisElement = sizesAllLines[lineIndex][elementIndex];
        if (sizesThisElement[b.size] > line.largestSize[b.size]) {
          line.largestElement = line[elementIndex];
          line.largestSize = sizesThisElement;
        }
      }
      largestElementsForEachLine.push(line.largestElement);
      largestSizesForEachLine.push(line.largestSize);
    }
    const idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
    const fittingAction = determineFittingAction(options2[b.fitting], idealRequiredSpace, availableSpace[b.axis]);
    if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
      stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
    } else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
      shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
    }
    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
      const line = lines[lineIndex];
      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
        const sizesForThisElement = sizesAllLines[lineIndex][elementIndex];
        const currentSize = sizesForThisElement[b.size];
        const availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];
        const elementFittingAction = determineFittingAction(options2[b.fitting], currentSize, availableSize);
        if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
          sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
        } else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
          sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
        }
      }
    }
    return sizesAllLines;
  }
  function determineFittingAction(fittingMode, currentSize, availableSize) {
    switch (fittingMode) {
      case FITTING_NONE:
        return FITTING_ACTION.NONE;
      case FITTING_STRETCH:
        if (currentSize < availableSize) {
          return FITTING_ACTION.APPLY_STRETCHING;
        }
        return FITTING_ACTION.NONE;
      case FITTING_SHRINK:
        if (currentSize >= availableSize) {
          return FITTING_ACTION.APPLY_SHRINKING;
        }
        return FITTING_ACTION.NONE;
      case FITTING_BOTH:
        if (currentSize < availableSize) {
          return FITTING_ACTION.APPLY_STRETCHING;
        }
        return FITTING_ACTION.APPLY_SHRINKING;
      default:
        throw new Error(`Unrecognized fitting mode: ${fittingMode}`);
    }
  }
  function calculateTotalSpace(sizes, axis) {
    const totalSizes = sumValues(sizes, axis.size);
    const totalSpacing = (sizes.length - 1) * options2.spacing[axis.axis];
    return totalSizes + totalSpacing;
  }
  function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
    const ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
    const fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
    const fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
    let remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;
    for (let i = 0; i < sizesThisLine.length; ++i) {
      const index = ascendingMaxSizeOrder[i];
      const targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
      const targetSize = sizesThisLine[index][axis.size] + targetIncrease;
      const maxSize = sizesThisLine[index][axis.maxSize];
      const actualSize = Math.min(targetSize, maxSize);
      sizesThisLine[index][axis.size] = actualSize;
      const actualIncrease = Math.max(targetSize - actualSize, 0);
      const appliedIncrease = targetIncrease - actualIncrease;
      remainingUndershoot -= appliedIncrease;
    }
  }
  function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
    const descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
    const fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
    const inverseFittingProportions = invertNormalizedValues(fittingProportions);
    const inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
    let remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];
    for (let i = 0; i < sizesThisLine.length; ++i) {
      const index = descendingMinSizeOrder[i];
      const targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
      const targetSize = sizesThisLine[index][axis.size] - targetReduction;
      const minSize = sizesThisLine[index][axis.minSize];
      const actualSize = Math.max(targetSize, minSize);
      sizesThisLine[index][axis.size] = actualSize;
      const actualReduction = Math.max(actualSize - targetSize, 0);
      const appliedReduction = targetReduction - actualReduction;
      remainingOvershoot -= appliedReduction;
    }
  }
  function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
    const proportion = fittingProportions[index];
    const sumOfRemainingProportions = fittingProportionSums[index];
    if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
      return remainingAdjustment;
    }
    return remainingAdjustment * proportion / sumOfRemainingProportions;
  }
  function calculateBasePositions(lines, sizes) {
    const cursor = {};
    cursor[a.axis] = 0;
    cursor[b.axis] = 0;
    lines[a.size] = Number.NEGATIVE_INFINITY;
    const positionsAllLines = [];
    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
      const line = lines[lineIndex];
      if (line.length === 0) {
        positionsAllLines.push([]);
        continue;
      }
      const positionsThisLine = [];
      const sizesThisLine = sizes[lineIndex];
      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
        const element = line[elementIndex];
        const sizesThisElement = sizesThisLine[elementIndex];
        cursor[b.axis] -= minExtentB(element, sizesThisElement);
        cursor[a.axis] -= minExtentA(element, sizesThisElement);
        positionsThisLine[elementIndex] = {};
        positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
        positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
        cursor[b.axis] += minExtentB(element, sizesThisElement);
        cursor[a.axis] += maxExtentA(element, sizesThisElement) + options2.spacing[a.axis];
      }
      line[a.size] = cursor[a.axis] - options2.spacing[a.axis];
      line[b.size] = line.largestSize[b.size];
      lines[a.size] = Math.max(lines[a.size], line[a.size]);
      cursor[a.axis] = 0;
      cursor[b.axis] += line[b.size] + options2.spacing[b.axis];
      positionsAllLines.push(positionsThisLine);
    }
    lines[b.size] = cursor[b.axis] - options2.spacing[b.axis];
    return positionsAllLines;
  }
  function applyAlignmentAndPadding(lines, sizes, positions) {
    const alignmentA = options2.alignment[a.axis];
    const alignmentB = options2.alignment[b.axis];
    const paddingA = options2.padding[a.axis];
    const paddingB = options2.padding[b.axis];
    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
      const line = lines[lineIndex];
      const sizesThisLine = sizes[lineIndex];
      const positionsThisLine = positions[lineIndex];
      const axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
      const axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;
      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
        const withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options2.alignment[b.axis];
        positionsThisLine[elementIndex][a.axis] += axisAOffset;
        positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
      }
    }
  }
  function applySizesAndPositions(lines, sizes, positions) {
    for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
      const line = lines[lineIndex];
      const sizesThisLine = sizes[lineIndex];
      const positionsThisLine = positions[lineIndex];
      for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
        const element = line[elementIndex];
        element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
        element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];
        if (options2.orientation === ORIENTATION_HORIZONTAL) {
          element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
        } else {
          element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
        }
      }
    }
  }
  function createLayoutInfo(lines) {
    const layoutWidth = lines.width;
    const layoutHeight = lines.height;
    const xOffset = (availableSpace.x - layoutWidth) * options2.alignment.x + options2.padding.x;
    const yOffset = (availableSpace.y - layoutHeight) * options2.alignment.y + options2.padding.y;
    return {
      bounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)
    };
  }
  function getElementSizeProperties(elements) {
    const sizeProperties = [];
    for (let i = 0; i < elements.length; ++i) {
      const element = elements[i];
      const minWidth = Math.max(getProperty(element, "minWidth"), 0);
      const minHeight = Math.max(getProperty(element, "minHeight"), 0);
      const maxWidth = Math.max(getProperty(element, "maxWidth"), minWidth);
      const maxHeight = Math.max(getProperty(element, "maxHeight"), minHeight);
      const width = clamp(getProperty(element, "width"), minWidth, maxWidth);
      const height = clamp(getProperty(element, "height"), minHeight, maxHeight);
      const fitWidthProportion = getProperty(element, "fitWidthProportion");
      const fitHeightProportion = getProperty(element, "fitHeightProportion");
      sizeProperties.push({
        minWidth,
        minHeight,
        maxWidth,
        maxHeight,
        width,
        height,
        fitWidthProportion,
        fitHeightProportion
      });
    }
    return sizeProperties;
  }
  function getProperty(element, propertyName) {
    const layoutChildComponent = element.entity.layoutchild;
    if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== void 0 && layoutChildComponent[propertyName] !== null) {
      return layoutChildComponent[propertyName];
    } else if (element[propertyName] !== void 0) {
      return element[propertyName];
    }
    return PROPERTY_DEFAULTS[propertyName];
  }
  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  function sumValues(items, propertyName) {
    return items.reduce((accumulator, current) => {
      return accumulator + current[propertyName];
    }, 0);
  }
  function getNormalizedValues(items, propertyName) {
    const sum = sumValues(items, propertyName);
    const normalizedValues = [];
    const numItems = items.length;
    if (sum === 0) {
      for (let i = 0; i < numItems; ++i) {
        normalizedValues.push(1 / numItems);
      }
    } else {
      for (let i = 0; i < numItems; ++i) {
        normalizedValues.push(items[i][propertyName] / sum);
      }
    }
    return normalizedValues;
  }
  function invertNormalizedValues(values) {
    if (values.length === 1) {
      return [1];
    }
    const invertedValues = [];
    const numValues = values.length;
    for (let i = 0; i < numValues; ++i) {
      invertedValues.push((1 - values[i]) / (numValues - 1));
    }
    return invertedValues;
  }
  function getTraversalOrder(items, orderBy, descending) {
    items.forEach(assignIndex);
    return items.slice().sort((itemA, itemB) => {
      return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
    }).map(getIndex);
  }
  function assignIndex(item, index) {
    item.index = index;
  }
  function getIndex(item) {
    return item.index;
  }
  function createSumArray(values, order) {
    const sumArray = [];
    sumArray[order[values.length - 1]] = values[order[values.length - 1]];
    for (let i = values.length - 2; i >= 0; --i) {
      sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
    }
    return sumArray;
  }
  return calculateAll;
}
var CALCULATE_FNS = {};
CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);
var LayoutCalculator = class {
  calculateLayout(elements, options2) {
    const calculateFn = CALCULATE_FNS[options2.orientation];
    if (!calculateFn) {
      throw new Error(`Unrecognized orientation value: ${options2.orientation}`);
    } else {
      return calculateFn(elements, options2);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/component.js
function getElement(entity) {
  return entity.element;
}
function isEnabledAndHasEnabledElement(entity) {
  return entity.enabled && entity.element && entity.element.enabled;
}
var LayoutGroupComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._orientation = ORIENTATION_HORIZONTAL;
    this._reverseX = false;
    this._reverseY = true;
    this._alignment = new Vec2(0, 1);
    this._padding = new Vec4();
    this._spacing = new Vec2();
    this._widthFitting = FITTING_NONE;
    this._heightFitting = FITTING_NONE;
    this._wrap = false;
    this._layoutCalculator = new LayoutCalculator();
    this._listenForReflowEvents(this.entity, "on");
    this.entity.children.forEach((child) => {
      this._listenForReflowEvents(child, "on");
    });
    this.entity.on("childinsert", this._onChildInsert, this);
    this.entity.on("childremove", this._onChildRemove, this);
    system.app.systems.element.on("add", this._onElementOrLayoutComponentAdd, this);
    system.app.systems.element.on("beforeremove", this._onElementOrLayoutComponentRemove, this);
    system.app.systems.layoutchild.on("add", this._onElementOrLayoutComponentAdd, this);
    system.app.systems.layoutchild.on("beforeremove", this._onElementOrLayoutComponentRemove, this);
  }
  set orientation(value) {
    if (value !== this._orientation) {
      this._orientation = value;
      this._scheduleReflow();
    }
  }
  get orientation() {
    return this._orientation;
  }
  set reverseX(value) {
    if (value !== this._reverseX) {
      this._reverseX = value;
      this._scheduleReflow();
    }
  }
  get reverseX() {
    return this._reverseX;
  }
  set reverseY(value) {
    if (value !== this._reverseY) {
      this._reverseY = value;
      this._scheduleReflow();
    }
  }
  get reverseY() {
    return this._reverseY;
  }
  set alignment(value) {
    if (!value.equals(this._alignment)) {
      this._alignment.copy(value);
      this._scheduleReflow();
    }
  }
  get alignment() {
    return this._alignment;
  }
  set padding(value) {
    if (!value.equals(this._padding)) {
      this._padding.copy(value);
      this._scheduleReflow();
    }
  }
  get padding() {
    return this._padding;
  }
  set spacing(value) {
    if (!value.equals(this._spacing)) {
      this._spacing.copy(value);
      this._scheduleReflow();
    }
  }
  get spacing() {
    return this._spacing;
  }
  set widthFitting(value) {
    if (value !== this._widthFitting) {
      this._widthFitting = value;
      this._scheduleReflow();
    }
  }
  get widthFitting() {
    return this._widthFitting;
  }
  set heightFitting(value) {
    if (value !== this._heightFitting) {
      this._heightFitting = value;
      this._scheduleReflow();
    }
  }
  get heightFitting() {
    return this._heightFitting;
  }
  set wrap(value) {
    if (value !== this._wrap) {
      this._wrap = value;
      this._scheduleReflow();
    }
  }
  get wrap() {
    return this._wrap;
  }
  _isSelfOrChild(entity) {
    return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
  }
  _listenForReflowEvents(target2, onOff) {
    if (target2.element) {
      target2.element[onOff]("enableelement", this._scheduleReflow, this);
      target2.element[onOff]("disableelement", this._scheduleReflow, this);
      target2.element[onOff]("resize", this._scheduleReflow, this);
      target2.element[onOff]("set:pivot", this._scheduleReflow, this);
    }
    if (target2.layoutchild) {
      target2.layoutchild[onOff]("set_enabled", this._scheduleReflow, this);
      target2.layoutchild[onOff]("resize", this._scheduleReflow, this);
    }
  }
  _onElementOrLayoutComponentAdd(entity) {
    if (this._isSelfOrChild(entity)) {
      this._listenForReflowEvents(entity, "on");
      this._scheduleReflow();
    }
  }
  _onElementOrLayoutComponentRemove(entity) {
    if (this._isSelfOrChild(entity)) {
      this._listenForReflowEvents(entity, "off");
      this._scheduleReflow();
    }
  }
  _onChildInsert(child) {
    this._listenForReflowEvents(child, "on");
    this._scheduleReflow();
  }
  _onChildRemove(child) {
    this._listenForReflowEvents(child, "off");
    this._scheduleReflow();
  }
  _scheduleReflow() {
    if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
      this.system.scheduleReflow(this);
    }
  }
  reflow() {
    const container = getElement(this.entity);
    const elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);
    if (!container || elements.length === 0) {
      return;
    }
    const containerWidth = Math.max(container.calculatedWidth, 0);
    const containerHeight = Math.max(container.calculatedHeight, 0);
    const options2 = {
      orientation: this._orientation,
      reverseX: this._reverseX,
      reverseY: this._reverseY,
      alignment: this._alignment,
      padding: this._padding,
      spacing: this._spacing,
      widthFitting: this._widthFitting,
      heightFitting: this._heightFitting,
      wrap: this._wrap,
      containerSize: new Vec2(containerWidth, containerHeight)
    };
    this._isPerformingReflow = true;
    const layoutInfo = this._layoutCalculator.calculateLayout(elements, options2);
    this._isPerformingReflow = false;
    this.fire("reflow", layoutInfo);
  }
  onEnable() {
    this._scheduleReflow();
  }
  onRemove() {
    this.entity.off("childinsert", this._onChildInsert, this);
    this.entity.off("childremove", this._onChildRemove, this);
    this._listenForReflowEvents(this.entity, "off");
    this.entity.children.forEach((child) => {
      this._listenForReflowEvents(child, "off");
    });
    this.system.app.systems.element.off("add", this._onElementOrLayoutComponentAdd, this);
    this.system.app.systems.element.off("beforeremove", this._onElementOrLayoutComponentRemove, this);
    this.system.app.systems.layoutchild.off("add", this._onElementOrLayoutComponentAdd, this);
    this.system.app.systems.layoutchild.off("beforeremove", this._onElementOrLayoutComponentRemove, this);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/data.js
var LayoutGroupComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/system.js
var _schema9 = ["enabled"];
var MAX_ITERATIONS = 100;
var LayoutGroupComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "layoutgroup";
    this.ComponentType = LayoutGroupComponent;
    this.DataType = LayoutGroupComponentData;
    this.schema = _schema9;
    this._reflowQueue = [];
    this.on("beforeremove", this._onRemoveComponent, this);
    this.app.systems.on("postUpdate", this._onPostUpdate, this);
  }
  initializeComponentData(component, data2, properties3) {
    if (data2.enabled !== void 0) component.enabled = data2.enabled;
    if (data2.orientation !== void 0) component.orientation = data2.orientation;
    if (data2.reverseX !== void 0) component.reverseX = data2.reverseX;
    if (data2.reverseY !== void 0) component.reverseY = data2.reverseY;
    if (data2.alignment !== void 0) {
      component.alignment = Array.isArray(data2.alignment) ? new Vec2(data2.alignment) : data2.alignment;
    }
    if (data2.padding !== void 0) {
      component.padding = Array.isArray(data2.padding) ? new Vec4(data2.padding) : data2.padding;
    }
    if (data2.spacing !== void 0) {
      component.spacing = Array.isArray(data2.spacing) ? new Vec2(data2.spacing) : data2.spacing;
    }
    if (data2.widthFitting !== void 0) component.widthFitting = data2.widthFitting;
    if (data2.heightFitting !== void 0) component.heightFitting = data2.heightFitting;
    if (data2.wrap !== void 0) component.wrap = data2.wrap;
    super.initializeComponentData(component, data2, properties3);
  }
  cloneComponent(entity, clone) {
    const layoutGroup = entity.layoutgroup;
    return this.addComponent(clone, {
      enabled: layoutGroup.enabled,
      orientation: layoutGroup.orientation,
      reverseX: layoutGroup.reverseX,
      reverseY: layoutGroup.reverseY,
      alignment: layoutGroup.alignment,
      padding: layoutGroup.padding,
      spacing: layoutGroup.spacing,
      widthFitting: layoutGroup.widthFitting,
      heightFitting: layoutGroup.heightFitting,
      wrap: layoutGroup.wrap
    });
  }
  scheduleReflow(component) {
    if (this._reflowQueue.indexOf(component) === -1) {
      this._reflowQueue.push(component);
    }
  }
  _onPostUpdate() {
    this._processReflowQueue();
  }
  _processReflowQueue() {
    if (this._reflowQueue.length === 0) {
      return;
    }
    let iterationCount = 0;
    while (this._reflowQueue.length > 0) {
      const queue2 = this._reflowQueue.slice();
      this._reflowQueue.length = 0;
      queue2.sort((componentA, componentB) => {
        return componentA.entity.graphDepth - componentB.entity.graphDepth;
      });
      for (let i = 0; i < queue2.length; ++i) {
        queue2[i].reflow();
      }
      if (++iterationCount >= MAX_ITERATIONS) {
        console.warn("Max reflow iterations limit reached, bailing.");
        break;
      }
    }
  }
  _onRemoveComponent(entity, component) {
    component.onRemove();
  }
  destroy() {
    super.destroy();
    this.app.systems.off("postUpdate", this._onPostUpdate, this);
  }
};
Component._buildAccessors(LayoutGroupComponent.prototype, _schema9);

// ../node_modules/playcanvas/build/playcanvas/src/framework/graphics/primitive-cache.js
var PrimitivesCache = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  destroy(device) {
    this.map.forEach((primData) => primData.mesh.destroy());
  }
};
var _primitivesCache = new DeviceCache();
var getShapePrimitive = (device, type) => {
  const cache = _primitivesCache.get(device, () => {
    return new PrimitivesCache();
  });
  let primData = cache.map.get(type);
  if (!primData) {
    let mesh, area;
    switch (type) {
      case "box":
        mesh = Mesh.fromGeometry(device, new BoxGeometry());
        area = {
          x: 2,
          y: 2,
          z: 2,
          uv: 2 / 3
        };
        break;
      case "capsule":
        mesh = Mesh.fromGeometry(device, new CapsuleGeometry({
          radius: 0.5,
          height: 2
        }));
        area = {
          x: Math.PI * 2,
          y: Math.PI,
          z: Math.PI * 2,
          uv: 1 / 3 + 1 / 3 / 3 * 2
        };
        break;
      case "cone":
        mesh = Mesh.fromGeometry(device, new ConeGeometry({
          baseRadius: 0.5,
          peakRadius: 0,
          height: 1
        }));
        area = {
          x: 2.54,
          y: 2.54,
          z: 2.54,
          uv: 1 / 3 + 1 / 3 / 3
        };
        break;
      case "cylinder":
        mesh = Mesh.fromGeometry(device, new CylinderGeometry({
          radius: 0.5,
          height: 1
        }));
        area = {
          x: Math.PI,
          y: 0.79 * 2,
          z: Math.PI,
          uv: 1 / 3 + 1 / 3 / 3 * 2
        };
        break;
      case "plane":
        mesh = Mesh.fromGeometry(device, new PlaneGeometry({
          halfExtents: new Vec2(0.5, 0.5),
          widthSegments: 1,
          lengthSegments: 1
        }));
        area = {
          x: 0,
          y: 1,
          z: 0,
          uv: 1
        };
        break;
      case "sphere":
        mesh = Mesh.fromGeometry(device, new SphereGeometry({
          radius: 0.5
        }));
        area = {
          x: Math.PI,
          y: Math.PI,
          z: Math.PI,
          uv: 1
        };
        break;
      case "torus":
        mesh = Mesh.fromGeometry(device, new TorusGeometry({
          tubeRadius: 0.2,
          ringRadius: 0.3
        }));
        area = {
          x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,
          y: 0.4,
          z: 0.4,
          uv: 1
        };
        break;
      default:
        throw new Error(`Invalid primitive type: ${type}`);
    }
    mesh.incRefCount();
    primData = {
      mesh,
      area
    };
    cache.map.set(type, primData);
  }
  return primData;
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/model/component.js
var ModelComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._type = "asset";
    this._asset = null;
    this._model = null;
    this._mapping = {};
    this._castShadows = true;
    this._receiveShadows = true;
    this._materialAsset = null;
    this._material = void 0;
    this._castShadowsLightmap = true;
    this._lightmapped = false;
    this._lightmapSizeMultiplier = 1;
    this.isStatic = false;
    this._layers = [LAYERID_WORLD];
    this._batchGroupId = -1;
    this._customAabb = null;
    this._area = null;
    this._materialEvents = null;
    this._clonedModel = false;
    this._material = system.defaultMaterial;
    entity.on("remove", this.onRemoveChild, this);
    entity.on("removehierarchy", this.onRemoveChild, this);
    entity.on("insert", this.onInsertChild, this);
    entity.on("inserthierarchy", this.onInsertChild, this);
  }
  set meshInstances(value) {
    if (!this._model) {
      return;
    }
    this._model.meshInstances = value;
  }
  get meshInstances() {
    if (!this._model) {
      return null;
    }
    return this._model.meshInstances;
  }
  set customAabb(value) {
    this._customAabb = value;
    if (this._model) {
      const mi = this._model.meshInstances;
      if (mi) {
        for (let i = 0; i < mi.length; i++) {
          mi[i].setCustomAabb(this._customAabb);
        }
      }
    }
  }
  get customAabb() {
    return this._customAabb;
  }
  set type(value) {
    if (this._type === value) return;
    this._area = null;
    this._type = value;
    if (value === "asset") {
      if (this._asset !== null) {
        this._bindModelAsset(this._asset);
      } else {
        this.model = null;
      }
    } else {
      const primData = getShapePrimitive(this.system.app.graphicsDevice, value);
      this._area = primData.area;
      const mesh = primData.mesh;
      const node = new GraphNode();
      const model = new Model();
      model.graph = node;
      model.meshInstances = [new MeshInstance(mesh, this._material, node)];
      this.model = model;
      this._asset = null;
    }
  }
  get type() {
    return this._type;
  }
  set asset(value) {
    const assets = this.system.app.assets;
    let _id = value;
    if (value instanceof Asset) {
      _id = value.id;
    }
    if (this._asset !== _id) {
      if (this._asset) {
        assets.off(`add:${this._asset}`, this._onModelAssetAdded, this);
        const _prev = assets.get(this._asset);
        if (_prev) {
          this._unbindModelAsset(_prev);
        }
      }
      this._asset = _id;
      if (this._asset) {
        const asset = assets.get(this._asset);
        if (!asset) {
          this.model = null;
          assets.on(`add:${this._asset}`, this._onModelAssetAdded, this);
        } else {
          this._bindModelAsset(asset);
        }
      } else {
        this.model = null;
      }
    }
  }
  get asset() {
    return this._asset;
  }
  set model(value) {
    if (this._model === value) {
      return;
    }
    if (value && value._immutable) {
      return;
    }
    if (this._model) {
      this._model._immutable = false;
      this.removeModelFromLayers();
      this._model.getGraph().destroy();
      delete this._model._entity;
      if (this._clonedModel) {
        this._model.destroy();
        this._clonedModel = false;
      }
    }
    this._model = value;
    if (this._model) {
      this._model._immutable = true;
      const meshInstances = this._model.meshInstances;
      for (let i = 0; i < meshInstances.length; i++) {
        meshInstances[i].castShadow = this._castShadows;
        meshInstances[i].receiveShadow = this._receiveShadows;
        meshInstances[i].setCustomAabb(this._customAabb);
      }
      this.lightmapped = this._lightmapped;
      this.entity.addChild(this._model.graph);
      if (this.enabled && this.entity.enabled) {
        this.addModelToLayers();
      }
      this._model._entity = this.entity;
      if (this.entity.animation) {
        this.entity.animation.setModel(this._model);
      }
      if (this.entity.anim) {
        this.entity.anim.rebind();
      }
      if (this.type === "asset") {
        this.mapping = this._mapping;
      } else {
        this._unsetMaterialEvents();
      }
    }
  }
  get model() {
    return this._model;
  }
  set lightmapped(value) {
    if (value !== this._lightmapped) {
      this._lightmapped = value;
      if (this._model) {
        const mi = this._model.meshInstances;
        for (let i = 0; i < mi.length; i++) {
          mi[i].setLightmapped(value);
        }
      }
    }
  }
  get lightmapped() {
    return this._lightmapped;
  }
  set castShadows(value) {
    if (this._castShadows === value) return;
    const model = this._model;
    if (model) {
      const layers = this.layers;
      const scene = this.system.app.scene;
      if (this._castShadows && !value) {
        for (let i = 0; i < layers.length; i++) {
          const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
          if (!layer) continue;
          layer.removeShadowCasters(model.meshInstances);
        }
      }
      const meshInstances = model.meshInstances;
      for (let i = 0; i < meshInstances.length; i++) {
        meshInstances[i].castShadow = value;
      }
      if (!this._castShadows && value) {
        for (let i = 0; i < layers.length; i++) {
          const layer = scene.layers.getLayerById(layers[i]);
          if (!layer) continue;
          layer.addShadowCasters(model.meshInstances);
        }
      }
    }
    this._castShadows = value;
  }
  get castShadows() {
    return this._castShadows;
  }
  set receiveShadows(value) {
    if (this._receiveShadows === value) return;
    this._receiveShadows = value;
    if (this._model) {
      const meshInstances = this._model.meshInstances;
      for (let i = 0, len = meshInstances.length; i < len; i++) {
        meshInstances[i].receiveShadow = value;
      }
    }
  }
  get receiveShadows() {
    return this._receiveShadows;
  }
  set castShadowsLightmap(value) {
    this._castShadowsLightmap = value;
  }
  get castShadowsLightmap() {
    return this._castShadowsLightmap;
  }
  set lightmapSizeMultiplier(value) {
    this._lightmapSizeMultiplier = value;
  }
  get lightmapSizeMultiplier() {
    return this._lightmapSizeMultiplier;
  }
  set layers(value) {
    const layers = this.system.app.scene.layers;
    if (this.meshInstances) {
      for (let i = 0; i < this._layers.length; i++) {
        const layer = layers.getLayerById(this._layers[i]);
        if (!layer) continue;
        layer.removeMeshInstances(this.meshInstances);
      }
    }
    this._layers.length = 0;
    for (let i = 0; i < value.length; i++) {
      this._layers[i] = value[i];
    }
    if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;
    for (let i = 0; i < this._layers.length; i++) {
      const layer = layers.getLayerById(this._layers[i]);
      if (!layer) continue;
      layer.addMeshInstances(this.meshInstances);
    }
  }
  get layers() {
    return this._layers;
  }
  set batchGroupId(value) {
    if (this._batchGroupId === value) return;
    if (this.entity.enabled && this._batchGroupId >= 0) {
      var _this$system$app$batc;
      (_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
    }
    if (this.entity.enabled && value >= 0) {
      var _this$system$app$batc2;
      (_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.MODEL, value, this.entity);
    }
    if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
      this.addModelToLayers();
    }
    this._batchGroupId = value;
  }
  get batchGroupId() {
    return this._batchGroupId;
  }
  set materialAsset(value) {
    let _id = value;
    if (value instanceof Asset) {
      _id = value.id;
    }
    const assets = this.system.app.assets;
    if (_id !== this._materialAsset) {
      if (this._materialAsset) {
        assets.off(`add:${this._materialAsset}`, this._onMaterialAssetAdd, this);
        const _prev = assets.get(this._materialAsset);
        if (_prev) {
          this._unbindMaterialAsset(_prev);
        }
      }
      this._materialAsset = _id;
      if (this._materialAsset) {
        const asset = assets.get(this._materialAsset);
        if (!asset) {
          this._setMaterial(this.system.defaultMaterial);
          assets.on(`add:${this._materialAsset}`, this._onMaterialAssetAdd, this);
        } else {
          this._bindMaterialAsset(asset);
        }
      } else {
        this._setMaterial(this.system.defaultMaterial);
      }
    }
  }
  get materialAsset() {
    return this._materialAsset;
  }
  set material(value) {
    if (this._material === value) {
      return;
    }
    this.materialAsset = null;
    this._setMaterial(value);
  }
  get material() {
    return this._material;
  }
  set mapping(value) {
    if (this._type !== "asset") {
      return;
    }
    this._unsetMaterialEvents();
    if (!value) {
      value = {};
    }
    this._mapping = value;
    if (!this._model) return;
    const meshInstances = this._model.meshInstances;
    const modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
    const assetMapping = modelAsset ? modelAsset.data.mapping : null;
    let asset = null;
    for (let i = 0, len = meshInstances.length; i < len; i++) {
      if (value[i] !== void 0) {
        if (value[i]) {
          asset = this.system.app.assets.get(value[i]);
          this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
        } else {
          meshInstances[i].material = this.system.defaultMaterial;
        }
      } else if (assetMapping) {
        if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
          if (assetMapping[i].material !== void 0) {
            asset = this.system.app.assets.get(assetMapping[i].material);
          } else if (assetMapping[i].path !== void 0) {
            const url = this._getMaterialAssetUrl(assetMapping[i].path);
            if (url) {
              asset = this.system.app.assets.getByUrl(url);
            }
          }
          this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
        } else {
          meshInstances[i].material = this.system.defaultMaterial;
        }
      }
    }
  }
  get mapping() {
    return this._mapping;
  }
  addModelToLayers() {
    const layers = this.system.app.scene.layers;
    for (let i = 0; i < this._layers.length; i++) {
      const layer = layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.addMeshInstances(this.meshInstances);
      }
    }
  }
  removeModelFromLayers() {
    const layers = this.system.app.scene.layers;
    for (let i = 0; i < this._layers.length; i++) {
      const layer = layers.getLayerById(this._layers[i]);
      if (!layer) continue;
      layer.removeMeshInstances(this.meshInstances);
    }
  }
  onRemoveChild() {
    if (this._model) {
      this.removeModelFromLayers();
    }
  }
  onInsertChild() {
    if (this._model && this.enabled && this.entity.enabled) {
      this.addModelToLayers();
    }
  }
  onRemove() {
    this.asset = null;
    this.model = null;
    this.materialAsset = null;
    this._unsetMaterialEvents();
    this.entity.off("remove", this.onRemoveChild, this);
    this.entity.off("insert", this.onInsertChild, this);
  }
  onLayersChanged(oldComp, newComp) {
    this.addModelToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    layer.addMeshInstances(this.meshInstances);
  }
  onLayerRemoved(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    layer.removeMeshInstances(this.meshInstances);
  }
  _setMaterialEvent(index, event, id13, handler) {
    const evt = `${event}:${id13}`;
    this.system.app.assets.on(evt, handler, this);
    if (!this._materialEvents) {
      this._materialEvents = [];
    }
    if (!this._materialEvents[index]) {
      this._materialEvents[index] = {};
    }
    this._materialEvents[index][evt] = {
      id: id13,
      handler
    };
  }
  _unsetMaterialEvents() {
    const assets = this.system.app.assets;
    const events = this._materialEvents;
    if (!events) {
      return;
    }
    for (let i = 0, len = events.length; i < len; i++) {
      if (!events[i]) continue;
      const evt = events[i];
      for (const key in evt) {
        assets.off(key, evt[key].handler, this);
      }
    }
    this._materialEvents = null;
  }
  _getAssetByIdOrPath(idOrPath) {
    let asset = null;
    const isPath = isNaN(parseInt(idOrPath, 10));
    if (!isPath) {
      asset = this.system.app.assets.get(idOrPath);
    } else if (this.asset) {
      const url = this._getMaterialAssetUrl(idOrPath);
      if (url) {
        asset = this.system.app.assets.getByUrl(url);
      }
    }
    return asset;
  }
  _getMaterialAssetUrl(path2) {
    if (!this.asset) return null;
    const modelAsset = this.system.app.assets.get(this.asset);
    return modelAsset ? modelAsset.getAbsoluteUrl(path2) : null;
  }
  _loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {
    const assets = this.system.app.assets;
    if (!materialAsset) {
      return;
    }
    if (materialAsset.resource) {
      meshInstance.material = materialAsset.resource;
      this._setMaterialEvent(index, "remove", materialAsset.id, function() {
        meshInstance.material = this.system.defaultMaterial;
      });
    } else {
      this._setMaterialEvent(index, "load", materialAsset.id, function(asset) {
        meshInstance.material = asset.resource;
        this._setMaterialEvent(index, "remove", materialAsset.id, function() {
          meshInstance.material = this.system.defaultMaterial;
        });
      });
      if (this.enabled && this.entity.enabled) {
        assets.load(materialAsset);
      }
    }
  }
  onEnable() {
    const app2 = this.system.app;
    const scene = app2.scene;
    scene.on("set:layers", this.onLayersChanged, this);
    if (scene.layers) {
      scene.layers.on("add", this.onLayerAdded, this);
      scene.layers.on("remove", this.onLayerRemoved, this);
    }
    const isAsset = this._type === "asset";
    let asset;
    if (this._model) {
      this.addModelToLayers();
    } else if (isAsset && this._asset) {
      asset = app2.assets.get(this._asset);
      if (asset && asset.resource !== this._model) {
        this._bindModelAsset(asset);
      }
    }
    if (this._materialAsset) {
      asset = app2.assets.get(this._materialAsset);
      if (asset && asset.resource !== this._material) {
        this._bindMaterialAsset(asset);
      }
    }
    if (isAsset) {
      if (this._mapping) {
        for (const index in this._mapping) {
          if (this._mapping[index]) {
            asset = this._getAssetByIdOrPath(this._mapping[index]);
            if (asset && !asset.resource) {
              app2.assets.load(asset);
            }
          }
        }
      }
    }
    if (this._batchGroupId >= 0) {
      var _app$batcher;
      (_app$batcher = app2.batcher) == null || _app$batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
    }
  }
  onDisable() {
    const app2 = this.system.app;
    const scene = app2.scene;
    scene.off("set:layers", this.onLayersChanged, this);
    if (scene.layers) {
      scene.layers.off("add", this.onLayerAdded, this);
      scene.layers.off("remove", this.onLayerRemoved, this);
    }
    if (this._batchGroupId >= 0) {
      var _app$batcher2;
      (_app$batcher2 = app2.batcher) == null || _app$batcher2.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
    }
    if (this._model) {
      this.removeModelFromLayers();
    }
  }
  hide() {
    if (this._model) {
      const instances = this._model.meshInstances;
      for (let i = 0, l = instances.length; i < l; i++) {
        instances[i].visible = false;
      }
    }
  }
  show() {
    if (this._model) {
      const instances = this._model.meshInstances;
      for (let i = 0, l = instances.length; i < l; i++) {
        instances[i].visible = true;
      }
    }
  }
  _bindMaterialAsset(asset) {
    asset.on("load", this._onMaterialAssetLoad, this);
    asset.on("unload", this._onMaterialAssetUnload, this);
    asset.on("remove", this._onMaterialAssetRemove, this);
    asset.on("change", this._onMaterialAssetChange, this);
    if (asset.resource) {
      this._onMaterialAssetLoad(asset);
    } else {
      if (!this.enabled || !this.entity.enabled) return;
      this.system.app.assets.load(asset);
    }
  }
  _unbindMaterialAsset(asset) {
    asset.off("load", this._onMaterialAssetLoad, this);
    asset.off("unload", this._onMaterialAssetUnload, this);
    asset.off("remove", this._onMaterialAssetRemove, this);
    asset.off("change", this._onMaterialAssetChange, this);
  }
  _onMaterialAssetAdd(asset) {
    this.system.app.assets.off(`add:${asset.id}`, this._onMaterialAssetAdd, this);
    if (this._materialAsset === asset.id) {
      this._bindMaterialAsset(asset);
    }
  }
  _onMaterialAssetLoad(asset) {
    this._setMaterial(asset.resource);
  }
  _onMaterialAssetUnload(asset) {
    this._setMaterial(this.system.defaultMaterial);
  }
  _onMaterialAssetRemove(asset) {
    this._onMaterialAssetUnload(asset);
  }
  _onMaterialAssetChange(asset) {
  }
  _bindModelAsset(asset) {
    this._unbindModelAsset(asset);
    asset.on("load", this._onModelAssetLoad, this);
    asset.on("unload", this._onModelAssetUnload, this);
    asset.on("change", this._onModelAssetChange, this);
    asset.on("remove", this._onModelAssetRemove, this);
    if (asset.resource) {
      this._onModelAssetLoad(asset);
    } else {
      if (!this.enabled || !this.entity.enabled) return;
      this.system.app.assets.load(asset);
    }
  }
  _unbindModelAsset(asset) {
    asset.off("load", this._onModelAssetLoad, this);
    asset.off("unload", this._onModelAssetUnload, this);
    asset.off("change", this._onModelAssetChange, this);
    asset.off("remove", this._onModelAssetRemove, this);
  }
  _onModelAssetAdded(asset) {
    this.system.app.assets.off(`add:${asset.id}`, this._onModelAssetAdded, this);
    if (asset.id === this._asset) {
      this._bindModelAsset(asset);
    }
  }
  _onModelAssetLoad(asset) {
    this.model = asset.resource.clone();
    this._clonedModel = true;
  }
  _onModelAssetUnload(asset) {
    this.model = null;
  }
  _onModelAssetChange(asset, attr, _new, _old) {
    if (attr === "data") {
      this.mapping = this._mapping;
    }
  }
  _onModelAssetRemove(asset) {
    this.model = null;
  }
  _setMaterial(material) {
    if (this._material === material) {
      return;
    }
    this._material = material;
    const model = this._model;
    if (model && this._type !== "asset") {
      const meshInstances = model.meshInstances;
      for (let i = 0, len = meshInstances.length; i < len; i++) {
        meshInstances[i].material = material;
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/model/data.js
var ModelComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/model/system.js
var _schema10 = ["enabled"];
var ModelComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "model";
    this.ComponentType = ModelComponent;
    this.DataType = ModelComponentData;
    this.schema = _schema10;
    this.defaultMaterial = getDefaultMaterial(app2.graphicsDevice);
    this.on("beforeremove", this.onRemove, this);
  }
  initializeComponentData(component, _data, properties3) {
    properties3 = ["material", "materialAsset", "asset", "castShadows", "receiveShadows", "castShadowsLightmap", "lightmapped", "lightmapSizeMultiplier", "type", "mapping", "layers", "isStatic", "batchGroupId"];
    if (_data.batchGroupId === null || _data.batchGroupId === void 0) {
      _data.batchGroupId = -1;
    }
    if (_data.layers && _data.layers.length) {
      _data.layers = _data.layers.slice(0);
    }
    for (let i = 0; i < properties3.length; i++) {
      if (_data.hasOwnProperty(properties3[i])) {
        component[properties3[i]] = _data[properties3[i]];
      }
    }
    if (_data.aabbCenter && _data.aabbHalfExtents) {
      component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
    }
    super.initializeComponentData(component, _data, ["enabled"]);
  }
  cloneComponent(entity, clone) {
    const data2 = {
      type: entity.model.type,
      asset: entity.model.asset,
      castShadows: entity.model.castShadows,
      receiveShadows: entity.model.receiveShadows,
      castShadowsLightmap: entity.model.castShadowsLightmap,
      lightmapped: entity.model.lightmapped,
      lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
      isStatic: entity.model.isStatic,
      enabled: entity.model.enabled,
      layers: entity.model.layers,
      batchGroupId: entity.model.batchGroupId,
      mapping: extend({}, entity.model.mapping)
    };
    let materialAsset = entity.model.materialAsset;
    if (!(materialAsset instanceof Asset) && materialAsset != null) {
      materialAsset = this.app.assets.get(materialAsset);
    }
    const material = entity.model.material;
    if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {
      data2.materialAsset = materialAsset;
    }
    const component = this.addComponent(clone, data2);
    if (entity.model.model && entity.model.type === "asset" && !entity.model.asset) {
      component.model = entity.model.model.clone();
      component._clonedModel = true;
    }
    if (!data2.materialAsset) {
      component.material = material;
    }
    if (entity.model.model) {
      const meshInstances = entity.model.model.meshInstances;
      const meshInstancesClone = component.model.meshInstances;
      for (let i = 0; i < meshInstances.length; i++) {
        meshInstancesClone[i].mask = meshInstances[i].mask;
        meshInstancesClone[i].material = meshInstances[i].material;
        meshInstancesClone[i].layer = meshInstances[i].layer;
        meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
      }
    }
    if (entity.model.customAabb) {
      component.customAabb = entity.model.customAabb.clone();
    }
    return component;
  }
  onRemove(entity, component) {
    component.onRemove();
  }
};
Component._buildAccessors(ModelComponent.prototype, _schema10);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/particle-system/component.js
var SIMPLE_PROPERTIES = ["emitterExtents", "emitterRadius", "emitterExtentsInner", "emitterRadiusInner", "loop", "initialVelocity", "animSpeed", "normalMap", "particleNormal"];
var COMPLEX_PROPERTIES = ["numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "lighting", "halfLambert", "intensity", "wrap", "wrapBounds", "depthWrite", "noFog", "sort", "stretch", "alignToMotion", "preWarm", "emitterShape", "animTilesX", "animTilesY", "animStartFrame", "animNumFrames", "animNumAnimations", "animIndex", "randomizeAnimIndex", "animLoop", "colorMap", "localSpace", "screenSpace", "orientation"];
var GRAPH_PROPERTIES = ["scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "velocityGraph", "velocityGraph2", "localVelocityGraph", "localVelocityGraph2", "rotationSpeedGraph", "rotationSpeedGraph2", "radialSpeedGraph", "radialSpeedGraph2"];
var ASSET_PROPERTIES = ["colorMapAsset", "normalMapAsset", "meshAsset", "renderAsset"];
var depthLayer;
var ParticleSystemComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._requestedDepth = false;
    this._drawOrder = 0;
    this.on("set_colorMapAsset", this.onSetColorMapAsset, this);
    this.on("set_normalMapAsset", this.onSetNormalMapAsset, this);
    this.on("set_meshAsset", this.onSetMeshAsset, this);
    this.on("set_mesh", this.onSetMesh, this);
    this.on("set_renderAsset", this.onSetRenderAsset, this);
    this.on("set_loop", this.onSetLoop, this);
    this.on("set_blendType", this.onSetBlendType, this);
    this.on("set_depthSoftening", this.onSetDepthSoftening, this);
    this.on("set_layers", this.onSetLayers, this);
    SIMPLE_PROPERTIES.forEach((prop) => {
      this.on(`set_${prop}`, this.onSetSimpleProperty, this);
    });
    COMPLEX_PROPERTIES.forEach((prop) => {
      this.on(`set_${prop}`, this.onSetComplexProperty, this);
    });
    GRAPH_PROPERTIES.forEach((prop) => {
      this.on(`set_${prop}`, this.onSetGraphProperty, this);
    });
  }
  get data() {
    const record = this.system.store[this.entity.getGuid()];
    return record ? record.data : null;
  }
  set enabled(arg) {
    this._setValue("enabled", arg);
  }
  get enabled() {
    return this.data.enabled;
  }
  set autoPlay(arg) {
    this._setValue("autoPlay", arg);
  }
  get autoPlay() {
    return this.data.autoPlay;
  }
  set numParticles(arg) {
    this._setValue("numParticles", arg);
  }
  get numParticles() {
    return this.data.numParticles;
  }
  set lifetime(arg) {
    this._setValue("lifetime", arg);
  }
  get lifetime() {
    return this.data.lifetime;
  }
  set rate(arg) {
    this._setValue("rate", arg);
  }
  get rate() {
    return this.data.rate;
  }
  set rate2(arg) {
    this._setValue("rate2", arg);
  }
  get rate2() {
    return this.data.rate2;
  }
  set startAngle(arg) {
    this._setValue("startAngle", arg);
  }
  get startAngle() {
    return this.data.startAngle;
  }
  set startAngle2(arg) {
    this._setValue("startAngle2", arg);
  }
  get startAngle2() {
    return this.data.startAngle2;
  }
  set loop(arg) {
    this._setValue("loop", arg);
  }
  get loop() {
    return this.data.loop;
  }
  set preWarm(arg) {
    this._setValue("preWarm", arg);
  }
  get preWarm() {
    return this.data.preWarm;
  }
  set lighting(arg) {
    this._setValue("lighting", arg);
  }
  get lighting() {
    return this.data.lighting;
  }
  set halfLambert(arg) {
    this._setValue("halfLambert", arg);
  }
  get halfLambert() {
    return this.data.halfLambert;
  }
  set intensity(arg) {
    this._setValue("intensity", arg);
  }
  get intensity() {
    return this.data.intensity;
  }
  set depthWrite(arg) {
    this._setValue("depthWrite", arg);
  }
  get depthWrite() {
    return this.data.depthWrite;
  }
  set noFog(arg) {
    this._setValue("noFog", arg);
  }
  get noFog() {
    return this.data.noFog;
  }
  set depthSoftening(arg) {
    this._setValue("depthSoftening", arg);
  }
  get depthSoftening() {
    return this.data.depthSoftening;
  }
  set sort(arg) {
    this._setValue("sort", arg);
  }
  get sort() {
    return this.data.sort;
  }
  set blendType(arg) {
    this._setValue("blendType", arg);
  }
  get blendType() {
    return this.data.blendType;
  }
  set stretch(arg) {
    this._setValue("stretch", arg);
  }
  get stretch() {
    return this.data.stretch;
  }
  set alignToMotion(arg) {
    this._setValue("alignToMotion", arg);
  }
  get alignToMotion() {
    return this.data.alignToMotion;
  }
  set emitterShape(arg) {
    this._setValue("emitterShape", arg);
  }
  get emitterShape() {
    return this.data.emitterShape;
  }
  set emitterExtents(arg) {
    this._setValue("emitterExtents", arg);
  }
  get emitterExtents() {
    return this.data.emitterExtents;
  }
  set emitterExtentsInner(arg) {
    this._setValue("emitterExtentsInner", arg);
  }
  get emitterExtentsInner() {
    return this.data.emitterExtentsInner;
  }
  set emitterRadius(arg) {
    this._setValue("emitterRadius", arg);
  }
  get emitterRadius() {
    return this.data.emitterRadius;
  }
  set emitterRadiusInner(arg) {
    this._setValue("emitterRadiusInner", arg);
  }
  get emitterRadiusInner() {
    return this.data.emitterRadiusInner;
  }
  set initialVelocity(arg) {
    this._setValue("initialVelocity", arg);
  }
  get initialVelocity() {
    return this.data.initialVelocity;
  }
  set wrap(arg) {
    this._setValue("wrap", arg);
  }
  get wrap() {
    return this.data.wrap;
  }
  set wrapBounds(arg) {
    this._setValue("wrapBounds", arg);
  }
  get wrapBounds() {
    return this.data.wrapBounds;
  }
  set localSpace(arg) {
    this._setValue("localSpace", arg);
  }
  get localSpace() {
    return this.data.localSpace;
  }
  set screenSpace(arg) {
    this._setValue("screenSpace", arg);
  }
  get screenSpace() {
    return this.data.screenSpace;
  }
  set colorMapAsset(arg) {
    this._setValue("colorMapAsset", arg);
  }
  get colorMapAsset() {
    return this.data.colorMapAsset;
  }
  set normalMapAsset(arg) {
    this._setValue("normalMapAsset", arg);
  }
  get normalMapAsset() {
    return this.data.normalMapAsset;
  }
  set mesh(arg) {
    this._setValue("mesh", arg);
  }
  get mesh() {
    return this.data.mesh;
  }
  set meshAsset(arg) {
    this._setValue("meshAsset", arg);
  }
  get meshAsset() {
    return this.data.meshAsset;
  }
  set renderAsset(arg) {
    this._setValue("renderAsset", arg);
  }
  get renderAsset() {
    return this.data.renderAsset;
  }
  set orientation(arg) {
    this._setValue("orientation", arg);
  }
  get orientation() {
    return this.data.orientation;
  }
  set particleNormal(arg) {
    this._setValue("particleNormal", arg);
  }
  get particleNormal() {
    return this.data.particleNormal;
  }
  set localVelocityGraph(arg) {
    this._setValue("localVelocityGraph", arg);
  }
  get localVelocityGraph() {
    return this.data.localVelocityGraph;
  }
  set localVelocityGraph2(arg) {
    this._setValue("localVelocityGraph2", arg);
  }
  get localVelocityGraph2() {
    return this.data.localVelocityGraph2;
  }
  set velocityGraph(arg) {
    this._setValue("velocityGraph", arg);
  }
  get velocityGraph() {
    return this.data.velocityGraph;
  }
  set velocityGraph2(arg) {
    this._setValue("velocityGraph2", arg);
  }
  get velocityGraph2() {
    return this.data.velocityGraph2;
  }
  set rotationSpeedGraph(arg) {
    this._setValue("rotationSpeedGraph", arg);
  }
  get rotationSpeedGraph() {
    return this.data.rotationSpeedGraph;
  }
  set rotationSpeedGraph2(arg) {
    this._setValue("rotationSpeedGraph2", arg);
  }
  get rotationSpeedGraph2() {
    return this.data.rotationSpeedGraph2;
  }
  set radialSpeedGraph(arg) {
    this._setValue("radialSpeedGraph", arg);
  }
  get radialSpeedGraph() {
    return this.data.radialSpeedGraph;
  }
  set radialSpeedGraph2(arg) {
    this._setValue("radialSpeedGraph2", arg);
  }
  get radialSpeedGraph2() {
    return this.data.radialSpeedGraph2;
  }
  set scaleGraph(arg) {
    this._setValue("scaleGraph", arg);
  }
  get scaleGraph() {
    return this.data.scaleGraph;
  }
  set scaleGraph2(arg) {
    this._setValue("scaleGraph2", arg);
  }
  get scaleGraph2() {
    return this.data.scaleGraph2;
  }
  set colorGraph(arg) {
    this._setValue("colorGraph", arg);
  }
  get colorGraph() {
    return this.data.colorGraph;
  }
  set colorGraph2(arg) {
    this._setValue("colorGraph2", arg);
  }
  get colorGraph2() {
    return this.data.colorGraph2;
  }
  set alphaGraph(arg) {
    this._setValue("alphaGraph", arg);
  }
  get alphaGraph() {
    return this.data.alphaGraph;
  }
  set alphaGraph2(arg) {
    this._setValue("alphaGraph2", arg);
  }
  get alphaGraph2() {
    return this.data.alphaGraph2;
  }
  set colorMap(arg) {
    this._setValue("colorMap", arg);
  }
  get colorMap() {
    return this.data.colorMap;
  }
  set normalMap(arg) {
    this._setValue("normalMap", arg);
  }
  get normalMap() {
    return this.data.normalMap;
  }
  set animTilesX(arg) {
    this._setValue("animTilesX", arg);
  }
  get animTilesX() {
    return this.data.animTilesX;
  }
  set animTilesY(arg) {
    this._setValue("animTilesY", arg);
  }
  get animTilesY() {
    return this.data.animTilesY;
  }
  set animStartFrame(arg) {
    this._setValue("animStartFrame", arg);
  }
  get animStartFrame() {
    return this.data.animStartFrame;
  }
  set animNumFrames(arg) {
    this._setValue("animNumFrames", arg);
  }
  get animNumFrames() {
    return this.data.animNumFrames;
  }
  set animNumAnimations(arg) {
    this._setValue("animNumAnimations", arg);
  }
  get animNumAnimations() {
    return this.data.animNumAnimations;
  }
  set animIndex(arg) {
    this._setValue("animIndex", arg);
  }
  get animIndex() {
    return this.data.animIndex;
  }
  set randomizeAnimIndex(arg) {
    this._setValue("randomizeAnimIndex", arg);
  }
  get randomizeAnimIndex() {
    return this.data.randomizeAnimIndex;
  }
  set animSpeed(arg) {
    this._setValue("animSpeed", arg);
  }
  get animSpeed() {
    return this.data.animSpeed;
  }
  set animLoop(arg) {
    this._setValue("animLoop", arg);
  }
  get animLoop() {
    return this.data.animLoop;
  }
  set layers(arg) {
    this._setValue("layers", arg);
  }
  get layers() {
    return this.data.layers;
  }
  set drawOrder(drawOrder) {
    this._drawOrder = drawOrder;
    if (this.emitter) {
      this.emitter.drawOrder = drawOrder;
    }
  }
  get drawOrder() {
    return this._drawOrder;
  }
  _setValue(name, value) {
    const data2 = this.data;
    const oldValue = data2[name];
    data2[name] = value;
    this.fire("set", name, oldValue, value);
  }
  addMeshInstanceToLayers() {
    if (!this.emitter) return;
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) continue;
      layer.addMeshInstances([this.emitter.meshInstance]);
      this.emitter._layer = layer;
    }
  }
  removeMeshInstanceFromLayers() {
    if (!this.emitter) return;
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) continue;
      layer.removeMeshInstances([this.emitter.meshInstance]);
    }
  }
  onSetLayers(name, oldValue, newValue) {
    if (!this.emitter) return;
    for (let i = 0; i < oldValue.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
      if (!layer) continue;
      layer.removeMeshInstances([this.emitter.meshInstance]);
    }
    if (!this.enabled || !this.entity.enabled) return;
    for (let i = 0; i < newValue.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(newValue[i]);
      if (!layer) continue;
      layer.addMeshInstances([this.emitter.meshInstance]);
    }
  }
  onLayersChanged(oldComp, newComp) {
    this.addMeshInstanceToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(layer) {
    if (!this.emitter) return;
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    layer.addMeshInstances([this.emitter.meshInstance]);
  }
  onLayerRemoved(layer) {
    if (!this.emitter) return;
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    layer.removeMeshInstances([this.emitter.meshInstance]);
  }
  _bindColorMapAsset(asset) {
    asset.on("load", this._onColorMapAssetLoad, this);
    asset.on("unload", this._onColorMapAssetUnload, this);
    asset.on("remove", this._onColorMapAssetRemove, this);
    asset.on("change", this._onColorMapAssetChange, this);
    if (asset.resource) {
      this._onColorMapAssetLoad(asset);
    } else {
      if (!this.enabled || !this.entity.enabled) return;
      this.system.app.assets.load(asset);
    }
  }
  _unbindColorMapAsset(asset) {
    asset.off("load", this._onColorMapAssetLoad, this);
    asset.off("unload", this._onColorMapAssetUnload, this);
    asset.off("remove", this._onColorMapAssetRemove, this);
    asset.off("change", this._onColorMapAssetChange, this);
  }
  _onColorMapAssetLoad(asset) {
    this.colorMap = asset.resource;
  }
  _onColorMapAssetUnload(asset) {
    this.colorMap = null;
  }
  _onColorMapAssetRemove(asset) {
    this._onColorMapAssetUnload(asset);
  }
  _onColorMapAssetChange(asset) {
  }
  onSetColorMapAsset(name, oldValue, newValue) {
    const assets = this.system.app.assets;
    if (oldValue) {
      const asset = assets.get(oldValue);
      if (asset) {
        this._unbindColorMapAsset(asset);
      }
    }
    if (newValue) {
      if (newValue instanceof Asset) {
        this.data.colorMapAsset = newValue.id;
        newValue = newValue.id;
      }
      const asset = assets.get(newValue);
      if (asset) {
        this._bindColorMapAsset(asset);
      } else {
        assets.once(`add:${newValue}`, (asset2) => {
          this._bindColorMapAsset(asset2);
        });
      }
    } else {
      this.colorMap = null;
    }
  }
  _bindNormalMapAsset(asset) {
    asset.on("load", this._onNormalMapAssetLoad, this);
    asset.on("unload", this._onNormalMapAssetUnload, this);
    asset.on("remove", this._onNormalMapAssetRemove, this);
    asset.on("change", this._onNormalMapAssetChange, this);
    if (asset.resource) {
      this._onNormalMapAssetLoad(asset);
    } else {
      if (!this.enabled || !this.entity.enabled) return;
      this.system.app.assets.load(asset);
    }
  }
  _unbindNormalMapAsset(asset) {
    asset.off("load", this._onNormalMapAssetLoad, this);
    asset.off("unload", this._onNormalMapAssetUnload, this);
    asset.off("remove", this._onNormalMapAssetRemove, this);
    asset.off("change", this._onNormalMapAssetChange, this);
  }
  _onNormalMapAssetLoad(asset) {
    this.normalMap = asset.resource;
  }
  _onNormalMapAssetUnload(asset) {
    this.normalMap = null;
  }
  _onNormalMapAssetRemove(asset) {
    this._onNormalMapAssetUnload(asset);
  }
  _onNormalMapAssetChange(asset) {
  }
  onSetNormalMapAsset(name, oldValue, newValue) {
    const assets = this.system.app.assets;
    if (oldValue) {
      const asset = assets.get(oldValue);
      if (asset) {
        this._unbindNormalMapAsset(asset);
      }
    }
    if (newValue) {
      if (newValue instanceof Asset) {
        this.data.normalMapAsset = newValue.id;
        newValue = newValue.id;
      }
      const asset = assets.get(newValue);
      if (asset) {
        this._bindNormalMapAsset(asset);
      } else {
        assets.once(`add:${newValue}`, (asset2) => {
          this._bindNormalMapAsset(asset2);
        });
      }
    } else {
      this.normalMap = null;
    }
  }
  _bindMeshAsset(asset) {
    asset.on("load", this._onMeshAssetLoad, this);
    asset.on("unload", this._onMeshAssetUnload, this);
    asset.on("remove", this._onMeshAssetRemove, this);
    asset.on("change", this._onMeshAssetChange, this);
    if (asset.resource) {
      this._onMeshAssetLoad(asset);
    } else {
      if (!this.enabled || !this.entity.enabled) return;
      this.system.app.assets.load(asset);
    }
  }
  _unbindMeshAsset(asset) {
    asset.off("load", this._onMeshAssetLoad, this);
    asset.off("unload", this._onMeshAssetUnload, this);
    asset.off("remove", this._onMeshAssetRemove, this);
    asset.off("change", this._onMeshAssetChange, this);
  }
  _onMeshAssetLoad(asset) {
    this._onMeshChanged(asset.resource);
  }
  _onMeshAssetUnload(asset) {
    this.mesh = null;
  }
  _onMeshAssetRemove(asset) {
    this._onMeshAssetUnload(asset);
  }
  _onMeshAssetChange(asset) {
  }
  onSetMeshAsset(name, oldValue, newValue) {
    const assets = this.system.app.assets;
    if (oldValue) {
      const asset = assets.get(oldValue);
      if (asset) {
        this._unbindMeshAsset(asset);
      }
    }
    if (newValue) {
      if (newValue instanceof Asset) {
        this.data.meshAsset = newValue.id;
        newValue = newValue.id;
      }
      const asset = assets.get(newValue);
      if (asset) {
        this._bindMeshAsset(asset);
      }
    } else {
      this._onMeshChanged(null);
    }
  }
  onSetMesh(name, oldValue, newValue) {
    if (!newValue || newValue instanceof Asset || typeof newValue === "number") {
      this.meshAsset = newValue;
    } else {
      this._onMeshChanged(newValue);
    }
  }
  _onMeshChanged(mesh) {
    if (mesh && !(mesh instanceof Mesh)) {
      if (mesh.meshInstances[0]) {
        mesh = mesh.meshInstances[0].mesh;
      } else {
        mesh = null;
      }
    }
    this.data.mesh = mesh;
    if (this.emitter) {
      this.emitter.mesh = mesh;
      this.emitter.resetMaterial();
      this.rebuild();
    }
  }
  onSetRenderAsset(name, oldValue, newValue) {
    const assets = this.system.app.assets;
    if (oldValue) {
      const asset = assets.get(oldValue);
      if (asset) {
        this._unbindRenderAsset(asset);
      }
    }
    if (newValue) {
      if (newValue instanceof Asset) {
        this.data.renderAsset = newValue.id;
        newValue = newValue.id;
      }
      const asset = assets.get(newValue);
      if (asset) {
        this._bindRenderAsset(asset);
      }
    } else {
      this._onRenderChanged(null);
    }
  }
  _bindRenderAsset(asset) {
    asset.on("load", this._onRenderAssetLoad, this);
    asset.on("unload", this._onRenderAssetUnload, this);
    asset.on("remove", this._onRenderAssetRemove, this);
    if (asset.resource) {
      this._onRenderAssetLoad(asset);
    } else {
      if (!this.enabled || !this.entity.enabled) return;
      this.system.app.assets.load(asset);
    }
  }
  _unbindRenderAsset(asset) {
    asset.off("load", this._onRenderAssetLoad, this);
    asset.off("unload", this._onRenderAssetUnload, this);
    asset.off("remove", this._onRenderAssetRemove, this);
    if (asset.resource) {
      asset.resource.off("set:meshes", this._onRenderSetMeshes, this);
    }
  }
  _onRenderAssetLoad(asset) {
    this._onRenderChanged(asset.resource);
  }
  _onRenderAssetUnload(asset) {
    this._onRenderChanged(null);
  }
  _onRenderAssetRemove(asset) {
    this._onRenderAssetUnload(asset);
  }
  _onRenderChanged(render) {
    if (!render) {
      this._onMeshChanged(null);
      return;
    }
    render.off("set:meshes", this._onRenderSetMeshes, this);
    render.on("set:meshes", this._onRenderSetMeshes, this);
    if (render.meshes) {
      this._onRenderSetMeshes(render.meshes);
    }
  }
  _onRenderSetMeshes(meshes) {
    this._onMeshChanged(meshes && meshes[0]);
  }
  onSetLoop(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.resetTime();
    }
  }
  onSetBlendType(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.material.blendType = newValue;
      this.emitter.resetMaterial();
      this.rebuild();
    }
  }
  _requestDepth() {
    if (this._requestedDepth) return;
    if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
    if (depthLayer) {
      depthLayer.incrementCounter();
      this._requestedDepth = true;
    }
  }
  _releaseDepth() {
    if (!this._requestedDepth) return;
    if (depthLayer) {
      depthLayer.decrementCounter();
      this._requestedDepth = false;
    }
  }
  onSetDepthSoftening(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (newValue) {
        if (this.enabled && this.entity.enabled) this._requestDepth();
        if (this.emitter) this.emitter[name] = newValue;
      } else {
        if (this.enabled && this.entity.enabled) this._releaseDepth();
        if (this.emitter) this.emitter[name] = newValue;
      }
      if (this.emitter) {
        this.reset();
        this.emitter.resetMaterial();
        this.rebuild();
      }
    }
  }
  onSetSimpleProperty(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.resetMaterial();
    }
  }
  onSetComplexProperty(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.resetMaterial();
      this.rebuild();
      this.reset();
    }
  }
  onSetGraphProperty(name, oldValue, newValue) {
    if (this.emitter) {
      this.emitter[name] = newValue;
      this.emitter.rebuildGraphs();
      this.emitter.resetMaterial();
    }
  }
  onEnable() {
    const data2 = this.data;
    for (let i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
      let asset = data2[ASSET_PROPERTIES[i]];
      if (asset) {
        if (!(asset instanceof Asset)) {
          const id13 = parseInt(asset, 10);
          if (id13 >= 0) {
            asset = this.system.app.assets.get(asset);
          } else {
            continue;
          }
        }
        if (asset && !asset.resource) {
          this.system.app.assets.load(asset);
        }
      }
    }
    if (this.system.app.graphicsDevice.disableParticleSystem) {
      return;
    }
    if (!this.emitter) {
      let mesh = data2.mesh;
      if (!(mesh instanceof Mesh)) {
        mesh = null;
      }
      this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
        numParticles: data2.numParticles,
        emitterExtents: data2.emitterExtents,
        emitterExtentsInner: data2.emitterExtentsInner,
        emitterRadius: data2.emitterRadius,
        emitterRadiusInner: data2.emitterRadiusInner,
        emitterShape: data2.emitterShape,
        initialVelocity: data2.initialVelocity,
        wrap: data2.wrap,
        localSpace: data2.localSpace,
        screenSpace: data2.screenSpace,
        wrapBounds: data2.wrapBounds,
        lifetime: data2.lifetime,
        rate: data2.rate,
        rate2: data2.rate2,
        orientation: data2.orientation,
        particleNormal: data2.particleNormal,
        animTilesX: data2.animTilesX,
        animTilesY: data2.animTilesY,
        animStartFrame: data2.animStartFrame,
        animNumFrames: data2.animNumFrames,
        animNumAnimations: data2.animNumAnimations,
        animIndex: data2.animIndex,
        randomizeAnimIndex: data2.randomizeAnimIndex,
        animSpeed: data2.animSpeed,
        animLoop: data2.animLoop,
        startAngle: data2.startAngle,
        startAngle2: data2.startAngle2,
        scaleGraph: data2.scaleGraph,
        scaleGraph2: data2.scaleGraph2,
        colorGraph: data2.colorGraph,
        colorGraph2: data2.colorGraph2,
        alphaGraph: data2.alphaGraph,
        alphaGraph2: data2.alphaGraph2,
        localVelocityGraph: data2.localVelocityGraph,
        localVelocityGraph2: data2.localVelocityGraph2,
        velocityGraph: data2.velocityGraph,
        velocityGraph2: data2.velocityGraph2,
        rotationSpeedGraph: data2.rotationSpeedGraph,
        rotationSpeedGraph2: data2.rotationSpeedGraph2,
        radialSpeedGraph: data2.radialSpeedGraph,
        radialSpeedGraph2: data2.radialSpeedGraph2,
        colorMap: data2.colorMap,
        normalMap: data2.normalMap,
        loop: data2.loop,
        preWarm: data2.preWarm,
        sort: data2.sort,
        stretch: data2.stretch,
        alignToMotion: data2.alignToMotion,
        lighting: data2.lighting,
        halfLambert: data2.halfLambert,
        intensity: data2.intensity,
        depthSoftening: data2.depthSoftening,
        scene: this.system.app.scene,
        mesh,
        depthWrite: data2.depthWrite,
        noFog: data2.noFog,
        node: this.entity,
        blendType: data2.blendType
      });
      this.emitter.meshInstance.node = this.entity;
      this.emitter.drawOrder = this.drawOrder;
      if (!data2.autoPlay) {
        this.pause();
        this.emitter.meshInstance.visible = false;
      }
    }
    if (this.emitter.colorMap) {
      this.addMeshInstanceToLayers();
    }
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this.enabled && this.entity.enabled && data2.depthSoftening) {
      this._requestDepth();
    }
  }
  onDisable() {
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    if (this.emitter) {
      this.removeMeshInstanceFromLayers();
      if (this.data.depthSoftening) this._releaseDepth();
      this.emitter.camera = null;
    }
  }
  onBeforeRemove() {
    if (this.enabled) {
      this.enabled = false;
    }
    if (this.emitter) {
      this.emitter.destroy();
      this.emitter = null;
    }
    for (let i = 0; i < ASSET_PROPERTIES.length; i++) {
      const prop = ASSET_PROPERTIES[i];
      if (this.data[prop]) {
        this[prop] = null;
      }
    }
    this.off();
  }
  reset() {
    if (this.emitter) {
      this.emitter.reset();
    }
  }
  stop() {
    if (this.emitter) {
      this.emitter.loop = false;
      this.emitter.resetTime();
      this.emitter.addTime(0, true);
    }
  }
  pause() {
    this.data.paused = true;
  }
  unpause() {
    this.data.paused = false;
  }
  play() {
    this.data.paused = false;
    if (this.emitter) {
      this.emitter.meshInstance.visible = true;
      this.emitter.loop = this.data.loop;
      this.emitter.resetTime();
    }
  }
  isPlaying() {
    if (this.data.paused) {
      return false;
    }
    if (this.emitter && this.emitter.loop) {
      return true;
    }
    return Date.now() <= this.emitter.endTime;
  }
  setInTools() {
    const {
      emitter
    } = this;
    if (emitter && !emitter.inTools) {
      emitter.inTools = true;
      this.rebuild();
    }
  }
  rebuild() {
    const enabled = this.enabled;
    this.enabled = false;
    if (this.emitter) {
      this.emitter.rebuild();
    }
    this.enabled = enabled;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/particle-system/data.js
var ParticleSystemComponentData = class {
  constructor() {
    this.numParticles = 1;
    this.rate = 1;
    this.rate2 = null;
    this.startAngle = 0;
    this.startAngle2 = null;
    this.lifetime = 50;
    this.emitterExtents = new Vec3();
    this.emitterExtentsInner = new Vec3();
    this.emitterRadius = 0;
    this.emitterRadiusInner = 0;
    this.emitterShape = EMITTERSHAPE_BOX;
    this.initialVelocity = 0;
    this.wrap = false;
    this.wrapBounds = new Vec3();
    this.localSpace = false;
    this.screenSpace = false;
    this.colorMap = null;
    this.colorMapAsset = null;
    this.normalMap = null;
    this.normalMapAsset = null;
    this.loop = true;
    this.preWarm = false;
    this.sort = 0;
    this.mode = PARTICLEMODE_GPU;
    this.scene = null;
    this.lighting = false;
    this.halfLambert = false;
    this.intensity = 1;
    this.stretch = 0;
    this.alignToMotion = false;
    this.depthSoftening = 0;
    this.renderAsset = null;
    this.meshAsset = null;
    this.mesh = null;
    this.depthWrite = false;
    this.noFog = false;
    this.orientation = PARTICLEORIENTATION_SCREEN;
    this.particleNormal = new Vec3(0, 1, 0);
    this.animTilesX = 1;
    this.animTilesY = 1;
    this.animStartFrame = 0;
    this.animNumFrames = 1;
    this.animNumAnimations = 1;
    this.animIndex = 0;
    this.randomizeAnimIndex = false;
    this.animSpeed = 1;
    this.animLoop = true;
    this.scaleGraph = null;
    this.scaleGraph2 = null;
    this.colorGraph = null;
    this.colorGraph2 = null;
    this.alphaGraph = null;
    this.alphaGraph2 = null;
    this.localVelocityGraph = null;
    this.localVelocityGraph2 = null;
    this.velocityGraph = null;
    this.velocityGraph2 = null;
    this.rotationSpeedGraph = null;
    this.rotationSpeedGraph2 = null;
    this.radialSpeedGraph = null;
    this.radialSpeedGraph2 = null;
    this.blendType = BLEND_NORMAL;
    this.enabled = true;
    this.paused = false;
    this.autoPlay = true;
    this.layers = [LAYERID_WORLD];
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/particle-system/system.js
var _schema11 = ["enabled", "autoPlay", "numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "loop", "preWarm", "lighting", "halfLambert", "intensity", "depthWrite", "noFog", "depthSoftening", "sort", "blendType", "stretch", "alignToMotion", "emitterShape", "emitterExtents", "emitterExtentsInner", "emitterRadius", "emitterRadiusInner", "initialVelocity", "wrap", "wrapBounds", "localSpace", "screenSpace", "colorMapAsset", "normalMapAsset", "mesh", "meshAsset", "renderAsset", "orientation", "particleNormal", "localVelocityGraph", "localVelocityGraph2", "velocityGraph", "velocityGraph2", "rotationSpeedGraph", "rotationSpeedGraph2", "radialSpeedGraph", "radialSpeedGraph2", "scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "colorMap", "normalMap", "animTilesX", "animTilesY", "animStartFrame", "animNumFrames", "animNumAnimations", "animIndex", "randomizeAnimIndex", "animSpeed", "animLoop", "layers"];
var ParticleSystemComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "particlesystem";
    this.ComponentType = ParticleSystemComponent;
    this.DataType = ParticleSystemComponentData;
    this.schema = _schema11;
    this.propertyTypes = {
      emitterExtents: "vec3",
      emitterExtentsInner: "vec3",
      particleNormal: "vec3",
      wrapBounds: "vec3",
      localVelocityGraph: "curveset",
      localVelocityGraph2: "curveset",
      velocityGraph: "curveset",
      velocityGraph2: "curveset",
      colorGraph: "curveset",
      colorGraph2: "curveset",
      alphaGraph: "curve",
      alphaGraph2: "curve",
      rotationSpeedGraph: "curve",
      rotationSpeedGraph2: "curve",
      radialSpeedGraph: "curve",
      radialSpeedGraph2: "curve",
      scaleGraph: "curve",
      scaleGraph2: "curve"
    };
    this.on("beforeremove", this.onBeforeRemove, this);
    this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(component, _data, properties3) {
    const data2 = {};
    properties3 = [];
    const types = this.propertyTypes;
    if (_data.mesh instanceof Asset || typeof _data.mesh === "number") {
      _data.meshAsset = _data.mesh;
      delete _data.mesh;
    }
    for (const prop in _data) {
      if (_data.hasOwnProperty(prop)) {
        properties3.push(prop);
        data2[prop] = _data[prop];
      }
      if (types[prop] === "vec3") {
        if (Array.isArray(data2[prop])) {
          data2[prop] = new Vec3(data2[prop][0], data2[prop][1], data2[prop][2]);
        }
      } else if (types[prop] === "curve") {
        if (!(data2[prop] instanceof Curve)) {
          const t = data2[prop].type;
          data2[prop] = new Curve(data2[prop].keys);
          data2[prop].type = t;
        }
      } else if (types[prop] === "curveset") {
        if (!(data2[prop] instanceof CurveSet)) {
          const t = data2[prop].type;
          data2[prop] = new CurveSet(data2[prop].keys);
          data2[prop].type = t;
        }
      }
      if (data2.layers && Array.isArray(data2.layers)) {
        data2.layers = data2.layers.slice(0);
      }
    }
    super.initializeComponentData(component, data2, properties3);
  }
  cloneComponent(entity, clone) {
    const source = entity.particlesystem.data;
    const schema = this.schema;
    const data2 = {};
    for (let i = 0, len = schema.length; i < len; i++) {
      const prop = schema[i];
      let sourceProp = source[prop];
      if (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {
        sourceProp = sourceProp.clone();
        data2[prop] = sourceProp;
      } else if (prop === "layers") {
        data2.layers = source.layers.slice(0);
      } else {
        if (sourceProp !== null && sourceProp !== void 0) {
          data2[prop] = sourceProp;
        }
      }
    }
    return this.addComponent(clone, data2);
  }
  onUpdate(dt) {
    const components2 = this.store;
    let numSteps;
    const stats = this.app.stats.particles;
    const composition = this.app.scene.layers;
    for (let i = 0; i < composition.layerList.length; i++) {
      composition.layerList[i].requiresLightCube = false;
    }
    for (const id13 in components2) {
      if (components2.hasOwnProperty(id13)) {
        const component = components2[id13];
        const entity = component.entity;
        const data2 = component.data;
        if (data2.enabled && entity.enabled) {
          const emitter = entity.particlesystem.emitter;
          if (!(emitter != null && emitter.meshInstance.visible)) continue;
          if (emitter.lighting) {
            const layers = data2.layers;
            for (let i = 0; i < layers.length; i++) {
              const layer = composition.getLayerById(layers[i]);
              if (layer) {
                layer.requiresLightCube = true;
              }
            }
          }
          if (!data2.paused) {
            emitter.simTime += dt;
            if (emitter.simTime > emitter.fixedTimeStep) {
              numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
              emitter.simTime -= numSteps * emitter.fixedTimeStep;
            }
            if (numSteps) {
              numSteps = Math.min(numSteps, emitter.maxSubSteps);
              for (let i = 0; i < numSteps; i++) {
                emitter.addTime(emitter.fixedTimeStep, false);
              }
              stats._updatesPerFrame += numSteps;
              stats._frameTime += emitter._addTimeTime;
              emitter._addTimeTime = 0;
            }
            emitter.finishFrame();
          }
        }
      }
    }
  }
  onBeforeRemove(entity, component) {
    component.onBeforeRemove();
  }
  destroy() {
    super.destroy();
    this.app.systems.off("update", this.onUpdate, this);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/skin-instance-cache.js
var SkinInstanceCachedObject = class extends RefCountedObject {
  constructor(skin, skinInstance) {
    super();
    this.skin = skin;
    this.skinInstance = skinInstance;
  }
};
var SkinInstanceCache = class _SkinInstanceCache {
  static createCachedSkinInstance(skin, rootBone, entity) {
    let skinInst = _SkinInstanceCache.getCachedSkinInstance(skin, rootBone);
    if (!skinInst) {
      skinInst = new SkinInstance(skin);
      skinInst.resolve(rootBone, entity);
      _SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);
    }
    return skinInst;
  }
  static getCachedSkinInstance(skin, rootBone) {
    let skinInstance = null;
    const cachedObjArray = _SkinInstanceCache._skinInstanceCache.get(rootBone);
    if (cachedObjArray) {
      const cachedObj = cachedObjArray.find((element) => element.skin === skin);
      if (cachedObj) {
        cachedObj.incRefCount();
        skinInstance = cachedObj.skinInstance;
      }
    }
    return skinInstance;
  }
  static addCachedSkinInstance(skin, rootBone, skinInstance) {
    let cachedObjArray = _SkinInstanceCache._skinInstanceCache.get(rootBone);
    if (!cachedObjArray) {
      cachedObjArray = [];
      _SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);
    }
    let cachedObj = cachedObjArray.find((element) => element.skin === skin);
    if (!cachedObj) {
      cachedObj = new SkinInstanceCachedObject(skin, skinInstance);
      cachedObjArray.push(cachedObj);
    }
    cachedObj.incRefCount();
  }
  static removeCachedSkinInstance(skinInstance) {
    if (skinInstance) {
      const rootBone = skinInstance.rootBone;
      if (rootBone) {
        const cachedObjArray = _SkinInstanceCache._skinInstanceCache.get(rootBone);
        if (cachedObjArray) {
          const cachedObjIndex = cachedObjArray.findIndex((element) => element.skinInstance === skinInstance);
          if (cachedObjIndex >= 0) {
            const cachedObj = cachedObjArray[cachedObjIndex];
            cachedObj.decRefCount();
            if (cachedObj.refCount === 0) {
              cachedObjArray.splice(cachedObjIndex, 1);
              if (!cachedObjArray.length) {
                _SkinInstanceCache._skinInstanceCache.delete(rootBone);
              }
              if (skinInstance) {
                skinInstance.destroy();
                cachedObj.skinInstance = null;
              }
            }
          }
        }
      }
    }
  }
};
SkinInstanceCache._skinInstanceCache = /* @__PURE__ */ new Map();

// ../node_modules/playcanvas/build/playcanvas/src/framework/asset/asset-reference.js
var AssetReference = class {
  constructor(propertyName, parent, registry, callbacks, scope) {
    this.propertyName = propertyName;
    this.parent = parent;
    this._scope = scope;
    this._registry = registry;
    this.id = null;
    this.url = null;
    this.asset = null;
    this._onAssetLoad = callbacks.load;
    this._onAssetAdd = callbacks.add;
    this._onAssetRemove = callbacks.remove;
    this._onAssetUnload = callbacks.unload;
  }
  set id(value) {
    if (this.url) throw Error("Can't set id and url");
    this._unbind();
    this._id = value;
    this.asset = this._registry.get(this._id);
    this._bind();
  }
  get id() {
    return this._id;
  }
  set url(value) {
    if (this.id) throw Error("Can't set id and url");
    this._unbind();
    this._url = value;
    this.asset = this._registry.getByUrl(this._url);
    this._bind();
  }
  get url() {
    return this._url;
  }
  _bind() {
    if (this.id) {
      if (this._onAssetLoad) this._registry.on(`load:${this.id}`, this._onLoad, this);
      if (this._onAssetAdd) this._registry.once(`add:${this.id}`, this._onAdd, this);
      if (this._onAssetRemove) this._registry.on(`remove:${this.id}`, this._onRemove, this);
      if (this._onAssetUnload) this._registry.on(`unload:${this.id}`, this._onUnload, this);
    }
    if (this.url) {
      if (this._onAssetLoad) this._registry.on(`load:url:${this.url}`, this._onLoad, this);
      if (this._onAssetAdd) this._registry.once(`add:url:${this.url}`, this._onAdd, this);
      if (this._onAssetRemove) this._registry.on(`remove:url:${this.url}`, this._onRemove, this);
    }
  }
  _unbind() {
    if (this.id) {
      if (this._onAssetLoad) this._registry.off(`load:${this.id}`, this._onLoad, this);
      if (this._onAssetAdd) this._registry.off(`add:${this.id}`, this._onAdd, this);
      if (this._onAssetRemove) this._registry.off(`remove:${this.id}`, this._onRemove, this);
      if (this._onAssetUnload) this._registry.off(`unload:${this.id}`, this._onUnload, this);
    }
    if (this.url) {
      if (this._onAssetLoad) this._registry.off(`load:${this.url}`, this._onLoad, this);
      if (this._onAssetAdd) this._registry.off(`add:${this.url}`, this._onAdd, this);
      if (this._onAssetRemove) this._registry.off(`remove:${this.url}`, this._onRemove, this);
    }
  }
  _onLoad(asset) {
    this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
  }
  _onAdd(asset) {
    this.asset = asset;
    this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
  }
  _onRemove(asset) {
    this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);
    this.asset = null;
  }
  _onUnload(asset) {
    this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/render/component.js
var RenderComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._type = "asset";
    this._castShadows = true;
    this._receiveShadows = true;
    this._castShadowsLightmap = true;
    this._lightmapped = false;
    this._lightmapSizeMultiplier = 1;
    this.isStatic = false;
    this._batchGroupId = -1;
    this._layers = [LAYERID_WORLD];
    this._renderStyle = RENDERSTYLE_SOLID;
    this._meshInstances = [];
    this._customAabb = null;
    this._area = null;
    this._assetReference = void 0;
    this._materialReferences = [];
    this._material = void 0;
    this._rootBone = void 0;
    this._rootBone = new EntityReference(this, "rootBone");
    this._rootBone.on("set:entity", this._onSetRootBone, this);
    this._assetReference = new AssetReference("asset", this, system.app.assets, {
      add: this._onRenderAssetAdded,
      load: this._onRenderAssetLoad,
      remove: this._onRenderAssetRemove,
      unload: this._onRenderAssetUnload
    }, this);
    this._material = system.defaultMaterial;
    entity.on("remove", this.onRemoveChild, this);
    entity.on("removehierarchy", this.onRemoveChild, this);
    entity.on("insert", this.onInsertChild, this);
    entity.on("inserthierarchy", this.onInsertChild, this);
  }
  set renderStyle(renderStyle) {
    if (this._renderStyle !== renderStyle) {
      this._renderStyle = renderStyle;
      MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);
    }
  }
  get renderStyle() {
    return this._renderStyle;
  }
  set customAabb(value) {
    this._customAabb = value;
    const mi = this._meshInstances;
    if (mi) {
      for (let i = 0; i < mi.length; i++) {
        mi[i].setCustomAabb(this._customAabb);
      }
    }
  }
  get customAabb() {
    return this._customAabb;
  }
  set type(value) {
    if (this._type !== value) {
      this._area = null;
      this._type = value;
      this.destroyMeshInstances();
      if (value !== "asset") {
        let material = this._material;
        if (!material || material === this.system.defaultMaterial) {
          material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;
        }
        const primData = getShapePrimitive(this.system.app.graphicsDevice, value);
        this._area = primData.area;
        this.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];
      }
    }
  }
  get type() {
    return this._type;
  }
  set meshInstances(value) {
    this.destroyMeshInstances();
    this._meshInstances = value;
    if (this._meshInstances) {
      const mi = this._meshInstances;
      for (let i = 0; i < mi.length; i++) {
        if (!mi[i].node) {
          mi[i].node = this.entity;
        }
        mi[i].castShadow = this._castShadows;
        mi[i].receiveShadow = this._receiveShadows;
        mi[i].renderStyle = this._renderStyle;
        mi[i].setLightmapped(this._lightmapped);
        mi[i].setCustomAabb(this._customAabb);
      }
      if (this.enabled && this.entity.enabled) {
        this.addToLayers();
      }
    }
  }
  get meshInstances() {
    return this._meshInstances;
  }
  set lightmapped(value) {
    if (value !== this._lightmapped) {
      this._lightmapped = value;
      const mi = this._meshInstances;
      if (mi) {
        for (let i = 0; i < mi.length; i++) {
          mi[i].setLightmapped(value);
        }
      }
    }
  }
  get lightmapped() {
    return this._lightmapped;
  }
  set castShadows(value) {
    if (this._castShadows !== value) {
      const mi = this._meshInstances;
      if (mi) {
        const layers = this.layers;
        const scene = this.system.app.scene;
        if (this._castShadows && !value) {
          for (let i = 0; i < layers.length; i++) {
            const layer = scene.layers.getLayerById(this.layers[i]);
            if (layer) {
              layer.removeShadowCasters(mi);
            }
          }
        }
        for (let i = 0; i < mi.length; i++) {
          mi[i].castShadow = value;
        }
        if (!this._castShadows && value) {
          for (let i = 0; i < layers.length; i++) {
            const layer = scene.layers.getLayerById(layers[i]);
            if (layer) {
              layer.addShadowCasters(mi);
            }
          }
        }
      }
      this._castShadows = value;
    }
  }
  get castShadows() {
    return this._castShadows;
  }
  set receiveShadows(value) {
    if (this._receiveShadows !== value) {
      this._receiveShadows = value;
      const mi = this._meshInstances;
      if (mi) {
        for (let i = 0; i < mi.length; i++) {
          mi[i].receiveShadow = value;
        }
      }
    }
  }
  get receiveShadows() {
    return this._receiveShadows;
  }
  set castShadowsLightmap(value) {
    this._castShadowsLightmap = value;
  }
  get castShadowsLightmap() {
    return this._castShadowsLightmap;
  }
  set lightmapSizeMultiplier(value) {
    this._lightmapSizeMultiplier = value;
  }
  get lightmapSizeMultiplier() {
    return this._lightmapSizeMultiplier;
  }
  set layers(value) {
    const layers = this.system.app.scene.layers;
    let layer;
    if (this._meshInstances) {
      for (let i = 0; i < this._layers.length; i++) {
        layer = layers.getLayerById(this._layers[i]);
        if (layer) {
          layer.removeMeshInstances(this._meshInstances);
        }
      }
    }
    this._layers.length = 0;
    for (let i = 0; i < value.length; i++) {
      this._layers[i] = value[i];
    }
    if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;
    for (let i = 0; i < this._layers.length; i++) {
      layer = layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.addMeshInstances(this._meshInstances);
      }
    }
  }
  get layers() {
    return this._layers;
  }
  set batchGroupId(value) {
    if (this._batchGroupId !== value) {
      if (this.entity.enabled && this._batchGroupId >= 0) {
        var _this$system$app$batc;
        (_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
      }
      if (this.entity.enabled && value >= 0) {
        var _this$system$app$batc2;
        (_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.RENDER, value, this.entity);
      }
      if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
        this.addToLayers();
      }
      this._batchGroupId = value;
    }
  }
  get batchGroupId() {
    return this._batchGroupId;
  }
  set material(value) {
    if (this._material !== value) {
      this._material = value;
      if (this._meshInstances && this._type !== "asset") {
        for (let i = 0; i < this._meshInstances.length; i++) {
          this._meshInstances[i].material = value;
        }
      }
    }
  }
  get material() {
    return this._material;
  }
  set materialAssets(value = []) {
    if (this._materialReferences.length > value.length) {
      for (let i = value.length; i < this._materialReferences.length; i++) {
        this._materialReferences[i].id = null;
      }
      this._materialReferences.length = value.length;
    }
    for (let i = 0; i < value.length; i++) {
      if (!this._materialReferences[i]) {
        this._materialReferences.push(new AssetReference(i, this, this.system.app.assets, {
          add: this._onMaterialAdded,
          load: this._onMaterialLoad,
          remove: this._onMaterialRemove,
          unload: this._onMaterialUnload
        }, this));
      }
      if (value[i]) {
        const id13 = value[i] instanceof Asset ? value[i].id : value[i];
        if (this._materialReferences[i].id !== id13) {
          this._materialReferences[i].id = id13;
        }
        if (this._materialReferences[i].asset) {
          this._onMaterialAdded(i, this, this._materialReferences[i].asset);
        }
      } else {
        this._materialReferences[i].id = null;
        if (this._meshInstances[i]) {
          this._meshInstances[i].material = this.system.defaultMaterial;
        }
      }
    }
  }
  get materialAssets() {
    return this._materialReferences.map((ref) => {
      return ref.id;
    });
  }
  set asset(value) {
    const id13 = value instanceof Asset ? value.id : value;
    if (this._assetReference.id === id13) return;
    if (this._assetReference.asset && this._assetReference.asset.resource) {
      this._onRenderAssetRemove();
    }
    this._assetReference.id = id13;
    if (this._assetReference.asset) {
      this._onRenderAssetAdded();
    }
  }
  get asset() {
    return this._assetReference.id;
  }
  assignAsset(asset) {
    const id13 = asset instanceof Asset ? asset.id : asset;
    this._assetReference.id = id13;
  }
  _onSetRootBone(entity) {
    if (entity) {
      this._onRootBoneChanged();
    }
  }
  _onRootBoneChanged() {
    this._clearSkinInstances();
    if (this.enabled && this.entity.enabled) {
      this._cloneSkinInstances();
    }
  }
  destroyMeshInstances() {
    const meshInstances = this._meshInstances;
    if (meshInstances) {
      this.removeFromLayers();
      this._clearSkinInstances();
      for (let i = 0; i < meshInstances.length; i++) {
        meshInstances[i].destroy();
      }
      this._meshInstances.length = 0;
    }
  }
  addToLayers() {
    const layers = this.system.app.scene.layers;
    for (let i = 0; i < this._layers.length; i++) {
      const layer = layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.addMeshInstances(this._meshInstances);
      }
    }
  }
  removeFromLayers() {
    if (this._meshInstances && this._meshInstances.length) {
      const layers = this.system.app.scene.layers;
      for (let i = 0; i < this._layers.length; i++) {
        const layer = layers.getLayerById(this._layers[i]);
        if (layer) {
          layer.removeMeshInstances(this._meshInstances);
        }
      }
    }
  }
  onRemoveChild() {
    this.removeFromLayers();
  }
  onInsertChild() {
    if (this._meshInstances && this.enabled && this.entity.enabled) {
      this.addToLayers();
    }
  }
  onRemove() {
    this.destroyMeshInstances();
    this.asset = null;
    this.materialAsset = null;
    this._assetReference.id = null;
    for (let i = 0; i < this._materialReferences.length; i++) {
      this._materialReferences[i].id = null;
    }
    this.entity.off("remove", this.onRemoveChild, this);
    this.entity.off("insert", this.onInsertChild, this);
  }
  onLayersChanged(oldComp, newComp) {
    this.addToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    layer.addMeshInstances(this._meshInstances);
  }
  onLayerRemoved(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    layer.removeMeshInstances(this._meshInstances);
  }
  onEnable() {
    const app2 = this.system.app;
    const scene = app2.scene;
    this._rootBone.onParentComponentEnable();
    this._cloneSkinInstances();
    scene.on("set:layers", this.onLayersChanged, this);
    if (scene.layers) {
      scene.layers.on("add", this.onLayerAdded, this);
      scene.layers.on("remove", this.onLayerRemoved, this);
    }
    const isAsset = this._type === "asset";
    if (this._meshInstances && this._meshInstances.length) {
      this.addToLayers();
    } else if (isAsset && this.asset) {
      this._onRenderAssetAdded();
    }
    for (let i = 0; i < this._materialReferences.length; i++) {
      if (this._materialReferences[i].asset) {
        this.system.app.assets.load(this._materialReferences[i].asset);
      }
    }
    if (this._batchGroupId >= 0) {
      var _app$batcher;
      (_app$batcher = app2.batcher) == null || _app$batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);
    }
  }
  onDisable() {
    const app2 = this.system.app;
    const scene = app2.scene;
    scene.off("set:layers", this.onLayersChanged, this);
    if (scene.layers) {
      scene.layers.off("add", this.onLayerAdded, this);
      scene.layers.off("remove", this.onLayerRemoved, this);
    }
    if (this._batchGroupId >= 0) {
      var _app$batcher2;
      (_app$batcher2 = app2.batcher) == null || _app$batcher2.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
    }
    this.removeFromLayers();
  }
  hide() {
    if (this._meshInstances) {
      for (let i = 0; i < this._meshInstances.length; i++) {
        this._meshInstances[i].visible = false;
      }
    }
  }
  show() {
    if (this._meshInstances) {
      for (let i = 0; i < this._meshInstances.length; i++) {
        this._meshInstances[i].visible = true;
      }
    }
  }
  _onRenderAssetAdded() {
    if (!this._assetReference.asset) return;
    if (this._assetReference.asset.resource) {
      this._onRenderAssetLoad();
    } else if (this.enabled && this.entity.enabled) {
      this.system.app.assets.load(this._assetReference.asset);
    }
  }
  _onRenderAssetLoad() {
    this.destroyMeshInstances();
    if (this._assetReference.asset) {
      const render = this._assetReference.asset.resource;
      render.off("set:meshes", this._onSetMeshes, this);
      render.on("set:meshes", this._onSetMeshes, this);
      if (render.meshes) {
        this._onSetMeshes(render.meshes);
      }
    }
  }
  _onSetMeshes(meshes) {
    this._cloneMeshes(meshes);
  }
  _clearSkinInstances() {
    for (let i = 0; i < this._meshInstances.length; i++) {
      const meshInstance = this._meshInstances[i];
      SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);
      meshInstance.skinInstance = null;
    }
  }
  _cloneSkinInstances() {
    if (this._meshInstances.length && this._rootBone.entity instanceof GraphNode) {
      for (let i = 0; i < this._meshInstances.length; i++) {
        const meshInstance = this._meshInstances[i];
        const mesh = meshInstance.mesh;
        if (mesh.skin && !meshInstance.skinInstance) {
          meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone.entity, this.entity);
        }
      }
    }
  }
  _cloneMeshes(meshes) {
    if (meshes && meshes.length) {
      const meshInstances = [];
      for (let i = 0; i < meshes.length; i++) {
        const mesh = meshes[i];
        const material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;
        const meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);
        meshInstances.push(meshInst);
        if (mesh.morph) {
          meshInst.morphInstance = new MorphInstance(mesh.morph);
        }
      }
      this.meshInstances = meshInstances;
      this._cloneSkinInstances();
    }
  }
  _onRenderAssetUnload() {
    if (this._type === "asset") {
      this.destroyMeshInstances();
    }
  }
  _onRenderAssetRemove() {
    if (this._assetReference.asset && this._assetReference.asset.resource) {
      this._assetReference.asset.resource.off("set:meshes", this._onSetMeshes, this);
    }
    this._onRenderAssetUnload();
  }
  _onMaterialAdded(index, component, asset) {
    if (asset.resource) {
      this._onMaterialLoad(index, component, asset);
    } else {
      if (this.enabled && this.entity.enabled) {
        this.system.app.assets.load(asset);
      }
    }
  }
  _updateMainMaterial(index, material) {
    if (index === 0) {
      this.material = material;
    }
  }
  _onMaterialLoad(index, component, asset) {
    if (this._meshInstances[index]) {
      this._meshInstances[index].material = asset.resource;
    }
    this._updateMainMaterial(index, asset.resource);
  }
  _onMaterialRemove(index, component, asset) {
    if (this._meshInstances[index]) {
      this._meshInstances[index].material = this.system.defaultMaterial;
    }
    this._updateMainMaterial(index, this.system.defaultMaterial);
  }
  _onMaterialUnload(index, component, asset) {
    if (this._meshInstances[index]) {
      this._meshInstances[index].material = this.system.defaultMaterial;
    }
    this._updateMainMaterial(index, this.system.defaultMaterial);
  }
  resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {
    if (oldRender.rootBone && duplicatedIdsMap[oldRender.rootBone]) {
      this.rootBone = duplicatedIdsMap[oldRender.rootBone];
    }
    this._clearSkinInstances();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/render/data.js
var RenderComponentData = class {
  constructor() {
    this.enabled = true;
    this.rootBone = null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/render/system.js
var _schema12 = [{
  name: "rootBone",
  type: "entity"
}, "enabled"];
var _properties = ["material", "meshInstances", "asset", "materialAssets", "castShadows", "receiveShadows", "castShadowsLightmap", "lightmapped", "lightmapSizeMultiplier", "renderStyle", "type", "layers", "isStatic", "batchGroupId"];
var RenderComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "render";
    this.ComponentType = RenderComponent;
    this.DataType = RenderComponentData;
    this.schema = _schema12;
    this.defaultMaterial = getDefaultMaterial(app2.graphicsDevice);
    this.on("beforeremove", this.onRemove, this);
  }
  initializeComponentData(component, _data, properties3) {
    if (_data.batchGroupId === null || _data.batchGroupId === void 0) {
      _data.batchGroupId = -1;
    }
    if (_data.layers && _data.layers.length) {
      _data.layers = _data.layers.slice(0);
    }
    for (let i = 0; i < _properties.length; i++) {
      if (_data.hasOwnProperty(_properties[i])) {
        component[_properties[i]] = _data[_properties[i]];
      }
    }
    if (_data.aabbCenter && _data.aabbHalfExtents) {
      component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
    }
    super.initializeComponentData(component, _data, _schema12);
  }
  cloneComponent(entity, clone) {
    const data2 = {};
    for (let i = 0; i < _properties.length; i++) {
      data2[_properties[i]] = entity.render[_properties[i]];
    }
    data2.enabled = entity.render.enabled;
    delete data2.meshInstances;
    const component = this.addComponent(clone, data2);
    const srcMeshInstances = entity.render.meshInstances;
    const meshes = srcMeshInstances.map((mi) => mi.mesh);
    component._onSetMeshes(meshes);
    for (let m = 0; m < srcMeshInstances.length; m++) {
      component.meshInstances[m].material = srcMeshInstances[m].material;
    }
    if (entity.render.customAabb) {
      component.customAabb = entity.render.customAabb.clone();
    }
    return component;
  }
  onRemove(entity, component) {
    component.onRemove();
  }
};
Component._buildAccessors(RenderComponent.prototype, _schema12);

// ../node_modules/playcanvas/build/playcanvas/src/core/object-pool.js
var ObjectPool = class {
  constructor(constructorFunc, size) {
    this._constructor = void 0;
    this._pool = [];
    this._count = 0;
    this._constructor = constructorFunc;
    this._resize(size);
  }
  _resize(size) {
    if (size > this._pool.length) {
      for (let i = this._pool.length; i < size; i++) {
        this._pool[i] = new this._constructor();
      }
    }
  }
  allocate() {
    if (this._count >= this._pool.length) {
      this._resize(this._pool.length * 2);
    }
    return this._pool[this._count++];
  }
  freeAll() {
    this._count = 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/rigid-body/component.js
var _ammoTransform2;
var _ammoVec12;
var _ammoVec2;
var _ammoQuat2;
var _quat1 = new Quat();
var _quat2 = new Quat();
var _vec32 = new Vec3();
var RigidBodyComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._angularDamping = 0;
    this._angularFactor = new Vec3(1, 1, 1);
    this._angularVelocity = new Vec3();
    this._body = null;
    this._friction = 0.5;
    this._group = BODYGROUP_STATIC;
    this._linearDamping = 0;
    this._linearFactor = new Vec3(1, 1, 1);
    this._linearVelocity = new Vec3();
    this._mask = BODYMASK_NOT_STATIC;
    this._mass = 1;
    this._restitution = 0;
    this._rollingFriction = 0;
    this._simulationEnabled = false;
    this._type = BODYTYPE_STATIC;
  }
  static onLibraryLoaded() {
    if (typeof Ammo !== "undefined") {
      _ammoTransform2 = new Ammo.btTransform();
      _ammoVec12 = new Ammo.btVector3();
      _ammoVec2 = new Ammo.btVector3();
      _ammoQuat2 = new Ammo.btQuaternion();
    }
  }
  set angularDamping(damping) {
    if (this._angularDamping !== damping) {
      this._angularDamping = damping;
      if (this._body) {
        this._body.setDamping(this._linearDamping, damping);
      }
    }
  }
  get angularDamping() {
    return this._angularDamping;
  }
  set angularFactor(factor) {
    if (!this._angularFactor.equals(factor)) {
      this._angularFactor.copy(factor);
      if (this._body && this._type === BODYTYPE_DYNAMIC) {
        _ammoVec12.setValue(factor.x, factor.y, factor.z);
        this._body.setAngularFactor(_ammoVec12);
      }
    }
  }
  get angularFactor() {
    return this._angularFactor;
  }
  set angularVelocity(velocity) {
    if (this._body && this._type === BODYTYPE_DYNAMIC) {
      this._body.activate();
      _ammoVec12.setValue(velocity.x, velocity.y, velocity.z);
      this._body.setAngularVelocity(_ammoVec12);
      this._angularVelocity.copy(velocity);
    }
  }
  get angularVelocity() {
    if (this._body && this._type === BODYTYPE_DYNAMIC) {
      const velocity = this._body.getAngularVelocity();
      this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());
    }
    return this._angularVelocity;
  }
  set body(body) {
    if (this._body !== body) {
      this._body = body;
      if (body && this._simulationEnabled) {
        body.activate();
      }
    }
  }
  get body() {
    return this._body;
  }
  set friction(friction) {
    if (this._friction !== friction) {
      this._friction = friction;
      if (this._body) {
        this._body.setFriction(friction);
      }
    }
  }
  get friction() {
    return this._friction;
  }
  set group(group) {
    if (this._group !== group) {
      this._group = group;
      if (this.enabled && this.entity.enabled) {
        this.disableSimulation();
        this.enableSimulation();
      }
    }
  }
  get group() {
    return this._group;
  }
  set linearDamping(damping) {
    if (this._linearDamping !== damping) {
      this._linearDamping = damping;
      if (this._body) {
        this._body.setDamping(damping, this._angularDamping);
      }
    }
  }
  get linearDamping() {
    return this._linearDamping;
  }
  set linearFactor(factor) {
    if (!this._linearFactor.equals(factor)) {
      this._linearFactor.copy(factor);
      if (this._body && this._type === BODYTYPE_DYNAMIC) {
        _ammoVec12.setValue(factor.x, factor.y, factor.z);
        this._body.setLinearFactor(_ammoVec12);
      }
    }
  }
  get linearFactor() {
    return this._linearFactor;
  }
  set linearVelocity(velocity) {
    if (this._body && this._type === BODYTYPE_DYNAMIC) {
      this._body.activate();
      _ammoVec12.setValue(velocity.x, velocity.y, velocity.z);
      this._body.setLinearVelocity(_ammoVec12);
      this._linearVelocity.copy(velocity);
    }
  }
  get linearVelocity() {
    if (this._body && this._type === BODYTYPE_DYNAMIC) {
      const velocity = this._body.getLinearVelocity();
      this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());
    }
    return this._linearVelocity;
  }
  set mask(mask) {
    if (this._mask !== mask) {
      this._mask = mask;
      if (this.enabled && this.entity.enabled) {
        this.disableSimulation();
        this.enableSimulation();
      }
    }
  }
  get mask() {
    return this._mask;
  }
  set mass(mass) {
    if (this._mass !== mass) {
      this._mass = mass;
      if (this._body && this._type === BODYTYPE_DYNAMIC) {
        const enabled = this.enabled && this.entity.enabled;
        if (enabled) {
          this.disableSimulation();
        }
        this._body.getCollisionShape().calculateLocalInertia(mass, _ammoVec12);
        this._body.setMassProps(mass, _ammoVec12);
        this._body.updateInertiaTensor();
        if (enabled) {
          this.enableSimulation();
        }
      }
    }
  }
  get mass() {
    return this._mass;
  }
  set restitution(restitution) {
    if (this._restitution !== restitution) {
      this._restitution = restitution;
      if (this._body) {
        this._body.setRestitution(restitution);
      }
    }
  }
  get restitution() {
    return this._restitution;
  }
  set rollingFriction(friction) {
    if (this._rollingFriction !== friction) {
      this._rollingFriction = friction;
      if (this._body) {
        this._body.setRollingFriction(friction);
      }
    }
  }
  get rollingFriction() {
    return this._rollingFriction;
  }
  set type(type) {
    if (this._type !== type) {
      this._type = type;
      this.disableSimulation();
      switch (type) {
        case BODYTYPE_DYNAMIC:
          this._group = BODYGROUP_DYNAMIC;
          this._mask = BODYMASK_ALL;
          break;
        case BODYTYPE_KINEMATIC:
          this._group = BODYGROUP_KINEMATIC;
          this._mask = BODYMASK_ALL;
          break;
        case BODYTYPE_STATIC:
        default:
          this._group = BODYGROUP_STATIC;
          this._mask = BODYMASK_NOT_STATIC;
          break;
      }
      this.createBody();
    }
  }
  get type() {
    return this._type;
  }
  createBody() {
    const entity = this.entity;
    let shape;
    if (entity.collision) {
      shape = entity.collision.shape;
      if (entity.trigger) {
        entity.trigger.destroy();
        delete entity.trigger;
      }
    }
    if (shape) {
      if (this._body) {
        this.system.removeBody(this._body);
        this.system.destroyBody(this._body);
        this._body = null;
      }
      const mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;
      this._getEntityTransform(_ammoTransform2);
      const body = this.system.createBody(mass, shape, _ammoTransform2);
      body.setRestitution(this._restitution);
      body.setFriction(this._friction);
      body.setRollingFriction(this._rollingFriction);
      body.setDamping(this._linearDamping, this._angularDamping);
      if (this._type === BODYTYPE_DYNAMIC) {
        const linearFactor = this._linearFactor;
        _ammoVec12.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
        body.setLinearFactor(_ammoVec12);
        const angularFactor = this._angularFactor;
        _ammoVec12.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
        body.setAngularFactor(_ammoVec12);
      } else if (this._type === BODYTYPE_KINEMATIC) {
        body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
        body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
      }
      body.entity = entity;
      this.body = body;
      if (this.enabled && entity.enabled) {
        this.enableSimulation();
      }
    }
  }
  isActive() {
    return this._body ? this._body.isActive() : false;
  }
  activate() {
    if (this._body) {
      this._body.activate();
    }
  }
  enableSimulation() {
    const entity = this.entity;
    if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {
      const body = this._body;
      if (body) {
        this.system.addBody(body, this._group, this._mask);
        switch (this._type) {
          case BODYTYPE_DYNAMIC:
            this.system._dynamic.push(this);
            body.forceActivationState(BODYSTATE_ACTIVE_TAG);
            this.syncEntityToBody();
            break;
          case BODYTYPE_KINEMATIC:
            this.system._kinematic.push(this);
            body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
            break;
          case BODYTYPE_STATIC:
            body.forceActivationState(BODYSTATE_ACTIVE_TAG);
            this.syncEntityToBody();
            break;
        }
        if (entity.collision.type === "compound") {
          this.system._compounds.push(entity.collision);
        }
        body.activate();
        this._simulationEnabled = true;
      }
    }
  }
  disableSimulation() {
    const body = this._body;
    if (body && this._simulationEnabled) {
      const system = this.system;
      let idx = system._compounds.indexOf(this.entity.collision);
      if (idx > -1) {
        system._compounds.splice(idx, 1);
      }
      idx = system._dynamic.indexOf(this);
      if (idx > -1) {
        system._dynamic.splice(idx, 1);
      }
      idx = system._kinematic.indexOf(this);
      if (idx > -1) {
        system._kinematic.splice(idx, 1);
      }
      system.removeBody(body);
      body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
      this._simulationEnabled = false;
    }
  }
  applyForce(x2, y2, z2, px, py, pz) {
    const body = this._body;
    if (body) {
      body.activate();
      if (x2 instanceof Vec3) {
        _ammoVec12.setValue(x2.x, x2.y, x2.z);
      } else {
        _ammoVec12.setValue(x2, y2, z2);
      }
      if (y2 instanceof Vec3) {
        _ammoVec2.setValue(y2.x, y2.y, y2.z);
      } else if (px !== void 0) {
        _ammoVec2.setValue(px, py, pz);
      } else {
        _ammoVec2.setValue(0, 0, 0);
      }
      body.applyForce(_ammoVec12, _ammoVec2);
    }
  }
  applyTorque(x2, y2, z2) {
    const body = this._body;
    if (body) {
      body.activate();
      if (x2 instanceof Vec3) {
        _ammoVec12.setValue(x2.x, x2.y, x2.z);
      } else {
        _ammoVec12.setValue(x2, y2, z2);
      }
      body.applyTorque(_ammoVec12);
    }
  }
  applyImpulse(x2, y2, z2, px, py, pz) {
    const body = this._body;
    if (body) {
      body.activate();
      if (x2 instanceof Vec3) {
        _ammoVec12.setValue(x2.x, x2.y, x2.z);
      } else {
        _ammoVec12.setValue(x2, y2, z2);
      }
      if (y2 instanceof Vec3) {
        _ammoVec2.setValue(y2.x, y2.y, y2.z);
      } else if (px !== void 0) {
        _ammoVec2.setValue(px, py, pz);
      } else {
        _ammoVec2.setValue(0, 0, 0);
      }
      body.applyImpulse(_ammoVec12, _ammoVec2);
    }
  }
  applyTorqueImpulse(x2, y2, z2) {
    const body = this._body;
    if (body) {
      body.activate();
      if (x2 instanceof Vec3) {
        _ammoVec12.setValue(x2.x, x2.y, x2.z);
      } else {
        _ammoVec12.setValue(x2, y2, z2);
      }
      body.applyTorqueImpulse(_ammoVec12);
    }
  }
  isStatic() {
    return this._type === BODYTYPE_STATIC;
  }
  isStaticOrKinematic() {
    return this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;
  }
  isKinematic() {
    return this._type === BODYTYPE_KINEMATIC;
  }
  _getEntityTransform(transform) {
    const entity = this.entity;
    const component = entity.collision;
    if (component) {
      const bodyPos = component.getShapePosition();
      const bodyRot = component.getShapeRotation();
      _ammoVec12.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
      _ammoQuat2.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
    } else {
      const pos = entity.getPosition();
      const rot = entity.getRotation();
      _ammoVec12.setValue(pos.x, pos.y, pos.z);
      _ammoQuat2.setValue(rot.x, rot.y, rot.z, rot.w);
    }
    transform.setOrigin(_ammoVec12);
    transform.setRotation(_ammoQuat2);
  }
  syncEntityToBody() {
    const body = this._body;
    if (body) {
      this._getEntityTransform(_ammoTransform2);
      body.setWorldTransform(_ammoTransform2);
      if (this._type === BODYTYPE_KINEMATIC) {
        const motionState = body.getMotionState();
        if (motionState) {
          motionState.setWorldTransform(_ammoTransform2);
        }
      }
      body.activate();
    }
  }
  _updateDynamic() {
    const body = this._body;
    if (body.isActive()) {
      const motionState = body.getMotionState();
      if (motionState) {
        const entity = this.entity;
        motionState.getWorldTransform(_ammoTransform2);
        const p = _ammoTransform2.getOrigin();
        const q3 = _ammoTransform2.getRotation();
        const component = entity.collision;
        if (component && component._hasOffset) {
          const lo = component.data.linearOffset;
          const ao = component.data.angularOffset;
          const invertedAo = _quat2.copy(ao).invert();
          const entityRot = _quat1.set(q3.x(), q3.y(), q3.z(), q3.w()).mul(invertedAo);
          entityRot.transformVector(lo, _vec32);
          entity.setPosition(p.x() - _vec32.x, p.y() - _vec32.y, p.z() - _vec32.z);
          entity.setRotation(entityRot);
        } else {
          entity.setPosition(p.x(), p.y(), p.z());
          entity.setRotation(q3.x(), q3.y(), q3.z(), q3.w());
        }
      }
    }
  }
  _updateKinematic() {
    const motionState = this._body.getMotionState();
    if (motionState) {
      this._getEntityTransform(_ammoTransform2);
      motionState.setWorldTransform(_ammoTransform2);
    }
  }
  teleport(x2, y2, z2, rx, ry, rz) {
    if (x2 instanceof Vec3) {
      this.entity.setPosition(x2);
    } else {
      this.entity.setPosition(x2, y2, z2);
    }
    if (y2 instanceof Quat) {
      this.entity.setRotation(y2);
    } else if (y2 instanceof Vec3) {
      this.entity.setEulerAngles(y2);
    } else if (rx !== void 0) {
      this.entity.setEulerAngles(rx, ry, rz);
    }
    this.syncEntityToBody();
  }
  onEnable() {
    if (!this._body) {
      this.createBody();
    }
    this.enableSimulation();
  }
  onDisable() {
    this.disableSimulation();
  }
};
RigidBodyComponent.EVENT_CONTACT = "contact";
RigidBodyComponent.EVENT_COLLISIONSTART = "collisionstart";
RigidBodyComponent.EVENT_COLLISIONEND = "collisionend";
RigidBodyComponent.EVENT_TRIGGERENTER = "triggerenter";
RigidBodyComponent.EVENT_TRIGGERLEAVE = "triggerleave";
RigidBodyComponent.order = -1;

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/rigid-body/data.js
var RigidBodyComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/rigid-body/system.js
var ammoRayStart;
var ammoRayEnd;
var RaycastResult = class {
  constructor(entity, point, normal, hitFraction) {
    this.entity = void 0;
    this.point = void 0;
    this.normal = void 0;
    this.hitFraction = void 0;
    this.entity = entity;
    this.point = point;
    this.normal = normal;
    this.hitFraction = hitFraction;
  }
};
var SingleContactResult = class {
  constructor(a, b, contactPoint) {
    this.a = void 0;
    this.b = void 0;
    this.impulse = void 0;
    this.localPointA = void 0;
    this.localPointB = void 0;
    this.pointA = void 0;
    this.pointB = void 0;
    this.normal = void 0;
    if (arguments.length !== 0) {
      this.a = a;
      this.b = b;
      this.impulse = contactPoint.impulse;
      this.localPointA = contactPoint.localPoint;
      this.localPointB = contactPoint.localPointOther;
      this.pointA = contactPoint.point;
      this.pointB = contactPoint.pointOther;
      this.normal = contactPoint.normal;
    } else {
      this.a = null;
      this.b = null;
      this.impulse = 0;
      this.localPointA = new Vec3();
      this.localPointB = new Vec3();
      this.pointA = new Vec3();
      this.pointB = new Vec3();
      this.normal = new Vec3();
    }
  }
};
var ContactPoint = class {
  constructor(localPoint = new Vec3(), localPointOther = new Vec3(), point = new Vec3(), pointOther = new Vec3(), normal = new Vec3(), impulse = 0) {
    this.localPoint = void 0;
    this.localPointOther = void 0;
    this.point = void 0;
    this.pointOther = void 0;
    this.normal = void 0;
    this.impulse = void 0;
    this.localPoint = localPoint;
    this.localPointOther = localPointOther;
    this.point = point;
    this.pointOther = pointOther;
    this.normal = normal;
    this.impulse = impulse;
  }
};
var ContactResult = class {
  constructor(other, contacts) {
    this.other = void 0;
    this.contacts = void 0;
    this.other = other;
    this.contacts = contacts;
  }
};
var _schema13 = ["enabled"];
var RigidBodyComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.maxSubSteps = 10;
    this.fixedTimeStep = 1 / 60;
    this.gravity = new Vec3(0, -9.81, 0);
    this._gravityFloat32 = new Float32Array(3);
    this._dynamic = [];
    this._kinematic = [];
    this._triggers = [];
    this._compounds = [];
    this.id = "rigidbody";
    this._stats = app2.stats.frame;
    this.ComponentType = RigidBodyComponent;
    this.DataType = RigidBodyComponentData;
    this.contactPointPool = null;
    this.contactResultPool = null;
    this.singleContactResultPool = null;
    this.schema = _schema13;
    this.collisions = {};
    this.frameCollisions = {};
    this.on("beforeremove", this.onBeforeRemove, this);
  }
  onLibraryLoaded() {
    if (typeof Ammo !== "undefined") {
      this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
      this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
      this.overlappingPairCache = new Ammo.btDbvtBroadphase();
      this.solver = new Ammo.btSequentialImpulseConstraintSolver();
      this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);
      if (this.dynamicsWorld.setInternalTickCallback) {
        const checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), "vif");
        this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
      }
      ammoRayStart = new Ammo.btVector3();
      ammoRayEnd = new Ammo.btVector3();
      RigidBodyComponent.onLibraryLoaded();
      this.contactPointPool = new ObjectPool(ContactPoint, 1);
      this.contactResultPool = new ObjectPool(ContactResult, 1);
      this.singleContactResultPool = new ObjectPool(SingleContactResult, 1);
      this.app.systems.on("update", this.onUpdate, this);
    } else {
      this.app.systems.off("update", this.onUpdate, this);
    }
  }
  initializeComponentData(component, data2, properties3) {
    const props = ["mass", "linearDamping", "angularDamping", "linearFactor", "angularFactor", "friction", "rollingFriction", "restitution", "type", "group", "mask"];
    for (const property of props) {
      if (data2.hasOwnProperty(property)) {
        const value = data2[property];
        if (Array.isArray(value)) {
          component[property] = new Vec3(value[0], value[1], value[2]);
        } else {
          component[property] = value;
        }
      }
    }
    super.initializeComponentData(component, data2, ["enabled"]);
  }
  cloneComponent(entity, clone) {
    const rigidbody = entity.rigidbody;
    const data2 = {
      enabled: rigidbody.enabled,
      mass: rigidbody.mass,
      linearDamping: rigidbody.linearDamping,
      angularDamping: rigidbody.angularDamping,
      linearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],
      angularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],
      friction: rigidbody.friction,
      rollingFriction: rigidbody.rollingFriction,
      restitution: rigidbody.restitution,
      type: rigidbody.type,
      group: rigidbody.group,
      mask: rigidbody.mask
    };
    return this.addComponent(clone, data2);
  }
  onBeforeRemove(entity, component) {
    if (component.enabled) {
      component.enabled = false;
    }
    if (component.body) {
      this.destroyBody(component.body);
      component.body = null;
    }
  }
  addBody(body, group, mask) {
    if (group !== void 0 && mask !== void 0) {
      this.dynamicsWorld.addRigidBody(body, group, mask);
    } else {
      this.dynamicsWorld.addRigidBody(body);
    }
  }
  removeBody(body) {
    this.dynamicsWorld.removeRigidBody(body);
  }
  createBody(mass, shape, transform) {
    const localInertia = new Ammo.btVector3(0, 0, 0);
    if (mass !== 0) {
      shape.calculateLocalInertia(mass, localInertia);
    }
    const motionState = new Ammo.btDefaultMotionState(transform);
    const bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
    const body = new Ammo.btRigidBody(bodyInfo);
    Ammo.destroy(bodyInfo);
    Ammo.destroy(localInertia);
    return body;
  }
  destroyBody(body) {
    const motionState = body.getMotionState();
    if (motionState) {
      Ammo.destroy(motionState);
    }
    Ammo.destroy(body);
  }
  raycastFirst(start, end, options2 = {}) {
    if (options2.filterTags || options2.filterCallback) {
      options2.sort = true;
      return this.raycastAll(start, end, options2)[0] || null;
    }
    let result = null;
    ammoRayStart.setValue(start.x, start.y, start.z);
    ammoRayEnd.setValue(end.x, end.y, end.z);
    const rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
    if (typeof options2.filterCollisionGroup === "number") {
      rayCallback.set_m_collisionFilterGroup(options2.filterCollisionGroup);
    }
    if (typeof options2.filterCollisionMask === "number") {
      rayCallback.set_m_collisionFilterMask(options2.filterCollisionMask);
    }
    this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
    if (rayCallback.hasHit()) {
      const collisionObj = rayCallback.get_m_collisionObject();
      const body = Ammo.castObject(collisionObj, Ammo.btRigidBody);
      if (body) {
        const point = rayCallback.get_m_hitPointWorld();
        const normal = rayCallback.get_m_hitNormalWorld();
        result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), rayCallback.get_m_closestHitFraction());
      }
    }
    Ammo.destroy(rayCallback);
    return result;
  }
  raycastAll(start, end, options2 = {}) {
    const results = [];
    ammoRayStart.setValue(start.x, start.y, start.z);
    ammoRayEnd.setValue(end.x, end.y, end.z);
    const rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
    if (typeof options2.filterCollisionGroup === "number") {
      rayCallback.set_m_collisionFilterGroup(options2.filterCollisionGroup);
    }
    if (typeof options2.filterCollisionMask === "number") {
      rayCallback.set_m_collisionFilterMask(options2.filterCollisionMask);
    }
    this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
    if (rayCallback.hasHit()) {
      const collisionObjs = rayCallback.get_m_collisionObjects();
      const points = rayCallback.get_m_hitPointWorld();
      const normals = rayCallback.get_m_hitNormalWorld();
      const hitFractions = rayCallback.get_m_hitFractions();
      const numHits = collisionObjs.size();
      for (let i = 0; i < numHits; i++) {
        const body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);
        if (body && body.entity) {
          if (options2.filterTags && !body.entity.tags.has(...options2.filterTags) || options2.filterCallback && !options2.filterCallback(body.entity)) {
            continue;
          }
          const point = points.at(i);
          const normal = normals.at(i);
          const result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), hitFractions.at(i));
          results.push(result);
        }
      }
      if (options2.sort) {
        results.sort((a, b) => a.hitFraction - b.hitFraction);
      }
    }
    Ammo.destroy(rayCallback);
    return results;
  }
  _storeCollision(entity, other) {
    let isNewCollision = false;
    const guid2 = entity.getGuid();
    this.collisions[guid2] = this.collisions[guid2] || {
      others: [],
      entity
    };
    if (this.collisions[guid2].others.indexOf(other) < 0) {
      this.collisions[guid2].others.push(other);
      isNewCollision = true;
    }
    this.frameCollisions[guid2] = this.frameCollisions[guid2] || {
      others: [],
      entity
    };
    this.frameCollisions[guid2].others.push(other);
    return isNewCollision;
  }
  _createContactPointFromAmmo(contactPoint) {
    const localPointA = contactPoint.get_m_localPointA();
    const localPointB = contactPoint.get_m_localPointB();
    const positionWorldOnA = contactPoint.getPositionWorldOnA();
    const positionWorldOnB = contactPoint.getPositionWorldOnB();
    const normalWorldOnB = contactPoint.get_m_normalWorldOnB();
    const contact = this.contactPointPool.allocate();
    contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
    contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
    contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
    contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
    contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
    contact.impulse = contactPoint.getAppliedImpulse();
    return contact;
  }
  _createReverseContactPointFromAmmo(contactPoint) {
    const localPointA = contactPoint.get_m_localPointA();
    const localPointB = contactPoint.get_m_localPointB();
    const positionWorldOnA = contactPoint.getPositionWorldOnA();
    const positionWorldOnB = contactPoint.getPositionWorldOnB();
    const normalWorldOnB = contactPoint.get_m_normalWorldOnB();
    const contact = this.contactPointPool.allocate();
    contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
    contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
    contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
    contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
    contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
    contact.impulse = contactPoint.getAppliedImpulse();
    return contact;
  }
  _createSingleContactResult(a, b, contactPoint) {
    const result = this.singleContactResultPool.allocate();
    result.a = a;
    result.b = b;
    result.localPointA = contactPoint.localPoint;
    result.localPointB = contactPoint.localPointOther;
    result.pointA = contactPoint.point;
    result.pointB = contactPoint.pointOther;
    result.normal = contactPoint.normal;
    result.impulse = contactPoint.impulse;
    return result;
  }
  _createContactResult(other, contacts) {
    const result = this.contactResultPool.allocate();
    result.other = other;
    result.contacts = contacts;
    return result;
  }
  _cleanOldCollisions() {
    for (const guid2 in this.collisions) {
      if (this.collisions.hasOwnProperty(guid2)) {
        const frameCollision = this.frameCollisions[guid2];
        const collision = this.collisions[guid2];
        const entity = collision.entity;
        const entityCollision = entity.collision;
        const entityRigidbody = entity.rigidbody;
        const others = collision.others;
        const length = others.length;
        let i = length;
        while (i--) {
          const other = others[i];
          if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
            others.splice(i, 1);
            if (entity.trigger) {
              if (entityCollision) {
                entityCollision.fire("triggerleave", other);
              }
              if (other.rigidbody) {
                other.rigidbody.fire("triggerleave", entity);
              }
            } else if (!other.trigger) {
              if (entityRigidbody) {
                entityRigidbody.fire("collisionend", other);
              }
              if (entityCollision) {
                entityCollision.fire("collisionend", other);
              }
            }
          }
        }
        if (others.length === 0) {
          delete this.collisions[guid2];
        }
      }
    }
  }
  _hasContactEvent(entity) {
    const c2 = entity.collision;
    if (c2 && (c2.hasEvent("collisionstart") || c2.hasEvent("collisionend") || c2.hasEvent("contact"))) {
      return true;
    }
    const r = entity.rigidbody;
    return r && (r.hasEvent("collisionstart") || r.hasEvent("collisionend") || r.hasEvent("contact"));
  }
  _checkForCollisions(world, timeStep) {
    const dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
    const dispatcher = dynamicsWorld.getDispatcher();
    const numManifolds = dispatcher.getNumManifolds();
    this.frameCollisions = {};
    for (let i = 0; i < numManifolds; i++) {
      const manifold = dispatcher.getManifoldByIndexInternal(i);
      const body0 = manifold.getBody0();
      const body1 = manifold.getBody1();
      const wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
      const wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
      const e0 = wb0.entity;
      const e12 = wb1.entity;
      if (!e0 || !e12) {
        continue;
      }
      const flags0 = wb0.getCollisionFlags();
      const flags1 = wb1.getCollisionFlags();
      const numContacts = manifold.getNumContacts();
      const forwardContacts = [];
      const reverseContacts = [];
      let newCollision;
      if (numContacts > 0) {
        if (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {
          const e0Events = e0.collision && (e0.collision.hasEvent("triggerenter") || e0.collision.hasEvent("triggerleave"));
          const e1Events = e12.collision && (e12.collision.hasEvent("triggerenter") || e12.collision.hasEvent("triggerleave"));
          const e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent("triggerenter") || e0.rigidbody.hasEvent("triggerleave"));
          const e1BodyEvents = e12.rigidbody && (e12.rigidbody.hasEvent("triggerenter") || e12.rigidbody.hasEvent("triggerleave"));
          if (e0Events) {
            newCollision = this._storeCollision(e0, e12);
            if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
              e0.collision.fire("triggerenter", e12);
            }
          }
          if (e1Events) {
            newCollision = this._storeCollision(e12, e0);
            if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
              e12.collision.fire("triggerenter", e0);
            }
          }
          if (e0BodyEvents) {
            if (!newCollision) {
              newCollision = this._storeCollision(e12, e0);
            }
            if (newCollision) {
              e0.rigidbody.fire("triggerenter", e12);
            }
          }
          if (e1BodyEvents) {
            if (!newCollision) {
              newCollision = this._storeCollision(e0, e12);
            }
            if (newCollision) {
              e12.rigidbody.fire("triggerenter", e0);
            }
          }
        } else {
          const e0Events = this._hasContactEvent(e0);
          const e1Events = this._hasContactEvent(e12);
          const globalEvents = this.hasEvent("contact");
          if (globalEvents || e0Events || e1Events) {
            for (let j = 0; j < numContacts; j++) {
              const btContactPoint = manifold.getContactPoint(j);
              const contactPoint = this._createContactPointFromAmmo(btContactPoint);
              if (e0Events || e1Events) {
                forwardContacts.push(contactPoint);
                const reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);
                reverseContacts.push(reverseContactPoint);
              }
              if (globalEvents) {
                const result = this._createSingleContactResult(e0, e12, contactPoint);
                this.fire("contact", result);
              }
            }
            if (e0Events) {
              const forwardResult = this._createContactResult(e12, forwardContacts);
              newCollision = this._storeCollision(e0, e12);
              if (e0.collision) {
                e0.collision.fire("contact", forwardResult);
                if (newCollision) {
                  e0.collision.fire("collisionstart", forwardResult);
                }
              }
              if (e0.rigidbody) {
                e0.rigidbody.fire("contact", forwardResult);
                if (newCollision) {
                  e0.rigidbody.fire("collisionstart", forwardResult);
                }
              }
            }
            if (e1Events) {
              const reverseResult = this._createContactResult(e0, reverseContacts);
              newCollision = this._storeCollision(e12, e0);
              if (e12.collision) {
                e12.collision.fire("contact", reverseResult);
                if (newCollision) {
                  e12.collision.fire("collisionstart", reverseResult);
                }
              }
              if (e12.rigidbody) {
                e12.rigidbody.fire("contact", reverseResult);
                if (newCollision) {
                  e12.rigidbody.fire("collisionstart", reverseResult);
                }
              }
            }
          }
        }
      }
    }
    this._cleanOldCollisions();
    this.contactPointPool.freeAll();
    this.contactResultPool.freeAll();
    this.singleContactResultPool.freeAll();
  }
  onUpdate(dt) {
    let i, len;
    this._gravityFloat32[0] = this.gravity.x;
    this._gravityFloat32[1] = this.gravity.y;
    this._gravityFloat32[2] = this.gravity.z;
    const gravity = this.dynamicsWorld.getGravity();
    if (gravity.x() !== this._gravityFloat32[0] || gravity.y() !== this._gravityFloat32[1] || gravity.z() !== this._gravityFloat32[2]) {
      gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
      this.dynamicsWorld.setGravity(gravity);
    }
    const triggers = this._triggers;
    for (i = 0, len = triggers.length; i < len; i++) {
      triggers[i].updateTransform();
    }
    const compounds = this._compounds;
    for (i = 0, len = compounds.length; i < len; i++) {
      compounds[i]._updateCompound();
    }
    const kinematic = this._kinematic;
    for (i = 0, len = kinematic.length; i < len; i++) {
      kinematic[i]._updateKinematic();
    }
    this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
    const dynamic = this._dynamic;
    for (i = 0, len = dynamic.length; i < len; i++) {
      dynamic[i]._updateDynamic();
    }
    if (!this.dynamicsWorld.setInternalTickCallback) {
      this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
    }
  }
  destroy() {
    super.destroy();
    this.app.systems.off("update", this.onUpdate, this);
    if (typeof Ammo !== "undefined") {
      Ammo.destroy(this.dynamicsWorld);
      Ammo.destroy(this.solver);
      Ammo.destroy(this.overlappingPairCache);
      Ammo.destroy(this.dispatcher);
      Ammo.destroy(this.collisionConfiguration);
      this.dynamicsWorld = null;
      this.solver = null;
      this.overlappingPairCache = null;
      this.dispatcher = null;
      this.collisionConfiguration = null;
    }
  }
};
RigidBodyComponentSystem.EVENT_CONTACT = "contact";
Component._buildAccessors(RigidBodyComponent.prototype, _schema13);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/screen/constants.js
var SCALEMODE_NONE = "none";
var SCALEMODE_BLEND = "blend";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/screen/component.js
var _transform = new Mat4();
var ScreenComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._resolution = new Vec2(640, 320);
    this._referenceResolution = new Vec2(640, 320);
    this._scaleMode = SCALEMODE_NONE;
    this.scale = 1;
    this._scaleBlend = 0.5;
    this._priority = 0;
    this._screenSpace = false;
    this.cull = this._screenSpace;
    this._screenMatrix = new Mat4();
    this._elements = /* @__PURE__ */ new Set();
    system.app.graphicsDevice.on("resizecanvas", this._onResize, this);
  }
  syncDrawOrder() {
    this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
  }
  _recurseDrawOrderSync(e, i) {
    if (!(e instanceof Entity)) {
      return i;
    }
    if (e.element) {
      const prevDrawOrder = e.element.drawOrder;
      e.element.drawOrder = i++;
      if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {
        var _this$system$app$batc;
        (_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.markGroupDirty(e.element._batchGroupId);
      }
    }
    if (e.particlesystem) {
      e.particlesystem.drawOrder = i++;
    }
    const children = e.children;
    for (let j = 0; j < children.length; j++) {
      i = this._recurseDrawOrderSync(children[j], i);
    }
    return i;
  }
  _processDrawOrderSync() {
    const i = 1;
    this._recurseDrawOrderSync(this.entity, i);
    this.fire("syncdraworder");
  }
  _calcProjectionMatrix() {
    const w = this._resolution.x / this.scale;
    const h2 = this._resolution.y / this.scale;
    const left = 0;
    const right = w;
    const bottom = -h2;
    const top = 0;
    const near = 1;
    const far = -1;
    this._screenMatrix.setOrtho(left, right, bottom, top, near, far);
    if (!this._screenSpace) {
      _transform.setScale(0.5 * w, 0.5 * h2, 1);
      this._screenMatrix.mul2(_transform, this._screenMatrix);
    }
  }
  _updateScale() {
    this.scale = this._calcScale(this._resolution, this.referenceResolution);
  }
  _calcScale(resolution, referenceResolution) {
    const lx = Math.log2((resolution.x || 1) / referenceResolution.x);
    const ly = Math.log2((resolution.y || 1) / referenceResolution.y);
    return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
  }
  _onResize(width, height) {
    if (this._screenSpace) {
      this._resolution.set(width, height);
      this.resolution = this._resolution;
    }
  }
  _bindElement(element) {
    this._elements.add(element);
  }
  _unbindElement(element) {
    this._elements.delete(element);
  }
  onRemove() {
    this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this);
    this.fire("remove");
    this._elements.forEach((element) => element._onScreenRemove());
    this._elements.clear();
    this.off();
  }
  set resolution(value) {
    if (!this._screenSpace) {
      this._resolution.set(value.x, value.y);
    } else {
      this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
    }
    this._updateScale();
    this._calcProjectionMatrix();
    if (!this.entity._dirtyLocal) {
      this.entity._dirtifyLocal();
    }
    this.fire("set:resolution", this._resolution);
    this._elements.forEach((element) => element._onScreenResize(this._resolution));
  }
  get resolution() {
    return this._resolution;
  }
  set referenceResolution(value) {
    this._referenceResolution.set(value.x, value.y);
    this._updateScale();
    this._calcProjectionMatrix();
    if (!this.entity._dirtyLocal) {
      this.entity._dirtifyLocal();
    }
    this.fire("set:referenceresolution", this._resolution);
    this._elements.forEach((element) => element._onScreenResize(this._resolution));
  }
  get referenceResolution() {
    if (this._scaleMode === SCALEMODE_NONE) {
      return this._resolution;
    }
    return this._referenceResolution;
  }
  set screenSpace(value) {
    this._screenSpace = value;
    if (this._screenSpace) {
      this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
    }
    this.resolution = this._resolution;
    if (!this.entity._dirtyLocal) {
      this.entity._dirtifyLocal();
    }
    this.fire("set:screenspace", this._screenSpace);
    this._elements.forEach((element) => element._onScreenSpaceChange());
  }
  get screenSpace() {
    return this._screenSpace;
  }
  set scaleMode(value) {
    if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
      value = SCALEMODE_NONE;
    }
    if (!this._screenSpace && value !== SCALEMODE_NONE) {
      value = SCALEMODE_NONE;
    }
    this._scaleMode = value;
    this.resolution = this._resolution;
    this.fire("set:scalemode", this._scaleMode);
  }
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleBlend(value) {
    this._scaleBlend = value;
    this._updateScale();
    this._calcProjectionMatrix();
    if (!this.entity._dirtyLocal) {
      this.entity._dirtifyLocal();
    }
    this.fire("set:scaleblend", this._scaleBlend);
    this._elements.forEach((element) => element._onScreenResize(this._resolution));
  }
  get scaleBlend() {
    return this._scaleBlend;
  }
  set priority(value) {
    if (value > 255) {
      value = 255;
    }
    if (this._priority === value) {
      return;
    }
    this._priority = value;
    this.syncDrawOrder();
  }
  get priority() {
    return this._priority;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/screen/data.js
var ScreenComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/screen/system.js
var _schema14 = ["enabled"];
var ScreenComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "screen";
    this.ComponentType = ScreenComponent;
    this.DataType = ScreenComponentData;
    this.schema = _schema14;
    this.windowResolution = new Vec2();
    this._drawOrderSyncQueue = new IndexedList();
    this.app.graphicsDevice.on("resizecanvas", this._onResize, this);
    this.app.systems.on("update", this._onUpdate, this);
    this.on("beforeremove", this.onRemoveComponent, this);
  }
  initializeComponentData(component, data2, properties3) {
    if (data2.priority !== void 0) component.priority = data2.priority;
    if (data2.screenSpace !== void 0) component.screenSpace = data2.screenSpace;
    component.cull = component.screenSpace;
    if (data2.scaleMode !== void 0) component.scaleMode = data2.scaleMode;
    if (data2.scaleBlend !== void 0) component.scaleBlend = data2.scaleBlend;
    if (data2.resolution !== void 0) {
      if (data2.resolution instanceof Vec2) {
        component._resolution.copy(data2.resolution);
      } else {
        component._resolution.set(data2.resolution[0], data2.resolution[1]);
      }
      component.resolution = component._resolution;
    }
    if (data2.referenceResolution !== void 0) {
      if (data2.referenceResolution instanceof Vec2) {
        component._referenceResolution.copy(data2.referenceResolution);
      } else {
        component._referenceResolution.set(data2.referenceResolution[0], data2.referenceResolution[1]);
      }
      component.referenceResolution = component._referenceResolution;
    }
    component.syncDrawOrder();
    super.initializeComponentData(component, data2, properties3);
  }
  destroy() {
    super.destroy();
    this.app.graphicsDevice.off("resizecanvas", this._onResize, this);
    this.app.systems.off("update", this._onUpdate, this);
  }
  _onUpdate(dt) {
    const components2 = this.store;
    for (const id13 in components2) {
      if (components2[id13].entity.screen.update) components2[id13].entity.screen.update(dt);
    }
  }
  _onResize(width, height) {
    this.windowResolution.x = width;
    this.windowResolution.y = height;
  }
  cloneComponent(entity, clone) {
    const screen = entity.screen;
    return this.addComponent(clone, {
      enabled: screen.enabled,
      screenSpace: screen.screenSpace,
      scaleMode: screen.scaleMode,
      resolution: screen.resolution.clone(),
      referenceResolution: screen.referenceResolution.clone()
    });
  }
  onRemoveComponent(entity, component) {
    component.onRemove();
  }
  processDrawOrderSyncQueue() {
    const list = this._drawOrderSyncQueue.list();
    for (let i = 0; i < list.length; i++) {
      const item = list[i];
      item.callback.call(item.scope);
    }
    this._drawOrderSyncQueue.clear();
  }
  queueDrawOrderSync(id13, fn, scope) {
    if (!this._drawOrderSyncQueue.list().length) {
      this.app.once("prerender", this.processDrawOrderSyncQueue, this);
    }
    if (!this._drawOrderSyncQueue.has(id13)) {
      this._drawOrderSyncQueue.push(id13, {
        callback: fn,
        scope
      });
    }
  }
};
Component._buildAccessors(ScreenComponent.prototype, _schema14);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/element/element-drag-helper.js
var _inputScreenPosition = new Vec2();
var _inputWorldPosition = new Vec3();
var _ray = new Ray();
var _plane = new Plane();
var _normal = new Vec3();
var _point2 = new Vec3();
var _entityRotation = new Quat();
var OPPOSITE_AXIS = {
  x: "y",
  y: "x"
};
var ElementDragHelper = class extends EventHandler {
  constructor(element, axis) {
    super();
    if (!element || !(element instanceof ElementComponent)) {
      throw new Error("Element was null or not an ElementComponent");
    }
    if (axis && axis !== "x" && axis !== "y") {
      throw new Error(`Unrecognized axis: ${axis}`);
    }
    this._element = element;
    this._app = element.system.app;
    this._axis = axis || null;
    this._enabled = true;
    this._dragScale = new Vec3();
    this._dragStartMousePosition = new Vec3();
    this._dragStartHandlePosition = new Vec3();
    this._deltaMousePosition = new Vec3();
    this._deltaHandlePosition = new Vec3();
    this._isDragging = false;
    this._toggleLifecycleListeners("on");
  }
  _toggleLifecycleListeners(onOrOff) {
    this._element[onOrOff]("mousedown", this._onMouseDownOrTouchStart, this);
    this._element[onOrOff]("touchstart", this._onMouseDownOrTouchStart, this);
    this._element[onOrOff]("selectstart", this._onMouseDownOrTouchStart, this);
  }
  _toggleDragListeners(onOrOff) {
    const isOn = onOrOff === "on";
    if (this._hasDragListeners && isOn) {
      return;
    }
    if (this._app.mouse) {
      this._element[onOrOff]("mousemove", this._onMove, this);
      this._element[onOrOff]("mouseup", this._onMouseUpOrTouchEnd, this);
    }
    if (platform.touch) {
      this._element[onOrOff]("touchmove", this._onMove, this);
      this._element[onOrOff]("touchend", this._onMouseUpOrTouchEnd, this);
      this._element[onOrOff]("touchcancel", this._onMouseUpOrTouchEnd, this);
    }
    this._element[onOrOff]("selectmove", this._onMove, this);
    this._element[onOrOff]("selectend", this._onMouseUpOrTouchEnd, this);
    this._hasDragListeners = isOn;
  }
  _onMouseDownOrTouchStart(event) {
    if (this._element && !this._isDragging && this.enabled) {
      this._dragCamera = event.camera;
      this._calculateDragScale();
      const currentMousePosition = this._screenToLocal(event);
      if (currentMousePosition) {
        this._toggleDragListeners("on");
        this._isDragging = true;
        this._dragStartMousePosition.copy(currentMousePosition);
        this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());
        this.fire("drag:start");
      }
    }
  }
  _onMouseUpOrTouchEnd() {
    if (this._isDragging) {
      this._isDragging = false;
      this._toggleDragListeners("off");
      this.fire("drag:end");
    }
  }
  _screenToLocal(event) {
    if (event.inputSource) {
      _ray.set(event.inputSource.getOrigin(), event.inputSource.getDirection());
    } else {
      this._determineInputPosition(event);
      this._chooseRayOriginAndDirection();
    }
    _normal.copy(this._element.entity.forward).mulScalar(-1);
    _plane.setFromPointNormal(this._element.entity.getPosition(), _normal);
    if (_plane.intersectsRay(_ray, _point2)) {
      _entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(_point2, _point2);
      _point2.mul(this._dragScale);
      return _point2;
    }
    return null;
  }
  _determineInputPosition(event) {
    const devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;
    if (typeof event.x !== "undefined" && typeof event.y !== "undefined") {
      _inputScreenPosition.x = event.x * devicePixelRatio;
      _inputScreenPosition.y = event.y * devicePixelRatio;
    } else if (event.changedTouches) {
      _inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
      _inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
    } else {
      console.warn("Could not determine position from input event");
    }
  }
  _chooseRayOriginAndDirection() {
    if (this._element.screen && this._element.screen.screen.screenSpace) {
      _ray.origin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);
      _ray.direction.copy(Vec3.FORWARD);
    } else {
      _inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));
      _ray.origin.copy(this._dragCamera.entity.getPosition());
      _ray.direction.copy(_inputWorldPosition).sub(_ray.origin).normalize();
    }
  }
  _calculateDragScale() {
    let current = this._element.entity.parent;
    const screen = this._element.screen && this._element.screen.screen;
    const isWithin2DScreen = screen && screen.screenSpace;
    const screenScale = isWithin2DScreen ? screen.scale : 1;
    const dragScale = this._dragScale;
    dragScale.set(screenScale, screenScale, screenScale);
    while (current) {
      dragScale.mul(current.getLocalScale());
      current = current.parent;
      if (isWithin2DScreen && current.screen) {
        break;
      }
    }
    dragScale.x = 1 / dragScale.x;
    dragScale.y = 1 / dragScale.y;
    dragScale.z = 0;
  }
  _onMove(event) {
    const {
      _element: element,
      _deltaMousePosition: deltaMousePosition,
      _deltaHandlePosition: deltaHandlePosition,
      _axis: axis
    } = this;
    if (element && this._isDragging && this.enabled && element.enabled && element.entity.enabled) {
      const currentMousePosition = this._screenToLocal(event);
      if (currentMousePosition) {
        deltaMousePosition.sub2(currentMousePosition, this._dragStartMousePosition);
        deltaHandlePosition.add2(this._dragStartHandlePosition, deltaMousePosition);
        if (axis) {
          const currentPosition = element.entity.getLocalPosition();
          const constrainedAxis = OPPOSITE_AXIS[axis];
          deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
        }
        element.entity.setLocalPosition(deltaHandlePosition);
        this.fire("drag:move", deltaHandlePosition);
      }
    }
  }
  destroy() {
    this._toggleLifecycleListeners("off");
    this._toggleDragListeners("off");
  }
  set enabled(value) {
    this._enabled = value;
  }
  get enabled() {
    return this._enabled;
  }
  get isDragging() {
    return this._isDragging;
  }
};
ElementDragHelper.EVENT_DRAGSTART = "drag:start";
ElementDragHelper.EVENT_DRAGEND = "drag:end";
ElementDragHelper.EVENT_DRAGMOVE = "drag:move";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/scroll-view/constants.js
var SCROLL_MODE_CLAMP = 0;
var SCROLL_MODE_BOUNCE = 1;
var SCROLL_MODE_INFINITE = 2;
var SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
var SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/scroll-view/component.js
var _tempScrollValue = new Vec2();
var ScrollViewComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._viewportReference = new EntityReference(this, "viewportEntity", {
      "element#gain": this._onViewportElementGain,
      "element#resize": this._onSetContentOrViewportSize
    });
    this._contentReference = new EntityReference(this, "contentEntity", {
      "element#gain": this._onContentElementGain,
      "element#lose": this._onContentElementLose,
      "element#resize": this._onSetContentOrViewportSize
    });
    this._scrollbarUpdateFlags = {};
    this._scrollbarReferences = {};
    this._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(this, "horizontalScrollbarEntity", {
      "scrollbar#set:value": this._onSetHorizontalScrollbarValue,
      "scrollbar#gain": this._onHorizontalScrollbarGain
    });
    this._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(this, "verticalScrollbarEntity", {
      "scrollbar#set:value": this._onSetVerticalScrollbarValue,
      "scrollbar#gain": this._onVerticalScrollbarGain
    });
    this._prevContentSizes = {};
    this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
    this._prevContentSizes[ORIENTATION_VERTICAL] = null;
    this._scroll = new Vec2();
    this._velocity = new Vec3();
    this._dragStartPosition = new Vec3();
    this._disabledContentInput = false;
    this._disabledContentInputEntities = [];
    this._toggleLifecycleListeners("on", system);
    this._toggleElementListeners("on");
  }
  get data() {
    const record = this.system.store[this.entity.getGuid()];
    return record ? record.data : null;
  }
  set enabled(arg) {
    this._setValue("enabled", arg);
  }
  get enabled() {
    return this.data.enabled;
  }
  set horizontal(arg) {
    this._setValue("horizontal", arg);
  }
  get horizontal() {
    return this.data.horizontal;
  }
  set vertical(arg) {
    this._setValue("vertical", arg);
  }
  get vertical() {
    return this.data.vertical;
  }
  set scrollMode(arg) {
    this._setValue("scrollMode", arg);
  }
  get scrollMode() {
    return this.data.scrollMode;
  }
  set bounceAmount(arg) {
    this._setValue("bounceAmount", arg);
  }
  get bounceAmount() {
    return this.data.bounceAmount;
  }
  set friction(arg) {
    this._setValue("friction", arg);
  }
  get friction() {
    return this.data.friction;
  }
  set dragThreshold(arg) {
    this._setValue("dragThreshold", arg);
  }
  get dragThreshold() {
    return this.data.dragThreshold;
  }
  set useMouseWheel(arg) {
    this._setValue("useMouseWheel", arg);
  }
  get useMouseWheel() {
    return this.data.useMouseWheel;
  }
  set mouseWheelSensitivity(arg) {
    this._setValue("mouseWheelSensitivity", arg);
  }
  get mouseWheelSensitivity() {
    return this.data.mouseWheelSensitivity;
  }
  set horizontalScrollbarVisibility(arg) {
    this._setValue("horizontalScrollbarVisibility", arg);
  }
  get horizontalScrollbarVisibility() {
    return this.data.horizontalScrollbarVisibility;
  }
  set verticalScrollbarVisibility(arg) {
    this._setValue("verticalScrollbarVisibility", arg);
  }
  get verticalScrollbarVisibility() {
    return this.data.verticalScrollbarVisibility;
  }
  set viewportEntity(arg) {
    this._setValue("viewportEntity", arg);
  }
  get viewportEntity() {
    return this.data.viewportEntity;
  }
  set contentEntity(arg) {
    this._setValue("contentEntity", arg);
  }
  get contentEntity() {
    return this.data.contentEntity;
  }
  set horizontalScrollbarEntity(arg) {
    this._setValue("horizontalScrollbarEntity", arg);
  }
  get horizontalScrollbarEntity() {
    return this.data.horizontalScrollbarEntity;
  }
  set verticalScrollbarEntity(arg) {
    this._setValue("verticalScrollbarEntity", arg);
  }
  get verticalScrollbarEntity() {
    return this.data.verticalScrollbarEntity;
  }
  set scroll(value) {
    this._onSetScroll(value.x, value.y);
  }
  get scroll() {
    return this._scroll;
  }
  _setValue(name, value) {
    const data2 = this.data;
    const oldValue = data2[name];
    data2[name] = value;
    this.fire("set", name, oldValue, value);
  }
  _toggleLifecycleListeners(onOrOff, system) {
    this[onOrOff]("set_horizontal", this._onSetHorizontalScrollingEnabled, this);
    this[onOrOff]("set_vertical", this._onSetVerticalScrollingEnabled, this);
    system.app.systems.element[onOrOff]("add", this._onElementComponentAdd, this);
    system.app.systems.element[onOrOff]("beforeremove", this._onElementComponentRemove, this);
  }
  _toggleElementListeners(onOrOff) {
    if (this.entity.element) {
      if (onOrOff === "on" && this._hasElementListeners) {
        return;
      }
      this.entity.element[onOrOff]("resize", this._onSetContentOrViewportSize, this);
      this.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);
      this._hasElementListeners = onOrOff === "on";
    }
  }
  _onElementComponentAdd(entity) {
    if (this.entity === entity) {
      this._toggleElementListeners("on");
    }
  }
  _onElementComponentRemove(entity) {
    if (this.entity === entity) {
      this._toggleElementListeners("off");
    }
  }
  _onViewportElementGain() {
    this._syncAll();
  }
  _onContentElementGain() {
    this._destroyDragHelper();
    this._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);
    this._contentDragHelper.on("drag:start", this._onContentDragStart, this);
    this._contentDragHelper.on("drag:end", this._onContentDragEnd, this);
    this._contentDragHelper.on("drag:move", this._onContentDragMove, this);
    this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
    this._prevContentSizes[ORIENTATION_VERTICAL] = null;
    this._syncAll();
  }
  _onContentElementLose() {
    this._destroyDragHelper();
  }
  _onContentDragStart() {
    if (this._contentReference.entity && this.enabled && this.entity.enabled) {
      this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
    }
  }
  _onContentDragEnd() {
    this._prevContentDragPosition = null;
    this._enableContentInput();
  }
  _onContentDragMove(position3) {
    if (this._contentReference.entity && this.enabled && this.entity.enabled) {
      this._wasDragged = true;
      this._setScrollFromContentPosition(position3);
      this._setVelocityFromContentPositionDelta(position3);
      if (!this._disabledContentInput) {
        const dx = position3.x - this._dragStartPosition.x;
        const dy = position3.y - this._dragStartPosition.y;
        if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {
          this._disableContentInput();
        }
      }
    }
  }
  _onSetContentOrViewportSize() {
    this._syncAll();
  }
  _onSetHorizontalScrollbarValue(scrollValueX) {
    if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
      this._onSetScroll(scrollValueX, null);
    }
  }
  _onSetVerticalScrollbarValue(scrollValueY) {
    if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
      this._onSetScroll(null, scrollValueY);
    }
  }
  _onSetHorizontalScrollingEnabled() {
    this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
  }
  _onSetVerticalScrollingEnabled() {
    this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
  }
  _onHorizontalScrollbarGain() {
    this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
    this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
  }
  _onVerticalScrollbarGain() {
    this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
    this._syncScrollbarPosition(ORIENTATION_VERTICAL);
  }
  _onSetScroll(x2, y2, resetVelocity) {
    if (resetVelocity !== false) {
      this._velocity.set(0, 0, 0);
    }
    const xChanged = this._updateAxis(x2, "x", ORIENTATION_HORIZONTAL);
    const yChanged = this._updateAxis(y2, "y", ORIENTATION_VERTICAL);
    if (xChanged || yChanged) {
      this.fire("set:scroll", this._scroll);
    }
  }
  _updateAxis(scrollValue, axis, orientation) {
    const hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;
    if (hasChanged || this._isDragging() || scrollValue === 0) {
      this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);
      this._syncContentPosition(orientation);
      this._syncScrollbarPosition(orientation);
    }
    return hasChanged;
  }
  _determineNewScrollValue(scrollValue, axis, orientation) {
    if (!this._getScrollingEnabled(orientation)) {
      return this._scroll[axis];
    }
    switch (this.scrollMode) {
      case SCROLL_MODE_CLAMP:
        return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));
      case SCROLL_MODE_BOUNCE:
        this._setVelocityFromOvershoot(scrollValue, axis, orientation);
        return scrollValue;
      case SCROLL_MODE_INFINITE:
        return scrollValue;
      default:
        console.warn(`Unhandled scroll mode:${this.scrollMode}`);
        return scrollValue;
    }
  }
  _syncAll() {
    this._syncContentPosition(ORIENTATION_HORIZONTAL);
    this._syncContentPosition(ORIENTATION_VERTICAL);
    this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
    this._syncScrollbarPosition(ORIENTATION_VERTICAL);
    this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
    this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
  }
  _syncContentPosition(orientation) {
    const axis = this._getAxis(orientation);
    const sign = this._getSign(orientation);
    const contentEntity = this._contentReference.entity;
    if (contentEntity) {
      const prevContentSize = this._prevContentSizes[orientation];
      const currContentSize = this._getContentSize(orientation);
      if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
        const prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);
        const currMaxOffset = this._getMaxOffset(orientation, currContentSize);
        if (currMaxOffset === 0) {
          this._scroll[axis] = 1;
        } else {
          this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
        }
      }
      const offset = this._scroll[axis] * this._getMaxOffset(orientation);
      const contentPosition = contentEntity.getLocalPosition();
      contentPosition[axis] = offset * sign;
      contentEntity.setLocalPosition(contentPosition);
      this._prevContentSizes[orientation] = currContentSize;
    }
  }
  _syncScrollbarPosition(orientation) {
    const axis = this._getAxis(orientation);
    const scrollbarEntity = this._scrollbarReferences[orientation].entity;
    if (scrollbarEntity && scrollbarEntity.scrollbar) {
      this._scrollbarUpdateFlags[orientation] = true;
      scrollbarEntity.scrollbar.value = this._scroll[axis];
      scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
      this._scrollbarUpdateFlags[orientation] = false;
    }
  }
  _syncScrollbarEnabledState(orientation) {
    const entity = this._scrollbarReferences[orientation].entity;
    if (entity) {
      const isScrollingEnabled = this._getScrollingEnabled(orientation);
      const requestedVisibility = this._getScrollbarVisibility(orientation);
      switch (requestedVisibility) {
        case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
          entity.enabled = isScrollingEnabled;
          return;
        case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
          entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
          return;
        default:
          console.warn(`Unhandled scrollbar visibility:${requestedVisibility}`);
          entity.enabled = isScrollingEnabled;
      }
    }
  }
  _contentIsLargerThanViewport(orientation) {
    return this._getContentSize(orientation) > this._getViewportSize(orientation);
  }
  _contentPositionToScrollValue(contentPosition) {
    const maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);
    const maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);
    if (maxOffsetH === 0) {
      _tempScrollValue.x = 0;
    } else {
      _tempScrollValue.x = contentPosition.x / maxOffsetH;
    }
    if (maxOffsetV === 0) {
      _tempScrollValue.y = 0;
    } else {
      _tempScrollValue.y = contentPosition.y / -maxOffsetV;
    }
    return _tempScrollValue;
  }
  _getMaxOffset(orientation, contentSize) {
    contentSize = contentSize === void 0 ? this._getContentSize(orientation) : contentSize;
    const viewportSize = this._getViewportSize(orientation);
    if (contentSize < viewportSize) {
      return -this._getViewportSize(orientation);
    }
    return viewportSize - contentSize;
  }
  _getMaxScrollValue(orientation) {
    return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
  }
  _getScrollbarHandleSize(axis, orientation) {
    const viewportSize = this._getViewportSize(orientation);
    const contentSize = this._getContentSize(orientation);
    if (Math.abs(contentSize) < 1e-3) {
      return 1;
    }
    const handleSize = Math.min(viewportSize / contentSize, 1);
    const overshoot = this._toOvershoot(this._scroll[axis], orientation);
    if (overshoot === 0) {
      return handleSize;
    }
    return handleSize / (1 + Math.abs(overshoot));
  }
  _getViewportSize(orientation) {
    return this._getSize(orientation, this._viewportReference);
  }
  _getContentSize(orientation) {
    return this._getSize(orientation, this._contentReference);
  }
  _getSize(orientation, entityReference) {
    if (entityReference.entity && entityReference.entity.element) {
      return entityReference.entity.element[this._getCalculatedDimension(orientation)];
    }
    return 0;
  }
  _getScrollingEnabled(orientation) {
    if (orientation === ORIENTATION_HORIZONTAL) {
      return this.horizontal;
    } else if (orientation === ORIENTATION_VERTICAL) {
      return this.vertical;
    }
    return void 0;
  }
  _getScrollbarVisibility(orientation) {
    if (orientation === ORIENTATION_HORIZONTAL) {
      return this.horizontalScrollbarVisibility;
    } else if (orientation === ORIENTATION_VERTICAL) {
      return this.verticalScrollbarVisibility;
    }
    return void 0;
  }
  _getSign(orientation) {
    return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
  }
  _getAxis(orientation) {
    return orientation === ORIENTATION_HORIZONTAL ? "x" : "y";
  }
  _getCalculatedDimension(orientation) {
    return orientation === ORIENTATION_HORIZONTAL ? "calculatedWidth" : "calculatedHeight";
  }
  _destroyDragHelper() {
    if (this._contentDragHelper) {
      this._contentDragHelper.destroy();
    }
  }
  onUpdate() {
    if (this._contentReference.entity) {
      this._updateVelocity();
      this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
      this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
    }
  }
  _updateVelocity() {
    if (!this._isDragging()) {
      if (this.scrollMode === SCROLL_MODE_BOUNCE) {
        if (this._hasOvershoot("x", ORIENTATION_HORIZONTAL)) {
          this._setVelocityFromOvershoot(this.scroll.x, "x", ORIENTATION_HORIZONTAL);
        }
        if (this._hasOvershoot("y", ORIENTATION_VERTICAL)) {
          this._setVelocityFromOvershoot(this.scroll.y, "y", ORIENTATION_VERTICAL);
        }
      }
      if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
        const position3 = this._contentReference.entity.getLocalPosition();
        position3.x += this._velocity.x;
        position3.y += this._velocity.y;
        this._contentReference.entity.setLocalPosition(position3);
        this._setScrollFromContentPosition(position3);
      }
      this._velocity.x *= 1 - this.friction;
      this._velocity.y *= 1 - this.friction;
    }
  }
  _hasOvershoot(axis, orientation) {
    return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 1e-3;
  }
  _toOvershoot(scrollValue, orientation) {
    const maxScrollValue = this._getMaxScrollValue(orientation);
    if (scrollValue < 0) {
      return scrollValue;
    } else if (scrollValue > maxScrollValue) {
      return scrollValue - maxScrollValue;
    }
    return 0;
  }
  _setVelocityFromOvershoot(scrollValue, axis, orientation) {
    const overshootValue = this._toOvershoot(scrollValue, orientation);
    const overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);
    if (Math.abs(overshootPixels) > 0) {
      this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
    }
  }
  _setVelocityFromContentPositionDelta(position3) {
    if (this._prevContentDragPosition) {
      this._velocity.sub2(position3, this._prevContentDragPosition);
      this._prevContentDragPosition.copy(position3);
    } else {
      this._velocity.set(0, 0, 0);
      this._prevContentDragPosition = position3.clone();
    }
  }
  _setScrollFromContentPosition(position3) {
    let scrollValue = this._contentPositionToScrollValue(position3);
    if (this._isDragging()) {
      scrollValue = this._applyScrollValueTension(scrollValue);
    }
    this._onSetScroll(scrollValue.x, scrollValue.y, false);
  }
  _applyScrollValueTension(scrollValue) {
    const factor = 1;
    let max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);
    let overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);
    if (overshoot > 0) {
      scrollValue.x = max + factor * Math.log10(1 + overshoot);
    } else if (overshoot < 0) {
      scrollValue.x = -factor * Math.log10(1 - overshoot);
    }
    max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
    overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);
    if (overshoot > 0) {
      scrollValue.y = max + factor * Math.log10(1 + overshoot);
    } else if (overshoot < 0) {
      scrollValue.y = -factor * Math.log10(1 - overshoot);
    }
    return scrollValue;
  }
  _isDragging() {
    return this._contentDragHelper && this._contentDragHelper.isDragging;
  }
  _setScrollbarComponentsEnabled(enabled) {
    if (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent("scrollbar")) {
      this._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
    }
    if (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent("scrollbar")) {
      this._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
    }
  }
  _setContentDraggingEnabled(enabled) {
    if (this._contentDragHelper) {
      this._contentDragHelper.enabled = enabled;
    }
  }
  _onMouseWheel(event) {
    if (this.useMouseWheel) {
      const wheelEvent = event.event;
      const normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;
      const normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;
      const scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));
      const scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));
      this.scroll = new Vec2(scrollX, scrollY);
    }
  }
  _enableContentInput() {
    while (this._disabledContentInputEntities.length) {
      const e = this._disabledContentInputEntities.pop();
      if (e.element) {
        e.element.useInput = true;
      }
    }
    this._disabledContentInput = false;
  }
  _disableContentInput() {
    const _disableInput = (e) => {
      if (e.element && e.element.useInput) {
        this._disabledContentInputEntities.push(e);
        e.element.useInput = false;
      }
      const children = e.children;
      for (let i = 0, l = children.length; i < l; i++) {
        _disableInput(children[i]);
      }
    };
    const contentEntity = this._contentReference.entity;
    if (contentEntity) {
      const children = contentEntity.children;
      for (let i = 0, l = children.length; i < l; i++) {
        _disableInput(children[i]);
      }
    }
    this._disabledContentInput = true;
  }
  onEnable() {
    this._viewportReference.onParentComponentEnable();
    this._contentReference.onParentComponentEnable();
    this._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();
    this._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();
    this._setScrollbarComponentsEnabled(true);
    this._setContentDraggingEnabled(true);
    this._syncAll();
  }
  onDisable() {
    this._setScrollbarComponentsEnabled(false);
    this._setContentDraggingEnabled(false);
  }
  onRemove() {
    this._toggleLifecycleListeners("off", this.system);
    this._toggleElementListeners("off");
    this._destroyDragHelper();
  }
};
ScrollViewComponent.EVENT_SETSCROLL = "set:scroll";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/scroll-view/data.js
var DEFAULT_DRAG_THRESHOLD = 10;
var ScrollViewComponentData = class {
  constructor() {
    this.enabled = true;
    this.horizontal = void 0;
    this.vertical = void 0;
    this.scrollMode = void 0;
    this.bounceAmount = void 0;
    this.friction = void 0;
    this.dragThreshold = DEFAULT_DRAG_THRESHOLD;
    this.useMouseWheel = true;
    this.mouseWheelSensitivity = new Vec2(1, 1);
    this.horizontalScrollbarVisibility = void 0;
    this.verticalScrollbarVisibility = void 0;
    this.viewportEntity = void 0;
    this.contentEntity = void 0;
    this.horizontalScrollbarEntity = void 0;
    this.verticalScrollbarEntity = void 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/scroll-view/system.js
var _schema15 = [{
  name: "enabled",
  type: "boolean"
}, {
  name: "horizontal",
  type: "boolean"
}, {
  name: "vertical",
  type: "boolean"
}, {
  name: "scrollMode",
  type: "number"
}, {
  name: "bounceAmount",
  type: "number"
}, {
  name: "friction",
  type: "number"
}, {
  name: "dragThreshold",
  type: "number"
}, {
  name: "useMouseWheel",
  type: "boolean"
}, {
  name: "mouseWheelSensitivity",
  type: "vec2"
}, {
  name: "horizontalScrollbarVisibility",
  type: "number"
}, {
  name: "verticalScrollbarVisibility",
  type: "number"
}, {
  name: "viewportEntity",
  type: "entity"
}, {
  name: "contentEntity",
  type: "entity"
}, {
  name: "horizontalScrollbarEntity",
  type: "entity"
}, {
  name: "verticalScrollbarEntity",
  type: "entity"
}];
var DEFAULT_DRAG_THRESHOLD2 = 10;
var ScrollViewComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "scrollview";
    this.ComponentType = ScrollViewComponent;
    this.DataType = ScrollViewComponentData;
    this.schema = _schema15;
    this.on("beforeremove", this._onRemoveComponent, this);
    this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(component, data2, properties3) {
    if (data2.dragThreshold === void 0) {
      data2.dragThreshold = DEFAULT_DRAG_THRESHOLD2;
    }
    if (data2.useMouseWheel === void 0) {
      data2.useMouseWheel = true;
    }
    if (data2.mouseWheelSensitivity === void 0) {
      data2.mouseWheelSensitivity = new Vec2(1, 1);
    }
    super.initializeComponentData(component, data2, _schema15);
  }
  onUpdate(dt) {
    const components2 = this.store;
    for (const id13 in components2) {
      const entity = components2[id13].entity;
      const component = entity.scrollview;
      if (component.enabled && entity.enabled) {
        component.onUpdate();
      }
    }
  }
  _onRemoveComponent(entity, component) {
    component.onRemove();
  }
  destroy() {
    super.destroy();
    this.app.systems.off("update", this.onUpdate, this);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/scrollbar/component.js
var ScrollbarComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._handleReference = new EntityReference(this, "handleEntity", {
      "element#gain": this._onHandleElementGain,
      "element#lose": this._onHandleElementLose,
      "element#set:anchor": this._onSetHandleAlignment,
      "element#set:margin": this._onSetHandleAlignment,
      "element#set:pivot": this._onSetHandleAlignment
    });
    this._toggleLifecycleListeners("on");
  }
  get data() {
    const record = this.system.store[this.entity.getGuid()];
    return record ? record.data : null;
  }
  set enabled(arg) {
    this._setValue("enabled", arg);
  }
  get enabled() {
    return this.data.enabled;
  }
  set orientation(arg) {
    this._setValue("orientation", arg);
  }
  get orientation() {
    return this.data.orientation;
  }
  set value(arg) {
    this._setValue("value", arg);
  }
  get value() {
    return this.data.value;
  }
  set handleSize(arg) {
    this._setValue("handleSize", arg);
  }
  get handleSize() {
    return this.data.handleSize;
  }
  set handleEntity(arg) {
    this._setValue("handleEntity", arg);
  }
  get handleEntity() {
    return this.data.handleEntity;
  }
  _setValue(name, value) {
    const data2 = this.data;
    const oldValue = data2[name];
    data2[name] = value;
    this.fire("set", name, oldValue, value);
  }
  _toggleLifecycleListeners(onOrOff) {
    this[onOrOff]("set_value", this._onSetValue, this);
    this[onOrOff]("set_handleSize", this._onSetHandleSize, this);
    this[onOrOff]("set_orientation", this._onSetOrientation, this);
  }
  _onHandleElementGain() {
    this._destroyDragHelper();
    this._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());
    this._handleDragHelper.on("drag:move", this._onHandleDrag, this);
    this._updateHandlePositionAndSize();
  }
  _onHandleElementLose() {
    this._destroyDragHelper();
  }
  _onHandleDrag(position3) {
    if (this._handleReference.entity && this.enabled && this.entity.enabled) {
      this.value = this._handlePositionToScrollValue(position3[this._getAxis()]);
    }
  }
  _onSetValue(name, oldValue, newValue) {
    if (Math.abs(newValue - oldValue) > 1e-5) {
      this.data.value = math.clamp(newValue, 0, 1);
      this._updateHandlePositionAndSize();
      this.fire("set:value", this.data.value);
    }
  }
  _onSetHandleSize(name, oldValue, newValue) {
    if (Math.abs(newValue - oldValue) > 1e-5) {
      this.data.handleSize = math.clamp(newValue, 0, 1);
      this._updateHandlePositionAndSize();
    }
  }
  _onSetHandleAlignment() {
    this._updateHandlePositionAndSize();
  }
  _onSetOrientation(name, oldValue, newValue) {
    if (newValue !== oldValue && this._handleReference.hasComponent("element")) {
      this._handleReference.entity.element[this._getOppositeDimension()] = 0;
    }
  }
  _updateHandlePositionAndSize() {
    const handleEntity = this._handleReference.entity;
    const handleElement = handleEntity && handleEntity.element;
    if (handleEntity) {
      const position3 = handleEntity.getLocalPosition();
      position3[this._getAxis()] = this._getHandlePosition();
      this._handleReference.entity.setLocalPosition(position3);
    }
    if (handleElement) {
      handleElement[this._getDimension()] = this._getHandleLength();
    }
  }
  _handlePositionToScrollValue(handlePosition) {
    return handlePosition * this._getSign() / this._getUsableTrackLength();
  }
  _scrollValueToHandlePosition(value) {
    return value * this._getSign() * this._getUsableTrackLength();
  }
  _getUsableTrackLength() {
    return Math.max(this._getTrackLength() - this._getHandleLength(), 1e-3);
  }
  _getTrackLength() {
    if (this.entity.element) {
      return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
    }
    return 0;
  }
  _getHandleLength() {
    return this._getTrackLength() * this.handleSize;
  }
  _getHandlePosition() {
    return this._scrollValueToHandlePosition(this.value);
  }
  _getSign() {
    return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
  }
  _getAxis() {
    return this.orientation === ORIENTATION_HORIZONTAL ? "x" : "y";
  }
  _getDimension() {
    return this.orientation === ORIENTATION_HORIZONTAL ? "width" : "height";
  }
  _getOppositeDimension() {
    return this.orientation === ORIENTATION_HORIZONTAL ? "height" : "width";
  }
  _destroyDragHelper() {
    if (this._handleDragHelper) {
      this._handleDragHelper.destroy();
    }
  }
  _setHandleDraggingEnabled(enabled) {
    if (this._handleDragHelper) {
      this._handleDragHelper.enabled = enabled;
    }
  }
  onEnable() {
    this._handleReference.onParentComponentEnable();
    this._setHandleDraggingEnabled(true);
  }
  onDisable() {
    this._setHandleDraggingEnabled(false);
  }
  onRemove() {
    this._destroyDragHelper();
    this._toggleLifecycleListeners("off");
  }
};
ScrollbarComponent.EVENT_SETVALUE = "set:value";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/scrollbar/data.js
var ScrollbarComponentData = class {
  constructor() {
    this.enabled = true;
    this.orientation = ORIENTATION_HORIZONTAL;
    this.value = 0;
    this.handleSize = void 0;
    this.handleEntity = void 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/scrollbar/system.js
var _schema16 = [{
  name: "enabled",
  type: "boolean"
}, {
  name: "orientation",
  type: "number"
}, {
  name: "value",
  type: "number"
}, {
  name: "handleSize",
  type: "number"
}, {
  name: "handleEntity",
  type: "entity"
}];
var ScrollbarComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "scrollbar";
    this.ComponentType = ScrollbarComponent;
    this.DataType = ScrollbarComponentData;
    this.schema = _schema16;
    this.on("beforeremove", this._onRemoveComponent, this);
  }
  initializeComponentData(component, data2, properties3) {
    super.initializeComponentData(component, data2, _schema16);
  }
  _onRemoveComponent(entity, component) {
    component.onRemove();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/sound/slot.js
var instanceOptions = {
  volume: 0,
  pitch: 0,
  loop: false,
  startTime: 0,
  duration: 0,
  position: new Vec3(),
  maxDistance: 0,
  refDistance: 0,
  rollOffFactor: 0,
  distanceModel: 0,
  onPlay: null,
  onPause: null,
  onResume: null,
  onStop: null,
  onEnd: null
};
var SoundSlot = class extends EventHandler {
  constructor(component, name = "Untitled", options2 = {}) {
    super();
    this.name = void 0;
    this.instances = [];
    this._component = component;
    this._assets = component.system.app.assets;
    this._manager = component.system.manager;
    this.name = name;
    this._volume = options2.volume !== void 0 ? math.clamp(Number(options2.volume) || 0, 0, 1) : 1;
    this._pitch = options2.pitch !== void 0 ? Math.max(0.01, Number(options2.pitch) || 0) : 1;
    this._loop = !!(options2.loop !== void 0 ? options2.loop : false);
    this._duration = options2.duration > 0 ? options2.duration : null;
    this._startTime = Math.max(0, Number(options2.startTime) || 0);
    this._overlap = !!options2.overlap;
    this._autoPlay = !!options2.autoPlay;
    this._firstNode = null;
    this._lastNode = null;
    this._asset = options2.asset;
    if (this._asset instanceof Asset) {
      this._asset = this._asset.id;
    }
    this._onInstancePlayHandler = this._onInstancePlay.bind(this);
    this._onInstancePauseHandler = this._onInstancePause.bind(this);
    this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
    this._onInstanceStopHandler = this._onInstanceStop.bind(this);
    this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
  }
  play() {
    if (!this.overlap) {
      this.stop();
    }
    if (!this.isLoaded && !this._hasAsset()) {
      return void 0;
    }
    const instance = this._createInstance();
    this.instances.push(instance);
    if (!this.isLoaded) {
      const onLoad = function onLoad2(sound) {
        const playWhenLoaded = instance._playWhenLoaded;
        instance.sound = sound;
        if (playWhenLoaded) {
          instance.play();
        }
      };
      this.off("load", onLoad);
      this.once("load", onLoad);
      this.load();
    } else {
      instance.play();
    }
    return instance;
  }
  pause() {
    let paused = false;
    const instances = this.instances;
    for (let i = 0, len = instances.length; i < len; i++) {
      if (instances[i].pause()) {
        paused = true;
      }
    }
    return paused;
  }
  resume() {
    let resumed = false;
    const instances = this.instances;
    for (let i = 0, len = instances.length; i < len; i++) {
      if (instances[i].resume()) {
        resumed = true;
      }
    }
    return resumed;
  }
  stop() {
    let stopped = false;
    const instances = this.instances;
    let i = instances.length;
    while (i--) {
      instances[i].stop();
      stopped = true;
    }
    instances.length = 0;
    return stopped;
  }
  load() {
    if (!this._hasAsset()) {
      return;
    }
    const asset = this._assets.get(this._asset);
    if (!asset) {
      this._assets.off(`add:${this._asset}`, this._onAssetAdd, this);
      this._assets.once(`add:${this._asset}`, this._onAssetAdd, this);
      return;
    }
    asset.off("remove", this._onAssetRemoved, this);
    asset.on("remove", this._onAssetRemoved, this);
    if (!asset.resource) {
      asset.off("load", this._onAssetLoad, this);
      asset.once("load", this._onAssetLoad, this);
      this._assets.load(asset);
      return;
    }
    this.fire("load", asset.resource);
  }
  setExternalNodes(firstNode, lastNode) {
    if (!firstNode) {
      console.error("The firstNode must have a valid AudioNode");
      return;
    }
    if (!lastNode) {
      lastNode = firstNode;
    }
    this._firstNode = firstNode;
    this._lastNode = lastNode;
    if (!this._overlap) {
      const instances = this.instances;
      for (let i = 0, len = instances.length; i < len; i++) {
        instances[i].setExternalNodes(firstNode, lastNode);
      }
    }
  }
  clearExternalNodes() {
    this._firstNode = null;
    this._lastNode = null;
    if (!this._overlap) {
      const instances = this.instances;
      for (let i = 0, len = instances.length; i < len; i++) {
        instances[i].clearExternalNodes();
      }
    }
  }
  getExternalNodes() {
    return [this._firstNode, this._lastNode];
  }
  _hasAsset() {
    return this._asset != null;
  }
  _createInstance() {
    let instance = null;
    const component = this._component;
    let sound = null;
    if (this._hasAsset()) {
      const asset = this._assets.get(this._asset);
      if (asset) {
        sound = asset.resource;
      }
    }
    const data2 = instanceOptions;
    data2.volume = this._volume * component.volume;
    data2.pitch = this._pitch * component.pitch;
    data2.loop = this._loop;
    data2.startTime = this._startTime;
    data2.duration = this._duration;
    data2.onPlay = this._onInstancePlayHandler;
    data2.onPause = this._onInstancePauseHandler;
    data2.onResume = this._onInstanceResumeHandler;
    data2.onStop = this._onInstanceStopHandler;
    data2.onEnd = this._onInstanceEndHandler;
    if (component.positional) {
      data2.position.copy(component.entity.getPosition());
      data2.maxDistance = component.maxDistance;
      data2.refDistance = component.refDistance;
      data2.rollOffFactor = component.rollOffFactor;
      data2.distanceModel = component.distanceModel;
      instance = new SoundInstance3d(this._manager, sound, data2);
    } else {
      instance = new SoundInstance(this._manager, sound, data2);
    }
    if (this._firstNode) {
      instance.setExternalNodes(this._firstNode, this._lastNode);
    }
    return instance;
  }
  _onInstancePlay(instance) {
    this.fire("play", instance);
    this._component.fire("play", this, instance);
  }
  _onInstancePause(instance) {
    this.fire("pause", instance);
    this._component.fire("pause", this, instance);
  }
  _onInstanceResume(instance) {
    this.fire("resume", instance);
    this._component.fire("resume", this, instance);
  }
  _onInstanceStop(instance) {
    const idx = this.instances.indexOf(instance);
    if (idx !== -1) {
      this.instances.splice(idx, 1);
    }
    this.fire("stop", instance);
    this._component.fire("stop", this, instance);
  }
  _onInstanceEnd(instance) {
    const idx = this.instances.indexOf(instance);
    if (idx !== -1) {
      this.instances.splice(idx, 1);
    }
    this.fire("end", instance);
    this._component.fire("end", this, instance);
  }
  _onAssetAdd(asset) {
    this.load();
  }
  _onAssetLoad(asset) {
    this.load();
  }
  _onAssetRemoved(asset) {
    asset.off("remove", this._onAssetRemoved, this);
    this._assets.off(`add:${asset.id}`, this._onAssetAdd, this);
    this.stop();
  }
  updatePosition(position3) {
    const instances = this.instances;
    for (let i = 0, len = instances.length; i < len; i++) {
      instances[i].position = position3;
    }
  }
  set asset(value) {
    const old = this._asset;
    if (old) {
      this._assets.off(`add:${old}`, this._onAssetAdd, this);
      const oldAsset = this._assets.get(old);
      if (oldAsset) {
        oldAsset.off("remove", this._onAssetRemoved, this);
      }
    }
    this._asset = value;
    if (this._asset instanceof Asset) {
      this._asset = this._asset.id;
    }
    if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
      this.load();
    }
  }
  get asset() {
    return this._asset;
  }
  set autoPlay(value) {
    this._autoPlay = !!value;
  }
  get autoPlay() {
    return this._autoPlay;
  }
  set duration(value) {
    this._duration = Math.max(0, Number(value) || 0) || null;
    if (!this._overlap) {
      const instances = this.instances;
      for (let i = 0, len = instances.length; i < len; i++) {
        instances[i].duration = this._duration;
      }
    }
  }
  get duration() {
    let assetDuration = 0;
    if (this._hasAsset()) {
      const asset = this._assets.get(this._asset);
      assetDuration = asset != null && asset.resource ? asset.resource.duration : 0;
    }
    if (this._duration != null) {
      return this._duration % (assetDuration || 1);
    }
    return assetDuration;
  }
  get isLoaded() {
    if (this._hasAsset()) {
      const asset = this._assets.get(this._asset);
      if (asset) {
        return !!asset.resource;
      }
    }
    return false;
  }
  get isPaused() {
    const instances = this.instances;
    const len = instances.length;
    if (len === 0) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (!instances[i].isPaused) {
        return false;
      }
    }
    return true;
  }
  get isPlaying() {
    const instances = this.instances;
    for (let i = 0, len = instances.length; i < len; i++) {
      if (instances[i].isPlaying) {
        return true;
      }
    }
    return false;
  }
  get isStopped() {
    const instances = this.instances;
    for (let i = 0, len = instances.length; i < len; i++) {
      if (!instances[i].isStopped) {
        return false;
      }
    }
    return true;
  }
  set loop(value) {
    this._loop = !!value;
    const instances = this.instances;
    for (let i = 0, len = instances.length; i < len; i++) {
      instances[i].loop = this._loop;
    }
  }
  get loop() {
    return this._loop;
  }
  set overlap(value) {
    this._overlap = !!value;
  }
  get overlap() {
    return this._overlap;
  }
  set pitch(value) {
    this._pitch = Math.max(Number(value) || 0, 0.01);
    if (!this._overlap) {
      const instances = this.instances;
      for (let i = 0, len = instances.length; i < len; i++) {
        instances[i].pitch = this.pitch * this._component.pitch;
      }
    }
  }
  get pitch() {
    return this._pitch;
  }
  set startTime(value) {
    this._startTime = Math.max(0, Number(value) || 0);
    if (!this._overlap) {
      const instances = this.instances;
      for (let i = 0, len = instances.length; i < len; i++) {
        instances[i].startTime = this._startTime;
      }
    }
  }
  get startTime() {
    return this._startTime;
  }
  set volume(value) {
    this._volume = math.clamp(Number(value) || 0, 0, 1);
    if (!this._overlap) {
      const instances = this.instances;
      for (let i = 0, len = instances.length; i < len; i++) {
        instances[i].volume = this._volume * this._component.volume;
      }
    }
  }
  get volume() {
    return this._volume;
  }
};
SoundSlot.EVENT_PLAY = "play";
SoundSlot.EVENT_PAUSE = "pause";
SoundSlot.EVENT_RESUME = "resume";
SoundSlot.EVENT_STOP = "stop";
SoundSlot.EVENT_LOAD = "load";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/sound/component.js
var SoundComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._volume = 1;
    this._pitch = 1;
    this._positional = true;
    this._refDistance = 1;
    this._maxDistance = 1e4;
    this._rollOffFactor = 1;
    this._distanceModel = DISTANCE_LINEAR;
    this._slots = {};
    this._playingBeforeDisable = {};
  }
  _updateSoundInstances(property, value, isFactor) {
    const slots = this._slots;
    for (const key in slots) {
      const slot = slots[key];
      if (!slot.overlap) {
        const instances = slot.instances;
        for (let i = 0, len = instances.length; i < len; i++) {
          instances[i][property] = isFactor ? slot[property] * value : value;
        }
      }
    }
  }
  set distanceModel(value) {
    this._distanceModel = value;
    this._updateSoundInstances("distanceModel", value, false);
  }
  get distanceModel() {
    return this._distanceModel;
  }
  set maxDistance(value) {
    this._maxDistance = value;
    this._updateSoundInstances("maxDistance", value, false);
  }
  get maxDistance() {
    return this._maxDistance;
  }
  set refDistance(value) {
    this._refDistance = value;
    this._updateSoundInstances("refDistance", value, false);
  }
  get refDistance() {
    return this._refDistance;
  }
  set rollOffFactor(value) {
    this._rollOffFactor = value;
    this._updateSoundInstances("rollOffFactor", value, false);
  }
  get rollOffFactor() {
    return this._rollOffFactor;
  }
  set pitch(value) {
    this._pitch = value;
    this._updateSoundInstances("pitch", value, true);
  }
  get pitch() {
    return this._pitch;
  }
  set volume(value) {
    this._volume = value;
    this._updateSoundInstances("volume", value, true);
  }
  get volume() {
    return this._volume;
  }
  set positional(newValue) {
    this._positional = newValue;
    const slots = this._slots;
    for (const key in slots) {
      const slot = slots[key];
      if (!slot.overlap) {
        const instances = slot.instances;
        const oldLength = instances.length;
        for (let i = oldLength - 1; i >= 0; i--) {
          const isPlaying = instances[i].isPlaying || instances[i].isSuspended;
          const currentTime = instances[i].currentTime;
          if (isPlaying) {
            instances[i].stop();
          }
          const instance = slot._createInstance();
          if (isPlaying) {
            instance.play();
            instance.currentTime = currentTime;
          }
          instances.push(instance);
        }
      }
    }
  }
  get positional() {
    return this._positional;
  }
  set slots(newValue) {
    const oldValue = this._slots;
    if (oldValue) {
      for (const key in oldValue) {
        oldValue[key].stop();
      }
    }
    const slots = {};
    for (const key in newValue) {
      if (!(newValue[key] instanceof SoundSlot)) {
        if (newValue[key].name) {
          slots[newValue[key].name] = new SoundSlot(this, newValue[key].name, newValue[key]);
        }
      } else {
        slots[newValue[key].name] = newValue[key];
      }
    }
    this._slots = slots;
    if (this.enabled && this.entity.enabled) {
      this.onEnable();
    }
  }
  get slots() {
    return this._slots;
  }
  onEnable() {
    if (this.system._inTools) {
      return;
    }
    const slots = this._slots;
    const playingBeforeDisable = this._playingBeforeDisable;
    for (const key in slots) {
      const slot = slots[key];
      if (slot.autoPlay && slot.isStopped) {
        slot.play();
      } else if (playingBeforeDisable[key]) {
        slot.resume();
      } else if (!slot.isLoaded) {
        slot.load();
      }
    }
  }
  onDisable() {
    const slots = this._slots;
    const playingBeforeDisable = {};
    for (const key in slots) {
      if (!slots[key].overlap) {
        if (slots[key].isPlaying) {
          slots[key].pause();
          playingBeforeDisable[key] = true;
        }
      }
    }
    this._playingBeforeDisable = playingBeforeDisable;
  }
  onRemove() {
    this.off();
  }
  addSlot(name, options2) {
    const slots = this._slots;
    if (slots[name]) {
      return null;
    }
    const slot = new SoundSlot(this, name, options2);
    slots[name] = slot;
    if (slot.autoPlay && this.enabled && this.entity.enabled) {
      slot.play();
    }
    return slot;
  }
  removeSlot(name) {
    const slots = this._slots;
    if (slots[name]) {
      slots[name].stop();
      delete slots[name];
    }
  }
  slot(name) {
    return this._slots[name];
  }
  _getSlotProperty(name, property) {
    if (!this.enabled || !this.entity.enabled) {
      return void 0;
    }
    const slot = this._slots[name];
    if (!slot) {
      return void 0;
    }
    return slot[property];
  }
  isPlaying(name) {
    return this._getSlotProperty(name, "isPlaying") || false;
  }
  isLoaded(name) {
    return this._getSlotProperty(name, "isLoaded") || false;
  }
  isPaused(name) {
    return this._getSlotProperty(name, "isPaused") || false;
  }
  isStopped(name) {
    return this._getSlotProperty(name, "isStopped") || false;
  }
  play(name) {
    if (!this.enabled || !this.entity.enabled) {
      return null;
    }
    const slot = this._slots[name];
    if (!slot) {
      return null;
    }
    return slot.play();
  }
  pause(name) {
    const slots = this._slots;
    if (name) {
      const slot = slots[name];
      if (!slot) {
        return;
      }
      slot.pause();
    } else {
      for (const key in slots) {
        slots[key].pause();
      }
    }
  }
  resume(name) {
    const slots = this._slots;
    if (name) {
      const slot = slots[name];
      if (!slot) {
        return;
      }
      if (slot.isPaused) {
        slot.resume();
      }
    } else {
      for (const key in slots) {
        slots[key].resume();
      }
    }
  }
  stop(name) {
    const slots = this._slots;
    if (name) {
      const slot = slots[name];
      if (!slot) {
        return;
      }
      slot.stop();
    } else {
      for (const key in slots) {
        slots[key].stop();
      }
    }
  }
};
SoundComponent.EVENT_PLAY = "play";
SoundComponent.EVENT_PAUSE = "pause";
SoundComponent.EVENT_RESUME = "resume";
SoundComponent.EVENT_STOP = "stop";
SoundComponent.EVENT_END = "end";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/sound/data.js
var SoundComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/sound/system.js
var _schema17 = ["enabled"];
var SoundComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "sound";
    this.ComponentType = SoundComponent;
    this.DataType = SoundComponentData;
    this.schema = _schema17;
    this.manager = app2.soundManager;
    this.app.systems.on("update", this.onUpdate, this);
    this.on("beforeremove", this.onBeforeRemove, this);
  }
  set volume(volume) {
    this.manager.volume = volume;
  }
  get volume() {
    return this.manager.volume;
  }
  get context() {
    if (!hasAudioContext()) {
      return null;
    }
    return this.manager.context;
  }
  initializeComponentData(component, data2, properties3) {
    properties3 = ["volume", "pitch", "positional", "refDistance", "maxDistance", "rollOffFactor", "distanceModel", "slots"];
    for (let i = 0; i < properties3.length; i++) {
      if (data2.hasOwnProperty(properties3[i])) {
        component[properties3[i]] = data2[properties3[i]];
      }
    }
    super.initializeComponentData(component, data2, ["enabled"]);
  }
  cloneComponent(entity, clone) {
    const srcComponent = entity.sound;
    const srcSlots = srcComponent.slots;
    const slots = {};
    for (const key in srcSlots) {
      const srcSlot = srcSlots[key];
      slots[key] = {
        name: srcSlot.name,
        volume: srcSlot.volume,
        pitch: srcSlot.pitch,
        loop: srcSlot.loop,
        duration: srcSlot.duration,
        startTime: srcSlot.startTime,
        overlap: srcSlot.overlap,
        autoPlay: srcSlot.autoPlay,
        asset: srcSlot.asset
      };
    }
    const cloneData = {
      distanceModel: srcComponent.distanceModel,
      enabled: srcComponent.enabled,
      maxDistance: srcComponent.maxDistance,
      pitch: srcComponent.pitch,
      positional: srcComponent.positional,
      refDistance: srcComponent.refDistance,
      rollOffFactor: srcComponent.rollOffFactor,
      slots,
      volume: srcComponent.volume
    };
    return this.addComponent(clone, cloneData);
  }
  onUpdate(dt) {
    const store = this.store;
    for (const id13 in store) {
      if (store.hasOwnProperty(id13)) {
        const item = store[id13];
        const entity = item.entity;
        if (entity.enabled) {
          const component = entity.sound;
          if (component.enabled && component.positional) {
            const position3 = entity.getPosition();
            const slots = component.slots;
            for (const key in slots) {
              slots[key].updatePosition(position3);
            }
          }
        }
      }
    }
  }
  onBeforeRemove(entity, component) {
    const slots = component.slots;
    for (const key in slots) {
      if (!slots[key].overlap) {
        slots[key].stop();
      }
    }
    component.onRemove();
  }
  destroy() {
    super.destroy();
    this.app.systems.off("update", this.onUpdate, this);
  }
};
Component._buildAccessors(SoundComponent.prototype, _schema17);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/constants.js
var SPRITETYPE_SIMPLE = "simple";
var SPRITETYPE_ANIMATED = "animated";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/sprite-animation-clip.js
var SpriteAnimationClip = class extends EventHandler {
  constructor(component, data2) {
    super();
    this._component = component;
    this._frame = 0;
    this._sprite = null;
    this._spriteAsset = null;
    this.spriteAsset = data2.spriteAsset;
    this.name = data2.name;
    this.fps = data2.fps || 0;
    this.loop = data2.loop || false;
    this._playing = false;
    this._paused = false;
    this._time = 0;
  }
  get duration() {
    if (this._sprite) {
      const fps = this.fps || Number.MIN_VALUE;
      return this._sprite.frameKeys.length / Math.abs(fps);
    }
    return 0;
  }
  set frame(value) {
    this._setFrame(value);
    const fps = this.fps || Number.MIN_VALUE;
    this._setTime(this._frame / fps);
  }
  get frame() {
    return this._frame;
  }
  get isPaused() {
    return this._paused;
  }
  get isPlaying() {
    return this._playing;
  }
  set sprite(value) {
    if (this._sprite) {
      this._sprite.off("set:meshes", this._onSpriteMeshesChange, this);
      this._sprite.off("set:pixelsPerUnit", this._onSpritePpuChanged, this);
      this._sprite.off("set:atlas", this._onSpriteMeshesChange, this);
      if (this._sprite.atlas) {
        this._sprite.atlas.off("set:texture", this._onSpriteMeshesChange, this);
      }
    }
    this._sprite = value;
    if (this._sprite) {
      this._sprite.on("set:meshes", this._onSpriteMeshesChange, this);
      this._sprite.on("set:pixelsPerUnit", this._onSpritePpuChanged, this);
      this._sprite.on("set:atlas", this._onSpriteMeshesChange, this);
      if (this._sprite.atlas) {
        this._sprite.atlas.on("set:texture", this._onSpriteMeshesChange, this);
      }
    }
    if (this._component.currentClip === this) {
      let mi;
      if (!value || !value.atlas) {
        mi = this._component._meshInstance;
        if (mi) {
          mi.deleteParameter("texture_emissiveMap");
          mi.deleteParameter("texture_opacityMap");
        }
        this._component._hideModel();
      } else {
        if (value.atlas.texture) {
          mi = this._component._meshInstance;
          if (mi) {
            mi.setParameter("texture_emissiveMap", value.atlas.texture);
            mi.setParameter("texture_opacityMap", value.atlas.texture);
          }
          if (this._component.enabled && this._component.entity.enabled) {
            this._component._showModel();
          }
        }
        if (this.time && this.fps) {
          this.time = this.time;
        } else {
          this.frame = this.frame;
        }
      }
    }
  }
  get sprite() {
    return this._sprite;
  }
  set spriteAsset(value) {
    const assets = this._component.system.app.assets;
    let id13 = value;
    if (value instanceof Asset) {
      id13 = value.id;
    }
    if (this._spriteAsset !== id13) {
      if (this._spriteAsset) {
        const prev = assets.get(this._spriteAsset);
        if (prev) {
          this._unbindSpriteAsset(prev);
        }
      }
      this._spriteAsset = id13;
      if (this._spriteAsset) {
        const asset = assets.get(this._spriteAsset);
        if (!asset) {
          this.sprite = null;
          assets.on(`add:${this._spriteAsset}`, this._onSpriteAssetAdded, this);
        } else {
          this._bindSpriteAsset(asset);
        }
      } else {
        this.sprite = null;
      }
    }
  }
  get spriteAsset() {
    return this._spriteAsset;
  }
  set time(value) {
    this._setTime(value);
    if (this._sprite) {
      this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
    } else {
      this.frame = 0;
    }
  }
  get time() {
    return this._time;
  }
  _onSpriteAssetAdded(asset) {
    this._component.system.app.assets.off(`add:${asset.id}`, this._onSpriteAssetAdded, this);
    if (this._spriteAsset === asset.id) {
      this._bindSpriteAsset(asset);
    }
  }
  _bindSpriteAsset(asset) {
    asset.on("load", this._onSpriteAssetLoad, this);
    asset.on("remove", this._onSpriteAssetRemove, this);
    if (asset.resource) {
      this._onSpriteAssetLoad(asset);
    } else {
      this._component.system.app.assets.load(asset);
    }
  }
  _unbindSpriteAsset(asset) {
    if (!asset) {
      return;
    }
    asset.off("load", this._onSpriteAssetLoad, this);
    asset.off("remove", this._onSpriteAssetRemove, this);
    if (asset.resource && !asset.resource.atlas) {
      this._component.system.app.assets.off(`load:${asset.data.textureAtlasAsset}`, this._onTextureAtlasLoad, this);
    }
  }
  _onSpriteAssetLoad(asset) {
    if (!asset.resource) {
      this.sprite = null;
    } else {
      if (!asset.resource.atlas) {
        const atlasAssetId = asset.data.textureAtlasAsset;
        const assets = this._component.system.app.assets;
        assets.off(`load:${atlasAssetId}`, this._onTextureAtlasLoad, this);
        assets.once(`load:${atlasAssetId}`, this._onTextureAtlasLoad, this);
      } else {
        this.sprite = asset.resource;
      }
    }
  }
  _onTextureAtlasLoad(atlasAsset) {
    const spriteAsset = this._spriteAsset;
    if (spriteAsset instanceof Asset) {
      this._onSpriteAssetLoad(spriteAsset);
    } else {
      this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
    }
  }
  _onSpriteAssetRemove(asset) {
    this.sprite = null;
  }
  _onSpriteMeshesChange() {
    if (this._component.currentClip === this) {
      this._component._showFrame(this.frame);
    }
  }
  _onSpritePpuChanged() {
    if (this._component.currentClip === this) {
      if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
        this._component._showFrame(this.frame);
      }
    }
  }
  _update(dt) {
    if (this.fps === 0) return;
    if (!this._playing || this._paused || !this._sprite) return;
    const dir = this.fps < 0 ? -1 : 1;
    const time = this._time + dt * this._component.speed * dir;
    const duration = this.duration;
    const end = time > duration || time < 0;
    this._setTime(time);
    let frame = this.frame;
    if (this._sprite) {
      frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
    } else {
      frame = 0;
    }
    if (frame !== this._frame) {
      this._setFrame(frame);
    }
    if (end) {
      if (this.loop) {
        this.fire("loop");
        this._component.fire("loop", this);
      } else {
        this._playing = false;
        this._paused = false;
        this.fire("end");
        this._component.fire("end", this);
      }
    }
  }
  _setTime(value) {
    this._time = value;
    const duration = this.duration;
    if (this._time < 0) {
      if (this.loop) {
        this._time = this._time % duration + duration;
      } else {
        this._time = 0;
      }
    } else if (this._time > duration) {
      if (this.loop) {
        this._time %= duration;
      } else {
        this._time = duration;
      }
    }
  }
  _setFrame(value) {
    if (this._sprite) {
      this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
    } else {
      this._frame = value;
    }
    if (this._component.currentClip === this) {
      this._component._showFrame(this._frame);
    }
  }
  _destroy() {
    if (this._spriteAsset) {
      const assets = this._component.system.app.assets;
      this._unbindSpriteAsset(assets.get(this._spriteAsset));
    }
    if (this._sprite) {
      this.sprite = null;
    }
    if (this._spriteAsset) {
      this.spriteAsset = null;
    }
  }
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    this._paused = false;
    this.frame = 0;
    this.fire("play");
    this._component.fire("play", this);
  }
  pause() {
    if (!this._playing || this._paused) {
      return;
    }
    this._paused = true;
    this.fire("pause");
    this._component.fire("pause", this);
  }
  resume() {
    if (!this._paused) return;
    this._paused = false;
    this.fire("resume");
    this._component.fire("resume", this);
  }
  stop() {
    if (!this._playing) return;
    this._playing = false;
    this._paused = false;
    this._time = 0;
    this.frame = 0;
    this.fire("stop");
    this._component.fire("stop", this);
  }
};
SpriteAnimationClip.EVENT_PLAY = "play";
SpriteAnimationClip.EVENT_PAUSE = "pause";
SpriteAnimationClip.EVENT_RESUME = "resume";
SpriteAnimationClip.EVENT_STOP = "stop";
SpriteAnimationClip.EVENT_END = "end";
SpriteAnimationClip.EVENT_LOOP = "loop";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/component.js
var PARAM_EMISSIVE_MAP = "texture_emissiveMap";
var PARAM_OPACITY_MAP = "texture_opacityMap";
var PARAM_EMISSIVE = "material_emissive";
var PARAM_OPACITY = "material_opacity";
var PARAM_INNER_OFFSET = "innerOffset";
var PARAM_OUTER_SCALE = "outerScale";
var PARAM_ATLAS_RECT = "atlasRect";
var SpriteComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._type = SPRITETYPE_SIMPLE;
    this._material = system.defaultMaterial;
    this._color = new Color(1, 1, 1, 1);
    this._colorUniform = new Float32Array(3);
    this._speed = 1;
    this._flipX = false;
    this._flipY = false;
    this._width = 1;
    this._height = 1;
    this._drawOrder = 0;
    this._layers = [LAYERID_WORLD];
    this._outerScale = new Vec2(1, 1);
    this._outerScaleUniform = new Float32Array(2);
    this._innerOffset = new Vec4();
    this._innerOffsetUniform = new Float32Array(4);
    this._atlasRect = new Vec4();
    this._atlasRectUniform = new Float32Array(4);
    this._batchGroupId = -1;
    this._batchGroup = null;
    this._node = new GraphNode();
    this._model = new Model();
    this._model.graph = this._node;
    this._meshInstance = null;
    entity.addChild(this._model.graph);
    this._model._entity = entity;
    this._updateAabbFunc = this._updateAabb.bind(this);
    this._addedModel = false;
    this._autoPlayClip = null;
    this._clips = {};
    this._defaultClip = new SpriteAnimationClip(this, {
      name: this.entity.name,
      fps: 0,
      loop: false,
      spriteAsset: null
    });
    this._currentClip = this._defaultClip;
  }
  set type(value) {
    if (this._type === value) {
      return;
    }
    this._type = value;
    if (this._type === SPRITETYPE_SIMPLE) {
      this.stop();
      this._currentClip = this._defaultClip;
      if (this.enabled && this.entity.enabled) {
        this._currentClip.frame = this.frame;
        if (this._currentClip.sprite) {
          this._showModel();
        } else {
          this._hideModel();
        }
      }
    } else if (this._type === SPRITETYPE_ANIMATED) {
      this.stop();
      if (this._autoPlayClip) {
        this._tryAutoPlay();
      }
      if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
        this._showModel();
      } else {
        this._hideModel();
      }
    }
  }
  get type() {
    return this._type;
  }
  set frame(value) {
    this._currentClip.frame = value;
  }
  get frame() {
    return this._currentClip.frame;
  }
  set spriteAsset(value) {
    this._defaultClip.spriteAsset = value;
  }
  get spriteAsset() {
    return this._defaultClip._spriteAsset;
  }
  set sprite(value) {
    this._currentClip.sprite = value;
  }
  get sprite() {
    return this._currentClip.sprite;
  }
  set material(value) {
    this._material = value;
    if (this._meshInstance) {
      this._meshInstance.material = value;
    }
  }
  get material() {
    return this._material;
  }
  set color(value) {
    this._color.r = value.r;
    this._color.g = value.g;
    this._color.b = value.b;
    if (this._meshInstance) {
      this._colorUniform[0] = this._color.r;
      this._colorUniform[1] = this._color.g;
      this._colorUniform[2] = this._color.b;
      this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
    }
  }
  get color() {
    return this._color;
  }
  set opacity(value) {
    this._color.a = value;
    if (this._meshInstance) {
      this._meshInstance.setParameter(PARAM_OPACITY, value);
    }
  }
  get opacity() {
    return this._color.a;
  }
  set clips(value) {
    if (!value) {
      for (const name in this._clips) {
        this.removeClip(name);
      }
      return;
    }
    for (const name in this._clips) {
      let found = false;
      for (const key in value) {
        if (value[key].name === name) {
          found = true;
          this._clips[name].fps = value[key].fps;
          this._clips[name].loop = value[key].loop;
          if (value[key].hasOwnProperty("sprite")) {
            this._clips[name].sprite = value[key].sprite;
          } else if (value[key].hasOwnProperty("spriteAsset")) {
            this._clips[name].spriteAsset = value[key].spriteAsset;
          }
          break;
        }
      }
      if (!found) {
        this.removeClip(name);
      }
    }
    for (const key in value) {
      if (this._clips[value[key].name]) continue;
      this.addClip(value[key]);
    }
    if (this._autoPlayClip) {
      this._tryAutoPlay();
    }
    if (!this._currentClip || !this._currentClip.sprite) {
      this._hideModel();
    }
  }
  get clips() {
    return this._clips;
  }
  get currentClip() {
    return this._currentClip;
  }
  set speed(value) {
    this._speed = value;
  }
  get speed() {
    return this._speed;
  }
  set flipX(value) {
    if (this._flipX === value) return;
    this._flipX = value;
    this._updateTransform();
  }
  get flipX() {
    return this._flipX;
  }
  set flipY(value) {
    if (this._flipY === value) return;
    this._flipY = value;
    this._updateTransform();
  }
  get flipY() {
    return this._flipY;
  }
  set width(value) {
    if (value === this._width) return;
    this._width = value;
    this._outerScale.x = this._width;
    if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
      this._updateTransform();
    }
  }
  get width() {
    return this._width;
  }
  set height(value) {
    if (value === this._height) return;
    this._height = value;
    this._outerScale.y = this.height;
    if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
      this._updateTransform();
    }
  }
  get height() {
    return this._height;
  }
  set batchGroupId(value) {
    if (this._batchGroupId === value) {
      return;
    }
    const prev = this._batchGroupId;
    this._batchGroupId = value;
    if (this.entity.enabled && prev >= 0) {
      var _this$system$app$batc;
      (_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.SPRITE, prev, this.entity);
    }
    if (this.entity.enabled && value >= 0) {
      var _this$system$app$batc2;
      (_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.SPRITE, value, this.entity);
    } else {
      if (prev >= 0) {
        if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
          this._showModel();
        }
      }
    }
  }
  get batchGroupId() {
    return this._batchGroupId;
  }
  set autoPlayClip(value) {
    this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;
    this._tryAutoPlay();
  }
  get autoPlayClip() {
    return this._autoPlayClip;
  }
  set drawOrder(value) {
    this._drawOrder = value;
    if (this._meshInstance) {
      this._meshInstance.drawOrder = value;
    }
  }
  get drawOrder() {
    return this._drawOrder;
  }
  set layers(value) {
    if (this._addedModel) {
      this._hideModel();
    }
    this._layers = value;
    if (!this._meshInstance) {
      return;
    }
    if (this.enabled && this.entity.enabled) {
      this._showModel();
    }
  }
  get layers() {
    return this._layers;
  }
  get aabb() {
    if (this._meshInstance) {
      return this._meshInstance.aabb;
    }
    return null;
  }
  onEnable() {
    const app2 = this.system.app;
    const scene = app2.scene;
    scene.on("set:layers", this._onLayersChanged, this);
    if (scene.layers) {
      scene.layers.on("add", this._onLayerAdded, this);
      scene.layers.on("remove", this._onLayerRemoved, this);
    }
    this._showModel();
    if (this._autoPlayClip) {
      this._tryAutoPlay();
    }
    if (this._batchGroupId >= 0) {
      var _app$batcher;
      (_app$batcher = app2.batcher) == null || _app$batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
    }
  }
  onDisable() {
    const app2 = this.system.app;
    const scene = app2.scene;
    scene.off("set:layers", this._onLayersChanged, this);
    if (scene.layers) {
      scene.layers.off("add", this._onLayerAdded, this);
      scene.layers.off("remove", this._onLayerRemoved, this);
    }
    this.stop();
    this._hideModel();
    if (this._batchGroupId >= 0) {
      var _app$batcher2;
      (_app$batcher2 = app2.batcher) == null || _app$batcher2.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
    }
  }
  onDestroy() {
    var _this$_node;
    this._currentClip = null;
    if (this._defaultClip) {
      this._defaultClip._destroy();
      this._defaultClip = null;
    }
    for (const key in this._clips) {
      this._clips[key]._destroy();
    }
    this._clips = null;
    this._hideModel();
    this._model = null;
    (_this$_node = this._node) == null || _this$_node.remove();
    this._node = null;
    if (this._meshInstance) {
      this._meshInstance.material = null;
      this._meshInstance.mesh = null;
      this._meshInstance = null;
    }
  }
  _showModel() {
    if (this._addedModel) return;
    if (!this._meshInstance) return;
    const meshInstances = [this._meshInstance];
    for (let i = 0, len = this._layers.length; i < len; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.addMeshInstances(meshInstances);
      }
    }
    this._addedModel = true;
  }
  _hideModel() {
    if (!this._addedModel || !this._meshInstance) return;
    const meshInstances = [this._meshInstance];
    for (let i = 0, len = this._layers.length; i < len; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
      if (layer) {
        layer.removeMeshInstances(meshInstances);
      }
    }
    this._addedModel = false;
  }
  _showFrame(frame) {
    if (!this.sprite) return;
    const mesh = this.sprite.meshes[frame];
    if (!mesh) {
      if (this._meshInstance) {
        this._meshInstance.mesh = null;
        this._meshInstance.visible = false;
      }
      return;
    }
    let material;
    if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
      material = this.system.default9SlicedMaterialSlicedMode;
    } else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
      material = this.system.default9SlicedMaterialTiledMode;
    } else {
      material = this.system.defaultMaterial;
    }
    if (!this._meshInstance) {
      this._meshInstance = new MeshInstance(mesh, this._material, this._node);
      this._meshInstance.castShadow = false;
      this._meshInstance.receiveShadow = false;
      this._meshInstance.drawOrder = this._drawOrder;
      this._model.meshInstances.push(this._meshInstance);
      this._colorUniform[0] = this._color.r;
      this._colorUniform[1] = this._color.g;
      this._colorUniform[2] = this._color.b;
      this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
      this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);
      if (this.enabled && this.entity.enabled) {
        this._showModel();
      }
    }
    if (this._meshInstance.material !== material) {
      this._meshInstance.material = material;
    }
    if (this._meshInstance.mesh !== mesh) {
      this._meshInstance.mesh = mesh;
      this._meshInstance.visible = true;
      this._meshInstance._aabbVer = -1;
    }
    if (this.sprite.atlas && this.sprite.atlas.texture) {
      this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);
      this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
    } else {
      this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);
      this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
    }
    if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
      this._meshInstance._updateAabbFunc = this._updateAabbFunc;
      const frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];
      if (frameData) {
        const borderWidthScale = 2 / frameData.rect.z;
        const borderHeightScale = 2 / frameData.rect.w;
        this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
        const tex = this.sprite.atlas.texture;
        this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
      } else {
        this._innerOffset.set(0, 0, 0, 0);
      }
      this._innerOffsetUniform[0] = this._innerOffset.x;
      this._innerOffsetUniform[1] = this._innerOffset.y;
      this._innerOffsetUniform[2] = this._innerOffset.z;
      this._innerOffsetUniform[3] = this._innerOffset.w;
      this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);
      this._atlasRectUniform[0] = this._atlasRect.x;
      this._atlasRectUniform[1] = this._atlasRect.y;
      this._atlasRectUniform[2] = this._atlasRect.z;
      this._atlasRectUniform[3] = this._atlasRect.w;
      this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
    } else {
      this._meshInstance._updateAabbFunc = null;
    }
    this._updateTransform();
  }
  _updateTransform() {
    let scaleX = this.flipX ? -1 : 1;
    let scaleY = this.flipY ? -1 : 1;
    let posX = 0;
    let posY = 0;
    if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
      let w = 1;
      let h2 = 1;
      if (this.sprite.atlas) {
        const frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
        if (frameData) {
          w = frameData.rect.z;
          h2 = frameData.rect.w;
          posX = (0.5 - frameData.pivot.x) * this._width;
          posY = (0.5 - frameData.pivot.y) * this._height;
        }
      }
      const scaleMulX = w / this.sprite.pixelsPerUnit;
      const scaleMulY = h2 / this.sprite.pixelsPerUnit;
      this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));
      scaleX *= scaleMulX;
      scaleY *= scaleMulY;
      this._outerScale.x /= scaleMulX;
      this._outerScale.y /= scaleMulY;
      scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 1e-4, 1);
      scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 1e-4, 1);
      if (this._meshInstance) {
        this._outerScaleUniform[0] = this._outerScale.x;
        this._outerScaleUniform[1] = this._outerScale.y;
        this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);
      }
    }
    this._node.setLocalScale(scaleX, scaleY, 1);
    this._node.setLocalPosition(posX, posY, 0);
  }
  _updateAabb(aabb3) {
    aabb3.center.set(0, 0, 0);
    aabb3.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 1e-3);
    aabb3.setFromTransformedAabb(aabb3, this._node.getWorldTransform());
    return aabb3;
  }
  _tryAutoPlay() {
    if (!this._autoPlayClip) return;
    if (this.type !== SPRITETYPE_ANIMATED) return;
    const clip = this._clips[this._autoPlayClip];
    if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
      if (this.enabled && this.entity.enabled) {
        this.play(clip.name);
      }
    }
  }
  _onLayersChanged(oldComp, newComp) {
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
    if (this.enabled && this.entity.enabled) {
      this._showModel();
    }
  }
  _onLayerAdded(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
      layer.addMeshInstances([this._meshInstance]);
    }
  }
  _onLayerRemoved(layer) {
    if (!this._meshInstance) return;
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    layer.removeMeshInstances([this._meshInstance]);
  }
  removeModelFromLayers() {
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (!layer) continue;
      layer.removeMeshInstances([this._meshInstance]);
    }
  }
  addClip(data2) {
    const clip = new SpriteAnimationClip(this, {
      name: data2.name,
      fps: data2.fps,
      loop: data2.loop,
      spriteAsset: data2.spriteAsset
    });
    this._clips[data2.name] = clip;
    if (clip.name && clip.name === this._autoPlayClip) {
      this._tryAutoPlay();
    }
    return clip;
  }
  removeClip(name) {
    delete this._clips[name];
  }
  clip(name) {
    return this._clips[name];
  }
  play(name) {
    const clip = this._clips[name];
    const current = this._currentClip;
    if (current && current !== clip) {
      current._playing = false;
    }
    this._currentClip = clip;
    if (this._currentClip) {
      this._currentClip = clip;
      this._currentClip.play();
    }
    return clip;
  }
  pause() {
    if (this._currentClip === this._defaultClip) return;
    if (this._currentClip.isPlaying) {
      this._currentClip.pause();
    }
  }
  resume() {
    if (this._currentClip === this._defaultClip) return;
    if (this._currentClip.isPaused) {
      this._currentClip.resume();
    }
  }
  stop() {
    if (this._currentClip === this._defaultClip) return;
    this._currentClip.stop();
  }
};
SpriteComponent.EVENT_PLAY = "play";
SpriteComponent.EVENT_PAUSE = "pause";
SpriteComponent.EVENT_RESUME = "resume";
SpriteComponent.EVENT_STOP = "stop";
SpriteComponent.EVENT_END = "end";
SpriteComponent.EVENT_LOOP = "loop";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/data.js
var SpriteComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/system.js
var _schema18 = ["enabled"];
var SpriteComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "sprite";
    this.ComponentType = SpriteComponent;
    this.DataType = SpriteComponentData;
    this.schema = _schema18;
    this._defaultTexture = null;
    this._defaultMaterial = null;
    this._default9SlicedMaterialSlicedMode = null;
    this._default9SlicedMaterialTiledMode = null;
    this.app.systems.on("update", this.onUpdate, this);
    this.on("beforeremove", this.onBeforeRemove, this);
  }
  set defaultMaterial(material) {
    this._defaultMaterial = material;
  }
  get defaultMaterial() {
    if (!this._defaultMaterial) {
      const texture = new Texture(this.app.graphicsDevice, {
        width: 1,
        height: 1,
        format: PIXELFORMAT_RGBA8,
        name: "sprite"
      });
      const pixels = new Uint8Array(texture.lock());
      pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
      texture.unlock();
      const material = new StandardMaterial();
      material.diffuse.set(0, 0, 0);
      material.emissive.set(1, 1, 1);
      material.emissiveMap = texture;
      material.opacityMap = texture;
      material.opacityMapChannel = "a";
      material.useLighting = false;
      material.useTonemap = false;
      material.useFog = false;
      material.useSkybox = false;
      material.blendType = BLEND_PREMULTIPLIED;
      material.depthWrite = false;
      material.pixelSnap = false;
      material.cull = CULLFACE_NONE;
      material.update();
      this._defaultTexture = texture;
      this._defaultMaterial = material;
    }
    return this._defaultMaterial;
  }
  set default9SlicedMaterialSlicedMode(material) {
    this._default9SlicedMaterialSlicedMode = material;
  }
  get default9SlicedMaterialSlicedMode() {
    if (!this._default9SlicedMaterialSlicedMode) {
      const material = this.defaultMaterial.clone();
      material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
      material.update();
      this._default9SlicedMaterialSlicedMode = material;
    }
    return this._default9SlicedMaterialSlicedMode;
  }
  set default9SlicedMaterialTiledMode(material) {
    this._default9SlicedMaterialTiledMode = material;
  }
  get default9SlicedMaterialTiledMode() {
    if (!this._default9SlicedMaterialTiledMode) {
      const material = this.defaultMaterial.clone();
      material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
      material.update();
      this._default9SlicedMaterialTiledMode = material;
    }
    return this._default9SlicedMaterialTiledMode;
  }
  destroy() {
    super.destroy();
    this.app.systems.off("update", this.onUpdate, this);
    if (this._defaultTexture) {
      this._defaultTexture.destroy();
      this._defaultTexture = null;
    }
  }
  initializeComponentData(component, data2, properties3) {
    if (data2.enabled !== void 0) {
      component.enabled = data2.enabled;
    }
    component.type = data2.type;
    if (data2.layers && Array.isArray(data2.layers)) {
      component.layers = data2.layers.slice(0);
    }
    if (data2.drawOrder !== void 0) {
      component.drawOrder = data2.drawOrder;
    }
    if (data2.color !== void 0) {
      if (data2.color instanceof Color) {
        var _data$opacity;
        component.color.set(data2.color.r, data2.color.g, data2.color.b, (_data$opacity = data2.opacity) != null ? _data$opacity : 1);
      } else {
        var _data$opacity2;
        component.color.set(data2.color[0], data2.color[1], data2.color[2], (_data$opacity2 = data2.opacity) != null ? _data$opacity2 : 1);
      }
      component.color = component.color;
    }
    if (data2.opacity !== void 0) {
      component.opacity = data2.opacity;
    }
    if (data2.flipX !== void 0) {
      component.flipX = data2.flipX;
    }
    if (data2.flipY !== void 0) {
      component.flipY = data2.flipY;
    }
    if (data2.width !== void 0) {
      component.width = data2.width;
    }
    if (data2.height !== void 0) {
      component.height = data2.height;
    }
    if (data2.spriteAsset !== void 0) {
      component.spriteAsset = data2.spriteAsset;
    }
    if (data2.sprite) {
      component.sprite = data2.sprite;
    }
    if (data2.frame !== void 0) {
      component.frame = data2.frame;
    }
    if (data2.clips) {
      for (const name in data2.clips) {
        component.addClip(data2.clips[name]);
      }
    }
    if (data2.speed !== void 0) {
      component.speed = data2.speed;
    }
    if (data2.autoPlayClip) {
      component.autoPlayClip = data2.autoPlayClip;
    }
    component.batchGroupId = data2.batchGroupId === void 0 || data2.batchGroupId === null ? -1 : data2.batchGroupId;
    super.initializeComponentData(component, data2, properties3);
  }
  cloneComponent(entity, clone) {
    const source = entity.sprite;
    return this.addComponent(clone, {
      enabled: source.enabled,
      type: source.type,
      spriteAsset: source.spriteAsset,
      sprite: source.sprite,
      width: source.width,
      height: source.height,
      frame: source.frame,
      color: source.color.clone(),
      opacity: source.opacity,
      flipX: source.flipX,
      flipY: source.flipY,
      speed: source.speed,
      clips: source.clips,
      autoPlayClip: source.autoPlayClip,
      batchGroupId: source.batchGroupId,
      drawOrder: source.drawOrder,
      layers: source.layers.slice(0)
    });
  }
  onUpdate(dt) {
    const components2 = this.store;
    for (const id13 in components2) {
      if (components2.hasOwnProperty(id13)) {
        const component = components2[id13];
        if (component.data.enabled && component.entity.enabled) {
          const sprite = component.entity.sprite;
          if (sprite._currentClip) {
            sprite._currentClip._update(dt);
          }
        }
      }
    }
  }
  onBeforeRemove(entity, component) {
    component.onDestroy();
  }
};
Component._buildAccessors(SpriteComponent.prototype, _schema18);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/zone/component.js
var ZoneComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._oldState = true;
    this._size = new Vec3();
    this.on("set_enabled", this._onSetEnabled, this);
  }
  set size(data2) {
    if (data2 instanceof Vec3) {
      this._size.copy(data2);
    } else if (data2 instanceof Array && data2.length >= 3) {
      this.size.set(data2[0], data2[1], data2[2]);
    }
  }
  get size() {
    return this._size;
  }
  onEnable() {
    this._checkState();
  }
  onDisable() {
    this._checkState();
  }
  _onSetEnabled(prop, old, value) {
    this._checkState();
  }
  _checkState() {
    const state = this.enabled && this.entity.enabled;
    if (state === this._oldState) {
      return;
    }
    this._oldState = state;
    this.fire("enable");
    this.fire("state", this.enabled);
  }
  _onBeforeRemove() {
    this.fire("remove");
  }
};
ZoneComponent.EVENT_ENABLE = "enable";
ZoneComponent.EVENT_DISABLE = "disable";
ZoneComponent.EVENT_STATE = "state";
ZoneComponent.EVENT_REMOVE = "remove";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/zone/data.js
var ZoneComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/zone/system.js
var _schema19 = ["enabled"];
var ZoneComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "zone";
    this.ComponentType = ZoneComponent;
    this.DataType = ZoneComponentData;
    this.schema = _schema19;
    this.on("beforeremove", this._onBeforeRemove, this);
  }
  initializeComponentData(component, data2, properties3) {
    component.enabled = data2.hasOwnProperty("enabled") ? !!data2.enabled : true;
    if (data2.size) {
      if (data2.size instanceof Vec3) {
        component.size.copy(data2.size);
      } else if (data2.size instanceof Array && data2.size.length >= 3) {
        component.size.set(data2.size[0], data2.size[1], data2.size[2]);
      }
    }
  }
  cloneComponent(entity, clone) {
    const data2 = {
      size: entity.zone.size
    };
    return this.addComponent(clone, data2);
  }
  _onBeforeRemove(entity, component) {
    component._onBeforeRemove();
  }
};
Component._buildAccessors(ZoneComponent.prototype, _schema19);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/camera/post-effect-queue.js
var PostEffectEntry = class {
  constructor(effect, inputTarget) {
    this.effect = effect;
    this.inputTarget = inputTarget;
    this.outputTarget = null;
    this.name = effect.constructor.name;
  }
};
var PostEffectQueue = class {
  constructor(app2, camera) {
    this.app = app2;
    this.camera = camera;
    this.destinationRenderTarget = null;
    this.effects = [];
    this.enabled = false;
    this.depthTarget = null;
    camera.on("set:rect", this.onCameraRectChanged, this);
  }
  _allocateColorBuffer(format, name) {
    var _renderTarget$width, _renderTarget$height;
    const rect = this.camera.rect;
    const renderTarget = this.destinationRenderTarget;
    const device = this.app.graphicsDevice;
    const width = Math.floor(rect.z * ((_renderTarget$width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width : device.width));
    const height = Math.floor(rect.w * ((_renderTarget$height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height : device.height));
    const colorBuffer = new Texture(device, {
      name,
      format,
      width,
      height,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
    return colorBuffer;
  }
  _createOffscreenTarget(useDepth, hdr) {
    var _this$destinationRend, _ref4;
    const device = this.app.graphicsDevice;
    const outputRt = (_this$destinationRend = this.destinationRenderTarget) != null ? _this$destinationRend : device.backBuffer;
    const srgb = outputRt.isColorBufferSrgb(0);
    const format = (_ref4 = hdr && device.getRenderableHdrFormat([PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F], true)) != null ? _ref4 : srgb ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8;
    const name = `${this.camera.entity.name}-posteffect-${this.effects.length}`;
    const colorBuffer = this._allocateColorBuffer(format, name);
    return new RenderTarget({
      colorBuffer,
      depth: useDepth,
      stencil: useDepth && this.app.graphicsDevice.supportsStencil,
      samples: useDepth ? device.samples : 1
    });
  }
  _resizeOffscreenTarget(rt) {
    const format = rt.colorBuffer.format;
    const name = rt.colorBuffer.name;
    rt.destroyFrameBuffers();
    rt.destroyTextureBuffers();
    rt._colorBuffer = this._allocateColorBuffer(format, name);
    rt._colorBuffers = [rt._colorBuffer];
  }
  _destroyOffscreenTarget(rt) {
    rt.destroyTextureBuffers();
    rt.destroy();
  }
  addEffect(effect) {
    const effects = this.effects;
    const isFirstEffect = effects.length === 0;
    const inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);
    const newEntry = new PostEffectEntry(effect, inputTarget);
    effects.push(newEntry);
    this._sourceTarget = newEntry.inputTarget;
    if (effects.length > 1) {
      effects[effects.length - 2].outputTarget = newEntry.inputTarget;
    }
    this._newPostEffect = effect;
    if (effect.needsDepthBuffer) {
      this._requestDepthMap();
    }
    this.enable();
    this._newPostEffect = void 0;
  }
  removeEffect(effect) {
    let index = -1;
    for (let i = 0, len = this.effects.length; i < len; i++) {
      if (this.effects[i].effect === effect) {
        index = i;
        break;
      }
    }
    if (index >= 0) {
      if (index > 0) {
        this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
      } else {
        if (this.effects.length > 1) {
          if (!this.effects[1].inputTarget._depth) {
            this._destroyOffscreenTarget(this.effects[1].inputTarget);
            this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
            this._sourceTarget = this.effects[1].inputTarget;
          }
          this.camera.renderTarget = this.effects[1].inputTarget;
        }
      }
      this._destroyOffscreenTarget(this.effects[index].inputTarget);
      this.effects.splice(index, 1);
    }
    if (this.enabled) {
      if (effect.needsDepthBuffer) {
        this._releaseDepthMap();
      }
    }
    if (this.effects.length === 0) {
      this.disable();
    }
  }
  _requestDepthMaps() {
    for (let i = 0, len = this.effects.length; i < len; i++) {
      const effect = this.effects[i].effect;
      if (this._newPostEffect === effect) {
        continue;
      }
      if (effect.needsDepthBuffer) {
        this._requestDepthMap();
      }
    }
  }
  _releaseDepthMaps() {
    for (let i = 0, len = this.effects.length; i < len; i++) {
      const effect = this.effects[i].effect;
      if (effect.needsDepthBuffer) {
        this._releaseDepthMap();
      }
    }
  }
  _requestDepthMap() {
    const depthLayer2 = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
    if (depthLayer2) {
      depthLayer2.incrementCounter();
      this.camera.requestSceneDepthMap(true);
    }
  }
  _releaseDepthMap() {
    const depthLayer2 = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
    if (depthLayer2) {
      depthLayer2.decrementCounter();
      this.camera.requestSceneDepthMap(false);
    }
  }
  destroy() {
    for (let i = 0, len = this.effects.length; i < len; i++) {
      this.effects[i].inputTarget.destroy();
    }
    this.effects.length = 0;
    this.disable();
  }
  enable() {
    if (!this.enabled && this.effects.length) {
      this.enabled = true;
      this._requestDepthMaps();
      this.app.graphicsDevice.on("resizecanvas", this._onCanvasResized, this);
      this.destinationRenderTarget = this.camera.renderTarget;
      this.camera.renderTarget = this.effects[0].inputTarget;
      this.camera.onPostprocessing = () => {
        if (this.enabled) {
          let rect = null;
          const len = this.effects.length;
          if (len) {
            for (let i = 0; i < len; i++) {
              const fx = this.effects[i];
              let destTarget = fx.outputTarget;
              if (i === len - 1) {
                rect = this.camera.rect;
                if (this.destinationRenderTarget) {
                  destTarget = this.destinationRenderTarget;
                }
              }
              fx.effect.render(fx.inputTarget, destTarget, rect);
            }
          }
        }
      };
    }
  }
  disable() {
    if (this.enabled) {
      this.enabled = false;
      this.app.graphicsDevice.off("resizecanvas", this._onCanvasResized, this);
      this._releaseDepthMaps();
      this._destroyOffscreenTarget(this._sourceTarget);
      this.camera.renderTarget = this.destinationRenderTarget;
      this.camera.onPostprocessing = null;
    }
  }
  _onCanvasResized(width, height) {
    var _renderTarget$width2, _renderTarget$height2;
    const rect = this.camera.rect;
    const renderTarget = this.destinationRenderTarget;
    width = (_renderTarget$width2 = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width2 : width;
    height = (_renderTarget$height2 = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height2 : height;
    this.camera.camera.aspectRatio = width * rect.z / (height * rect.w);
    this.resizeRenderTargets();
  }
  resizeRenderTargets() {
    var _renderTarget$width3, _renderTarget$height3;
    const device = this.app.graphicsDevice;
    const renderTarget = this.destinationRenderTarget;
    const width = (_renderTarget$width3 = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width3 : device.width;
    const height = (_renderTarget$height3 = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height3 : device.height;
    const rect = this.camera.rect;
    const desiredWidth = Math.floor(rect.z * width);
    const desiredHeight = Math.floor(rect.w * height);
    const effects = this.effects;
    for (let i = 0, len = effects.length; i < len; i++) {
      const fx = effects[i];
      if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
        this._resizeOffscreenTarget(fx.inputTarget);
      }
    }
  }
  onCameraRectChanged(name, oldValue, newValue) {
    if (this.enabled) {
      this.resizeRenderTargets();
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/camera/component.js
var CameraComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this.onPostprocessing = null;
    this.onPreRender = null;
    this.onPostRender = null;
    this.onPreCull = null;
    this.onPostCull = null;
    this._renderSceneDepthMap = 0;
    this._renderSceneColorMap = 0;
    this._sceneDepthMapRequested = false;
    this._sceneColorMapRequested = false;
    this._priority = 0;
    this._disablePostEffectsLayer = LAYERID_UI;
    this._camera = new Camera();
    this._camera.node = entity;
    this._postEffects = new PostEffectQueue(system.app, this);
  }
  setShaderPass(name) {
    const shaderPass = ShaderPass.get(this.system.app.graphicsDevice);
    const shaderPassInfo = name ? shaderPass.allocate(name, {
      isForward: true
    }) : null;
    this._camera.shaderPassInfo = shaderPassInfo;
    return shaderPassInfo.index;
  }
  getShaderPass() {
    var _this$_camera$shaderP;
    return (_this$_camera$shaderP = this._camera.shaderPassInfo) == null ? void 0 : _this$_camera$shaderP.name;
  }
  set renderPasses(passes) {
    this._camera.renderPasses = passes;
  }
  get renderPasses() {
    return this._camera.renderPasses;
  }
  set rendering(value) {
    this._camera.renderingParams = value;
  }
  get rendering() {
    return this._camera.renderingParams;
  }
  set aperture(value) {
    this._camera.aperture = value;
  }
  get aperture() {
    return this._camera.aperture;
  }
  set aspectRatio(value) {
    this._camera.aspectRatio = value;
  }
  get aspectRatio() {
    return this._camera.aspectRatio;
  }
  set aspectRatioMode(value) {
    this._camera.aspectRatioMode = value;
  }
  get aspectRatioMode() {
    return this._camera.aspectRatioMode;
  }
  set calculateProjection(value) {
    this._camera.calculateProjection = value;
  }
  get calculateProjection() {
    return this._camera.calculateProjection;
  }
  set calculateTransform(value) {
    this._camera.calculateTransform = value;
  }
  get calculateTransform() {
    return this._camera.calculateTransform;
  }
  get camera() {
    return this._camera;
  }
  set clearColor(value) {
    this._camera.clearColor = value;
  }
  get clearColor() {
    return this._camera.clearColor;
  }
  set clearColorBuffer(value) {
    this._camera.clearColorBuffer = value;
    this.dirtyLayerCompositionCameras();
  }
  get clearColorBuffer() {
    return this._camera.clearColorBuffer;
  }
  set clearDepthBuffer(value) {
    this._camera.clearDepthBuffer = value;
    this.dirtyLayerCompositionCameras();
  }
  get clearDepthBuffer() {
    return this._camera.clearDepthBuffer;
  }
  set clearStencilBuffer(value) {
    this._camera.clearStencilBuffer = value;
    this.dirtyLayerCompositionCameras();
  }
  get clearStencilBuffer() {
    return this._camera.clearStencilBuffer;
  }
  set cullFaces(value) {
    this._camera.cullFaces = value;
  }
  get cullFaces() {
    return this._camera.cullFaces;
  }
  set disablePostEffectsLayer(layer) {
    this._disablePostEffectsLayer = layer;
    this.dirtyLayerCompositionCameras();
  }
  get disablePostEffectsLayer() {
    return this._disablePostEffectsLayer;
  }
  set farClip(value) {
    this._camera.farClip = value;
  }
  get farClip() {
    return this._camera.farClip;
  }
  set flipFaces(value) {
    this._camera.flipFaces = value;
  }
  get flipFaces() {
    return this._camera.flipFaces;
  }
  set fov(value) {
    this._camera.fov = value;
  }
  get fov() {
    return this._camera.fov;
  }
  get frustum() {
    return this._camera.frustum;
  }
  set frustumCulling(value) {
    this._camera.frustumCulling = value;
  }
  get frustumCulling() {
    return this._camera.frustumCulling;
  }
  set horizontalFov(value) {
    this._camera.horizontalFov = value;
  }
  get horizontalFov() {
    return this._camera.horizontalFov;
  }
  set layers(newValue) {
    const layers = this._camera.layers;
    for (let i = 0; i < layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(layers[i]);
      if (!layer) continue;
      layer.removeCamera(this);
    }
    this._camera.layers = newValue;
    if (!this.enabled || !this.entity.enabled) return;
    for (let i = 0; i < newValue.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(newValue[i]);
      if (!layer) continue;
      layer.addCamera(this);
    }
  }
  get layers() {
    return this._camera.layers;
  }
  get layersSet() {
    return this._camera.layersSet;
  }
  set jitter(value) {
    this._camera.jitter = value;
  }
  get jitter() {
    return this._camera.jitter;
  }
  set nearClip(value) {
    this._camera.nearClip = value;
  }
  get nearClip() {
    return this._camera.nearClip;
  }
  set orthoHeight(value) {
    this._camera.orthoHeight = value;
  }
  get orthoHeight() {
    return this._camera.orthoHeight;
  }
  get postEffects() {
    return this._postEffects;
  }
  get postEffectsEnabled() {
    return this._postEffects.enabled;
  }
  set priority(newValue) {
    this._priority = newValue;
    this.dirtyLayerCompositionCameras();
  }
  get priority() {
    return this._priority;
  }
  set projection(value) {
    this._camera.projection = value;
  }
  get projection() {
    return this._camera.projection;
  }
  get projectionMatrix() {
    return this._camera.projectionMatrix;
  }
  set rect(value) {
    this._camera.rect = value;
    this.fire("set:rect", this._camera.rect);
  }
  get rect() {
    return this._camera.rect;
  }
  set renderSceneColorMap(value) {
    if (value && !this._sceneColorMapRequested) {
      this.requestSceneColorMap(true);
      this._sceneColorMapRequested = true;
    } else if (this._sceneColorMapRequested) {
      this.requestSceneColorMap(false);
      this._sceneColorMapRequested = false;
    }
  }
  get renderSceneColorMap() {
    return this._renderSceneColorMap > 0;
  }
  set renderSceneDepthMap(value) {
    if (value && !this._sceneDepthMapRequested) {
      this.requestSceneDepthMap(true);
      this._sceneDepthMapRequested = true;
    } else if (this._sceneDepthMapRequested) {
      this.requestSceneDepthMap(false);
      this._sceneDepthMapRequested = false;
    }
  }
  get renderSceneDepthMap() {
    return this._renderSceneDepthMap > 0;
  }
  set renderTarget(value) {
    this._camera.renderTarget = value;
    this.dirtyLayerCompositionCameras();
  }
  get renderTarget() {
    return this._camera.renderTarget;
  }
  set scissorRect(value) {
    this._camera.scissorRect = value;
  }
  get scissorRect() {
    return this._camera.scissorRect;
  }
  set sensitivity(value) {
    this._camera.sensitivity = value;
  }
  get sensitivity() {
    return this._camera.sensitivity;
  }
  set shutter(value) {
    this._camera.shutter = value;
  }
  get shutter() {
    return this._camera.shutter;
  }
  get viewMatrix() {
    return this._camera.viewMatrix;
  }
  _enableDepthLayer(value) {
    const hasDepthLayer = this.layers.find((layerId) => layerId === LAYERID_DEPTH);
    if (hasDepthLayer) {
      const depthLayer2 = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
      if (value) {
        depthLayer2 == null || depthLayer2.incrementCounter();
      } else {
        depthLayer2 == null || depthLayer2.decrementCounter();
      }
    } else if (value) {
      return false;
    }
    return true;
  }
  requestSceneColorMap(enabled) {
    this._renderSceneColorMap += enabled ? 1 : -1;
    this._enableDepthLayer(enabled);
    this.camera._enableRenderPassColorGrab(this.system.app.graphicsDevice, this.renderSceneColorMap);
  }
  requestSceneDepthMap(enabled) {
    this._renderSceneDepthMap += enabled ? 1 : -1;
    this._enableDepthLayer(enabled);
    this.camera._enableRenderPassDepthGrab(this.system.app.graphicsDevice, this.system.app.renderer, this.renderSceneDepthMap);
  }
  dirtyLayerCompositionCameras() {
    const layerComp = this.system.app.scene.layers;
    layerComp._dirty = true;
  }
  screenToWorld(screenx, screeny, cameraz, worldCoord) {
    const device = this.system.app.graphicsDevice;
    const w = device.clientRect.width;
    const h2 = device.clientRect.height;
    return this._camera.screenToWorld(screenx, screeny, cameraz, w, h2, worldCoord);
  }
  worldToScreen(worldCoord, screenCoord) {
    const device = this.system.app.graphicsDevice;
    const w = device.clientRect.width;
    const h2 = device.clientRect.height;
    return this._camera.worldToScreen(worldCoord, w, h2, screenCoord);
  }
  onAppPrerender() {
    this._camera._viewMatDirty = true;
    this._camera._viewProjMatDirty = true;
  }
  addCameraToLayers() {
    const layers = this.layers;
    for (let i = 0; i < layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(layers[i]);
      if (layer) {
        layer.addCamera(this);
      }
    }
  }
  removeCameraFromLayers() {
    const layers = this.layers;
    for (let i = 0; i < layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(layers[i]);
      if (layer) {
        layer.removeCamera(this);
      }
    }
  }
  onLayersChanged(oldComp, newComp) {
    this.addCameraToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    layer.addCamera(this);
  }
  onLayerRemoved(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    layer.removeCamera(this);
  }
  onEnable() {
    const system = this.system;
    const scene = system.app.scene;
    const layers = scene.layers;
    system.addCamera(this);
    scene.on("set:layers", this.onLayersChanged, this);
    if (layers) {
      layers.on("add", this.onLayerAdded, this);
      layers.on("remove", this.onLayerRemoved, this);
    }
    if (this.enabled && this.entity.enabled) {
      this.addCameraToLayers();
    }
    this.postEffects.enable();
  }
  onDisable() {
    const system = this.system;
    const scene = system.app.scene;
    const layers = scene.layers;
    this.postEffects.disable();
    this.removeCameraFromLayers();
    scene.off("set:layers", this.onLayersChanged, this);
    if (layers) {
      layers.off("add", this.onLayerAdded, this);
      layers.off("remove", this.onLayerRemoved, this);
    }
    system.removeCamera(this);
  }
  onRemove() {
    this.onDisable();
    this.off();
    this.camera.destroy();
  }
  calculateAspectRatio(rt) {
    const device = this.system.app.graphicsDevice;
    const width = rt ? rt.width : device.width;
    const height = rt ? rt.height : device.height;
    return width * this.rect.z / (height * this.rect.w);
  }
  frameUpdate(rt) {
    if (this.aspectRatioMode === ASPECT_AUTO) {
      this.aspectRatio = this.calculateAspectRatio(rt);
    }
  }
  startXr(type, spaceType, options2) {
    this.system.app.xr.start(this, type, spaceType, options2);
  }
  endXr(callback) {
    if (!this._camera.xr) {
      if (callback) callback(new Error("Camera is not in XR"));
      return;
    }
    this._camera.xr.end(callback);
  }
  copy(source) {
    this.aperture = source.aperture;
    this.aspectRatio = source.aspectRatio;
    this.aspectRatioMode = source.aspectRatioMode;
    this.calculateProjection = source.calculateProjection;
    this.calculateTransform = source.calculateTransform;
    this.clearColor = source.clearColor;
    this.clearColorBuffer = source.clearColorBuffer;
    this.clearDepthBuffer = source.clearDepthBuffer;
    this.clearStencilBuffer = source.clearStencilBuffer;
    this.cullFaces = source.cullFaces;
    this.disablePostEffectsLayer = source.disablePostEffectsLayer;
    this.farClip = source.farClip;
    this.flipFaces = source.flipFaces;
    this.fov = source.fov;
    this.frustumCulling = source.frustumCulling;
    this.horizontalFov = source.horizontalFov;
    this.layers = source.layers;
    this.nearClip = source.nearClip;
    this.orthoHeight = source.orthoHeight;
    this.priority = source.priority;
    this.projection = source.projection;
    this.rect = source.rect;
    this.renderTarget = source.renderTarget;
    this.scissorRect = source.scissorRect;
    this.sensitivity = source.sensitivity;
    this.shutter = source.shutter;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/camera/data.js
var CameraComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/camera/system.js
var _schema20 = ["enabled"];
var CameraComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.cameras = [];
    this.id = "camera";
    this.ComponentType = CameraComponent;
    this.DataType = CameraComponentData;
    this.schema = _schema20;
    this.on("beforeremove", this.onBeforeRemove, this);
    this.app.on("prerender", this.onAppPrerender, this);
    this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(component, data2, properties3) {
    properties3 = ["aspectRatio", "aspectRatioMode", "calculateProjection", "calculateTransform", "clearColor", "clearColorBuffer", "clearDepthBuffer", "clearStencilBuffer", "renderSceneColorMap", "renderSceneDepthMap", "cullFaces", "farClip", "flipFaces", "fov", "frustumCulling", "horizontalFov", "layers", "renderTarget", "nearClip", "orthoHeight", "projection", "priority", "rect", "scissorRect", "aperture", "shutter", "sensitivity"];
    for (let i = 0; i < properties3.length; i++) {
      const property = properties3[i];
      if (data2.hasOwnProperty(property)) {
        const value = data2[property];
        switch (property) {
          case "rect":
          case "scissorRect":
            if (Array.isArray(value)) {
              component[property] = new Vec4(value[0], value[1], value[2], value[3]);
            } else {
              component[property] = value;
            }
            break;
          case "clearColor":
            if (Array.isArray(value)) {
              component[property] = new Color(value[0], value[1], value[2], value[3]);
            } else {
              component[property] = value;
            }
            break;
          default:
            component[property] = value;
            break;
        }
      }
    }
    super.initializeComponentData(component, data2, ["enabled"]);
  }
  cloneComponent(entity, clone) {
    const c2 = entity.camera;
    return this.addComponent(clone, {
      aspectRatio: c2.aspectRatio,
      aspectRatioMode: c2.aspectRatioMode,
      calculateProjection: c2.calculateProjection,
      calculateTransform: c2.calculateTransform,
      clearColor: c2.clearColor,
      clearColorBuffer: c2.clearColorBuffer,
      clearDepthBuffer: c2.clearDepthBuffer,
      clearStencilBuffer: c2.clearStencilBuffer,
      renderSceneDepthMap: c2.renderSceneDepthMap,
      renderSceneColorMap: c2.renderSceneColorMap,
      cullFaces: c2.cullFaces,
      enabled: c2.enabled,
      farClip: c2.farClip,
      flipFaces: c2.flipFaces,
      fov: c2.fov,
      frustumCulling: c2.frustumCulling,
      horizontalFov: c2.horizontalFov,
      layers: c2.layers,
      renderTarget: c2.renderTarget,
      nearClip: c2.nearClip,
      orthoHeight: c2.orthoHeight,
      projection: c2.projection,
      priority: c2.priority,
      rect: c2.rect,
      scissorRect: c2.scissorRect,
      aperture: c2.aperture,
      sensitivity: c2.sensitivity,
      shutter: c2.shutter
    });
  }
  onBeforeRemove(entity, component) {
    this.removeCamera(component);
    component.onRemove();
  }
  onUpdate(dt) {
  }
  onAppPrerender() {
    for (let i = 0, len = this.cameras.length; i < len; i++) {
      this.cameras[i].onAppPrerender();
    }
  }
  addCamera(camera) {
    this.cameras.push(camera);
    sortPriority(this.cameras);
  }
  removeCamera(camera) {
    const index = this.cameras.indexOf(camera);
    if (index >= 0) {
      this.cameras.splice(index, 1);
      sortPriority(this.cameras);
    }
  }
  destroy() {
    super.destroy();
    this.app.systems.off("update", this.onUpdate, this);
  }
};
Component._buildAccessors(CameraComponent.prototype, _schema20);

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/light/data.js
var LightComponentData = class {
  constructor() {
    this.enabled = true;
    this.light = void 0;
    this.type = "directional";
    this.color = new Color(1, 1, 1);
    this.intensity = 1;
    this.luminance = 0;
    this.shape = LIGHTSHAPE_PUNCTUAL;
    this.affectSpecularity = true;
    this.castShadows = false;
    this.shadowDistance = 40;
    this.shadowIntensity = 1;
    this.shadowResolution = 1024;
    this.shadowBias = 0.05;
    this.numCascades = 1;
    this.bakeNumSamples = 1;
    this.bakeArea = 0;
    this.cascadeDistribution = 0.5;
    this.normalOffsetBias = 0;
    this.range = 10;
    this.innerConeAngle = 40;
    this.outerConeAngle = 45;
    this.falloffMode = LIGHTFALLOFF_LINEAR;
    this.shadowType = SHADOW_PCF3;
    this.vsmBlurSize = 11;
    this.vsmBlurMode = BLUR_GAUSSIAN;
    this.vsmBias = 0.01 * 0.25;
    this.cookieAsset = null;
    this.cookie = null;
    this.cookieIntensity = 1;
    this.cookieFalloff = true;
    this.cookieChannel = "rgb";
    this.cookieAngle = 0;
    this.cookieScale = null;
    this.cookieOffset = null;
    this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
    this.mask = 1;
    this.affectDynamic = true;
    this.affectLightmapped = false;
    this.bake = false;
    this.bakeDir = true;
    this.isStatic = false;
    this.layers = [LAYERID_WORLD];
    this.penumbraSize = 1;
  }
};
var properties2 = Object.keys(new LightComponentData());

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/light/component.js
var LightComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._cookieAsset = null;
    this._cookieAssetId = null;
    this._cookieAssetAdd = false;
    this._cookieMatrix = null;
  }
  get data() {
    const record = this.system.store[this.entity.getGuid()];
    return record ? record.data : null;
  }
  set enabled(arg) {
    this._setValue("enabled", arg, function(newValue, oldValue) {
      this.onSetEnabled(null, oldValue, newValue);
    });
  }
  get enabled() {
    return this.data.enabled;
  }
  set light(arg) {
    this._setValue("light", arg);
  }
  get light() {
    return this.data.light;
  }
  set type(arg) {
    this._setValue("type", arg, function(newValue, oldValue) {
      this.system.changeType(this, oldValue, newValue);
      this.refreshProperties();
    });
  }
  get type() {
    return this.data.type;
  }
  set color(arg) {
    this._setValue("color", arg, function(newValue, oldValue) {
      this.light.setColor(newValue);
    }, true);
  }
  get color() {
    return this.data.color;
  }
  set intensity(arg) {
    this._setValue("intensity", arg, function(newValue, oldValue) {
      this.light.intensity = newValue;
    });
  }
  get intensity() {
    return this.data.intensity;
  }
  set luminance(arg) {
    this._setValue("luminance", arg, function(newValue, oldValue) {
      this.light.luminance = newValue;
    });
  }
  get luminance() {
    return this.data.luminance;
  }
  set shape(arg) {
    this._setValue("shape", arg, function(newValue, oldValue) {
      this.light.shape = newValue;
    });
  }
  get shape() {
    return this.data.shape;
  }
  set affectSpecularity(arg) {
    this._setValue("affectSpecularity", arg, function(newValue, oldValue) {
      this.light.affectSpecularity = newValue;
    });
  }
  get affectSpecularity() {
    return this.data.affectSpecularity;
  }
  set castShadows(arg) {
    this._setValue("castShadows", arg, function(newValue, oldValue) {
      this.light.castShadows = newValue;
    });
  }
  get castShadows() {
    return this.data.castShadows;
  }
  set shadowDistance(arg) {
    this._setValue("shadowDistance", arg, function(newValue, oldValue) {
      this.light.shadowDistance = newValue;
    });
  }
  get shadowDistance() {
    return this.data.shadowDistance;
  }
  set shadowIntensity(arg) {
    this._setValue("shadowIntensity", arg, function(newValue, oldValue) {
      this.light.shadowIntensity = newValue;
    });
  }
  get shadowIntensity() {
    return this.data.shadowIntensity;
  }
  set shadowResolution(arg) {
    this._setValue("shadowResolution", arg, function(newValue, oldValue) {
      this.light.shadowResolution = newValue;
    });
  }
  get shadowResolution() {
    return this.data.shadowResolution;
  }
  set shadowBias(arg) {
    this._setValue("shadowBias", arg, function(newValue, oldValue) {
      this.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);
    });
  }
  get shadowBias() {
    return this.data.shadowBias;
  }
  set numCascades(arg) {
    this._setValue("numCascades", arg, function(newValue, oldValue) {
      this.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);
    });
  }
  get numCascades() {
    return this.data.numCascades;
  }
  set bakeNumSamples(arg) {
    this._setValue("bakeNumSamples", arg, function(newValue, oldValue) {
      this.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);
    });
  }
  get bakeNumSamples() {
    return this.data.bakeNumSamples;
  }
  set bakeArea(arg) {
    this._setValue("bakeArea", arg, function(newValue, oldValue) {
      this.light.bakeArea = math.clamp(newValue, 0, 180);
    });
  }
  get bakeArea() {
    return this.data.bakeArea;
  }
  set cascadeDistribution(arg) {
    this._setValue("cascadeDistribution", arg, function(newValue, oldValue) {
      this.light.cascadeDistribution = math.clamp(newValue, 0, 1);
    });
  }
  get cascadeDistribution() {
    return this.data.cascadeDistribution;
  }
  set normalOffsetBias(arg) {
    this._setValue("normalOffsetBias", arg, function(newValue, oldValue) {
      this.light.normalOffsetBias = math.clamp(newValue, 0, 1);
    });
  }
  get normalOffsetBias() {
    return this.data.normalOffsetBias;
  }
  set range(arg) {
    this._setValue("range", arg, function(newValue, oldValue) {
      this.light.attenuationEnd = newValue;
    });
  }
  get range() {
    return this.data.range;
  }
  set innerConeAngle(arg) {
    this._setValue("innerConeAngle", arg, function(newValue, oldValue) {
      this.light.innerConeAngle = newValue;
    });
  }
  get innerConeAngle() {
    return this.data.innerConeAngle;
  }
  set outerConeAngle(arg) {
    this._setValue("outerConeAngle", arg, function(newValue, oldValue) {
      this.light.outerConeAngle = newValue;
    });
  }
  get outerConeAngle() {
    return this.data.outerConeAngle;
  }
  set falloffMode(arg) {
    this._setValue("falloffMode", arg, function(newValue, oldValue) {
      this.light.falloffMode = newValue;
    });
  }
  get falloffMode() {
    return this.data.falloffMode;
  }
  set shadowType(arg) {
    this._setValue("shadowType", arg, function(newValue, oldValue) {
      this.light.shadowType = newValue;
    });
  }
  get shadowType() {
    return this.data.shadowType;
  }
  set vsmBlurSize(arg) {
    this._setValue("vsmBlurSize", arg, function(newValue, oldValue) {
      this.light.vsmBlurSize = newValue;
    });
  }
  get vsmBlurSize() {
    return this.data.vsmBlurSize;
  }
  set vsmBlurMode(arg) {
    this._setValue("vsmBlurMode", arg, function(newValue, oldValue) {
      this.light.vsmBlurMode = newValue;
    });
  }
  get vsmBlurMode() {
    return this.data.vsmBlurMode;
  }
  set vsmBias(arg) {
    this._setValue("vsmBias", arg, function(newValue, oldValue) {
      this.light.vsmBias = math.clamp(newValue, 0, 1);
    });
  }
  get vsmBias() {
    return this.data.vsmBias;
  }
  set cookieAsset(arg) {
    this._setValue("cookieAsset", arg, function(newValue, oldValue) {
      if (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) {
        return;
      }
      this.onCookieAssetRemove();
      this._cookieAssetId = null;
      if (newValue instanceof Asset) {
        this.data.cookieAsset = newValue.id;
        this._cookieAssetId = newValue.id;
        this.onCookieAssetAdd(newValue);
      } else if (typeof newValue === "number") {
        this._cookieAssetId = newValue;
        const asset = this.system.app.assets.get(newValue);
        if (asset) {
          this.onCookieAssetAdd(asset);
        } else {
          this._cookieAssetAdd = true;
          this.system.app.assets.on(`add:${this._cookieAssetId}`, this.onCookieAssetAdd, this);
        }
      }
    });
  }
  get cookieAsset() {
    return this.data.cookieAsset;
  }
  set cookie(arg) {
    this._setValue("cookie", arg, function(newValue, oldValue) {
      this.light.cookie = newValue;
    });
  }
  get cookie() {
    return this.data.cookie;
  }
  set cookieIntensity(arg) {
    this._setValue("cookieIntensity", arg, function(newValue, oldValue) {
      this.light.cookieIntensity = math.clamp(newValue, 0, 1);
    });
  }
  get cookieIntensity() {
    return this.data.cookieIntensity;
  }
  set cookieFalloff(arg) {
    this._setValue("cookieFalloff", arg, function(newValue, oldValue) {
      this.light.cookieFalloff = newValue;
    });
  }
  get cookieFalloff() {
    return this.data.cookieFalloff;
  }
  set cookieChannel(arg) {
    this._setValue("cookieChannel", arg, function(newValue, oldValue) {
      this.light.cookieChannel = newValue;
    });
  }
  get cookieChannel() {
    return this.data.cookieChannel;
  }
  set cookieAngle(arg) {
    this._setValue("cookieAngle", arg, function(newValue, oldValue) {
      if (newValue !== 0 || this.cookieScale !== null) {
        if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
        let scx = 1;
        let scy = 1;
        if (this.cookieScale) {
          scx = this.cookieScale.x;
          scy = this.cookieScale.y;
        }
        const c2 = Math.cos(newValue * math.DEG_TO_RAD);
        const s2 = Math.sin(newValue * math.DEG_TO_RAD);
        this._cookieMatrix.set(c2 / scx, -s2 / scx, s2 / scy, c2 / scy);
        this.light.cookieTransform = this._cookieMatrix;
      } else {
        this.light.cookieTransform = null;
      }
    });
  }
  get cookieAngle() {
    return this.data.cookieAngle;
  }
  set cookieScale(arg) {
    this._setValue("cookieScale", arg, function(newValue, oldValue) {
      if (newValue !== null || this.cookieAngle !== 0) {
        if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
        const scx = newValue.x;
        const scy = newValue.y;
        const c2 = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
        const s2 = Math.sin(this.cookieAngle * math.DEG_TO_RAD);
        this._cookieMatrix.set(c2 / scx, -s2 / scx, s2 / scy, c2 / scy);
        this.light.cookieTransform = this._cookieMatrix;
      } else {
        this.light.cookieTransform = null;
      }
    }, true);
  }
  get cookieScale() {
    return this.data.cookieScale;
  }
  set cookieOffset(arg) {
    this._setValue("cookieOffset", arg, function(newValue, oldValue) {
      this.light.cookieOffset = newValue;
    }, true);
  }
  get cookieOffset() {
    return this.data.cookieOffset;
  }
  set shadowUpdateMode(arg) {
    this._setValue("shadowUpdateMode", arg, function(newValue, oldValue) {
      this.light.shadowUpdateMode = newValue;
    }, true);
  }
  get shadowUpdateMode() {
    return this.data.shadowUpdateMode;
  }
  set mask(arg) {
    this._setValue("mask", arg, function(newValue, oldValue) {
      this.light.mask = newValue;
    });
  }
  get mask() {
    return this.data.mask;
  }
  set affectDynamic(arg) {
    this._setValue("affectDynamic", arg, function(newValue, oldValue) {
      if (newValue) {
        this.light.mask |= MASK_AFFECT_DYNAMIC;
      } else {
        this.light.mask &= ~MASK_AFFECT_DYNAMIC;
      }
      this.light.layersDirty();
    });
  }
  get affectDynamic() {
    return this.data.affectDynamic;
  }
  set affectLightmapped(arg) {
    this._setValue("affectLightmapped", arg, function(newValue, oldValue) {
      if (newValue) {
        this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
        if (this.bake) this.light.mask &= ~MASK_BAKE;
      } else {
        this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
        if (this.bake) this.light.mask |= MASK_BAKE;
      }
    });
  }
  get affectLightmapped() {
    return this.data.affectLightmapped;
  }
  set bake(arg) {
    this._setValue("bake", arg, function(newValue, oldValue) {
      if (newValue) {
        this.light.mask |= MASK_BAKE;
        if (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
      } else {
        this.light.mask &= ~MASK_BAKE;
        if (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
      }
      this.light.layersDirty();
    });
  }
  get bake() {
    return this.data.bake;
  }
  set bakeDir(arg) {
    this._setValue("bakeDir", arg, function(newValue, oldValue) {
      this.light.bakeDir = newValue;
    });
  }
  get bakeDir() {
    return this.data.bakeDir;
  }
  set isStatic(arg) {
    this._setValue("isStatic", arg, function(newValue, oldValue) {
      this.light.isStatic = newValue;
    });
  }
  get isStatic() {
    return this.data.isStatic;
  }
  set layers(arg) {
    this._setValue("layers", arg, function(newValue, oldValue) {
      for (let i = 0; i < oldValue.length; i++) {
        const layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
        if (!layer) continue;
        layer.removeLight(this);
        this.light.removeLayer(layer);
      }
      for (let i = 0; i < newValue.length; i++) {
        const layer = this.system.app.scene.layers.getLayerById(newValue[i]);
        if (!layer) continue;
        if (this.enabled && this.entity.enabled) {
          layer.addLight(this);
          this.light.addLayer(layer);
        }
      }
    });
  }
  get layers() {
    return this.data.layers;
  }
  set shadowUpdateOverrides(values) {
    this.light.shadowUpdateOverrides = values;
  }
  get shadowUpdateOverrides() {
    return this.light.shadowUpdateOverrides;
  }
  set penumbraSize(value) {
    this.light.penumbraSize = value;
  }
  get penumbraSize() {
    return this.light.penumbraSize;
  }
  _setValue(name, value, setFunc, skipEqualsCheck) {
    const data2 = this.data;
    const oldValue = data2[name];
    if (!skipEqualsCheck && oldValue === value) return;
    data2[name] = value;
    if (setFunc) setFunc.call(this, value, oldValue);
  }
  addLightToLayers() {
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (layer) {
        layer.addLight(this);
        this.light.addLayer(layer);
      }
    }
  }
  removeLightFromLayers() {
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
      if (layer) {
        layer.removeLight(this);
        this.light.removeLayer(layer);
      }
    }
  }
  onLayersChanged(oldComp, newComp) {
    if (this.enabled && this.entity.enabled) {
      this.addLightToLayers();
    }
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index >= 0 && this.enabled && this.entity.enabled) {
      layer.addLight(this);
      this.light.addLayer(layer);
    }
  }
  onLayerRemoved(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index >= 0) {
      layer.removeLight(this);
      this.light.removeLayer(layer);
    }
  }
  refreshProperties() {
    for (let i = 0; i < properties2.length; i++) {
      const name = properties2[i];
      this[name] = this[name];
    }
    if (this.enabled && this.entity.enabled) {
      this.onEnable();
    }
  }
  onCookieAssetSet() {
    let forceLoad = false;
    if (this._cookieAsset.type === "cubemap" && !this._cookieAsset.loadFaces) {
      this._cookieAsset.loadFaces = true;
      forceLoad = true;
    }
    if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);
    if (this._cookieAsset.resource) {
      this.onCookieAssetLoad();
    }
  }
  onCookieAssetAdd(asset) {
    if (this._cookieAssetId !== asset.id) return;
    this._cookieAsset = asset;
    if (this.light.enabled) {
      this.onCookieAssetSet();
    }
    this._cookieAsset.on("load", this.onCookieAssetLoad, this);
    this._cookieAsset.on("remove", this.onCookieAssetRemove, this);
  }
  onCookieAssetLoad() {
    if (!this._cookieAsset || !this._cookieAsset.resource) {
      return;
    }
    this.cookie = this._cookieAsset.resource;
  }
  onCookieAssetRemove() {
    if (!this._cookieAssetId) {
      return;
    }
    if (this._cookieAssetAdd) {
      this.system.app.assets.off(`add:${this._cookieAssetId}`, this.onCookieAssetAdd, this);
      this._cookieAssetAdd = false;
    }
    if (this._cookieAsset) {
      this._cookieAsset.off("load", this.onCookieAssetLoad, this);
      this._cookieAsset.off("remove", this.onCookieAssetRemove, this);
      this._cookieAsset = null;
    }
    this.cookie = null;
  }
  onEnable() {
    this.light.enabled = true;
    this.system.app.scene.on("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.on("add", this.onLayerAdded, this);
      this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this.enabled && this.entity.enabled) {
      this.addLightToLayers();
    }
    if (this._cookieAsset && !this.cookie) {
      this.onCookieAssetSet();
    }
  }
  onDisable() {
    this.light.enabled = false;
    this.system.app.scene.off("set:layers", this.onLayersChanged, this);
    if (this.system.app.scene.layers) {
      this.system.app.scene.layers.off("add", this.onLayerAdded, this);
      this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
    }
    this.removeLightFromLayers();
  }
  onRemove() {
    this.onDisable();
    this.light.destroy();
    this.cookieAsset = null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/light/system.js
var LightComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "light";
    this.ComponentType = LightComponent;
    this.DataType = LightComponentData;
    this.on("beforeremove", this._onRemoveComponent, this);
  }
  initializeComponentData(component, _data) {
    const data2 = _extends({}, _data);
    if (!data2.type) {
      data2.type = component.data.type;
    }
    component.data.type = data2.type;
    if (data2.layers && Array.isArray(data2.layers)) {
      data2.layers = data2.layers.slice(0);
    }
    if (data2.color && Array.isArray(data2.color)) {
      data2.color = new Color(data2.color[0], data2.color[1], data2.color[2]);
    }
    if (data2.cookieOffset && data2.cookieOffset instanceof Array) {
      data2.cookieOffset = new Vec2(data2.cookieOffset[0], data2.cookieOffset[1]);
    }
    if (data2.cookieScale && data2.cookieScale instanceof Array) {
      data2.cookieScale = new Vec2(data2.cookieScale[0], data2.cookieScale[1]);
    }
    if (data2.enable) {
      console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
      data2.enabled = data2.enable;
    }
    if (!data2.shape) {
      data2.shape = LIGHTSHAPE_PUNCTUAL;
    }
    const light = new Light(this.app.graphicsDevice, this.app.scene.clusteredLightingEnabled);
    light.type = lightTypes[data2.type];
    light._node = component.entity;
    component.data.light = light;
    super.initializeComponentData(component, data2, properties2);
  }
  _onRemoveComponent(entity, component) {
    component.onRemove();
  }
  cloneComponent(entity, clone) {
    const light = entity.light;
    const data2 = [];
    let name;
    for (let i = 0; i < properties2.length; i++) {
      name = properties2[i];
      if (name === "light") {
        continue;
      }
      if (light[name] && light[name].clone) {
        data2[name] = light[name].clone();
      } else {
        data2[name] = light[name];
      }
    }
    return this.addComponent(clone, data2);
  }
  changeType(component, oldValue, newValue) {
    if (oldValue !== newValue) {
      component.light.type = lightTypes[newValue];
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/script/script-attributes.js
var components = ["x", "y", "z", "w"];
var vecLookup = [void 0, void 0, Vec2, Vec3, Vec4];
function rawToValue(app2, args, value, old) {
  switch (args.type) {
    case "boolean":
      return !!value;
    case "number":
      if (typeof value === "number") {
        return value;
      } else if (typeof value === "string") {
        const v = parseInt(value, 10);
        if (isNaN(v)) return null;
        return v;
      } else if (typeof value === "boolean") {
        return 0 + value;
      }
      return null;
    case "json": {
      const result = {};
      if (Array.isArray(args.schema)) {
        if (!value || typeof value !== "object") {
          value = {};
        }
        for (let i = 0; i < args.schema.length; i++) {
          const field = args.schema[i];
          if (!field.name) continue;
          if (field.array) {
            result[field.name] = [];
            const arr = Array.isArray(value[field.name]) ? value[field.name] : [];
            for (let j = 0; j < arr.length; j++) {
              result[field.name].push(rawToValue(app2, field, arr[j]));
            }
          } else {
            const val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;
            result[field.name] = rawToValue(app2, field, val);
          }
        }
      }
      return result;
    }
    case "asset":
      if (value instanceof Asset) {
        return value;
      } else if (typeof value === "number") {
        return app2.assets.get(value) || null;
      } else if (typeof value === "string") {
        return app2.assets.get(parseInt(value, 10)) || null;
      }
      return null;
    case "entity":
      if (value instanceof GraphNode) {
        return value;
      } else if (typeof value === "string") {
        return app2.getEntityFromIndex(value);
      }
      return null;
    case "rgb":
    case "rgba":
      if (value instanceof Color) {
        if (old instanceof Color) {
          old.copy(value);
          return old;
        }
        return value.clone();
      } else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
        for (let i = 0; i < value.length; i++) {
          if (typeof value[i] !== "number") {
            return null;
          }
        }
        if (!old) old = new Color();
        old.r = value[0];
        old.g = value[1];
        old.b = value[2];
        old.a = value.length === 3 ? 1 : value[3];
        return old;
      } else if (typeof value === "string" && /#(?:[0-9a-f]{2}){3,4}/i.test(value)) {
        if (!old) {
          old = new Color();
        }
        old.fromString(value);
        return old;
      }
      return null;
    case "vec2":
    case "vec3":
    case "vec4": {
      const len = parseInt(args.type.slice(3), 10);
      const vecType = vecLookup[len];
      if (value instanceof vecType) {
        if (old instanceof vecType) {
          old.copy(value);
          return old;
        }
        return value.clone();
      } else if (value instanceof Array && value.length === len) {
        for (let i = 0; i < value.length; i++) {
          if (typeof value[i] !== "number") {
            return null;
          }
        }
        if (!old) old = new vecType();
        for (let i = 0; i < len; i++) {
          old[components[i]] = value[i];
        }
        return old;
      }
      return null;
    }
    case "curve":
      if (value) {
        let curve;
        if (value instanceof Curve || value instanceof CurveSet) {
          curve = value.clone();
        } else {
          const CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
          curve = new CurveType(value.keys);
          curve.type = value.type;
        }
        return curve;
      }
      break;
  }
  return value;
}
function attributeToValue(app2, schema, value, current) {
  if (schema.array) {
    return value.map((item, index) => rawToValue(app2, schema, item, current ? current[index] : null));
  }
  return rawToValue(app2, schema, value, current);
}
function assignAttributesToScript(app2, attributeSchemaMap, data2, script2) {
  if (!data2) return;
  for (const attributeName in attributeSchemaMap) {
    const attributeSchema = attributeSchemaMap[attributeName];
    const dataToAssign = data2[attributeName];
    if (dataToAssign === void 0) continue;
    script2[attributeName] = attributeToValue(app2, attributeSchema, dataToAssign, script2[attributeName]);
  }
}
var ScriptAttributes = class _ScriptAttributes {
  constructor(scriptType) {
    this.scriptType = scriptType;
    this.index = {};
  }
  add(name, args) {
    if (this.index[name]) {
      return;
    } else if (_ScriptAttributes.reservedNames.has(name)) {
      return;
    }
    this.index[name] = args;
    Object.defineProperty(this.scriptType.prototype, name, {
      get: function() {
        return this.__attributes[name];
      },
      set: function(raw) {
        const evt = "attr";
        const evtName = `attr:${name}`;
        const old = this.__attributes[name];
        let oldCopy = old;
        if (old && args.type !== "json" && args.type !== "entity" && old.clone) {
          if (this.hasEvent(evt) || this.hasEvent(evtName)) {
            oldCopy = old.clone();
          }
        }
        if (args.array) {
          this.__attributes[name] = [];
          if (raw) {
            for (let i = 0, len = raw.length; i < len; i++) {
              this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
            }
          }
        } else {
          this.__attributes[name] = rawToValue(this.app, args, raw, old);
        }
        this.fire(evt, name, this.__attributes[name], oldCopy);
        this.fire(evtName, this.__attributes[name], oldCopy);
      }
    });
  }
  remove(name) {
    if (!this.index[name]) {
      return false;
    }
    delete this.index[name];
    delete this.scriptType.prototype[name];
    return true;
  }
  has(name) {
    return !!this.index[name];
  }
  get(name) {
    return this.index[name] || null;
  }
};
ScriptAttributes.assignAttributesToScript = assignAttributesToScript;
ScriptAttributes.attributeToValue = attributeToValue;
ScriptAttributes.reservedNames = /* @__PURE__ */ new Set(["app", "entity", "enabled", "_enabled", "_enabledOld", "_destroyed", "__attributes", "__attributesRaw", "__scriptType", "__executionOrder", "_callbacks", "_callbackActive", "has", "get", "on", "off", "fire", "once", "hasEvent"]);

// ../node_modules/playcanvas/build/playcanvas/src/framework/script/constants.js
var SCRIPT_INITIALIZE = "initialize";
var SCRIPT_POST_INITIALIZE = "postInitialize";
var SCRIPT_UPDATE = "update";
var SCRIPT_POST_UPDATE = "postUpdate";
var SCRIPT_SWAP = "swap";

// ../node_modules/playcanvas/build/playcanvas/src/framework/script/script.js
var Script = class extends EventHandler {
  constructor(args) {
    super();
    this.app = void 0;
    this.entity = void 0;
    this._enabled = void 0;
    this._enabledOld = void 0;
    this._initialized = void 0;
    this._postInitialized = void 0;
    this.__destroyed = void 0;
    this.__scriptType = void 0;
    this.__executionOrder = void 0;
    this.initScript(args);
  }
  set enabled(value) {
    this._enabled = !!value;
    if (this.enabled === this._enabledOld) return;
    this._enabledOld = this.enabled;
    this.fire(this.enabled ? "enable" : "disable");
    this.fire("state", this.enabled);
    if (!this._initialized && this.enabled) {
      this._initialized = true;
      this.fire("preInitialize");
      if (this.initialize) {
        this.entity.script._scriptMethod(this, SCRIPT_INITIALIZE);
      }
    }
    if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
      this._postInitialized = true;
      if (this.postInitialize) {
        this.entity.script._scriptMethod(this, SCRIPT_POST_INITIALIZE);
      }
    }
  }
  get enabled() {
    return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
  }
  initScript(args) {
    const script2 = this.constructor;
    this.app = args.app;
    this.entity = args.entity;
    this._enabled = typeof args.enabled === "boolean" ? args.enabled : true;
    this._enabledOld = this.enabled;
    this.__destroyed = false;
    this.__scriptType = script2;
    this.__executionOrder = -1;
  }
  static get scriptName() {
    return this.__name;
  }
};
Script.EVENT_ENABLE = "enable";
Script.EVENT_DISABLE = "disable";
Script.EVENT_STATE = "state";
Script.EVENT_DESTROY = "destroy";
Script.EVENT_ATTR = "attr";
Script.EVENT_ERROR = "error";
Script.__name = null;
Script.__getScriptName = getScriptName;
var funcNameRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s\/]*)\s*/;
function getScriptName(constructorFn) {
  if (typeof constructorFn !== "function") return void 0;
  if ("name" in Function.prototype) return constructorFn.name;
  if (constructorFn === Function || constructorFn === Function.prototype.constructor) return "Function";
  const match = `${constructorFn}`.match(funcNameRegex);
  return match ? match[1] : void 0;
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/script/script-type.js
var ScriptType = class extends Script {
  constructor(...args) {
    super(...args);
    this.__attributes = void 0;
    this.__attributesRaw = void 0;
  }
  static get attributes() {
    if (!this.hasOwnProperty("__attributes")) this.__attributes = new ScriptAttributes(this);
    return this.__attributes;
  }
  initScript(args) {
    Script.prototype.initScript.call(this, args);
    this.__attributes = {};
    this.__attributesRaw = args.attributes || {};
  }
  initScriptType(args) {
    this.initScript(args);
  }
  __initializeAttributes(force) {
    if (!force && !this.__attributesRaw) {
      return;
    }
    for (const key in this.__scriptType.attributes.index) {
      if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
        this[key] = this.__attributesRaw[key];
      } else if (!this.__attributes.hasOwnProperty(key)) {
        if (this.__scriptType.attributes.index[key].hasOwnProperty("default")) {
          this[key] = this.__scriptType.attributes.index[key].default;
        } else {
          this[key] = null;
        }
      }
    }
    this.__attributesRaw = null;
  }
  static extend(methods) {
    for (const key in methods) {
      if (!methods.hasOwnProperty(key)) {
        continue;
      }
      this.prototype[key] = methods[key];
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/script/component.js
var toLowerCamelCase = (str) => str[0].toLowerCase() + str.substring(1);
var ScriptComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._attributeDataMap = /* @__PURE__ */ new Map();
    this._scripts = [];
    this._updateList = new SortedLoopArray({
      sortBy: "__executionOrder"
    });
    this._postUpdateList = new SortedLoopArray({
      sortBy: "__executionOrder"
    });
    this._scriptsIndex = {};
    this._destroyedScripts = [];
    this._destroyed = false;
    this._scriptsData = null;
    this._oldState = true;
    this._enabled = true;
    this._beingEnabled = false;
    this._isLoopingThroughScripts = false;
    this._executionOrder = -1;
    this.on("set_enabled", this._onSetEnabled, this);
  }
  set scripts(value) {
    this._scriptsData = value;
    for (const key in value) {
      if (!value.hasOwnProperty(key)) {
        continue;
      }
      const script2 = this._scriptsIndex[key];
      if (script2) {
        if (typeof value[key].enabled === "boolean") {
          script2.once("preInitialize", () => {
            this.initializeAttributes(script2);
          });
          script2.enabled = !!value[key].enabled;
        }
        if (typeof value[key].attributes === "object") {
          for (const attr in value[key].attributes) {
            if (ScriptAttributes.reservedNames.has(attr)) {
              continue;
            }
            if (!script2.__attributes.hasOwnProperty(attr)) {
              const scriptType = this.system.app.scripts.get(key);
              if (scriptType) {
                scriptType.attributes.add(attr, {});
              }
            }
            script2[attr] = value[key].attributes[attr];
          }
        }
      } else {
        console.log(this.order);
      }
    }
  }
  get scripts() {
    return this._scripts;
  }
  set enabled(value) {
    const oldValue = this._enabled;
    this._enabled = value;
    this.fire("set", "enabled", oldValue, value);
  }
  get enabled() {
    return this._enabled;
  }
  onEnable() {
    this._beingEnabled = true;
    this._checkState();
    if (!this.entity._beingEnabled) {
      this.onPostStateChange();
    }
    this._beingEnabled = false;
  }
  onDisable() {
    this._checkState();
  }
  onPostStateChange() {
    const wasLooping = this._beginLooping();
    for (let i = 0, len = this.scripts.length; i < len; i++) {
      const script2 = this.scripts[i];
      if (script2._initialized && !script2._postInitialized && script2.enabled) {
        script2._postInitialized = true;
        if (script2.postInitialize) {
          this._scriptMethod(script2, SCRIPT_POST_INITIALIZE);
        }
      }
    }
    this._endLooping(wasLooping);
  }
  _beginLooping() {
    const looping = this._isLoopingThroughScripts;
    this._isLoopingThroughScripts = true;
    return looping;
  }
  _endLooping(wasLoopingBefore) {
    this._isLoopingThroughScripts = wasLoopingBefore;
    if (!this._isLoopingThroughScripts) {
      this._removeDestroyedScripts();
    }
  }
  _onSetEnabled(prop, old, value) {
    this._beingEnabled = true;
    this._checkState();
    this._beingEnabled = false;
  }
  _checkState() {
    const state = this.enabled && this.entity.enabled;
    if (state === this._oldState) {
      return;
    }
    this._oldState = state;
    this.fire(state ? "enable" : "disable");
    this.fire("state", state);
    if (state) {
      this.system._addComponentToEnabled(this);
    } else {
      this.system._removeComponentFromEnabled(this);
    }
    const wasLooping = this._beginLooping();
    for (let i = 0, len = this.scripts.length; i < len; i++) {
      const script2 = this.scripts[i];
      script2.once("preInitialize", () => {
        this.initializeAttributes(script2);
      });
      script2.enabled = script2._enabled;
    }
    this._endLooping(wasLooping);
  }
  _onBeforeRemove() {
    this.fire("remove");
    const wasLooping = this._beginLooping();
    for (let i = 0; i < this.scripts.length; i++) {
      const script2 = this.scripts[i];
      if (!script2) continue;
      this.destroy(script2.__scriptType.__name);
    }
    this._endLooping(wasLooping);
  }
  _removeDestroyedScripts() {
    const len = this._destroyedScripts.length;
    if (!len) return;
    for (let i = 0; i < len; i++) {
      const script2 = this._destroyedScripts[i];
      this._removeScriptInstance(script2);
    }
    this._destroyedScripts.length = 0;
    this._resetExecutionOrder(0, this._scripts.length);
  }
  _onInitializeAttributes() {
    for (let i = 0, len = this.scripts.length; i < len; i++) {
      const script2 = this.scripts[i];
      this.initializeAttributes(script2);
    }
  }
  initializeAttributes(script2) {
    if (script2 instanceof ScriptType) {
      script2.__initializeAttributes();
    } else {
      var _this$system$app$scri;
      const name = script2.__scriptType.__name;
      const data2 = this._attributeDataMap.get(name);
      if (!data2) {
        return;
      }
      const schema = (_this$system$app$scri = this.system.app.scripts) == null ? void 0 : _this$system$app$scri.getSchema(name);
      assignAttributesToScript(this.system.app, schema.attributes, data2, script2);
    }
  }
  _scriptMethod(script2, method, arg) {
    script2[method](arg);
  }
  _onInitialize() {
    const scripts = this._scripts;
    const wasLooping = this._beginLooping();
    for (let i = 0, len = scripts.length; i < len; i++) {
      const script2 = scripts[i];
      if (!script2._initialized && script2.enabled) {
        script2._initialized = true;
        if (script2.initialize) {
          this._scriptMethod(script2, SCRIPT_INITIALIZE);
        }
      }
    }
    this._endLooping(wasLooping);
  }
  _onPostInitialize() {
    this.onPostStateChange();
  }
  _onUpdate(dt) {
    const list = this._updateList;
    if (!list.length) return;
    const wasLooping = this._beginLooping();
    for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
      const script2 = list.items[list.loopIndex];
      if (script2.enabled) {
        this._scriptMethod(script2, SCRIPT_UPDATE, dt);
      }
    }
    this._endLooping(wasLooping);
  }
  _onPostUpdate(dt) {
    const list = this._postUpdateList;
    if (!list.length) return;
    const wasLooping = this._beginLooping();
    for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
      const script2 = list.items[list.loopIndex];
      if (script2.enabled) {
        this._scriptMethod(script2, SCRIPT_POST_UPDATE, dt);
      }
    }
    this._endLooping(wasLooping);
  }
  _insertScriptInstance(scriptInstance, index, scriptsLength) {
    if (index === -1) {
      this._scripts.push(scriptInstance);
      scriptInstance.__executionOrder = scriptsLength;
      if (scriptInstance.update) {
        this._updateList.append(scriptInstance);
      }
      if (scriptInstance.postUpdate) {
        this._postUpdateList.append(scriptInstance);
      }
    } else {
      this._scripts.splice(index, 0, scriptInstance);
      scriptInstance.__executionOrder = index;
      this._resetExecutionOrder(index + 1, scriptsLength + 1);
      if (scriptInstance.update) {
        this._updateList.insert(scriptInstance);
      }
      if (scriptInstance.postUpdate) {
        this._postUpdateList.insert(scriptInstance);
      }
    }
  }
  _removeScriptInstance(scriptInstance) {
    const idx = this._scripts.indexOf(scriptInstance);
    if (idx === -1) return idx;
    this._scripts.splice(idx, 1);
    if (scriptInstance.update) {
      this._updateList.remove(scriptInstance);
    }
    if (scriptInstance.postUpdate) {
      this._postUpdateList.remove(scriptInstance);
    }
    return idx;
  }
  _resetExecutionOrder(startIndex, scriptsLength) {
    for (let i = startIndex; i < scriptsLength; i++) {
      this._scripts[i].__executionOrder = i;
    }
  }
  _resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {
    if (attribute.array) {
      const len = oldValue.length;
      if (!len) {
        return;
      }
      const newGuidArray = oldValue.slice();
      for (let i = 0; i < len; i++) {
        const guid2 = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];
        if (duplicatedIdsMap[guid2]) {
          newGuidArray[i] = useGuid ? duplicatedIdsMap[guid2].getGuid() : duplicatedIdsMap[guid2];
        }
      }
      newAttributes[attributeName] = newGuidArray;
    } else {
      if (oldValue instanceof Entity) {
        oldValue = oldValue.getGuid();
      } else if (typeof oldValue !== "string") {
        return;
      }
      if (duplicatedIdsMap[oldValue]) {
        newAttributes[attributeName] = duplicatedIdsMap[oldValue];
      }
    }
  }
  has(nameOrType) {
    if (typeof nameOrType === "string") {
      return !!this._scriptsIndex[nameOrType];
    }
    if (!nameOrType) return false;
    const scriptType = nameOrType;
    const scriptName = scriptType.__name;
    const scriptData = this._scriptsIndex[scriptName];
    const scriptInstance = scriptData && scriptData.instance;
    return scriptInstance instanceof scriptType;
  }
  get(nameOrType) {
    if (typeof nameOrType === "string") {
      const data2 = this._scriptsIndex[nameOrType];
      return data2 ? data2.instance : null;
    }
    if (!nameOrType) return null;
    const scriptType = nameOrType;
    const scriptName = scriptType.__name;
    const scriptData = this._scriptsIndex[scriptName];
    const scriptInstance = scriptData && scriptData.instance;
    return scriptInstance instanceof scriptType ? scriptInstance : null;
  }
  create(nameOrType, args = {}) {
    const self2 = this;
    let scriptType = nameOrType;
    let scriptName = nameOrType;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
    } else if (scriptType) {
      var _scriptType$__name;
      scriptName = (_scriptType$__name = scriptType.__name) != null ? _scriptType$__name : toLowerCamelCase(getScriptName(scriptType));
    }
    if (scriptType) {
      if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
        const scriptInstance = new scriptType({
          app: this.system.app,
          entity: this.entity,
          enabled: args.hasOwnProperty("enabled") ? args.enabled : true,
          attributes: args.attributes
        });
        if (!(scriptInstance instanceof ScriptType)) {
          this._attributeDataMap.set(scriptName, args.attributes);
        }
        const len = this._scripts.length;
        let ind = -1;
        if (typeof args.ind === "number" && args.ind !== -1 && len > args.ind) {
          ind = args.ind;
        }
        this._insertScriptInstance(scriptInstance, ind, len);
        this._scriptsIndex[scriptName] = {
          instance: scriptInstance,
          onSwap: function() {
            self2.swap(scriptName);
          }
        };
        this[scriptName] = scriptInstance;
        if (!args.preloading) {
          this.initializeAttributes(scriptInstance);
        }
        this.fire("create", scriptName, scriptInstance);
        this.fire(`create:${scriptName}`, scriptInstance);
        this.system.app.scripts.on(`swap:${scriptName}`, this._scriptsIndex[scriptName].onSwap);
        if (!args.preloading) {
          if (scriptInstance.enabled && !scriptInstance._initialized) {
            scriptInstance._initialized = true;
            if (scriptInstance.initialize) {
              this._scriptMethod(scriptInstance, SCRIPT_INITIALIZE);
            }
          }
          if (scriptInstance.enabled && !scriptInstance._postInitialized) {
            scriptInstance._postInitialized = true;
            if (scriptInstance.postInitialize) {
              this._scriptMethod(scriptInstance, SCRIPT_POST_INITIALIZE);
            }
          }
        }
        return scriptInstance;
      }
    } else {
      this._scriptsIndex[scriptName] = {
        awaiting: true,
        ind: this._scripts.length
      };
    }
    return null;
  }
  destroy(nameOrType) {
    let scriptName = nameOrType;
    let scriptType = nameOrType;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
    } else if (scriptType) {
      scriptName = scriptType.__name;
    }
    const scriptData = this._scriptsIndex[scriptName];
    delete this._scriptsIndex[scriptName];
    if (!scriptData) return false;
    this._attributeDataMap.delete(scriptName);
    const scriptInstance = scriptData.instance;
    if (scriptInstance && !scriptInstance._destroyed) {
      scriptInstance.enabled = false;
      scriptInstance._destroyed = true;
      if (!this._isLoopingThroughScripts) {
        const ind = this._removeScriptInstance(scriptInstance);
        if (ind >= 0) {
          this._resetExecutionOrder(ind, this._scripts.length);
        }
      } else {
        this._destroyedScripts.push(scriptInstance);
      }
    }
    this.system.app.scripts.off(`swap:${scriptName}`, scriptData.onSwap);
    delete this[scriptName];
    this.fire("destroy", scriptName, scriptInstance || null);
    this.fire(`destroy:${scriptName}`, scriptInstance || null);
    if (scriptInstance) {
      scriptInstance.fire("destroy");
    }
    return true;
  }
  swap(nameOrType) {
    let scriptName = nameOrType;
    let scriptType = nameOrType;
    if (typeof scriptType === "string") {
      scriptType = this.system.app.scripts.get(scriptType);
    } else if (scriptType) {
      scriptName = scriptType.__name;
    }
    const old = this._scriptsIndex[scriptName];
    if (!old || !old.instance) return false;
    const scriptInstanceOld = old.instance;
    const ind = this._scripts.indexOf(scriptInstanceOld);
    const scriptInstance = new scriptType({
      app: this.system.app,
      entity: this.entity,
      enabled: scriptInstanceOld.enabled,
      attributes: scriptInstanceOld.__attributes
    });
    if (!scriptInstance.swap) {
      return false;
    }
    this.initializeAttributes(scriptInstance);
    this._scripts[ind] = scriptInstance;
    this._scriptsIndex[scriptName].instance = scriptInstance;
    this[scriptName] = scriptInstance;
    scriptInstance.__executionOrder = ind;
    if (scriptInstanceOld.update) {
      this._updateList.remove(scriptInstanceOld);
    }
    if (scriptInstanceOld.postUpdate) {
      this._postUpdateList.remove(scriptInstanceOld);
    }
    if (scriptInstance.update) {
      this._updateList.insert(scriptInstance);
    }
    if (scriptInstance.postUpdate) {
      this._postUpdateList.insert(scriptInstance);
    }
    this._scriptMethod(scriptInstance, SCRIPT_SWAP, scriptInstanceOld);
    this.fire("swap", scriptName, scriptInstance);
    this.fire(`swap:${scriptName}`, scriptInstance);
    return true;
  }
  resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {
    const newScriptComponent = this.entity.script;
    for (const scriptName in oldScriptComponent._scriptsIndex) {
      const scriptType = this.system.app.scripts.get(scriptName);
      if (!scriptType) {
        continue;
      }
      const script2 = oldScriptComponent._scriptsIndex[scriptName];
      if (!script2 || !script2.instance) {
        continue;
      }
      const newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
      const newAttributes = newScriptComponent[scriptName].__attributes;
      if (!newAttributesRaw && !newAttributes) {
        continue;
      }
      const useGuid = !!newAttributesRaw;
      const oldAttributes = script2.instance.__attributes;
      for (const attributeName in oldAttributes) {
        if (!oldAttributes[attributeName]) {
          continue;
        }
        const attribute = scriptType.attributes.get(attributeName);
        if (!attribute) {
          continue;
        }
        if (attribute.type === "entity") {
          this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);
        } else if (attribute.type === "json" && Array.isArray(attribute.schema)) {
          const oldValue = oldAttributes[attributeName];
          const newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];
          for (let i = 0; i < attribute.schema.length; i++) {
            const field = attribute.schema[i];
            if (field.type !== "entity") {
              continue;
            }
            if (attribute.array) {
              for (let j = 0; j < oldValue.length; j++) {
                this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);
              }
            } else {
              this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);
            }
          }
        }
      }
    }
  }
  move(nameOrType, ind) {
    const len = this._scripts.length;
    if (ind >= len || ind < 0) {
      return false;
    }
    let scriptType = nameOrType;
    let scriptName = nameOrType;
    if (typeof scriptName !== "string") {
      scriptName = nameOrType.__name;
    } else {
      scriptType = null;
    }
    const scriptData = this._scriptsIndex[scriptName];
    if (!scriptData || !scriptData.instance) {
      return false;
    }
    const scriptInstance = scriptData.instance;
    if (scriptType && !(scriptInstance instanceof scriptType)) {
      return false;
    }
    const indOld = this._scripts.indexOf(scriptInstance);
    if (indOld === -1 || indOld === ind) {
      return false;
    }
    this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);
    this._resetExecutionOrder(0, len);
    this._updateList.sort();
    this._postUpdateList.sort();
    this.fire("move", scriptName, scriptInstance, ind, indOld);
    this.fire(`move:${scriptName}`, scriptInstance, ind, indOld);
    return true;
  }
};
ScriptComponent.EVENT_CREATE = "create";
ScriptComponent.EVENT_DESTROY = "destroy";
ScriptComponent.EVENT_ENABLE = "enable";
ScriptComponent.EVENT_DISABLE = "disable";
ScriptComponent.EVENT_REMOVE = "remove";
ScriptComponent.EVENT_STATE = "state";
ScriptComponent.EVENT_MOVE = "move";
ScriptComponent.EVENT_ERROR = "error";

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/script/data.js
var ScriptComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/script/system.js
var METHOD_INITIALIZE_ATTRIBUTES = "_onInitializeAttributes";
var METHOD_INITIALIZE = "_onInitialize";
var METHOD_POST_INITIALIZE = "_onPostInitialize";
var METHOD_UPDATE = "_onUpdate";
var METHOD_POST_UPDATE = "_onPostUpdate";
var executionOrderCounter = 0;
var ScriptComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "script";
    this.ComponentType = ScriptComponent;
    this.DataType = ScriptComponentData;
    this._components = new SortedLoopArray({
      sortBy: "_executionOrder"
    });
    this._enabledComponents = new SortedLoopArray({
      sortBy: "_executionOrder"
    });
    this.preloading = true;
    this.on("beforeremove", this._onBeforeRemove, this);
    this.app.systems.on("initialize", this._onInitialize, this);
    this.app.systems.on("postInitialize", this._onPostInitialize, this);
    this.app.systems.on("update", this._onUpdate, this);
    this.app.systems.on("postUpdate", this._onPostUpdate, this);
  }
  initializeComponentData(component, data2) {
    component._executionOrder = executionOrderCounter++;
    this._components.append(component);
    if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
      this._resetExecutionOrder();
    }
    component.enabled = data2.hasOwnProperty("enabled") ? !!data2.enabled : true;
    if (component.enabled && component.entity.enabled) {
      this._enabledComponents.append(component);
    }
    if (data2.hasOwnProperty("order") && data2.hasOwnProperty("scripts")) {
      component._scriptsData = data2.scripts;
      for (let i = 0; i < data2.order.length; i++) {
        component.create(data2.order[i], {
          enabled: data2.scripts[data2.order[i]].enabled,
          attributes: data2.scripts[data2.order[i]].attributes,
          preloading: this.preloading
        });
      }
    }
  }
  cloneComponent(entity, clone) {
    const order = [];
    const scripts = {};
    for (let i = 0; i < entity.script._scripts.length; i++) {
      const scriptInstance = entity.script._scripts[i];
      const scriptName = scriptInstance.__scriptType.__name;
      order.push(scriptName);
      const attributes = {};
      for (const key in scriptInstance.__attributes) {
        attributes[key] = scriptInstance.__attributes[key];
      }
      scripts[scriptName] = {
        enabled: scriptInstance._enabled,
        attributes
      };
    }
    for (const key in entity.script._scriptsIndex) {
      if (key.awaiting) {
        order.splice(key.ind, 0, key);
      }
    }
    const data2 = {
      enabled: entity.script.enabled,
      order,
      scripts
    };
    return this.addComponent(clone, data2);
  }
  _resetExecutionOrder() {
    executionOrderCounter = 0;
    for (let i = 0, len = this._components.length; i < len; i++) {
      this._components.items[i]._executionOrder = executionOrderCounter++;
    }
  }
  _callComponentMethod(components2, name, dt) {
    for (components2.loopIndex = 0; components2.loopIndex < components2.length; components2.loopIndex++) {
      components2.items[components2.loopIndex][name](dt);
    }
  }
  _onInitialize() {
    this.preloading = false;
    this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);
    this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
  }
  _onPostInitialize() {
    this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
  }
  _onUpdate(dt) {
    this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
  }
  _onPostUpdate(dt) {
    this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
  }
  _addComponentToEnabled(component) {
    this._enabledComponents.insert(component);
  }
  _removeComponentFromEnabled(component) {
    this._enabledComponents.remove(component);
  }
  _onBeforeRemove(entity, component) {
    const ind = this._components.items.indexOf(component);
    if (ind >= 0) {
      component._onBeforeRemove();
    }
    this._removeComponentFromEnabled(component);
    this._components.remove(component);
  }
  destroy() {
    super.destroy();
    this.app.systems.off("initialize", this._onInitialize, this);
    this.app.systems.off("postInitialize", this._onPostInitialize, this);
    this.app.systems.off("update", this._onUpdate, this);
    this.app.systems.off("postUpdate", this._onPostUpdate, this);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/gsplat/component.js
var GSplatComponent = class extends Component {
  constructor(system, entity) {
    super(system, entity);
    this._layers = [LAYERID_WORLD];
    this._instance = null;
    this._customAabb = null;
    this._assetReference = void 0;
    this._materialOptions = null;
    this._assetReference = new AssetReference("asset", this, system.app.assets, {
      add: this._onGSplatAssetAdded,
      load: this._onGSplatAssetLoad,
      remove: this._onGSplatAssetRemove,
      unload: this._onGSplatAssetUnload
    }, this);
    entity.on("remove", this.onRemoveChild, this);
    entity.on("removehierarchy", this.onRemoveChild, this);
    entity.on("insert", this.onInsertChild, this);
    entity.on("inserthierarchy", this.onInsertChild, this);
  }
  set customAabb(value) {
    var _this$_instance;
    this._customAabb = value;
    (_this$_instance = this._instance) == null || (_this$_instance = _this$_instance.meshInstance) == null || _this$_instance.setCustomAabb(this._customAabb);
  }
  get customAabb() {
    return this._customAabb;
  }
  set instance(value) {
    var _this$_instance2;
    this.destroyInstance();
    this._instance = value;
    if ((_this$_instance2 = this._instance) != null && _this$_instance2.meshInstance) {
      const mi = this._instance.meshInstance;
      if (!mi.node) {
        mi.node = this.entity;
      }
      mi.setCustomAabb(this._customAabb);
      if (this._materialOptions) {
        this._instance.createMaterial(this._materialOptions);
      }
      if (this.enabled && this.entity.enabled) {
        this.addToLayers();
      }
    }
  }
  get instance() {
    return this._instance;
  }
  set materialOptions(value) {
    this._materialOptions = Object.assign({}, value);
    if (this._instance) {
      this._instance.createMaterial(this._materialOptions);
    }
  }
  get materialOptions() {
    return this._materialOptions;
  }
  get material() {
    var _this$_instance3;
    return (_this$_instance3 = this._instance) == null ? void 0 : _this$_instance3.material;
  }
  set layers(value) {
    this.removeFromLayers();
    this._layers.length = 0;
    for (let i = 0; i < value.length; i++) {
      this._layers[i] = value[i];
    }
    if (!this.enabled || !this.entity.enabled) {
      return;
    }
    this.addToLayers();
  }
  get layers() {
    return this._layers;
  }
  set asset(value) {
    const id13 = value instanceof Asset ? value.id : value;
    if (this._assetReference.id === id13) return;
    if (this._assetReference.asset && this._assetReference.asset.resource) {
      this._onGSplatAssetRemove();
    }
    this._assetReference.id = id13;
    if (this._assetReference.asset) {
      this._onGSplatAssetAdded();
    }
  }
  get asset() {
    return this._assetReference.id;
  }
  assignAsset(asset) {
    const id13 = asset instanceof Asset ? asset.id : asset;
    this._assetReference.id = id13;
  }
  destroyInstance() {
    if (this._instance) {
      var _this$_instance4;
      this.removeFromLayers();
      (_this$_instance4 = this._instance) == null || _this$_instance4.destroy();
      this._instance = null;
    }
  }
  addToLayers() {
    var _this$instance;
    const meshInstance = (_this$instance = this.instance) == null ? void 0 : _this$instance.meshInstance;
    if (meshInstance) {
      const layers = this.system.app.scene.layers;
      for (let i = 0; i < this._layers.length; i++) {
        var _layers$getLayerById;
        (_layers$getLayerById = layers.getLayerById(this._layers[i])) == null || _layers$getLayerById.addMeshInstances([meshInstance]);
      }
    }
  }
  removeFromLayers() {
    var _this$instance2;
    const meshInstance = (_this$instance2 = this.instance) == null ? void 0 : _this$instance2.meshInstance;
    if (meshInstance) {
      const layers = this.system.app.scene.layers;
      for (let i = 0; i < this._layers.length; i++) {
        var _layers$getLayerById2;
        (_layers$getLayerById2 = layers.getLayerById(this._layers[i])) == null || _layers$getLayerById2.removeMeshInstances([meshInstance]);
      }
    }
  }
  onRemoveChild() {
    this.removeFromLayers();
  }
  onInsertChild() {
    if (this._instance && this.enabled && this.entity.enabled) {
      this.addToLayers();
    }
  }
  onRemove() {
    this.destroyInstance();
    this.asset = null;
    this._assetReference.id = null;
    this.entity.off("remove", this.onRemoveChild, this);
    this.entity.off("insert", this.onInsertChild, this);
  }
  onLayersChanged(oldComp, newComp) {
    this.addToLayers();
    oldComp.off("add", this.onLayerAdded, this);
    oldComp.off("remove", this.onLayerRemoved, this);
    newComp.on("add", this.onLayerAdded, this);
    newComp.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    if (this._instance) {
      layer.addMeshInstances(this._instance.meshInstance);
    }
  }
  onLayerRemoved(layer) {
    const index = this.layers.indexOf(layer.id);
    if (index < 0) return;
    if (this._instance) {
      layer.removeMeshInstances(this._instance.meshInstance);
    }
  }
  onEnable() {
    const scene = this.system.app.scene;
    scene.on("set:layers", this.onLayersChanged, this);
    if (scene.layers) {
      scene.layers.on("add", this.onLayerAdded, this);
      scene.layers.on("remove", this.onLayerRemoved, this);
    }
    if (this._instance) {
      this.addToLayers();
    } else if (this.asset) {
      this._onGSplatAssetAdded();
    }
  }
  onDisable() {
    const scene = this.system.app.scene;
    scene.off("set:layers", this.onLayersChanged, this);
    if (scene.layers) {
      scene.layers.off("add", this.onLayerAdded, this);
      scene.layers.off("remove", this.onLayerRemoved, this);
    }
    this.removeFromLayers();
  }
  hide() {
    if (this._instance) {
      this._instance.meshInstance.visible = false;
    }
  }
  show() {
    if (this._instance) {
      this._instance.meshInstance.visible = true;
    }
  }
  _onGSplatAssetAdded() {
    if (!this._assetReference.asset) {
      return;
    }
    if (this._assetReference.asset.resource) {
      this._onGSplatAssetLoad();
    } else if (this.enabled && this.entity.enabled) {
      this.system.app.assets.load(this._assetReference.asset);
    }
  }
  _onGSplatAssetLoad() {
    this.destroyInstance();
    const asset = this._assetReference.asset;
    if (asset) {
      this.instance = asset.resource.createInstance();
    }
  }
  _onGSplatAssetUnload() {
    this.destroyInstance();
  }
  _onGSplatAssetRemove() {
    this._onGSplatAssetUnload();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/gsplat/data.js
var GSplatComponentData = class {
  constructor() {
    this.enabled = true;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/components/gsplat/system.js
var _schema21 = ["enabled"];
var _properties2 = ["instance", "asset", "layers"];
var GSplatComponentSystem = class extends ComponentSystem {
  constructor(app2) {
    super(app2);
    this.id = "gsplat";
    this.ComponentType = GSplatComponent;
    this.DataType = GSplatComponentData;
    this.schema = _schema21;
    this.on("beforeremove", this.onRemove, this);
  }
  initializeComponentData(component, _data, properties3) {
    if (_data.layers && _data.layers.length) {
      _data.layers = _data.layers.slice(0);
    }
    for (let i = 0; i < _properties2.length; i++) {
      if (_data.hasOwnProperty(_properties2[i])) {
        component[_properties2[i]] = _data[_properties2[i]];
      }
    }
    if (_data.aabbCenter && _data.aabbHalfExtents) {
      component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
    }
    super.initializeComponentData(component, _data, _schema21);
  }
  cloneComponent(entity, clone) {
    const gSplatComponent = entity.gsplat;
    const data2 = {};
    for (let i = 0; i < _properties2.length; i++) {
      data2[_properties2[i]] = gSplatComponent[_properties2[i]];
    }
    data2.enabled = gSplatComponent.enabled;
    delete data2.instance;
    const component = this.addComponent(clone, data2);
    component.instance = gSplatComponent.instance.clone();
    if (gSplatComponent.customAabb) {
      component.customAabb = gSplatComponent.customAabb.clone();
    }
    return component;
  }
  onRemove(entity, component) {
    component.onRemove();
  }
};
Component._buildAccessors(GSplatComponent.prototype, _schema21);

// ../node_modules/playcanvas/build/playcanvas/src/scene/render.js
var Render = class extends EventHandler {
  constructor(...args) {
    super(...args);
    this._meshes = null;
  }
  set meshes(value) {
    this.decRefMeshes();
    this._meshes = value;
    this.incRefMeshes();
    this.fire("set:meshes", value);
  }
  get meshes() {
    return this._meshes;
  }
  destroy() {
    this.meshes = null;
  }
  decRefMeshes() {
    var _this$_meshes;
    (_this$_meshes = this._meshes) == null || _this$_meshes.forEach((mesh, index) => {
      if (mesh) {
        mesh.decRefCount();
        if (mesh.refCount < 1) {
          mesh.destroy();
          this._meshes[index] = null;
        }
      }
    });
  }
  incRefMeshes() {
    var _this$_meshes2;
    (_this$_meshes2 = this._meshes) == null || _this$_meshes2.forEach((mesh) => {
      mesh == null || mesh.incRefCount();
    });
  }
};
Render.EVENT_SETMESHES = "set:meshes";

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/render.js
function onContainerAssetLoaded(containerAsset) {
  const renderAsset = this;
  if (!renderAsset.resource) return;
  const containerResource = containerAsset.resource;
  const render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];
  if (render) {
    renderAsset.resource.meshes = render.resource.meshes;
  }
}
function onContainerAssetAdded(containerAsset) {
  const renderAsset = this;
  renderAsset.registry.off(`load:${containerAsset.id}`, onContainerAssetLoaded, renderAsset);
  renderAsset.registry.on(`load:${containerAsset.id}`, onContainerAssetLoaded, renderAsset);
  renderAsset.registry.off(`remove:${containerAsset.id}`, onContainerAssetRemoved, renderAsset);
  renderAsset.registry.once(`remove:${containerAsset.id}`, onContainerAssetRemoved, renderAsset);
  if (!containerAsset.resource) {
    renderAsset.registry.load(containerAsset);
  } else {
    onContainerAssetLoaded.call(renderAsset, containerAsset);
  }
}
function onContainerAssetRemoved(containerAsset) {
  const renderAsset = this;
  renderAsset.registry.off(`load:${containerAsset.id}`, onContainerAssetLoaded, renderAsset);
  if (renderAsset.resource) {
    renderAsset.resource.destroy();
  }
}
var RenderHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "render");
    this._registry = app2.assets;
  }
  open(url, data2) {
    return new Render();
  }
  patch(asset, registry) {
    if (!asset.data.containerAsset) {
      return;
    }
    const containerAsset = registry.get(asset.data.containerAsset);
    if (!containerAsset) {
      registry.once(`add:${asset.data.containerAsset}`, onContainerAssetAdded, asset);
      return;
    }
    onContainerAssetAdded.call(asset, containerAsset);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-curve.js
var AnimCurve = class {
  constructor(paths, input, output, interpolation) {
    this._paths = paths;
    this._input = input;
    this._output = output;
    this._interpolation = interpolation;
  }
  get paths() {
    return this._paths;
  }
  get input() {
    return this._input;
  }
  get output() {
    return this._output;
  }
  get interpolation() {
    return this._interpolation;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-data.js
var AnimData = class {
  constructor(components2, data2) {
    this._components = components2;
    this._data = data2;
  }
  get components() {
    return this._components;
  }
  get data() {
    return this._data;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/draco-worker.js
function DracoWorker(jsUrl, wasmUrl) {
  let draco;
  const POSITION_ATTRIBUTE = 0;
  const NORMAL_ATTRIBUTE = 1;
  const wrap = (typedArray, dataType) => {
    switch (dataType) {
      case draco.DT_INT8:
        return new Int8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
      case draco.DT_INT16:
        return new Int16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
      case draco.DT_INT32:
        return new Int32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
      case draco.DT_UINT8:
        return new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
      case draco.DT_UINT16:
        return new Uint16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
      case draco.DT_UINT32:
        return new Uint32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
      case draco.DT_FLOAT32:
        return new Float32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
    }
    return null;
  };
  const componentSizeInBytes = (dataType) => {
    switch (dataType) {
      case draco.DT_INT8:
        return 1;
      case draco.DT_INT16:
        return 2;
      case draco.DT_INT32:
        return 4;
      case draco.DT_UINT8:
        return 1;
      case draco.DT_UINT16:
        return 2;
      case draco.DT_UINT32:
        return 4;
      case draco.DT_FLOAT32:
        return 4;
    }
    return 1;
  };
  const attributeSizeInBytes = (attribute) => {
    return attribute.num_components() * componentSizeInBytes(attribute.data_type());
  };
  const attributeOrder2 = {
    0: 0,
    1: 1,
    5: 2,
    2: 3,
    7: 4,
    8: 5,
    4: 6,
    3: 7
  };
  const generateNormals2 = (vertices, indices) => {
    const subtract = (dst, a2, b2) => {
      dst[0] = a2[0] - b2[0];
      dst[1] = a2[1] - b2[1];
      dst[2] = a2[2] - b2[2];
    };
    const cross = (dst, a2, b2) => {
      dst[0] = a2[1] * b2[2] - b2[1] * a2[2];
      dst[1] = a2[2] * b2[0] - b2[2] * a2[0];
      dst[2] = a2[0] * b2[1] - b2[0] * a2[1];
    };
    const normalize = (dst, offset) => {
      const a2 = dst[offset + 0];
      const b2 = dst[offset + 1];
      const c3 = dst[offset + 2];
      const l = 1 / Math.sqrt(a2 * a2 + b2 * b2 + c3 * c3);
      dst[offset + 0] *= l;
      dst[offset + 1] *= l;
      dst[offset + 2] *= l;
    };
    const copy = (dst, src, srcOffset) => {
      for (let i = 0; i < 3; ++i) {
        dst[i] = src[srcOffset + i];
      }
    };
    const numTriangles = indices.length / 3;
    const numVertices = vertices.length / 3;
    const result = new Float32Array(vertices.length);
    const a = [0, 0, 0], b = [0, 0, 0], c2 = [0, 0, 0], t1 = [0, 0, 0], t2 = [0, 0, 0], n = [0, 0, 0];
    for (let i = 0; i < numTriangles; ++i) {
      const v0 = indices[i * 3 + 0] * 3;
      const v1 = indices[i * 3 + 1] * 3;
      const v22 = indices[i * 3 + 2] * 3;
      copy(a, vertices, v0);
      copy(b, vertices, v1);
      copy(c2, vertices, v22);
      subtract(t1, b, a);
      subtract(t2, c2, a);
      cross(n, t1, t2);
      normalize(n, 0);
      for (let j = 0; j < 3; ++j) {
        result[v0 + j] += n[j];
        result[v1 + j] += n[j];
        result[v22 + j] += n[j];
      }
    }
    for (let i = 0; i < numVertices; ++i) {
      normalize(result, i * 3);
    }
    return new Uint8Array(result.buffer);
  };
  const decodeMesh = (inputBuffer) => {
    const result = {};
    const buffer = new draco.DecoderBuffer();
    buffer.Init(inputBuffer, inputBuffer.length);
    const decoder = new draco.Decoder();
    if (decoder.GetEncodedGeometryType(buffer) !== draco.TRIANGULAR_MESH) {
      result.error = "Failed to decode draco mesh: not a mesh";
      return result;
    }
    const mesh = new draco.Mesh();
    const status = decoder.DecodeBufferToMesh(buffer, mesh);
    if (!status || !status.ok() || mesh.ptr === 0) {
      result.error = "Failed to decode draco asset";
      return result;
    }
    const numIndices = mesh.num_faces() * 3;
    const shortIndices = mesh.num_points() <= 65535;
    const indicesSize = numIndices * (shortIndices ? 2 : 4);
    const indicesPtr = draco._malloc(indicesSize);
    if (shortIndices) {
      decoder.GetTrianglesUInt16Array(mesh, indicesSize, indicesPtr);
      result.indices = new Uint16Array(draco.HEAPU16.buffer, indicesPtr, numIndices).slice().buffer;
    } else {
      decoder.GetTrianglesUInt32Array(mesh, indicesSize, indicesPtr);
      result.indices = new Uint32Array(draco.HEAPU32.buffer, indicesPtr, numIndices).slice().buffer;
    }
    draco._free(indicesPtr);
    const attributes = [];
    for (let i = 0; i < mesh.num_attributes(); ++i) {
      attributes.push(decoder.GetAttribute(mesh, i));
    }
    attributes.sort((a, b) => {
      var _attributeOrder$a$att, _attributeOrder$b$att;
      return ((_attributeOrder$a$att = attributeOrder2[a.attribute_type()]) != null ? _attributeOrder$a$att : attributeOrder2.length) - ((_attributeOrder$b$att = attributeOrder2[b.attribute_type()]) != null ? _attributeOrder$b$att : attributeOrder2.length);
    });
    result.attributes = attributes.map((a) => a.unique_id());
    let totalVertexSize = 0;
    const offsets = attributes.map((a) => {
      const offset = totalVertexSize;
      totalVertexSize += Math.ceil(attributeSizeInBytes(a) / 4) * 4;
      return offset;
    });
    const hasNormals = attributes.some((a) => a.attribute_type() === NORMAL_ATTRIBUTE);
    const normalOffset = offsets[1];
    if (!hasNormals) {
      for (let i = 1; i < offsets.length; ++i) {
        offsets[i] += 12;
      }
      totalVertexSize += 12;
    }
    result.vertices = new ArrayBuffer(mesh.num_points() * totalVertexSize);
    const dst = new Uint8Array(result.vertices);
    for (let i = 0; i < mesh.num_attributes(); ++i) {
      const attribute = attributes[i];
      const sizeInBytes = attributeSizeInBytes(attribute);
      const ptrSize = mesh.num_points() * sizeInBytes;
      const ptr = draco._malloc(ptrSize);
      decoder.GetAttributeDataArrayForAllPoints(mesh, attribute, attribute.data_type(), ptrSize, ptr);
      const src = new Uint8Array(draco.HEAPU8.buffer, ptr, ptrSize);
      for (let j = 0; j < mesh.num_points(); ++j) {
        for (let c2 = 0; c2 < sizeInBytes; ++c2) {
          dst[j * totalVertexSize + offsets[i] + c2] = src[j * sizeInBytes + c2];
        }
      }
      if (!hasNormals && attribute.attribute_type() === POSITION_ATTRIBUTE) {
        const normals = generateNormals2(wrap(src, attribute.data_type()), shortIndices ? new Uint16Array(result.indices) : new Uint32Array(result.indices));
        for (let j = 0; j < mesh.num_points(); ++j) {
          for (let c2 = 0; c2 < 12; ++c2) {
            dst[j * totalVertexSize + normalOffset + c2] = normals[j * 12 + c2];
          }
        }
      }
      draco._free(ptr);
    }
    draco.destroy(mesh);
    draco.destroy(decoder);
    draco.destroy(buffer);
    return result;
  };
  const decode = (data2) => {
    const result = decodeMesh(new Uint8Array(data2.buffer));
    self.postMessage({
      jobId: data2.jobId,
      error: result.error,
      indices: result.indices,
      vertices: result.vertices,
      attributes: result.attributes
    }, [result.indices, result.vertices].filter((t) => t != null));
  };
  const workQueue = [];
  self.onmessage = (message) => {
    const data2 = message.data;
    switch (data2.type) {
      case "init":
        self.DracoDecoderModule({
          instantiateWasm: (imports, successCallback) => {
            WebAssembly.instantiate(data2.module, imports).then((result) => successCallback(result)).catch((reason) => console.error(`instantiate failed + ${reason}`));
            return {};
          }
        }).then((instance) => {
          draco = instance;
          workQueue.forEach((data3) => decode(data3));
        });
        break;
      case "decodeMesh":
        if (draco) {
          decode(data2);
        } else {
          workQueue.push(data2);
        }
        break;
    }
  };
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/draco-decoder.js
var downloadMaxRetries = 3;
var JobQueue = class {
  constructor() {
    this.workers = [[], [], []];
    this.jobId = 0;
    this.jobQueue = [];
    this.jobCallbacks = /* @__PURE__ */ new Map();
    this.run = (worker, job) => {
      worker.postMessage({
        type: "decodeMesh",
        jobId: job.jobId,
        buffer: job.buffer
      }, [job.buffer]);
    };
  }
  init(workers2) {
    workers2.forEach((worker) => {
      worker.addEventListener("message", (message) => {
        const data2 = message.data;
        const callback = this.jobCallbacks.get(data2.jobId);
        if (callback) {
          callback(data2.error, {
            indices: data2.indices,
            vertices: data2.vertices,
            attributes: data2.attributes
          });
        }
        this.jobCallbacks.delete(data2.jobId);
        if (this.jobQueue.length > 0) {
          const job = this.jobQueue.shift();
          this.run(worker, job);
        } else {
          const index2 = this.workers[2].indexOf(worker);
          if (index2 !== -1) {
            this.workers[2].splice(index2, 1);
            this.workers[1].push(worker);
          } else {
            const index1 = this.workers[1].indexOf(worker);
            if (index1 !== -1) {
              this.workers[1].splice(index1, 1);
              this.workers[0].push(worker);
            }
          }
        }
      });
    });
    this.workers[0] = workers2;
    while (this.jobQueue.length && (this.workers[0].length || this.workers[1].length)) {
      const job = this.jobQueue.shift();
      if (this.workers[0].length > 0) {
        const worker = this.workers[0].shift();
        this.workers[1].push(worker);
        this.run(worker, job);
      } else {
        const worker = this.workers[1].shift();
        this.workers[2].push(worker);
        this.run(worker, job);
      }
    }
  }
  enqueueJob(buffer, callback) {
    const job = {
      jobId: this.jobId++,
      buffer
    };
    this.jobCallbacks.set(job.jobId, callback);
    if (this.workers[0].length > 0) {
      const worker = this.workers[0].shift();
      this.workers[1].push(worker);
      this.run(worker, job);
    } else if (this.workers[1].length > 0) {
      const worker = this.workers[1].shift();
      this.workers[2].push(worker);
      this.run(worker, job);
    } else {
      this.jobQueue.push(job);
    }
  }
};
var downloadScript = (url) => {
  return new Promise((resolve, reject) => {
    const options2 = {
      cache: true,
      responseType: "text",
      retry: downloadMaxRetries > 0,
      maxRetries: downloadMaxRetries
    };
    http.get(url, options2, (err3, response) => {
      if (err3) {
        reject(err3);
      } else {
        resolve(response);
      }
    });
  });
};
var compileModule = (url) => {
  const compileManual = () => {
    return fetch(url).then((result) => result.arrayBuffer()).then((buffer) => WebAssembly.compile(buffer));
  };
  const compileStreaming = () => {
    return WebAssembly.compileStreaming(fetch(url)).catch((err3) => {
      return compileManual();
    });
  };
  return WebAssembly.compileStreaming ? compileStreaming() : compileManual();
};
var defaultNumWorkers = 1;
var jobQueue;
var lazyConfig;
var initializeWorkers = (config) => {
  if (jobQueue) {
    return true;
  }
  if (!config) {
    if (lazyConfig) {
      config = lazyConfig;
    } else {
      const moduleConfig = WasmModule.getConfig("DracoDecoderModule");
      if (moduleConfig) {
        config = {
          jsUrl: moduleConfig.glueUrl,
          wasmUrl: moduleConfig.wasmUrl,
          numWorkers: moduleConfig.numWorkers
        };
      } else {
        config = {
          jsUrl: "draco.wasm.js",
          wasmUrl: "draco.wasm.wasm",
          numWorkers: defaultNumWorkers
        };
      }
    }
  }
  if (!config.jsUrl || !config.wasmUrl) {
    return false;
  }
  jobQueue = new JobQueue();
  Promise.all([downloadScript(config.jsUrl), compileModule(config.wasmUrl)]).then(([dracoSource, dracoModule]) => {
    const code = ["/* draco */", dracoSource, "/* worker */", `(
${DracoWorker.toString()}
)()

`].join("\n");
    const blob = new Blob([code], {
      type: "application/javascript"
    });
    const workerUrl = URL.createObjectURL(blob);
    const numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));
    const workers2 = [];
    for (let i = 0; i < numWorkers; ++i) {
      const worker = new Worker(workerUrl);
      worker.postMessage({
        type: "init",
        module: dracoModule
      });
      workers2.push(worker);
    }
    jobQueue.init(workers2);
  });
  return true;
};
var dracoInitialize = (config) => {
  if (config != null && config.lazyInit) {
    lazyConfig = config;
  } else {
    initializeWorkers(config);
  }
};
var dracoDecode = (buffer, callback) => {
  if (!initializeWorkers()) {
    return false;
  }
  jobQueue.enqueueJob(buffer, callback);
  return true;
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/glb-parser.js
var GlbResources = class {
  constructor() {
    this.gltf = void 0;
    this.nodes = void 0;
    this.scenes = void 0;
    this.animations = void 0;
    this.textures = void 0;
    this.materials = void 0;
    this.variants = void 0;
    this.meshVariants = void 0;
    this.meshDefaultMaterials = void 0;
    this.renders = void 0;
    this.skins = void 0;
    this.lights = void 0;
    this.cameras = void 0;
    this.nodeInstancingMap = void 0;
  }
  destroy() {
    if (this.renders) {
      this.renders.forEach((render) => {
        render.meshes = null;
      });
    }
  }
};
var isDataURI = (uri) => {
  return /^data:[^\n\r,\u2028\u2029]*,.*$/i.test(uri);
};
var getDataURIMimeType = (uri) => {
  return uri.substring(uri.indexOf(":") + 1, uri.indexOf(";"));
};
var getNumComponents = (accessorType) => {
  switch (accessorType) {
    case "SCALAR":
      return 1;
    case "VEC2":
      return 2;
    case "VEC3":
      return 3;
    case "VEC4":
      return 4;
    case "MAT2":
      return 4;
    case "MAT3":
      return 9;
    case "MAT4":
      return 16;
    default:
      return 3;
  }
};
var getComponentType = (componentType) => {
  switch (componentType) {
    case 5120:
      return TYPE_INT8;
    case 5121:
      return TYPE_UINT8;
    case 5122:
      return TYPE_INT16;
    case 5123:
      return TYPE_UINT16;
    case 5124:
      return TYPE_INT32;
    case 5125:
      return TYPE_UINT32;
    case 5126:
      return TYPE_FLOAT32;
    default:
      return 0;
  }
};
var getComponentSizeInBytes = (componentType) => {
  switch (componentType) {
    case 5120:
      return 1;
    case 5121:
      return 1;
    case 5122:
      return 2;
    case 5123:
      return 2;
    case 5124:
      return 4;
    case 5125:
      return 4;
    case 5126:
      return 4;
    default:
      return 0;
  }
};
var getComponentDataType = (componentType) => {
  switch (componentType) {
    case 5120:
      return Int8Array;
    case 5121:
      return Uint8Array;
    case 5122:
      return Int16Array;
    case 5123:
      return Uint16Array;
    case 5124:
      return Int32Array;
    case 5125:
      return Uint32Array;
    case 5126:
      return Float32Array;
    default:
      return null;
  }
};
var gltfToEngineSemanticMap = {
  "POSITION": SEMANTIC_POSITION,
  "NORMAL": SEMANTIC_NORMAL,
  "TANGENT": SEMANTIC_TANGENT,
  "COLOR_0": SEMANTIC_COLOR,
  "JOINTS_0": SEMANTIC_BLENDINDICES,
  "WEIGHTS_0": SEMANTIC_BLENDWEIGHT,
  "TEXCOORD_0": SEMANTIC_TEXCOORD0,
  "TEXCOORD_1": SEMANTIC_TEXCOORD1,
  "TEXCOORD_2": SEMANTIC_TEXCOORD2,
  "TEXCOORD_3": SEMANTIC_TEXCOORD3,
  "TEXCOORD_4": SEMANTIC_TEXCOORD4,
  "TEXCOORD_5": SEMANTIC_TEXCOORD5,
  "TEXCOORD_6": SEMANTIC_TEXCOORD6,
  "TEXCOORD_7": SEMANTIC_TEXCOORD7
};
var attributeOrder = {
  [SEMANTIC_POSITION]: 0,
  [SEMANTIC_NORMAL]: 1,
  [SEMANTIC_TANGENT]: 2,
  [SEMANTIC_COLOR]: 3,
  [SEMANTIC_BLENDINDICES]: 4,
  [SEMANTIC_BLENDWEIGHT]: 5,
  [SEMANTIC_TEXCOORD0]: 6,
  [SEMANTIC_TEXCOORD1]: 7,
  [SEMANTIC_TEXCOORD2]: 8,
  [SEMANTIC_TEXCOORD3]: 9,
  [SEMANTIC_TEXCOORD4]: 10,
  [SEMANTIC_TEXCOORD5]: 11,
  [SEMANTIC_TEXCOORD6]: 12,
  [SEMANTIC_TEXCOORD7]: 13
};
var getDequantizeFunc = (srcType) => {
  switch (srcType) {
    case TYPE_INT8:
      return (x2) => Math.max(x2 / 127, -1);
    case TYPE_UINT8:
      return (x2) => x2 / 255;
    case TYPE_INT16:
      return (x2) => Math.max(x2 / 32767, -1);
    case TYPE_UINT16:
      return (x2) => x2 / 65535;
    default:
      return (x2) => x2;
  }
};
var dequantizeArray = (dstArray, srcArray, srcType) => {
  const convFunc = getDequantizeFunc(srcType);
  const len = srcArray.length;
  for (let i = 0; i < len; ++i) {
    dstArray[i] = convFunc(srcArray[i]);
  }
  return dstArray;
};
var getAccessorData = (gltfAccessor, bufferViews, flatten = false) => {
  const numComponents = getNumComponents(gltfAccessor.type);
  const dataType = getComponentDataType(gltfAccessor.componentType);
  if (!dataType) {
    return null;
  }
  let result;
  if (gltfAccessor.sparse) {
    const sparse = gltfAccessor.sparse;
    const indicesAccessor = {
      count: sparse.count,
      type: "SCALAR"
    };
    const indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);
    const valuesAccessor = {
      count: sparse.count,
      type: gltfAccessor.type,
      componentType: gltfAccessor.componentType
    };
    const values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);
    if (gltfAccessor.hasOwnProperty("bufferView")) {
      const baseAccessor = {
        bufferView: gltfAccessor.bufferView,
        byteOffset: gltfAccessor.byteOffset,
        componentType: gltfAccessor.componentType,
        count: gltfAccessor.count,
        type: gltfAccessor.type
      };
      result = getAccessorData(baseAccessor, bufferViews, true).slice();
    } else {
      result = new dataType(gltfAccessor.count * numComponents);
    }
    for (let i = 0; i < sparse.count; ++i) {
      const targetIndex = indices[i];
      for (let j = 0; j < numComponents; ++j) {
        result[targetIndex * numComponents + j] = values[i * numComponents + j];
      }
    }
  } else {
    if (gltfAccessor.hasOwnProperty("bufferView")) {
      const bufferView = bufferViews[gltfAccessor.bufferView];
      if (flatten && bufferView.hasOwnProperty("byteStride")) {
        const bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;
        const storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);
        const tmpArray = new Uint8Array(storage);
        let dstOffset = 0;
        for (let i = 0; i < gltfAccessor.count; ++i) {
          let srcOffset = (gltfAccessor.byteOffset || 0) + i * bufferView.byteStride;
          for (let b = 0; b < bytesPerElement; ++b) {
            tmpArray[dstOffset++] = bufferView[srcOffset++];
          }
        }
        result = new dataType(storage);
      } else {
        result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);
      }
    } else {
      result = new dataType(gltfAccessor.count * numComponents);
    }
  }
  return result;
};
var getAccessorDataFloat32 = (gltfAccessor, bufferViews) => {
  const data2 = getAccessorData(gltfAccessor, bufferViews, true);
  if (data2 instanceof Float32Array || !gltfAccessor.normalized) {
    return data2;
  }
  const float32Data = new Float32Array(data2.length);
  dequantizeArray(float32Data, data2, getComponentType(gltfAccessor.componentType));
  return float32Data;
};
var getAccessorBoundingBox = (gltfAccessor) => {
  let min = gltfAccessor.min;
  let max = gltfAccessor.max;
  if (!min || !max) {
    return null;
  }
  if (gltfAccessor.normalized) {
    const ctype = getComponentType(gltfAccessor.componentType);
    min = dequantizeArray([], min, ctype);
    max = dequantizeArray([], max, ctype);
  }
  return new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
};
var getPrimitiveType = (primitive2) => {
  if (!primitive2.hasOwnProperty("mode")) {
    return PRIMITIVE_TRIANGLES;
  }
  switch (primitive2.mode) {
    case 0:
      return PRIMITIVE_POINTS;
    case 1:
      return PRIMITIVE_LINES;
    case 2:
      return PRIMITIVE_LINELOOP;
    case 3:
      return PRIMITIVE_LINESTRIP;
    case 4:
      return PRIMITIVE_TRIANGLES;
    case 5:
      return PRIMITIVE_TRISTRIP;
    case 6:
      return PRIMITIVE_TRIFAN;
    default:
      return PRIMITIVE_TRIANGLES;
  }
};
var generateIndices = (numVertices) => {
  const dummyIndices = new Uint16Array(numVertices);
  for (let i = 0; i < numVertices; i++) {
    dummyIndices[i] = i;
  }
  return dummyIndices;
};
var generateNormals = (sourceDesc, indices) => {
  const p = sourceDesc[SEMANTIC_POSITION];
  if (!p || p.components !== 3) {
    return;
  }
  let positions;
  if (p.size !== p.stride) {
    const srcStride = p.stride / typedArrayTypesByteSize[p.type];
    const src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
    positions = new typedArrayTypes[p.type](p.count * 3);
    for (let i = 0; i < p.count; ++i) {
      positions[i * 3 + 0] = src[i * srcStride + 0];
      positions[i * 3 + 1] = src[i * srcStride + 1];
      positions[i * 3 + 2] = src[i * srcStride + 2];
    }
  } else {
    positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
  }
  const numVertices = p.count;
  if (!indices) {
    indices = generateIndices(numVertices);
  }
  const normalsTemp = calculateNormals(positions, indices);
  const normals = new Float32Array(normalsTemp.length);
  normals.set(normalsTemp);
  sourceDesc[SEMANTIC_NORMAL] = {
    buffer: normals.buffer,
    size: 12,
    offset: 0,
    stride: 12,
    count: numVertices,
    components: 3,
    type: TYPE_FLOAT32
  };
};
var cloneTexture = (texture) => {
  const shallowCopyLevels = (texture2) => {
    const result2 = [];
    for (let mip = 0; mip < texture2._levels.length; ++mip) {
      let level = [];
      if (texture2.cubemap) {
        for (let face = 0; face < 6; ++face) {
          level.push(texture2._levels[mip][face]);
        }
      } else {
        level = texture2._levels[mip];
      }
      result2.push(level);
    }
    return result2;
  };
  const result = new Texture(texture.device, texture);
  result._levels = shallowCopyLevels(texture);
  return result;
};
var cloneTextureAsset = (src) => {
  const result = new Asset(`${src.name}_clone`, src.type, src.file, src.data, src.options);
  result.loaded = true;
  result.resource = cloneTexture(src.resource);
  src.registry.add(result);
  return result;
};
var createVertexBufferInternal = (device, sourceDesc) => {
  const positionDesc = sourceDesc[SEMANTIC_POSITION];
  if (!positionDesc) {
    return null;
  }
  const numVertices = positionDesc.count;
  const vertexDesc = [];
  for (const semantic in sourceDesc) {
    if (sourceDesc.hasOwnProperty(semantic)) {
      const element = {
        semantic,
        components: sourceDesc[semantic].components,
        type: sourceDesc[semantic].type,
        normalize: !!sourceDesc[semantic].normalize
      };
      if (!VertexFormat.isElementValid(device, element)) {
        element.components++;
      }
      vertexDesc.push(element);
    }
  }
  vertexDesc.sort((lhs, rhs) => {
    return attributeOrder[lhs.semantic] - attributeOrder[rhs.semantic];
  });
  let i, j, k;
  let source, target2, sourceOffset;
  const vertexFormat = new VertexFormat(device, vertexDesc);
  let isCorrectlyInterleaved = true;
  for (i = 0; i < vertexFormat.elements.length; ++i) {
    target2 = vertexFormat.elements[i];
    source = sourceDesc[target2.name];
    sourceOffset = source.offset - positionDesc.offset;
    if (source.buffer !== positionDesc.buffer || source.stride !== target2.stride || source.size !== target2.size || sourceOffset !== target2.offset) {
      isCorrectlyInterleaved = false;
      break;
    }
  }
  const vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices);
  const vertexData = vertexBuffer.lock();
  const targetArray = new Uint32Array(vertexData);
  let sourceArray;
  if (isCorrectlyInterleaved) {
    sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);
    targetArray.set(sourceArray);
  } else {
    let targetStride, sourceStride;
    for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
      target2 = vertexBuffer.format.elements[i];
      targetStride = target2.stride / 4;
      source = sourceDesc[target2.name];
      sourceStride = source.stride / 4;
      sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);
      let src = 0;
      let dst = target2.offset / 4;
      const kend = Math.floor((source.size + 3) / 4);
      for (j = 0; j < numVertices; ++j) {
        for (k = 0; k < kend; ++k) {
          targetArray[dst + k] = sourceArray[src + k];
        }
        src += sourceStride;
        dst += targetStride;
      }
    }
  }
  vertexBuffer.unlock();
  return vertexBuffer;
};
var createVertexBuffer = (device, attributes, indices, accessors, bufferViews, vertexBufferDict) => {
  const useAttributes = {};
  const attribIds = [];
  for (const attrib in attributes) {
    if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
      useAttributes[attrib] = attributes[attrib];
      attribIds.push(`${attrib}:${attributes[attrib]}`);
    }
  }
  attribIds.sort();
  const vbKey = attribIds.join();
  let vb = vertexBufferDict[vbKey];
  if (!vb) {
    const sourceDesc = {};
    for (const attrib in useAttributes) {
      const accessor = accessors[attributes[attrib]];
      const accessorData = getAccessorData(accessor, bufferViews);
      const bufferView = bufferViews[accessor.bufferView];
      const semantic = gltfToEngineSemanticMap[attrib];
      const size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
      const stride = bufferView && bufferView.hasOwnProperty("byteStride") ? bufferView.byteStride : size;
      sourceDesc[semantic] = {
        buffer: accessorData.buffer,
        size,
        offset: accessorData.byteOffset,
        stride,
        count: accessor.count,
        components: getNumComponents(accessor.type),
        type: getComponentType(accessor.componentType),
        normalize: accessor.normalized
      };
    }
    if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
      generateNormals(sourceDesc, indices);
    }
    vb = createVertexBufferInternal(device, sourceDesc);
    vertexBufferDict[vbKey] = vb;
  }
  return vb;
};
var createSkin = (device, gltfSkin, accessors, bufferViews, nodes, glbSkins) => {
  let i, j, bindMatrix;
  const joints = gltfSkin.joints;
  const numJoints = joints.length;
  const ibp = [];
  if (gltfSkin.hasOwnProperty("inverseBindMatrices")) {
    const inverseBindMatrices = gltfSkin.inverseBindMatrices;
    const ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);
    const ibmValues = [];
    for (i = 0; i < numJoints; i++) {
      for (j = 0; j < 16; j++) {
        ibmValues[j] = ibmData[i * 16 + j];
      }
      bindMatrix = new Mat4();
      bindMatrix.set(ibmValues);
      ibp.push(bindMatrix);
    }
  } else {
    for (i = 0; i < numJoints; i++) {
      bindMatrix = new Mat4();
      ibp.push(bindMatrix);
    }
  }
  const boneNames = [];
  for (i = 0; i < numJoints; i++) {
    boneNames[i] = nodes[joints[i]].name;
  }
  const key = boneNames.join("#");
  let skin = glbSkins.get(key);
  if (!skin) {
    skin = new Skin(device, ibp, boneNames);
    glbSkins.set(key, skin);
  }
  return skin;
};
var createDracoMesh = (device, primitive2, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises) => {
  var _primitive$extensions;
  const result = new Mesh(device);
  result.aabb = getAccessorBoundingBox(accessors[primitive2.attributes.POSITION]);
  const vertexDesc = [];
  for (const [name, index] of Object.entries(primitive2.attributes)) {
    var _accessor$normalized;
    const accessor = accessors[index];
    const semantic = gltfToEngineSemanticMap[name];
    const componentType = getComponentType(accessor.componentType);
    vertexDesc.push({
      semantic,
      components: getNumComponents(accessor.type),
      type: componentType,
      normalize: (_accessor$normalized = accessor.normalized) != null ? _accessor$normalized : semantic === SEMANTIC_COLOR && (componentType === TYPE_UINT8 || componentType === TYPE_UINT16)
    });
  }
  promises.push(new Promise((resolve, reject) => {
    const dracoExt = primitive2.extensions.KHR_draco_mesh_compression;
    dracoDecode(bufferViews[dracoExt.bufferView].slice().buffer, (err3, decompressedData) => {
      if (err3) {
        console.log(err3);
        reject(err3);
      } else {
        var _primitive$attributes;
        const order = {};
        for (const [name, index] of Object.entries(dracoExt.attributes)) {
          order[gltfToEngineSemanticMap[name]] = decompressedData.attributes.indexOf(index);
        }
        vertexDesc.sort((a, b) => {
          return order[a.semantic] - order[b.semantic];
        });
        if (!((_primitive$attributes = primitive2.attributes) != null && _primitive$attributes.NORMAL)) {
          vertexDesc.splice(1, 0, {
            semantic: "NORMAL",
            components: 3,
            type: TYPE_FLOAT32
          });
        }
        const vertexFormat = new VertexFormat(device, vertexDesc);
        const numVertices = decompressedData.vertices.byteLength / vertexFormat.size;
        const indexFormat = numVertices <= 65535 ? INDEXFORMAT_UINT16 : INDEXFORMAT_UINT32;
        const numIndices = decompressedData.indices.byteLength / (numVertices <= 65535 ? 2 : 4);
        const vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, {
          data: decompressedData.vertices
        });
        const indexBuffer = new IndexBuffer(device, indexFormat, numIndices, BUFFER_STATIC, decompressedData.indices);
        result.vertexBuffer = vertexBuffer;
        result.indexBuffer[0] = indexBuffer;
        result.primitive[0].type = getPrimitiveType(primitive2);
        result.primitive[0].base = 0;
        result.primitive[0].count = indexBuffer ? numIndices : numVertices;
        result.primitive[0].indexed = !!indexBuffer;
        resolve();
      }
    });
  }));
  if (primitive2 != null && (_primitive$extensions = primitive2.extensions) != null && _primitive$extensions.KHR_materials_variants) {
    const variants = primitive2.extensions.KHR_materials_variants;
    const tempMapping = {};
    variants.mappings.forEach((mapping) => {
      mapping.variants.forEach((variant) => {
        tempMapping[variant] = mapping.material;
      });
    });
    meshVariants[result.id] = tempMapping;
  }
  meshDefaultMaterials[result.id] = primitive2.material;
  return result;
};
var createMesh = (device, gltfMesh, accessors, bufferViews, vertexBufferDict, meshVariants, meshDefaultMaterials, assetOptions, promises) => {
  const meshes = [];
  gltfMesh.primitives.forEach((primitive2) => {
    var _primitive$extensions2;
    if ((_primitive$extensions2 = primitive2.extensions) != null && _primitive$extensions2.KHR_draco_mesh_compression) {
      meshes.push(createDracoMesh(device, primitive2, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises));
    } else {
      let indices = primitive2.hasOwnProperty("indices") ? getAccessorData(accessors[primitive2.indices], bufferViews, true) : null;
      const vertexBuffer = createVertexBuffer(device, primitive2.attributes, indices, accessors, bufferViews, vertexBufferDict);
      const primitiveType = getPrimitiveType(primitive2);
      const mesh = new Mesh(device);
      mesh.vertexBuffer = vertexBuffer;
      mesh.primitive[0].type = primitiveType;
      mesh.primitive[0].base = 0;
      mesh.primitive[0].indexed = indices !== null;
      if (indices !== null) {
        let indexFormat;
        if (indices instanceof Uint8Array) {
          indexFormat = INDEXFORMAT_UINT8;
        } else if (indices instanceof Uint16Array) {
          indexFormat = INDEXFORMAT_UINT16;
        } else {
          indexFormat = INDEXFORMAT_UINT32;
        }
        if (indexFormat === INDEXFORMAT_UINT8 && device.isWebGPU) {
          indexFormat = INDEXFORMAT_UINT16;
          indices = new Uint16Array(indices);
        }
        const indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
        mesh.indexBuffer[0] = indexBuffer;
        mesh.primitive[0].count = indices.length;
      } else {
        mesh.primitive[0].count = vertexBuffer.numVertices;
      }
      if (primitive2.hasOwnProperty("extensions") && primitive2.extensions.hasOwnProperty("KHR_materials_variants")) {
        const variants = primitive2.extensions.KHR_materials_variants;
        const tempMapping = {};
        variants.mappings.forEach((mapping) => {
          mapping.variants.forEach((variant) => {
            tempMapping[variant] = mapping.material;
          });
        });
        meshVariants[mesh.id] = tempMapping;
      }
      meshDefaultMaterials[mesh.id] = primitive2.material;
      let accessor = accessors[primitive2.attributes.POSITION];
      mesh.aabb = getAccessorBoundingBox(accessor);
      if (primitive2.hasOwnProperty("targets")) {
        const targets = [];
        primitive2.targets.forEach((target2, index) => {
          const options2 = {};
          if (target2.hasOwnProperty("POSITION")) {
            accessor = accessors[target2.POSITION];
            options2.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);
            options2.aabb = getAccessorBoundingBox(accessor);
          }
          if (target2.hasOwnProperty("NORMAL")) {
            accessor = accessors[target2.NORMAL];
            options2.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);
          }
          if (gltfMesh.hasOwnProperty("extras") && gltfMesh.extras.hasOwnProperty("targetNames")) {
            options2.name = gltfMesh.extras.targetNames[index];
          } else {
            options2.name = index.toString(10);
          }
          if (gltfMesh.hasOwnProperty("weights")) {
            options2.defaultWeight = gltfMesh.weights[index];
          }
          options2.preserveData = assetOptions.morphPreserveData;
          targets.push(new MorphTarget(options2));
        });
        mesh.morph = new Morph(targets, device, {
          preferHighPrecision: assetOptions.morphPreferHighPrecision
        });
      }
      meshes.push(mesh);
    }
  });
  return meshes;
};
var extractTextureTransform = (source, material, maps) => {
  var _source$extensions;
  let map;
  const texCoord = source.texCoord;
  if (texCoord) {
    for (map = 0; map < maps.length; ++map) {
      material[`${maps[map]}MapUv`] = texCoord;
    }
  }
  const zeros = [0, 0];
  const ones = [1, 1];
  const textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;
  if (textureTransform) {
    const offset = textureTransform.offset || zeros;
    const scale2 = textureTransform.scale || ones;
    const rotation2 = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;
    const tilingVec = new Vec2(scale2[0], scale2[1]);
    const offsetVec = new Vec2(offset[0], 1 - scale2[1] - offset[1]);
    for (map = 0; map < maps.length; ++map) {
      material[`${maps[map]}MapTiling`] = tilingVec;
      material[`${maps[map]}MapOffset`] = offsetVec;
      material[`${maps[map]}MapRotation`] = rotation2;
    }
  }
};
var extensionPbrSpecGlossiness = (data2, material, textures) => {
  let color, texture;
  if (data2.hasOwnProperty("diffuseFactor")) {
    color = data2.diffuseFactor;
    material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
    material.opacity = color[3];
  } else {
    material.diffuse.set(1, 1, 1);
    material.opacity = 1;
  }
  if (data2.hasOwnProperty("diffuseTexture")) {
    const diffuseTexture = data2.diffuseTexture;
    texture = textures[diffuseTexture.index];
    material.diffuseMap = texture;
    material.diffuseMapChannel = "rgb";
    material.opacityMap = texture;
    material.opacityMapChannel = "a";
    extractTextureTransform(diffuseTexture, material, ["diffuse", "opacity"]);
  }
  material.useMetalness = false;
  if (data2.hasOwnProperty("specularFactor")) {
    color = data2.specularFactor;
    material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
  } else {
    material.specular.set(1, 1, 1);
  }
  if (data2.hasOwnProperty("glossinessFactor")) {
    material.gloss = data2.glossinessFactor;
  } else {
    material.gloss = 1;
  }
  if (data2.hasOwnProperty("specularGlossinessTexture")) {
    const specularGlossinessTexture = data2.specularGlossinessTexture;
    material.specularEncoding = "srgb";
    material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
    material.specularMapChannel = "rgb";
    material.glossMapChannel = "a";
    extractTextureTransform(specularGlossinessTexture, material, ["gloss", "metalness"]);
  }
};
var extensionClearCoat = (data2, material, textures) => {
  if (data2.hasOwnProperty("clearcoatFactor")) {
    material.clearCoat = data2.clearcoatFactor * 0.25;
  } else {
    material.clearCoat = 0;
  }
  if (data2.hasOwnProperty("clearcoatTexture")) {
    const clearcoatTexture = data2.clearcoatTexture;
    material.clearCoatMap = textures[clearcoatTexture.index];
    material.clearCoatMapChannel = "r";
    extractTextureTransform(clearcoatTexture, material, ["clearCoat"]);
  }
  if (data2.hasOwnProperty("clearcoatRoughnessFactor")) {
    material.clearCoatGloss = data2.clearcoatRoughnessFactor;
  } else {
    material.clearCoatGloss = 0;
  }
  if (data2.hasOwnProperty("clearcoatRoughnessTexture")) {
    const clearcoatRoughnessTexture = data2.clearcoatRoughnessTexture;
    material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];
    material.clearCoatGlossMapChannel = "g";
    extractTextureTransform(clearcoatRoughnessTexture, material, ["clearCoatGloss"]);
  }
  if (data2.hasOwnProperty("clearcoatNormalTexture")) {
    const clearcoatNormalTexture = data2.clearcoatNormalTexture;
    material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];
    extractTextureTransform(clearcoatNormalTexture, material, ["clearCoatNormal"]);
    if (clearcoatNormalTexture.hasOwnProperty("scale")) {
      material.clearCoatBumpiness = clearcoatNormalTexture.scale;
    }
  }
  material.clearCoatGlossInvert = true;
};
var extensionUnlit = (data2, material, textures) => {
  material.useLighting = false;
  material.emissive.copy(material.diffuse);
  material.emissiveMap = material.diffuseMap;
  material.emissiveMapUv = material.diffuseMapUv;
  material.emissiveMapTiling.copy(material.diffuseMapTiling);
  material.emissiveMapOffset.copy(material.diffuseMapOffset);
  material.emissiveMapRotation = material.diffuseMapRotation;
  material.emissiveMapChannel = material.diffuseMapChannel;
  material.emissiveVertexColor = material.diffuseVertexColor;
  material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
  material.useLighting = false;
  material.useSkybox = false;
  material.diffuse.set(1, 1, 1);
  material.diffuseMap = null;
  material.diffuseVertexColor = false;
};
var extensionSpecular = (data2, material, textures) => {
  material.useMetalnessSpecularColor = true;
  if (data2.hasOwnProperty("specularColorTexture")) {
    material.specularEncoding = "srgb";
    material.specularMap = textures[data2.specularColorTexture.index];
    material.specularMapChannel = "rgb";
    extractTextureTransform(data2.specularColorTexture, material, ["specular"]);
  }
  if (data2.hasOwnProperty("specularColorFactor")) {
    const color = data2.specularColorFactor;
    material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
  } else {
    material.specular.set(1, 1, 1);
  }
  if (data2.hasOwnProperty("specularFactor")) {
    material.specularityFactor = data2.specularFactor;
  } else {
    material.specularityFactor = 1;
  }
  if (data2.hasOwnProperty("specularTexture")) {
    material.specularityFactorMapChannel = "a";
    material.specularityFactorMap = textures[data2.specularTexture.index];
    extractTextureTransform(data2.specularTexture, material, ["specularityFactor"]);
  }
};
var extensionIor = (data2, material, textures) => {
  if (data2.hasOwnProperty("ior")) {
    material.refractionIndex = 1 / data2.ior;
  }
};
var extensionDispersion = (data2, material, textures) => {
  if (data2.hasOwnProperty("dispersion")) {
    material.dispersion = data2.dispersion;
  }
};
var extensionTransmission = (data2, material, textures) => {
  material.blendType = BLEND_NORMAL;
  material.useDynamicRefraction = true;
  if (data2.hasOwnProperty("transmissionFactor")) {
    material.refraction = data2.transmissionFactor;
  }
  if (data2.hasOwnProperty("transmissionTexture")) {
    material.refractionMapChannel = "r";
    material.refractionMap = textures[data2.transmissionTexture.index];
    extractTextureTransform(data2.transmissionTexture, material, ["refraction"]);
  }
};
var extensionSheen = (data2, material, textures) => {
  material.useSheen = true;
  if (data2.hasOwnProperty("sheenColorFactor")) {
    const color = data2.sheenColorFactor;
    material.sheen.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
  } else {
    material.sheen.set(1, 1, 1);
  }
  if (data2.hasOwnProperty("sheenColorTexture")) {
    material.sheenMap = textures[data2.sheenColorTexture.index];
    material.sheenEncoding = "srgb";
    extractTextureTransform(data2.sheenColorTexture, material, ["sheen"]);
  }
  material.sheenGloss = data2.hasOwnProperty("sheenRoughnessFactor") ? data2.sheenRoughnessFactor : 0;
  if (data2.hasOwnProperty("sheenRoughnessTexture")) {
    material.sheenGlossMap = textures[data2.sheenRoughnessTexture.index];
    material.sheenGlossMapChannel = "a";
    extractTextureTransform(data2.sheenRoughnessTexture, material, ["sheenGloss"]);
  }
  material.sheenGlossInvert = true;
};
var extensionVolume = (data2, material, textures) => {
  material.blendType = BLEND_NORMAL;
  material.useDynamicRefraction = true;
  if (data2.hasOwnProperty("thicknessFactor")) {
    material.thickness = data2.thicknessFactor;
  }
  if (data2.hasOwnProperty("thicknessTexture")) {
    material.thicknessMap = textures[data2.thicknessTexture.index];
    material.thicknessMapChannel = "g";
    extractTextureTransform(data2.thicknessTexture, material, ["thickness"]);
  }
  if (data2.hasOwnProperty("attenuationDistance")) {
    material.attenuationDistance = data2.attenuationDistance;
  }
  if (data2.hasOwnProperty("attenuationColor")) {
    const color = data2.attenuationColor;
    material.attenuation.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
  }
};
var extensionEmissiveStrength = (data2, material, textures) => {
  if (data2.hasOwnProperty("emissiveStrength")) {
    material.emissiveIntensity = data2.emissiveStrength;
  }
};
var extensionIridescence = (data2, material, textures) => {
  material.useIridescence = true;
  if (data2.hasOwnProperty("iridescenceFactor")) {
    material.iridescence = data2.iridescenceFactor;
  }
  if (data2.hasOwnProperty("iridescenceTexture")) {
    material.iridescenceMapChannel = "r";
    material.iridescenceMap = textures[data2.iridescenceTexture.index];
    extractTextureTransform(data2.iridescenceTexture, material, ["iridescence"]);
  }
  if (data2.hasOwnProperty("iridescenceIor")) {
    material.iridescenceRefractionIndex = data2.iridescenceIor;
  }
  if (data2.hasOwnProperty("iridescenceThicknessMinimum")) {
    material.iridescenceThicknessMin = data2.iridescenceThicknessMinimum;
  }
  if (data2.hasOwnProperty("iridescenceThicknessMaximum")) {
    material.iridescenceThicknessMax = data2.iridescenceThicknessMaximum;
  }
  if (data2.hasOwnProperty("iridescenceThicknessTexture")) {
    material.iridescenceThicknessMapChannel = "g";
    material.iridescenceThicknessMap = textures[data2.iridescenceThicknessTexture.index];
    extractTextureTransform(data2.iridescenceThicknessTexture, material, ["iridescenceThickness"]);
  }
};
var createMaterial = (gltfMaterial, textures) => {
  const material = new StandardMaterial();
  material.occludeSpecular = SPECOCC_AO;
  material.diffuseVertexColor = true;
  material.specularTint = true;
  material.specularVertexColor = true;
  if (gltfMaterial.hasOwnProperty("name")) {
    material.name = gltfMaterial.name;
  }
  let color, texture;
  if (gltfMaterial.hasOwnProperty("pbrMetallicRoughness")) {
    const pbrData = gltfMaterial.pbrMetallicRoughness;
    if (pbrData.hasOwnProperty("baseColorFactor")) {
      color = pbrData.baseColorFactor;
      material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
      material.opacity = color[3];
    } else {
      material.diffuse.set(1, 1, 1);
      material.opacity = 1;
    }
    if (pbrData.hasOwnProperty("baseColorTexture")) {
      const baseColorTexture = pbrData.baseColorTexture;
      texture = textures[baseColorTexture.index];
      material.diffuseMap = texture;
      material.diffuseMapChannel = "rgb";
      material.opacityMap = texture;
      material.opacityMapChannel = "a";
      extractTextureTransform(baseColorTexture, material, ["diffuse", "opacity"]);
    }
    material.useMetalness = true;
    material.specular.set(1, 1, 1);
    if (pbrData.hasOwnProperty("metallicFactor")) {
      material.metalness = pbrData.metallicFactor;
    } else {
      material.metalness = 1;
    }
    if (pbrData.hasOwnProperty("roughnessFactor")) {
      material.gloss = pbrData.roughnessFactor;
    } else {
      material.gloss = 1;
    }
    material.glossInvert = true;
    if (pbrData.hasOwnProperty("metallicRoughnessTexture")) {
      const metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
      material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
      material.metalnessMapChannel = "b";
      material.glossMapChannel = "g";
      extractTextureTransform(metallicRoughnessTexture, material, ["gloss", "metalness"]);
    }
  }
  if (gltfMaterial.hasOwnProperty("normalTexture")) {
    const normalTexture = gltfMaterial.normalTexture;
    material.normalMap = textures[normalTexture.index];
    extractTextureTransform(normalTexture, material, ["normal"]);
    if (normalTexture.hasOwnProperty("scale")) {
      material.bumpiness = normalTexture.scale;
    }
  }
  if (gltfMaterial.hasOwnProperty("occlusionTexture")) {
    const occlusionTexture = gltfMaterial.occlusionTexture;
    material.aoMap = textures[occlusionTexture.index];
    material.aoMapChannel = "r";
    extractTextureTransform(occlusionTexture, material, ["ao"]);
  }
  if (gltfMaterial.hasOwnProperty("emissiveFactor")) {
    color = gltfMaterial.emissiveFactor;
    material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
  } else {
    material.emissive.set(0, 0, 0);
  }
  if (gltfMaterial.hasOwnProperty("emissiveTexture")) {
    const emissiveTexture = gltfMaterial.emissiveTexture;
    material.emissiveMap = textures[emissiveTexture.index];
    extractTextureTransform(emissiveTexture, material, ["emissive"]);
  }
  if (gltfMaterial.hasOwnProperty("alphaMode")) {
    switch (gltfMaterial.alphaMode) {
      case "MASK":
        material.blendType = BLEND_NONE;
        if (gltfMaterial.hasOwnProperty("alphaCutoff")) {
          material.alphaTest = gltfMaterial.alphaCutoff;
        } else {
          material.alphaTest = 0.5;
        }
        break;
      case "BLEND":
        material.blendType = BLEND_NORMAL;
        material.depthWrite = false;
        break;
      default:
      case "OPAQUE":
        material.blendType = BLEND_NONE;
        break;
    }
  } else {
    material.blendType = BLEND_NONE;
  }
  if (gltfMaterial.hasOwnProperty("doubleSided")) {
    material.twoSidedLighting = gltfMaterial.doubleSided;
    material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
  } else {
    material.twoSidedLighting = false;
    material.cull = CULLFACE_BACK;
  }
  const extensions = {
    "KHR_materials_clearcoat": extensionClearCoat,
    "KHR_materials_emissive_strength": extensionEmissiveStrength,
    "KHR_materials_ior": extensionIor,
    "KHR_materials_dispersion": extensionDispersion,
    "KHR_materials_iridescence": extensionIridescence,
    "KHR_materials_pbrSpecularGlossiness": extensionPbrSpecGlossiness,
    "KHR_materials_sheen": extensionSheen,
    "KHR_materials_specular": extensionSpecular,
    "KHR_materials_transmission": extensionTransmission,
    "KHR_materials_unlit": extensionUnlit,
    "KHR_materials_volume": extensionVolume
  };
  if (gltfMaterial.hasOwnProperty("extensions")) {
    for (const key in gltfMaterial.extensions) {
      const extensionFunc = extensions[key];
      if (extensionFunc !== void 0) {
        extensionFunc(gltfMaterial.extensions[key], material, textures);
      }
    }
  }
  material.update();
  return material;
};
var createAnimation = (gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes, meshes, gltfNodes) => {
  const createAnimData = (gltfAccessor) => {
    return new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));
  };
  const interpMap = {
    "STEP": INTERPOLATION_STEP,
    "LINEAR": INTERPOLATION_LINEAR,
    "CUBICSPLINE": INTERPOLATION_CUBIC
  };
  const inputMap = {};
  const outputMap = {};
  const curveMap = {};
  let outputCounter = 1;
  let i;
  for (i = 0; i < gltfAnimation.samplers.length; ++i) {
    const sampler = gltfAnimation.samplers[i];
    if (!inputMap.hasOwnProperty(sampler.input)) {
      inputMap[sampler.input] = createAnimData(gltfAccessors[sampler.input]);
    }
    if (!outputMap.hasOwnProperty(sampler.output)) {
      outputMap[sampler.output] = createAnimData(gltfAccessors[sampler.output]);
    }
    const interpolation = sampler.hasOwnProperty("interpolation") && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
    const curve = {
      paths: [],
      input: sampler.input,
      output: sampler.output,
      interpolation
    };
    curveMap[i] = curve;
  }
  const quatArrays = [];
  const transformSchema = {
    "translation": "localPosition",
    "rotation": "localRotation",
    "scale": "localScale"
  };
  const constructNodePath = (node) => {
    const path2 = [];
    while (node) {
      path2.unshift(node.name);
      node = node.parent;
    }
    return path2;
  };
  const createMorphTargetCurves = (curve, gltfNode, entityPath) => {
    const out = outputMap[curve.output];
    if (!out) {
      return;
    }
    let targetNames;
    if (meshes && meshes[gltfNode.mesh]) {
      const mesh = meshes[gltfNode.mesh];
      if (mesh.hasOwnProperty("extras") && mesh.extras.hasOwnProperty("targetNames")) {
        targetNames = mesh.extras.targetNames;
      }
    }
    const outData = out.data;
    const morphTargetCount = outData.length / inputMap[curve.input].data.length;
    const keyframeCount = outData.length / morphTargetCount;
    const singleBufferSize = keyframeCount * 4;
    const buffer = new ArrayBuffer(singleBufferSize * morphTargetCount);
    for (let j = 0; j < morphTargetCount; j++) {
      var _targetNames;
      const morphTargetOutput = new Float32Array(buffer, singleBufferSize * j, keyframeCount);
      for (let k = 0; k < keyframeCount; k++) {
        morphTargetOutput[k] = outData[k * morphTargetCount + j];
      }
      const output = new AnimData(1, morphTargetOutput);
      const weightName = (_targetNames = targetNames) != null && _targetNames[j] ? `name.${targetNames[j]}` : j;
      outputMap[-outputCounter] = output;
      const morphCurve = {
        paths: [{
          entityPath,
          component: "graph",
          propertyPath: [`weight.${weightName}`]
        }],
        input: curve.input,
        output: -outputCounter,
        interpolation: curve.interpolation
      };
      outputCounter++;
      curveMap[`morphCurve-${i}-${j}`] = morphCurve;
    }
  };
  for (i = 0; i < gltfAnimation.channels.length; ++i) {
    const channel = gltfAnimation.channels[i];
    const target2 = channel.target;
    const curve = curveMap[channel.sampler];
    const node = nodes[target2.node];
    const gltfNode = gltfNodes[target2.node];
    const entityPath = constructNodePath(node);
    if (target2.path.startsWith("weights")) {
      createMorphTargetCurves(curve, gltfNode, entityPath);
      curveMap[channel.sampler].morphCurve = true;
    } else {
      curve.paths.push({
        entityPath,
        component: "graph",
        propertyPath: [transformSchema[target2.path]]
      });
    }
  }
  const inputs = [];
  const outputs = [];
  const curves = [];
  for (const inputKey in inputMap) {
    inputs.push(inputMap[inputKey]);
    inputMap[inputKey] = inputs.length - 1;
  }
  for (const outputKey in outputMap) {
    outputs.push(outputMap[outputKey]);
    outputMap[outputKey] = outputs.length - 1;
  }
  for (const curveKey in curveMap) {
    const curveData = curveMap[curveKey];
    if (curveData.morphCurve) {
      continue;
    }
    curves.push(new AnimCurve(curveData.paths, inputMap[curveData.input], outputMap[curveData.output], curveData.interpolation));
    if (curveData.paths.length > 0 && curveData.paths[0].propertyPath[0] === "localRotation" && curveData.interpolation !== INTERPOLATION_CUBIC) {
      quatArrays.push(curves[curves.length - 1].output);
    }
  }
  quatArrays.sort();
  let prevIndex = null;
  let data2;
  for (i = 0; i < quatArrays.length; ++i) {
    const index = quatArrays[i];
    if (i === 0 || index !== prevIndex) {
      data2 = outputs[index];
      if (data2.components === 4) {
        const d = data2.data;
        const len = d.length - 4;
        for (let j = 0; j < len; j += 4) {
          const dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];
          if (dp < 0) {
            d[j + 4] *= -1;
            d[j + 5] *= -1;
            d[j + 6] *= -1;
            d[j + 7] *= -1;
          }
        }
      }
      prevIndex = index;
    }
  }
  let duration = 0;
  for (i = 0; i < inputs.length; i++) {
    data2 = inputs[i]._data;
    duration = Math.max(duration, data2.length === 0 ? 0 : data2[data2.length - 1]);
  }
  return new AnimTrack(gltfAnimation.hasOwnProperty("name") ? gltfAnimation.name : `animation_${animationIndex}`, duration, inputs, outputs, curves);
};
var tempMat = new Mat4();
var tempVec2 = new Vec3();
var createNode = (gltfNode, nodeIndex, nodeInstancingMap) => {
  const entity = new GraphNode();
  if (gltfNode.hasOwnProperty("name") && gltfNode.name.length > 0) {
    entity.name = gltfNode.name;
  } else {
    entity.name = `node_${nodeIndex}`;
  }
  if (gltfNode.hasOwnProperty("matrix")) {
    tempMat.data.set(gltfNode.matrix);
    tempMat.getTranslation(tempVec2);
    entity.setLocalPosition(tempVec2);
    tempMat.getEulerAngles(tempVec2);
    entity.setLocalEulerAngles(tempVec2);
    tempMat.getScale(tempVec2);
    entity.setLocalScale(tempVec2);
  }
  if (gltfNode.hasOwnProperty("rotation")) {
    const r = gltfNode.rotation;
    entity.setLocalRotation(r[0], r[1], r[2], r[3]);
  }
  if (gltfNode.hasOwnProperty("translation")) {
    const t = gltfNode.translation;
    entity.setLocalPosition(t[0], t[1], t[2]);
  }
  if (gltfNode.hasOwnProperty("scale")) {
    const s2 = gltfNode.scale;
    entity.setLocalScale(s2[0], s2[1], s2[2]);
  }
  if (gltfNode.hasOwnProperty("extensions") && gltfNode.extensions.EXT_mesh_gpu_instancing) {
    nodeInstancingMap.set(gltfNode, {
      ext: gltfNode.extensions.EXT_mesh_gpu_instancing
    });
  }
  return entity;
};
var createCamera = (gltfCamera, node) => {
  const projection = gltfCamera.type === "orthographic" ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
  const gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;
  const componentData = {
    enabled: false,
    projection,
    nearClip: gltfProperties.znear,
    aspectRatioMode: ASPECT_AUTO
  };
  if (gltfProperties.zfar) {
    componentData.farClip = gltfProperties.zfar;
  }
  if (projection === PROJECTION_ORTHOGRAPHIC) {
    componentData.orthoHeight = 0.5 * gltfProperties.ymag;
    if (gltfProperties.ymag) {
      componentData.aspectRatioMode = ASPECT_MANUAL;
      componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;
    }
  } else {
    componentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;
    if (gltfProperties.aspectRatio) {
      componentData.aspectRatioMode = ASPECT_MANUAL;
      componentData.aspectRatio = gltfProperties.aspectRatio;
    }
  }
  const cameraEntity = new Entity(gltfCamera.name);
  cameraEntity.addComponent("camera", componentData);
  return cameraEntity;
};
var createLight = (gltfLight, node) => {
  const lightProps = {
    enabled: false,
    type: gltfLight.type === "point" ? "omni" : gltfLight.type,
    color: gltfLight.hasOwnProperty("color") ? new Color(gltfLight.color) : Color.WHITE,
    range: gltfLight.hasOwnProperty("range") ? gltfLight.range : 9999,
    falloffMode: LIGHTFALLOFF_INVERSESQUARED,
    intensity: gltfLight.hasOwnProperty("intensity") ? math.clamp(gltfLight.intensity, 0, 2) : 1
  };
  if (gltfLight.hasOwnProperty("spot")) {
    lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty("innerConeAngle") ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;
    lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty("outerConeAngle") ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;
  }
  if (gltfLight.hasOwnProperty("intensity")) {
    lightProps.luminance = gltfLight.intensity * Light.getLightUnitConversion(lightTypes[lightProps.type], lightProps.outerConeAngle, lightProps.innerConeAngle);
  }
  const lightEntity = new Entity(node.name);
  lightEntity.rotateLocal(90, 0, 0);
  lightEntity.addComponent("light", lightProps);
  return lightEntity;
};
var createSkins = (device, gltf, nodes, bufferViews) => {
  if (!gltf.hasOwnProperty("skins") || gltf.skins.length === 0) {
    return [];
  }
  const glbSkins = /* @__PURE__ */ new Map();
  return gltf.skins.map((gltfSkin) => {
    return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);
  });
};
var createMeshes = (device, gltf, bufferViews, options2) => {
  var _gltf$meshes, _gltf$accessors, _gltf$bufferViews;
  const vertexBufferDict = {};
  const meshVariants = {};
  const meshDefaultMaterials = {};
  const promises = [];
  const valid = !options2.skipMeshes && (gltf == null || (_gltf$meshes = gltf.meshes) == null ? void 0 : _gltf$meshes.length) && (gltf == null || (_gltf$accessors = gltf.accessors) == null ? void 0 : _gltf$accessors.length) && (gltf == null || (_gltf$bufferViews = gltf.bufferViews) == null ? void 0 : _gltf$bufferViews.length);
  const meshes = valid ? gltf.meshes.map((gltfMesh) => {
    return createMesh(device, gltfMesh, gltf.accessors, bufferViews, vertexBufferDict, meshVariants, meshDefaultMaterials, options2, promises);
  }) : [];
  return {
    meshes,
    meshVariants,
    meshDefaultMaterials,
    promises
  };
};
var createMaterials = (gltf, textures, options2) => {
  var _options$material, _options$material$pro, _options$material2, _options$material3;
  if (!gltf.hasOwnProperty("materials") || gltf.materials.length === 0) {
    return [];
  }
  const preprocess = options2 == null || (_options$material = options2.material) == null ? void 0 : _options$material.preprocess;
  const process = (_options$material$pro = options2 == null || (_options$material2 = options2.material) == null ? void 0 : _options$material2.process) != null ? _options$material$pro : createMaterial;
  const postprocess = options2 == null || (_options$material3 = options2.material) == null ? void 0 : _options$material3.postprocess;
  return gltf.materials.map((gltfMaterial) => {
    if (preprocess) {
      preprocess(gltfMaterial);
    }
    const material = process(gltfMaterial, textures);
    if (postprocess) {
      postprocess(gltfMaterial, material);
    }
    return material;
  });
};
var createVariants = (gltf) => {
  if (!gltf.hasOwnProperty("extensions") || !gltf.extensions.hasOwnProperty("KHR_materials_variants")) {
    return null;
  }
  const data2 = gltf.extensions.KHR_materials_variants.variants;
  const variants = {};
  for (let i = 0; i < data2.length; i++) {
    variants[data2[i].name] = i;
  }
  return variants;
};
var createAnimations = (gltf, nodes, bufferViews, options2) => {
  var _options$animation, _options$animation2;
  if (!gltf.hasOwnProperty("animations") || gltf.animations.length === 0) {
    return [];
  }
  const preprocess = options2 == null || (_options$animation = options2.animation) == null ? void 0 : _options$animation.preprocess;
  const postprocess = options2 == null || (_options$animation2 = options2.animation) == null ? void 0 : _options$animation2.postprocess;
  return gltf.animations.map((gltfAnimation, index) => {
    if (preprocess) {
      preprocess(gltfAnimation);
    }
    const animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes, gltf.meshes, gltf.nodes);
    if (postprocess) {
      postprocess(gltfAnimation, animation);
    }
    return animation;
  });
};
var createInstancing = (device, gltf, nodeInstancingMap, bufferViews) => {
  const accessors = gltf.accessors;
  nodeInstancingMap.forEach((data2, entity) => {
    const attributes = data2.ext.attributes;
    let translations;
    if (attributes.hasOwnProperty("TRANSLATION")) {
      const accessor = accessors[attributes.TRANSLATION];
      translations = getAccessorDataFloat32(accessor, bufferViews);
    }
    let rotations;
    if (attributes.hasOwnProperty("ROTATION")) {
      const accessor = accessors[attributes.ROTATION];
      rotations = getAccessorDataFloat32(accessor, bufferViews);
    }
    let scales;
    if (attributes.hasOwnProperty("SCALE")) {
      const accessor = accessors[attributes.SCALE];
      scales = getAccessorDataFloat32(accessor, bufferViews);
    }
    const instanceCount = (translations ? translations.length / 3 : 0) || (rotations ? rotations.length / 4 : 0) || (scales ? scales.length / 3 : 0);
    if (instanceCount) {
      const matrices = new Float32Array(instanceCount * 16);
      const pos = new Vec3();
      const rot = new Quat();
      const scl = new Vec3(1, 1, 1);
      const matrix2 = new Mat4();
      let matrixIndex = 0;
      for (let i = 0; i < instanceCount; i++) {
        const i3 = i * 3;
        if (translations) {
          pos.set(translations[i3], translations[i3 + 1], translations[i3 + 2]);
        }
        if (rotations) {
          const i4 = i * 4;
          rot.set(rotations[i4], rotations[i4 + 1], rotations[i4 + 2], rotations[i4 + 3]);
        }
        if (scales) {
          scl.set(scales[i3], scales[i3 + 1], scales[i3 + 2]);
        }
        matrix2.setTRS(pos, rot, scl);
        for (let m = 0; m < 16; m++) {
          matrices[matrixIndex++] = matrix2.data[m];
        }
      }
      data2.matrices = matrices;
    }
  });
};
var createNodes = (gltf, options2, nodeInstancingMap) => {
  var _options$node, _options$node$process, _options$node2, _options$node3;
  if (!gltf.hasOwnProperty("nodes") || gltf.nodes.length === 0) {
    return [];
  }
  const preprocess = options2 == null || (_options$node = options2.node) == null ? void 0 : _options$node.preprocess;
  const process = (_options$node$process = options2 == null || (_options$node2 = options2.node) == null ? void 0 : _options$node2.process) != null ? _options$node$process : createNode;
  const postprocess = options2 == null || (_options$node3 = options2.node) == null ? void 0 : _options$node3.postprocess;
  const nodes = gltf.nodes.map((gltfNode, index) => {
    if (preprocess) {
      preprocess(gltfNode);
    }
    const node = process(gltfNode, index, nodeInstancingMap);
    if (postprocess) {
      postprocess(gltfNode, node);
    }
    return node;
  });
  for (let i = 0; i < gltf.nodes.length; ++i) {
    const gltfNode = gltf.nodes[i];
    if (gltfNode.hasOwnProperty("children")) {
      const parent = nodes[i];
      const uniqueNames = {};
      for (let j = 0; j < gltfNode.children.length; ++j) {
        const child = nodes[gltfNode.children[j]];
        if (!child.parent) {
          if (uniqueNames.hasOwnProperty(child.name)) {
            child.name += uniqueNames[child.name]++;
          } else {
            uniqueNames[child.name] = 1;
          }
          parent.addChild(child);
        }
      }
    }
  }
  return nodes;
};
var createScenes = (gltf, nodes) => {
  var _gltf$scenes$0$nodes;
  const scenes = [];
  const count = gltf.scenes.length;
  if (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {
    const nodeIndex = gltf.scenes[0].nodes[0];
    scenes.push(nodes[nodeIndex]);
  } else {
    for (let i = 0; i < count; i++) {
      const scene = gltf.scenes[i];
      if (scene.nodes) {
        const sceneRoot = new GraphNode(scene.name);
        for (let n = 0; n < scene.nodes.length; n++) {
          const childNode = nodes[scene.nodes[n]];
          sceneRoot.addChild(childNode);
        }
        scenes.push(sceneRoot);
      }
    }
  }
  return scenes;
};
var createCameras = (gltf, nodes, options2) => {
  let cameras = null;
  if (gltf.hasOwnProperty("nodes") && gltf.hasOwnProperty("cameras") && gltf.cameras.length > 0) {
    var _options$camera, _options$camera$proce, _options$camera2, _options$camera3;
    const preprocess = options2 == null || (_options$camera = options2.camera) == null ? void 0 : _options$camera.preprocess;
    const process = (_options$camera$proce = options2 == null || (_options$camera2 = options2.camera) == null ? void 0 : _options$camera2.process) != null ? _options$camera$proce : createCamera;
    const postprocess = options2 == null || (_options$camera3 = options2.camera) == null ? void 0 : _options$camera3.postprocess;
    gltf.nodes.forEach((gltfNode, nodeIndex) => {
      if (gltfNode.hasOwnProperty("camera")) {
        const gltfCamera = gltf.cameras[gltfNode.camera];
        if (gltfCamera) {
          if (preprocess) {
            preprocess(gltfCamera);
          }
          const camera = process(gltfCamera, nodes[nodeIndex]);
          if (postprocess) {
            postprocess(gltfCamera, camera);
          }
          if (camera) {
            if (!cameras) cameras = /* @__PURE__ */ new Map();
            cameras.set(gltfNode, camera);
          }
        }
      }
    });
  }
  return cameras;
};
var createLights = (gltf, nodes, options2) => {
  let lights2 = null;
  if (gltf.hasOwnProperty("nodes") && gltf.hasOwnProperty("extensions") && gltf.extensions.hasOwnProperty("KHR_lights_punctual") && gltf.extensions.KHR_lights_punctual.hasOwnProperty("lights")) {
    const gltfLights = gltf.extensions.KHR_lights_punctual.lights;
    if (gltfLights.length) {
      var _options$light, _options$light$proces, _options$light2, _options$light3;
      const preprocess = options2 == null || (_options$light = options2.light) == null ? void 0 : _options$light.preprocess;
      const process = (_options$light$proces = options2 == null || (_options$light2 = options2.light) == null ? void 0 : _options$light2.process) != null ? _options$light$proces : createLight;
      const postprocess = options2 == null || (_options$light3 = options2.light) == null ? void 0 : _options$light3.postprocess;
      gltf.nodes.forEach((gltfNode, nodeIndex) => {
        if (gltfNode.hasOwnProperty("extensions") && gltfNode.extensions.hasOwnProperty("KHR_lights_punctual") && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty("light")) {
          const lightIndex = gltfNode.extensions.KHR_lights_punctual.light;
          const gltfLight = gltfLights[lightIndex];
          if (gltfLight) {
            if (preprocess) {
              preprocess(gltfLight);
            }
            const light = process(gltfLight, nodes[nodeIndex]);
            if (postprocess) {
              postprocess(gltfLight, light);
            }
            if (light) {
              if (!lights2) lights2 = /* @__PURE__ */ new Map();
              lights2.set(gltfNode, light);
            }
          }
        }
      });
    }
  }
  return lights2;
};
var linkSkins = (gltf, renders, skins) => {
  gltf.nodes.forEach((gltfNode) => {
    if (gltfNode.hasOwnProperty("mesh") && gltfNode.hasOwnProperty("skin")) {
      const meshGroup = renders[gltfNode.mesh].meshes;
      meshGroup.forEach((mesh) => {
        mesh.skin = skins[gltfNode.skin];
      });
    }
  });
};
var createResources = async (device, gltf, bufferViews, textures, options2) => {
  var _options$global, _options$global2;
  const preprocess = options2 == null || (_options$global = options2.global) == null ? void 0 : _options$global.preprocess;
  const postprocess = options2 == null || (_options$global2 = options2.global) == null ? void 0 : _options$global2.postprocess;
  if (preprocess) {
    preprocess(gltf);
  }
  if (gltf.asset && gltf.asset.generator === "PlayCanvas") ;
  const nodeInstancingMap = /* @__PURE__ */ new Map();
  const nodes = createNodes(gltf, options2, nodeInstancingMap);
  const scenes = createScenes(gltf, nodes);
  const lights2 = createLights(gltf, nodes, options2);
  const cameras = createCameras(gltf, nodes, options2);
  const variants = createVariants(gltf);
  const bufferViewData = await Promise.all(bufferViews);
  const {
    meshes,
    meshVariants,
    meshDefaultMaterials,
    promises
  } = createMeshes(device, gltf, bufferViewData, options2);
  const animations = createAnimations(gltf, nodes, bufferViewData, options2);
  createInstancing(device, gltf, nodeInstancingMap, bufferViewData);
  const textureAssets = await Promise.all(textures);
  const textureInstances = textureAssets.map((t) => t.resource);
  const materials = createMaterials(gltf, textureInstances, options2);
  const skins = createSkins(device, gltf, nodes, bufferViewData);
  const renders = [];
  for (let i = 0; i < meshes.length; i++) {
    renders[i] = new Render();
    renders[i].meshes = meshes[i];
  }
  linkSkins(gltf, renders, skins);
  const result = new GlbResources();
  result.gltf = gltf;
  result.nodes = nodes;
  result.scenes = scenes;
  result.animations = animations;
  result.textures = textureAssets;
  result.materials = materials;
  result.variants = variants;
  result.meshVariants = meshVariants;
  result.meshDefaultMaterials = meshDefaultMaterials;
  result.renders = renders;
  result.skins = skins;
  result.lights = lights2;
  result.cameras = cameras;
  result.nodeInstancingMap = nodeInstancingMap;
  if (postprocess) {
    postprocess(gltf, result);
  }
  await Promise.all(promises);
  return result;
};
var applySampler = (texture, gltfSampler) => {
  const getFilter3 = (filter, defaultValue) => {
    switch (filter) {
      case 9728:
        return FILTER_NEAREST;
      case 9729:
        return FILTER_LINEAR;
      case 9984:
        return FILTER_NEAREST_MIPMAP_NEAREST;
      case 9985:
        return FILTER_LINEAR_MIPMAP_NEAREST;
      case 9986:
        return FILTER_NEAREST_MIPMAP_LINEAR;
      case 9987:
        return FILTER_LINEAR_MIPMAP_LINEAR;
      default:
        return defaultValue;
    }
  };
  const getWrap3 = (wrap, defaultValue) => {
    switch (wrap) {
      case 33071:
        return ADDRESS_CLAMP_TO_EDGE;
      case 33648:
        return ADDRESS_MIRRORED_REPEAT;
      case 10497:
        return ADDRESS_REPEAT;
      default:
        return defaultValue;
    }
  };
  if (texture) {
    var _gltfSampler;
    gltfSampler = (_gltfSampler = gltfSampler) != null ? _gltfSampler : {};
    texture.minFilter = getFilter3(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);
    texture.magFilter = getFilter3(gltfSampler.magFilter, FILTER_LINEAR);
    texture.addressU = getWrap3(gltfSampler.wrapS, ADDRESS_REPEAT);
    texture.addressV = getWrap3(gltfSampler.wrapT, ADDRESS_REPEAT);
  }
};
var gltfTextureUniqueId = 0;
var createImages = (gltf, bufferViews, urlBase, registry, options2) => {
  var _options$image, _options$image2, _options$image3;
  if (!gltf.images || gltf.images.length === 0) {
    return [];
  }
  const preprocess = options2 == null || (_options$image = options2.image) == null ? void 0 : _options$image.preprocess;
  const processAsync = options2 == null || (_options$image2 = options2.image) == null ? void 0 : _options$image2.processAsync;
  const postprocess = options2 == null || (_options$image3 = options2.image) == null ? void 0 : _options$image3.postprocess;
  const mimeTypeFileExtensions = {
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/basis": "basis",
    "image/ktx": "ktx",
    "image/ktx2": "ktx2",
    "image/vnd-ms.dds": "dds"
  };
  const getGammaTextures = (gltf2) => {
    const set = /* @__PURE__ */ new Set();
    if (gltf2.hasOwnProperty("materials")) {
      gltf2.materials.forEach((gltfMaterial) => {
        if (gltfMaterial.hasOwnProperty("pbrMetallicRoughness")) {
          const pbrData = gltfMaterial.pbrMetallicRoughness;
          if (pbrData.hasOwnProperty("baseColorTexture")) {
            set.add(pbrData.baseColorTexture.index);
          }
        }
        if (gltfMaterial.hasOwnProperty("emissiveTexture")) {
          set.add(gltfMaterial.emissiveTexture.index);
        }
      });
    }
    return set;
  };
  const loadTexture = (gltfImage, url, bufferView, mimeType, options3, srgb) => {
    return new Promise((resolve, reject) => {
      const continuation = (bufferViewData) => {
        const name = `${gltfImage.name || "gltf-texture"}-${gltfTextureUniqueId++}`;
        const file = {
          url: url || name
        };
        if (bufferViewData) {
          file.contents = bufferViewData.slice(0).buffer;
        }
        if (mimeType) {
          const extension = mimeTypeFileExtensions[mimeType];
          if (extension) {
            file.filename = `${file.url}.${extension}`;
          }
        }
        const data2 = {
          srgb
        };
        const asset = new Asset(name, "texture", file, data2, options3);
        asset.on("load", (asset2) => resolve(asset2));
        asset.on("error", (err3) => reject(err3));
        registry.add(asset);
        registry.load(asset);
      };
      if (bufferView) {
        bufferView.then((bufferViewData) => continuation(bufferViewData));
      } else {
        continuation(null);
      }
    });
  };
  const gammaTextures = getGammaTextures(gltf);
  return gltf.images.map((gltfImage, i) => {
    if (preprocess) {
      preprocess(gltfImage);
    }
    let promise;
    if (processAsync) {
      promise = new Promise((resolve, reject) => {
        processAsync(gltfImage, (err3, textureAsset) => {
          if (err3) {
            reject(err3);
          } else {
            resolve(textureAsset);
          }
        });
      });
    } else {
      promise = new Promise((resolve) => {
        resolve(null);
      });
    }
    promise = promise.then((textureAsset) => {
      const srgb = gammaTextures.has(i);
      if (textureAsset) {
        return textureAsset;
      } else if (gltfImage.hasOwnProperty("uri")) {
        if (isDataURI(gltfImage.uri)) {
          return loadTexture(gltfImage, gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null, srgb);
        }
        return loadTexture(gltfImage, ABSOLUTE_URL.test(gltfImage.uri) ? gltfImage.uri : path.join(urlBase, gltfImage.uri), null, null, {
          crossOrigin: "anonymous"
        }, srgb);
      } else if (gltfImage.hasOwnProperty("bufferView") && gltfImage.hasOwnProperty("mimeType")) {
        return loadTexture(gltfImage, null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null, srgb);
      }
      return Promise.reject(new Error(`Invalid image found in gltf (neither uri or bufferView found). index=${i}`));
    });
    if (postprocess) {
      promise = promise.then((textureAsset) => {
        postprocess(gltfImage, textureAsset);
        return textureAsset;
      });
    }
    return promise;
  });
};
var createTextures = (gltf, images, options2) => {
  var _gltf$images, _gltf$textures, _options$texture, _options$texture2, _options$texture3;
  if (!(gltf != null && (_gltf$images = gltf.images) != null && _gltf$images.length) || !(gltf != null && (_gltf$textures = gltf.textures) != null && _gltf$textures.length)) {
    return [];
  }
  const preprocess = options2 == null || (_options$texture = options2.texture) == null ? void 0 : _options$texture.preprocess;
  const processAsync = options2 == null || (_options$texture2 = options2.texture) == null ? void 0 : _options$texture2.processAsync;
  const postprocess = options2 == null || (_options$texture3 = options2.texture) == null ? void 0 : _options$texture3.postprocess;
  const seenImages = /* @__PURE__ */ new Set();
  return gltf.textures.map((gltfTexture) => {
    if (preprocess) {
      preprocess(gltfTexture);
    }
    let promise;
    if (processAsync) {
      promise = new Promise((resolve, reject) => {
        processAsync(gltfTexture, gltf.images, (err3, gltfImageIndex) => {
          if (err3) {
            reject(err3);
          } else {
            resolve(gltfImageIndex);
          }
        });
      });
    } else {
      promise = new Promise((resolve) => {
        resolve(null);
      });
    }
    promise = promise.then((gltfImageIndex) => {
      var _ref4, _ref22, _gltfImageIndex, _gltfTexture$extensio, _gltfTexture$extensio2;
      gltfImageIndex = (_ref4 = (_ref22 = (_gltfImageIndex = gltfImageIndex) != null ? _gltfImageIndex : gltfTexture == null || (_gltfTexture$extensio = gltfTexture.extensions) == null || (_gltfTexture$extensio = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio.source) != null ? _ref22 : gltfTexture == null || (_gltfTexture$extensio2 = gltfTexture.extensions) == null || (_gltfTexture$extensio2 = _gltfTexture$extensio2.EXT_texture_webp) == null ? void 0 : _gltfTexture$extensio2.source) != null ? _ref4 : gltfTexture.source;
      const cloneAsset = seenImages.has(gltfImageIndex);
      seenImages.add(gltfImageIndex);
      return images[gltfImageIndex].then((imageAsset) => {
        var _gltf$samplers;
        const asset = cloneAsset ? cloneTextureAsset(imageAsset) : imageAsset;
        applySampler(asset.resource, ((_gltf$samplers = gltf.samplers) != null ? _gltf$samplers : [])[gltfTexture.sampler]);
        return asset;
      });
    });
    if (postprocess) {
      promise = promise.then((textureAsset) => {
        postprocess(gltfTexture, textureAsset);
        return textureAsset;
      });
    }
    return promise;
  });
};
var loadBuffers = (gltf, binaryChunk, urlBase, options2) => {
  var _options$buffer, _options$buffer2, _options$buffer3;
  if (!gltf.buffers || gltf.buffers.length === 0) {
    return [];
  }
  const preprocess = options2 == null || (_options$buffer = options2.buffer) == null ? void 0 : _options$buffer.preprocess;
  const processAsync = options2 == null || (_options$buffer2 = options2.buffer) == null ? void 0 : _options$buffer2.processAsync;
  const postprocess = options2 == null || (_options$buffer3 = options2.buffer) == null ? void 0 : _options$buffer3.postprocess;
  return gltf.buffers.map((gltfBuffer, i) => {
    if (preprocess) {
      preprocess(gltfBuffer);
    }
    let promise;
    if (processAsync) {
      promise = new Promise((resolve, reject) => {
        processAsync(gltfBuffer, (err3, arrayBuffer) => {
          if (err3) {
            reject(err3);
          } else {
            resolve(arrayBuffer);
          }
        });
      });
    } else {
      promise = new Promise((resolve) => {
        resolve(null);
      });
    }
    promise = promise.then((arrayBuffer) => {
      if (arrayBuffer) {
        return arrayBuffer;
      } else if (gltfBuffer.hasOwnProperty("uri")) {
        if (isDataURI(gltfBuffer.uri)) {
          const byteString = atob(gltfBuffer.uri.split(",")[1]);
          const binaryArray = new Uint8Array(byteString.length);
          for (let j = 0; j < byteString.length; j++) {
            binaryArray[j] = byteString.charCodeAt(j);
          }
          return binaryArray;
        }
        return new Promise((resolve, reject) => {
          http.get(ABSOLUTE_URL.test(gltfBuffer.uri) ? gltfBuffer.uri : path.join(urlBase, gltfBuffer.uri), {
            cache: true,
            responseType: "arraybuffer",
            retry: false
          }, (err3, result) => {
            if (err3) {
              reject(err3);
            } else {
              resolve(new Uint8Array(result));
            }
          });
        });
      }
      return binaryChunk;
    });
    if (postprocess) {
      promise = promise.then((buffer) => {
        postprocess(gltf.buffers[i], buffer);
        return buffer;
      });
    }
    return promise;
  });
};
var parseGltf = (gltfChunk, callback) => {
  const decodeBinaryUtf8 = (array2) => {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array2);
    }
    let str = "";
    for (let i = 0; i < array2.length; i++) {
      str += String.fromCharCode(array2[i]);
    }
    return decodeURIComponent(escape(str));
  };
  const gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));
  if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
    callback(`Invalid gltf version. Expected version 2.0 or above but found version '${gltf.asset.version}'.`);
    return;
  }
  callback(null, gltf);
};
var parseGlb = (glbData, callback) => {
  const data2 = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);
  const magic = data2.getUint32(0, true);
  const version2 = data2.getUint32(4, true);
  const length = data2.getUint32(8, true);
  if (magic !== 1179937895) {
    callback(`Invalid magic number found in glb header. Expected 0x46546C67, found 0x${magic.toString(16)}`);
    return;
  }
  if (version2 !== 2) {
    callback(`Invalid version number found in glb header. Expected 2, found ${version2}`);
    return;
  }
  if (length <= 0 || length > data2.byteLength) {
    callback(`Invalid length found in glb header. Found ${length}`);
    return;
  }
  const chunks = [];
  let offset = 12;
  while (offset < length) {
    const chunkLength = data2.getUint32(offset, true);
    if (offset + chunkLength + 8 > data2.byteLength) {
      callback(`Invalid chunk length found in glb. Found ${chunkLength}`);
    }
    const chunkType = data2.getUint32(offset + 4, true);
    const chunkData = new Uint8Array(data2.buffer, data2.byteOffset + offset + 8, chunkLength);
    chunks.push({
      length: chunkLength,
      type: chunkType,
      data: chunkData
    });
    offset += chunkLength + 8;
  }
  if (chunks.length !== 1 && chunks.length !== 2) {
    callback("Invalid number of chunks found in glb file.");
    return;
  }
  if (chunks[0].type !== 1313821514) {
    callback(`Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x${chunks[0].type.toString(16)}`);
    return;
  }
  if (chunks.length > 1 && chunks[1].type !== 5130562) {
    callback(`Invalid chunk type found in glb file. Expected 0x004E4942, found 0x${chunks[1].type.toString(16)}`);
    return;
  }
  callback(null, {
    gltfChunk: chunks[0].data,
    binaryChunk: chunks.length === 2 ? chunks[1].data : null
  });
};
var parseChunk = (filename, data2, callback) => {
  const hasGlbHeader = () => {
    const u82 = new Uint8Array(data2);
    return u82[0] === 103 && u82[1] === 108 && u82[2] === 84 && u82[3] === 70;
  };
  if (filename && filename.toLowerCase().endsWith(".glb") || hasGlbHeader()) {
    parseGlb(data2, callback);
  } else {
    callback(null, {
      gltfChunk: data2,
      binaryChunk: null
    });
  }
};
var createBufferViews = (gltf, buffers, options2) => {
  var _options$bufferView, _options$bufferView2, _options$bufferView3, _gltf$bufferViews2;
  const result = [];
  const preprocess = options2 == null || (_options$bufferView = options2.bufferView) == null ? void 0 : _options$bufferView.preprocess;
  const processAsync = options2 == null || (_options$bufferView2 = options2.bufferView) == null ? void 0 : _options$bufferView2.processAsync;
  const postprocess = options2 == null || (_options$bufferView3 = options2.bufferView) == null ? void 0 : _options$bufferView3.postprocess;
  if (!((_gltf$bufferViews2 = gltf.bufferViews) != null && _gltf$bufferViews2.length)) {
    return result;
  }
  for (let i = 0; i < gltf.bufferViews.length; ++i) {
    const gltfBufferView = gltf.bufferViews[i];
    if (preprocess) {
      preprocess(gltfBufferView);
    }
    let promise;
    if (processAsync) {
      promise = new Promise((resolve, reject) => {
        processAsync(gltfBufferView, buffers, (err3, result2) => {
          if (err3) {
            reject(err3);
          } else {
            resolve(result2);
          }
        });
      });
    } else {
      promise = new Promise((resolve) => {
        resolve(null);
      });
    }
    promise = promise.then((buffer) => {
      if (buffer) {
        return buffer;
      }
      return buffers[gltfBufferView.buffer].then((buffer2) => {
        return new Uint8Array(buffer2.buffer, buffer2.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);
      });
    });
    if (gltfBufferView.hasOwnProperty("byteStride")) {
      promise = promise.then((typedArray) => {
        typedArray.byteStride = gltfBufferView.byteStride;
        return typedArray;
      });
    }
    if (postprocess) {
      promise = promise.then((typedArray) => {
        postprocess(gltfBufferView, typedArray);
        return typedArray;
      });
    }
    result.push(promise);
  }
  return result;
};
var GlbParser = class {
  static parse(filename, urlBase, data2, device, registry, options2, callback) {
    parseChunk(filename, data2, (err3, chunks) => {
      if (err3) {
        callback(err3);
        return;
      }
      parseGltf(chunks.gltfChunk, (err4, gltf) => {
        if (err4) {
          callback(err4);
          return;
        }
        const buffers = loadBuffers(gltf, chunks.binaryChunk, urlBase, options2);
        const bufferViews = createBufferViews(gltf, buffers, options2);
        const images = createImages(gltf, bufferViews, urlBase, registry, options2);
        const textures = createTextures(gltf, images, options2);
        createResources(device, gltf, bufferViews, textures, options2).then((result) => callback(null, result)).catch((err5) => callback(err5));
      });
    });
  }
  static createDefaultMaterial() {
    return createMaterial({
      name: "defaultGlbMaterial"
    }, []);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/animation.js
var AnimationHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "animation");
    this.device = app2.graphicsDevice;
    this.assets = app2.assets;
  }
  load(url, callback, asset) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const options2 = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    if (url.load.startsWith("blob:") || url.load.startsWith("data:")) {
      if (path.getExtension(url.original).toLowerCase() === ".glb") {
        options2.responseType = Http.ResponseType.ARRAY_BUFFER;
      } else {
        options2.responseType = Http.ResponseType.JSON;
      }
    }
    http.get(url.load, options2, (err3, response) => {
      if (err3) {
        callback(`Error loading animation resource: ${url.original} [${err3}]`);
      } else {
        if (path.getExtension(url.original).toLowerCase() === ".glb") {
          var _asset$options;
          GlbParser.parse("filename.glb", "", response, this.device, this.assets, (_asset$options = asset == null ? void 0 : asset.options) != null ? _asset$options : {}, (err4, parseResult) => {
            if (err4) {
              callback(err4);
            } else {
              var _asset$data;
              const animations = parseResult.animations;
              if (asset != null && (_asset$data = asset.data) != null && _asset$data.events) {
                for (let i = 0; i < animations.length; i++) {
                  animations[i].events = new AnimEvents(Object.values(asset.data.events));
                }
              }
              parseResult.destroy();
              callback(null, animations);
            }
          });
        } else {
          callback(null, this[`_parseAnimationV${response.animation.version}`](response));
        }
      }
    });
  }
  open(url, data2, asset) {
    return data2;
  }
  _parseAnimationV3(data2) {
    const animData = data2.animation;
    const anim = new Animation();
    anim.name = animData.name;
    anim.duration = animData.duration;
    for (let i = 0; i < animData.nodes.length; i++) {
      const node = new Node();
      const n = animData.nodes[i];
      node._name = n.name;
      for (let j = 0; j < n.keys.length; j++) {
        const k = n.keys[j];
        const t = k.time;
        const p = k.pos;
        const r = k.rot;
        const s2 = k.scale;
        const pos = new Vec3(p[0], p[1], p[2]);
        const rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
        const scl = new Vec3(s2[0], s2[1], s2[2]);
        const key = new Key(t, pos, rot, scl);
        node._keys.push(key);
      }
      anim.addNode(node);
    }
    return anim;
  }
  _parseAnimationV4(data2) {
    const animData = data2.animation;
    const anim = new Animation();
    anim.name = animData.name;
    anim.duration = animData.duration;
    for (let i = 0; i < animData.nodes.length; i++) {
      const node = new Node();
      const n = animData.nodes[i];
      node._name = n.name;
      const defPos = n.defaults.p;
      const defRot = n.defaults.r;
      const defScl = n.defaults.s;
      for (let j = 0; j < n.keys.length; j++) {
        const k = n.keys[j];
        const t = k.t;
        const p = defPos ? defPos : k.p;
        const r = defRot ? defRot : k.r;
        const s2 = defScl ? defScl : k.s;
        const pos = new Vec3(p[0], p[1], p[2]);
        const rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
        const scl = new Vec3(s2[0], s2[1], s2[2]);
        const key = new Key(t, pos, rot, scl);
        node._keys.push(key);
      }
      anim.addNode(node);
    }
    return anim;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/anim-clip.js
var AnimClipHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "animclip");
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const options2 = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    if (url.load.startsWith("blob:")) {
      options2.responseType = Http.ResponseType.JSON;
    }
    http.get(url.load, options2, (err3, response) => {
      if (err3) {
        callback(`Error loading animation clip resource: ${url.original} [${err3}]`);
      } else {
        callback(null, response);
      }
    });
  }
  open(url, data2) {
    const name = data2.name;
    const duration = data2.duration;
    const inputs = data2.inputs.map((input) => {
      return new AnimData(1, input);
    });
    const outputs = data2.outputs.map((output) => {
      return new AnimData(output.components, output.data);
    });
    const curves = data2.curves.map((curve) => {
      return new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);
    });
    return new AnimTrack(name, duration, inputs, outputs, curves);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/anim-state-graph.js
var AnimStateGraphHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "animstategraph");
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const options2 = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    if (url.load.startsWith("blob:")) {
      options2.responseType = Http.ResponseType.JSON;
    }
    http.get(url.load, options2, (err3, response) => {
      if (err3) {
        callback(`Error loading animation state graph resource: ${url.original} [${err3}]`);
      } else {
        callback(null, response);
      }
    });
  }
  open(url, data2) {
    return new AnimStateGraph(data2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/audio.js
var ie = function() {
  if (typeof window === "undefined") {
    return false;
  }
  const ua2 = window.navigator.userAgent;
  const msie = ua2.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua2.substring(msie + 5, ua2.indexOf(".", msie)), 10);
  }
  const trident = ua2.indexOf("Trident/");
  if (trident > 0) {
    const rv = ua2.indexOf("rv:");
    return parseInt(ua2.substring(rv + 3, ua2.indexOf(".", rv)), 10);
  }
  return false;
}();
var supportedExtensions = [".ogg", ".mp3", ".wav", ".mp4a", ".m4a", ".mp4", ".aac", ".opus"];
var AudioHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "audio");
    this.manager = app2.soundManager;
  }
  _isSupported(url) {
    const ext = path.getExtension(url);
    return supportedExtensions.indexOf(ext) > -1;
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const success = function success2(resource) {
      callback(null, new Sound(resource));
    };
    const error = function error2(err3) {
      let msg = `Error loading audio url: ${url.original}`;
      if (err3) {
        msg += `: ${err3.message || err3}`;
      }
      console.warn(msg);
      callback(msg);
    };
    if (this._createSound) {
      if (!this._isSupported(url.original)) {
        error(`Audio format for ${url.original} not supported`);
        return;
      }
      this._createSound(url.load, success, error);
    } else {
      error(null);
    }
  }
  _createSound(url, success, error) {
    if (hasAudioContext()) {
      const manager = this.manager;
      if (!manager.context) {
        error("Audio manager has no audio context");
        return;
      }
      const options2 = {
        retry: this.maxRetries > 0,
        maxRetries: this.maxRetries
      };
      if (url.startsWith("blob:") || url.startsWith("data:")) {
        options2.responseType = Http.ResponseType.ARRAY_BUFFER;
      }
      http.get(url, options2, (err3, response) => {
        if (err3) {
          error(err3);
          return;
        }
        manager.context.decodeAudioData(response, success, error);
      });
    } else {
      let audio = null;
      try {
        audio = new Audio();
      } catch (e) {
        error("No support for Audio element");
        return;
      }
      if (ie) {
        document.body.appendChild(audio);
      }
      const onReady = function onReady2() {
        audio.removeEventListener("canplaythrough", onReady2);
        if (ie) {
          document.body.removeChild(audio);
        }
        success(audio);
      };
      audio.onerror = function() {
        audio.onerror = null;
        if (ie) {
          document.body.removeChild(audio);
        }
        error();
      };
      audio.addEventListener("canplaythrough", onReady);
      audio.src = url;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/binary.js
var BinaryHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "binary");
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    http.get(url.load, {
      responseType: Http.ResponseType.ARRAY_BUFFER,
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, (err3, response) => {
      if (!err3) {
        callback(null, response);
      } else {
        callback(`Error loading binary resource: ${url.original} [${err3}]`);
      }
    });
  }
  openBinary(data2) {
    return data2.buffer;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/glb-container-resource.js
var GlbContainerResource = class _GlbContainerResource {
  constructor(data2, asset, assets, defaultMaterial) {
    const createAsset = function createAsset2(type, resource, index) {
      const subAsset = _GlbContainerResource.createAsset(asset.name, type, resource, index);
      assets.add(subAsset);
      return subAsset;
    };
    const renders = [];
    for (let i = 0; i < data2.renders.length; ++i) {
      renders.push(createAsset("render", data2.renders[i], i));
    }
    const materials = [];
    for (let i = 0; i < data2.materials.length; ++i) {
      materials.push(createAsset("material", data2.materials[i], i));
    }
    const animations = [];
    for (let i = 0; i < data2.animations.length; ++i) {
      animations.push(createAsset("animation", data2.animations[i], i));
    }
    this.data = data2;
    this._model = null;
    this._assetName = asset.name;
    this._assets = assets;
    this._defaultMaterial = defaultMaterial;
    this.renders = renders;
    this.materials = materials;
    this.textures = data2.textures;
    this.animations = animations;
  }
  get model() {
    if (!this._model) {
      const model = _GlbContainerResource.createModel(this.data, this._defaultMaterial);
      const modelAsset = _GlbContainerResource.createAsset(this._assetName, "model", model, 0);
      this._assets.add(modelAsset);
      this._model = modelAsset;
    }
    return this._model;
  }
  static createAsset(assetName, type, resource, index) {
    const subAsset = new Asset(`${assetName}/${type}/${index}`, type, {
      url: ""
    });
    subAsset.resource = resource;
    subAsset.loaded = true;
    return subAsset;
  }
  instantiateModelEntity(options2) {
    const entity = new Entity();
    entity.addComponent("model", Object.assign({
      type: "asset",
      asset: this.model
    }, options2));
    return entity;
  }
  instantiateRenderEntity(options2) {
    const defaultMaterial = this._defaultMaterial;
    const skinnedMeshInstances = [];
    const createMeshInstance = function createMeshInstance2(root, entity, mesh, materials, meshDefaultMaterials, skins, gltfNode, nodeInstancingMap) {
      const materialIndex = meshDefaultMaterials[mesh.id];
      const material = materialIndex === void 0 ? defaultMaterial : materials[materialIndex];
      const meshInstance = new MeshInstance(mesh, material);
      if (mesh.morph) {
        meshInstance.morphInstance = new MorphInstance(mesh.morph);
      }
      if (gltfNode.hasOwnProperty("skin")) {
        skinnedMeshInstances.push({
          meshInstance,
          rootBone: root,
          entity
        });
      }
      const instData = nodeInstancingMap.get(gltfNode);
      if (instData) {
        const matrices = instData.matrices;
        const vbFormat = VertexFormat.getDefaultInstancingFormat(mesh.device);
        const vb = new VertexBuffer(mesh.device, vbFormat, matrices.length / 16, {
          data: matrices
        });
        meshInstance.setInstancing(vb);
        meshInstance.instancingData._destroyVertexBuffer = true;
      }
      return meshInstance;
    };
    const cloneHierarchy = (root, node, glb) => {
      const entity = new Entity();
      node._cloneInternal(entity);
      if (!root) root = entity;
      let attachedMi = null;
      let renderAsset = null;
      for (let i = 0; i < glb.nodes.length; i++) {
        const glbNode = glb.nodes[i];
        if (glbNode === node) {
          const gltfNode = glb.gltf.nodes[i];
          if (gltfNode.hasOwnProperty("mesh")) {
            const meshGroup = glb.renders[gltfNode.mesh].meshes;
            renderAsset = this.renders[gltfNode.mesh];
            for (let mi = 0; mi < meshGroup.length; mi++) {
              const mesh = meshGroup[mi];
              if (mesh) {
                const cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.meshDefaultMaterials, glb.skins, gltfNode, glb.nodeInstancingMap);
                if (!attachedMi) {
                  attachedMi = [];
                }
                attachedMi.push(cloneMi);
              }
            }
          }
          if (glb.lights) {
            const lightEntity = glb.lights.get(gltfNode);
            if (lightEntity) {
              entity.addChild(lightEntity.clone());
            }
          }
          if (glb.cameras) {
            const cameraEntity = glb.cameras.get(gltfNode);
            if (cameraEntity) {
              cameraEntity.camera.system.cloneComponent(cameraEntity, entity);
            }
          }
        }
      }
      if (attachedMi) {
        entity.addComponent("render", Object.assign({
          type: "asset",
          meshInstances: attachedMi,
          rootBone: root
        }, options2));
        entity.render.assignAsset(renderAsset);
      }
      const children = node.children;
      for (let i = 0; i < children.length; i++) {
        const childClone = cloneHierarchy(root, children[i], glb);
        entity.addChild(childClone);
      }
      return entity;
    };
    const sceneClones = [];
    for (const scene of this.data.scenes) {
      sceneClones.push(cloneHierarchy(null, scene, this.data));
    }
    skinnedMeshInstances.forEach((data2) => {
      data2.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data2.meshInstance.mesh.skin, data2.rootBone, data2.entity);
    });
    return _GlbContainerResource.createSceneHierarchy(sceneClones, Entity);
  }
  getMaterialVariants() {
    return this.data.variants ? Object.keys(this.data.variants) : [];
  }
  applyMaterialVariant(entity, name) {
    const variant = name ? this.data.variants[name] : null;
    if (variant === void 0) {
      return;
    }
    const renders = entity.findComponents("render");
    for (let i = 0; i < renders.length; i++) {
      const renderComponent = renders[i];
      this._applyMaterialVariant(variant, renderComponent.meshInstances);
    }
  }
  applyMaterialVariantInstances(instances, name) {
    const variant = name ? this.data.variants[name] : null;
    if (variant === void 0) {
      return;
    }
    this._applyMaterialVariant(variant, instances);
  }
  _applyMaterialVariant(variant, instances) {
    instances.forEach((instance) => {
      if (variant === null) {
        instance.material = this._defaultMaterial;
      } else {
        const meshVariants = this.data.meshVariants[instance.mesh.id];
        if (meshVariants) {
          instance.material = this.data.materials[meshVariants[variant]];
        }
      }
    });
  }
  static createSceneHierarchy(sceneNodes, nodeType) {
    let root = null;
    if (sceneNodes.length === 1) {
      root = sceneNodes[0];
    } else {
      root = new nodeType("SceneGroup");
      for (const scene of sceneNodes) {
        root.addChild(scene);
      }
    }
    return root;
  }
  static createModel(glb, defaultMaterial) {
    const createMeshInstance = function createMeshInstance2(model2, mesh, skins, skinInstances2, materials, node, gltfNode) {
      const materialIndex = glb.meshDefaultMaterials[mesh.id];
      const material = materialIndex === void 0 ? defaultMaterial : materials[materialIndex];
      const meshInstance = new MeshInstance(mesh, material, node);
      if (mesh.morph) {
        const morphInstance = new MorphInstance(mesh.morph);
        meshInstance.morphInstance = morphInstance;
        model2.morphInstances.push(morphInstance);
      }
      if (gltfNode.hasOwnProperty("skin")) {
        const skinIndex = gltfNode.skin;
        const skin = skins[skinIndex];
        mesh.skin = skin;
        const skinInstance = skinInstances2[skinIndex];
        meshInstance.skinInstance = skinInstance;
        model2.skinInstances.push(skinInstance);
      }
      model2.meshInstances.push(meshInstance);
    };
    const model = new Model();
    const skinInstances = [];
    for (const skin of glb.skins) {
      const skinInstance = new SkinInstance(skin);
      skinInstance.bones = skin.bones;
      skinInstances.push(skinInstance);
    }
    model.graph = _GlbContainerResource.createSceneHierarchy(glb.scenes, GraphNode);
    for (let i = 0; i < glb.nodes.length; i++) {
      const node = glb.nodes[i];
      if (node.root === model.graph) {
        const gltfNode = glb.gltf.nodes[i];
        if (gltfNode.hasOwnProperty("mesh")) {
          const meshGroup = glb.renders[gltfNode.mesh].meshes;
          for (let mi = 0; mi < meshGroup.length; mi++) {
            const mesh = meshGroup[mi];
            if (mesh) {
              createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);
            }
          }
        }
      }
    }
    return model;
  }
  destroy() {
    const registry = this._assets;
    const destroyAsset = function destroyAsset2(asset) {
      registry.remove(asset);
      asset.unload();
    };
    const destroyAssets = function destroyAssets2(assets) {
      assets.forEach((asset) => {
        destroyAsset(asset);
      });
    };
    if (this.animations) {
      destroyAssets(this.animations);
      this.animations = null;
    }
    if (this.textures) {
      destroyAssets(this.textures);
      this.textures = null;
    }
    if (this.materials) {
      destroyAssets(this.materials);
      this.materials = null;
    }
    if (this.renders) {
      destroyAssets(this.renders);
      this.renders = null;
    }
    if (this._model) {
      destroyAsset(this._model);
      this._model = null;
    }
    this.data = null;
    this.assets = null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/glb-container-parser.js
var GlbContainerParser = class {
  constructor(device, assets, maxRetries) {
    this._device = device;
    this._assets = assets;
    this._defaultMaterial = GlbParser.createDefaultMaterial();
    this.maxRetries = maxRetries;
  }
  _getUrlWithoutParams(url) {
    return url.indexOf("?") >= 0 ? url.split("?")[0] : url;
  }
  load(url, callback, asset) {
    Asset.fetchArrayBuffer(url.load, (err3, result) => {
      if (err3) {
        callback(err3);
      } else {
        GlbParser.parse(this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, this._device, asset.registry, asset.options, (err4, result2) => {
          if (err4) {
            callback(err4);
          } else {
            callback(null, new GlbContainerResource(result2, asset, this._assets, this._defaultMaterial));
          }
        });
      }
    }, asset, this.maxRetries);
  }
  open(url, data2, asset) {
    return data2;
  }
  patch(asset, assets) {
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/container.js
var ContainerResource = class {
  instantiateModelEntity(options2) {
    return null;
  }
  instantiateRenderEntity(options2) {
    return null;
  }
  getMaterialVariants() {
    return null;
  }
  applyMaterialVariant(entity, name) {
  }
  applyMaterialVariantInstances(instances, name) {
  }
};
var ContainerHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "container");
    this.glbContainerParser = new GlbContainerParser(app2.graphicsDevice, app2.assets, 0);
    this.parsers = {};
  }
  set maxRetries(value) {
    this.glbContainerParser.maxRetries = value;
    for (const parser in this.parsers) {
      if (this.parsers.hasOwnProperty(parser)) {
        this.parsers[parser].maxRetries = value;
      }
    }
  }
  get maxRetries() {
    return this.glbContainerParser.maxRetries;
  }
  _getUrlWithoutParams(url) {
    return url.indexOf("?") >= 0 ? url.split("?")[0] : url;
  }
  _getParser(url) {
    const ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace(".", "") : null;
    return this.parsers[ext] || this.glbContainerParser;
  }
  load(url, callback, asset) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    this._getParser(url.original).load(url, callback, asset);
  }
  open(url, data2, asset) {
    return this._getParser(url).open(url, data2, asset);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/css.js
var CssHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "css");
    this.decoder = null;
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    http.get(url.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, (err3, response) => {
      if (!err3) {
        callback(null, response);
      } else {
        callback(`Error loading css resource: ${url.original} [${err3}]`);
      }
    });
  }
  openBinary(data2) {
    var _this$decoder;
    (_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder("utf-8");
    return this.decoder.decode(data2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/cubemap.js
var CubemapHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "cubemap");
    this._device = app2.graphicsDevice;
    this._registry = app2.assets;
    this._loader = app2.loader;
  }
  load(url, callback, asset) {
    this.loadAssets(asset, callback);
  }
  open(url, data2, asset) {
    return asset ? asset.resource : null;
  }
  patch(asset, registry) {
    this.loadAssets(asset, (err3, result) => {
      if (err3) {
        registry.fire("error", asset);
        registry.fire(`error:${asset.id}`, err3, asset);
        asset.fire("error", asset);
      }
    });
  }
  getAssetIds(cubemapAsset) {
    const result = [];
    result[0] = cubemapAsset.file;
    if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
      for (let i = 0; i < 6; ++i) {
        result[i + 1] = cubemapAsset.data.textures[i];
      }
    } else {
      result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
    }
    return result;
  }
  compareAssetIds(assetIdA, assetIdB) {
    if (assetIdA && assetIdB) {
      if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === "string") {
        return assetIdA === assetIdB;
      }
      return assetIdA.url === assetIdB.url;
    }
    return assetIdA !== null === (assetIdB !== null);
  }
  update(cubemapAsset, assetIds, assets) {
    const assetData = cubemapAsset.data || {};
    const oldAssets = cubemapAsset._handlerState.assets;
    const oldResources = cubemapAsset._resources;
    let tex, mip, i;
    const resources = [null, null, null, null, null, null, null];
    const getType = function getType2() {
      if (assetData.hasOwnProperty("type")) {
        return assetData.type;
      }
      if (assetData.hasOwnProperty("rgbm")) {
        return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
      }
      return null;
    };
    if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
      if (assets[0]) {
        tex = assets[0].resource;
        if (tex.cubemap) {
          for (i = 0; i < 6; ++i) {
            resources[i + 1] = new Texture(this._device, {
              name: `${cubemapAsset.name}_prelitCubemap${tex.width >> i}`,
              cubemap: true,
              type: getType() || tex.type,
              width: tex.width >> i,
              height: tex.height >> i,
              format: tex.format,
              levels: [tex._levels[i]],
              addressU: ADDRESS_CLAMP_TO_EDGE,
              addressV: ADDRESS_CLAMP_TO_EDGE,
              mipmaps: i === 0
            });
          }
        } else {
          resources[1] = tex;
        }
      }
    } else {
      resources[1] = oldResources[1] || null;
      resources[2] = oldResources[2] || null;
      resources[3] = oldResources[3] || null;
      resources[4] = oldResources[4] || null;
      resources[5] = oldResources[5] || null;
      resources[6] = oldResources[6] || null;
    }
    const faceAssets = assets.slice(1);
    if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
      if (faceAssets.indexOf(null) === -1) {
        var _assetData$mipmaps;
        const faceTextures = faceAssets.map((asset) => {
          return asset.resource;
        });
        const faceLevels = [];
        for (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {
          faceLevels.push(faceTextures.map((faceTexture) => {
            return faceTexture._levels[mip];
          }));
        }
        const format = faceTextures[0].format;
        const faces = new Texture(this._device, {
          name: `${cubemapAsset.name}_faces`,
          cubemap: true,
          type: getType() || faceTextures[0].type,
          width: faceTextures[0].width,
          height: faceTextures[0].height,
          format: format === PIXELFORMAT_RGB8 ? PIXELFORMAT_RGBA8 : format,
          mipmaps: (_assetData$mipmaps = assetData.mipmaps) != null ? _assetData$mipmaps : true,
          levels: faceLevels,
          minFilter: assetData.hasOwnProperty("minFilter") ? assetData.minFilter : faceTextures[0].minFilter,
          magFilter: assetData.hasOwnProperty("magFilter") ? assetData.magFilter : faceTextures[0].magFilter,
          anisotropy: assetData.hasOwnProperty("anisotropy") ? assetData.anisotropy : 1,
          addressU: ADDRESS_CLAMP_TO_EDGE,
          addressV: ADDRESS_CLAMP_TO_EDGE
        });
        resources[0] = faces;
      }
    } else {
      resources[0] = oldResources[0] || null;
    }
    if (!this.cmpArrays(resources, oldResources)) {
      cubemapAsset.resources = resources;
      cubemapAsset._handlerState.assetIds = assetIds;
      cubemapAsset._handlerState.assets = assets;
      for (i = 0; i < oldResources.length; ++i) {
        if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
          oldResources[i].destroy();
        }
      }
    }
    for (i = 0; i < oldAssets.length; ++i) {
      if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
        oldAssets[i].unload();
      }
    }
  }
  cmpArrays(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (let i = 0; i < arr1.length; ++i) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }
    return true;
  }
  resolveId(value) {
    const valueInt = parseInt(value, 10);
    return valueInt === value || valueInt.toString() === value ? valueInt : value;
  }
  loadAssets(cubemapAsset, callback) {
    if (!cubemapAsset.hasOwnProperty("_handlerState")) {
      cubemapAsset._handlerState = {
        assetIds: [null, null, null, null, null, null, null],
        assets: [null, null, null, null, null, null, null]
      };
    }
    const self2 = this;
    const assetIds = self2.getAssetIds(cubemapAsset);
    const assets = [null, null, null, null, null, null, null];
    const loadedAssetIds = cubemapAsset._handlerState.assetIds;
    const loadedAssets = cubemapAsset._handlerState.assets;
    const registry = self2._registry;
    let awaiting = 7;
    const onLoad = function onLoad2(index, asset) {
      assets[index] = asset;
      awaiting--;
      if (awaiting === 0) {
        self2.update(cubemapAsset, assetIds, assets);
        callback(null, cubemapAsset.resources);
      }
    };
    const onError = function onError2(index, err3, asset) {
      callback(err3);
    };
    const processTexAsset = function processTexAsset2(index, texAsset2) {
      if (texAsset2.loaded) {
        onLoad(index, texAsset2);
      } else {
        registry.once(`load:${texAsset2.id}`, onLoad.bind(self2, index));
        registry.once(`error:${texAsset2.id}`, onError.bind(self2, index));
        if (!texAsset2.loading) {
          registry.load(texAsset2);
        }
      }
    };
    let texAsset;
    for (let i = 0; i < 7; ++i) {
      const assetId = this.resolveId(assetIds[i]);
      if (!assetId) {
        onLoad(i, null);
      } else if (self2.compareAssetIds(assetId, loadedAssetIds[i])) {
        processTexAsset(i, loadedAssets[i]);
      } else if (parseInt(assetId, 10) === assetId) {
        texAsset = registry.get(assetId);
        if (texAsset) {
          processTexAsset(i, texAsset);
        } else {
          setTimeout(((index, assetId_) => {
            const texAsset2 = registry.get(assetId_);
            if (texAsset2) {
              processTexAsset(index, texAsset2);
            } else {
              onError(index, `failed to find dependent cubemap asset=${assetId_}`);
            }
          }).bind(null, i, assetId));
        }
      } else {
        const file = typeof assetId === "string" ? {
          url: assetId,
          filename: assetId
        } : assetId;
        const data2 = file.url.search(".dds") === -1 ? {
          type: "rgbp",
          addressu: "clamp",
          addressv: "clamp",
          mipmaps: false
        } : null;
        texAsset = new Asset(`${cubemapAsset.name}_part_${i}`, "texture", file, data2);
        registry.add(texAsset);
        processTexAsset(i, texAsset);
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/folder.js
var FolderHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "folder");
  }
  load(url, callback) {
    callback(null, null);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/font/font.js
var Font = class {
  constructor(textures, data2) {
    this.type = data2 ? data2.type || FONT_MSDF : FONT_MSDF;
    this.em = 1;
    this.textures = textures;
    this.intensity = 0;
    this._data = null;
    this.data = data2;
  }
  set data(value) {
    this._data = value;
    if (!value) {
      return;
    }
    if (this._data.intensity !== void 0) {
      this.intensity = this._data.intensity;
    }
    if (!this._data.info) {
      this._data.info = {};
    }
    if (!this._data.version || this._data.version < 2) {
      this._data.info.maps = [{
        width: this._data.info.width,
        height: this._data.info.height
      }];
      if (this._data.chars) {
        for (const key in this._data.chars) {
          this._data.chars[key].map = 0;
        }
      }
    }
  }
  get data() {
    return this._data;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/font.js
function upgradeDataSchema(data2) {
  if (data2.version < 3) {
    if (data2.version < 2) {
      data2.info.maps = data2.info.maps || [{
        width: data2.info.width,
        height: data2.info.height
      }];
    }
    data2.chars = Object.keys(data2.chars || {}).reduce((newChars, key) => {
      const existing = data2.chars[key];
      const newKey = existing.letter !== void 0 ? existing.letter : string.fromCodePoint(key);
      if (data2.version < 2) {
        existing.map = existing.map || 0;
      }
      newChars[newKey] = existing;
      return newChars;
    }, {});
    data2.version = 3;
  }
  return data2;
}
var FontHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "font");
    this._loader = app2.loader;
    this.maxRetries = 0;
  }
  load(url, callback, asset) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const self2 = this;
    if (path.getExtension(url.original) === ".json") {
      http.get(url.load, {
        retry: this.maxRetries > 0,
        maxRetries: this.maxRetries
      }, (err3, response) => {
        if (!err3) {
          const data2 = upgradeDataSchema(response);
          self2._loadTextures(url.load.replace(".json", ".png"), data2, (err4, textures) => {
            if (err4) {
              callback(err4);
            } else {
              callback(null, {
                data: data2,
                textures
              });
            }
          });
        } else {
          callback(`Error loading font resource: ${url.original} [${err3}]`);
        }
      });
    } else {
      if (asset && asset.data) {
        asset.data = upgradeDataSchema(asset.data);
      }
      this._loadTextures(url.load, asset && asset.data, callback);
    }
  }
  _loadTextures(url, data2, callback) {
    const numTextures = data2.info.maps.length;
    let numLoaded = 0;
    let error = null;
    const textures = new Array(numTextures);
    const loader = this._loader;
    const loadTexture = function loadTexture2(index) {
      const onLoaded = function onLoaded2(err3, texture) {
        if (error) return;
        if (err3) {
          error = err3;
          callback(err3);
          return;
        }
        texture.upload();
        textures[index] = texture;
        numLoaded++;
        if (numLoaded === numTextures) {
          callback(null, textures);
        }
      };
      if (index === 0) {
        loader.load(url, "texture", onLoaded);
      } else {
        loader.load(url.replace(".png", `${index}.png`), "texture", onLoaded);
      }
    };
    for (let i = 0; i < numTextures; i++) {
      loadTexture(i);
    }
  }
  open(url, data2, asset) {
    let font;
    if (data2.textures) {
      font = new Font(data2.textures, data2.data);
    } else {
      font = new Font(data2, null);
    }
    return font;
  }
  patch(asset, assets) {
    const font = asset.resource;
    if (!font.data && asset.data) {
      font.data = asset.data;
    } else if (!asset.data && font.data) {
      asset.data = font.data;
    }
    if (asset.data) {
      asset.data = upgradeDataSchema(asset.data);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-compressed-data.js
var SH_C02 = 0.28209479177387814;
var SplatCompressedIterator = class {
  constructor(gsplatData, p, r, s2, c2) {
    const unpackUnorm = (value, bits) => {
      const t = (1 << bits) - 1;
      return (value & t) / t;
    };
    const unpack111011 = (result, value) => {
      result.x = unpackUnorm(value >>> 21, 11);
      result.y = unpackUnorm(value >>> 11, 10);
      result.z = unpackUnorm(value, 11);
    };
    const unpack8888 = (result, value) => {
      result.x = unpackUnorm(value >>> 24, 8);
      result.y = unpackUnorm(value >>> 16, 8);
      result.z = unpackUnorm(value >>> 8, 8);
      result.w = unpackUnorm(value, 8);
    };
    const unpackRot = (result, value) => {
      const norm = 1 / (Math.sqrt(2) * 0.5);
      const a = (unpackUnorm(value >>> 20, 10) - 0.5) * norm;
      const b = (unpackUnorm(value >>> 10, 10) - 0.5) * norm;
      const c3 = (unpackUnorm(value, 10) - 0.5) * norm;
      const m = Math.sqrt(1 - (a * a + b * b + c3 * c3));
      switch (value >>> 30) {
        case 0:
          result.set(m, a, b, c3);
          break;
        case 1:
          result.set(a, m, b, c3);
          break;
        case 2:
          result.set(a, b, m, c3);
          break;
        case 3:
          result.set(a, b, c3, m);
          break;
      }
    };
    const lerp = (a, b, t) => a * (1 - t) + b * t;
    const chunkData = gsplatData.chunkData;
    const vertexData = gsplatData.vertexData;
    this.read = (i) => {
      const ci = Math.floor(i / 256) * 12;
      if (p) {
        unpack111011(p, vertexData[i * 4 + 0]);
        p.x = lerp(chunkData[ci + 0], chunkData[ci + 3], p.x);
        p.y = lerp(chunkData[ci + 1], chunkData[ci + 4], p.y);
        p.z = lerp(chunkData[ci + 2], chunkData[ci + 5], p.z);
      }
      if (r) {
        unpackRot(r, vertexData[i * 4 + 1]);
      }
      if (s2) {
        unpack111011(s2, vertexData[i * 4 + 2]);
        s2.x = lerp(chunkData[ci + 6], chunkData[ci + 9], s2.x);
        s2.y = lerp(chunkData[ci + 7], chunkData[ci + 10], s2.y);
        s2.z = lerp(chunkData[ci + 8], chunkData[ci + 11], s2.z);
      }
      if (c2) {
        unpack8888(c2, vertexData[i * 4 + 3]);
      }
    };
  }
};
var GSplatCompressedData = class {
  constructor() {
    this.numSplats = void 0;
    this.chunkData = void 0;
    this.vertexData = void 0;
  }
  createIter(p, r, s2, c2) {
    return new SplatCompressedIterator(this, p, r, s2, c2);
  }
  calcAabb(result) {
    let mx, my, mz, Mx, My, Mz;
    const numChunks = Math.ceil(this.numSplats / 256);
    const chunkData = this.chunkData;
    let s2 = Math.exp(Math.max(chunkData[9], chunkData[10], chunkData[11]));
    mx = chunkData[0] - s2;
    my = chunkData[1] - s2;
    mz = chunkData[2] - s2;
    Mx = chunkData[3] + s2;
    My = chunkData[4] + s2;
    Mz = chunkData[5] + s2;
    for (let i = 1; i < numChunks; ++i) {
      s2 = Math.exp(Math.max(chunkData[i * 12 + 9], chunkData[i * 12 + 10], chunkData[i * 12 + 11]));
      mx = Math.min(mx, chunkData[i * 12 + 0] - s2);
      my = Math.min(my, chunkData[i * 12 + 1] - s2);
      mz = Math.min(mz, chunkData[i * 12 + 2] - s2);
      Mx = Math.max(Mx, chunkData[i * 12 + 3] + s2);
      My = Math.max(My, chunkData[i * 12 + 4] + s2);
      Mz = Math.max(Mz, chunkData[i * 12 + 5] + s2);
    }
    result.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);
    result.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);
    return true;
  }
  getCenters(result) {
    const chunkData = this.chunkData;
    const vertexData = this.vertexData;
    const numChunks = Math.ceil(this.numSplats / 256);
    let mx, my, mz, Mx, My, Mz;
    for (let c2 = 0; c2 < numChunks; ++c2) {
      mx = chunkData[c2 * 12 + 0];
      my = chunkData[c2 * 12 + 1];
      mz = chunkData[c2 * 12 + 2];
      Mx = chunkData[c2 * 12 + 3];
      My = chunkData[c2 * 12 + 4];
      Mz = chunkData[c2 * 12 + 5];
      const end = Math.min(this.numSplats, (c2 + 1) * 256);
      for (let i = c2 * 256; i < end; ++i) {
        const p = vertexData[i * 4];
        const px = (p >>> 21) / 2047;
        const py = (p >>> 11 & 1023) / 1023;
        const pz = (p & 2047) / 2047;
        result[i * 3 + 0] = (1 - px) * mx + px * Mx;
        result[i * 3 + 1] = (1 - py) * my + py * My;
        result[i * 3 + 2] = (1 - pz) * mz + pz * Mz;
      }
    }
  }
  calcFocalPoint(result) {
    const chunkData = this.chunkData;
    const numChunks = Math.ceil(this.numSplats / 256);
    result.x = 0;
    result.y = 0;
    result.z = 0;
    for (let i = 0; i < numChunks; ++i) {
      result.x += chunkData[i * 12 + 0] + chunkData[i * 12 + 3];
      result.y += chunkData[i * 12 + 1] + chunkData[i * 12 + 4];
      result.z += chunkData[i * 12 + 2] + chunkData[i * 12 + 5];
    }
    result.mulScalar(0.5 / numChunks);
  }
  get isCompressed() {
    return true;
  }
  decompress() {
    const members = ["x", "y", "z", "f_dc_0", "f_dc_1", "f_dc_2", "opacity", "scale_0", "scale_1", "scale_2", "rot_0", "rot_1", "rot_2", "rot_3"];
    const data2 = {};
    members.forEach((name) => {
      data2[name] = new Float32Array(this.numSplats);
    });
    const p = new Vec3();
    const r = new Quat();
    const s2 = new Vec3();
    const c2 = new Vec4();
    const iter = this.createIter(p, r, s2, c2);
    for (let i = 0; i < this.numSplats; ++i) {
      iter.read(i);
      data2.x[i] = p.x;
      data2.y[i] = p.y;
      data2.z[i] = p.z;
      data2.rot_0[i] = r.x;
      data2.rot_1[i] = r.y;
      data2.rot_2[i] = r.z;
      data2.rot_3[i] = r.w;
      data2.scale_0[i] = s2.x;
      data2.scale_1[i] = s2.y;
      data2.scale_2[i] = s2.z;
      data2.f_dc_0[i] = (c2.x - 0.5) / SH_C02;
      data2.f_dc_1[i] = (c2.y - 0.5) / SH_C02;
      data2.f_dc_2[i] = (c2.z - 0.5) / SH_C02;
      data2.opacity[i] = c2.w <= 0 ? -40 : c2.w >= 1 ? 40 : -Math.log(1 / c2.w - 1);
    }
    return new GSplatData([{
      name: "vertex",
      count: this.numSplats,
      properties: members.map((name) => {
        return {
          name,
          type: "float",
          byteSize: 4,
          storage: data2[name]
        };
      })
    }]);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-compressed-material.js
var splatCoreVS2 = `
	uniform mat4 matrix_model;
	uniform mat4 matrix_view;
	uniform mat4 matrix_projection;
	uniform vec2 viewport;
	uniform vec4 tex_params;
	uniform highp usampler2D splatOrder;
	uniform highp usampler2D packedTexture;
	uniform highp sampler2D chunkTexture;
	attribute vec3 vertex_position;
	attribute uint vertex_id_attrib;
	varying vec2 texCoord;
	varying vec4 color;
	#ifndef DITHER_NONE
		varying float id;
	#endif
	uint orderId;
	uint splatId;
	ivec2 packedUV;
	ivec2 chunkUV;
	vec4 chunkDataA;
	vec4 chunkDataB;
	vec4 chunkDataC;
	uvec4 packedData;
	bool calcSplatUV() {
		uint numSplats = uint(tex_params.x);
		uint packedWidth = uint(tex_params.y);
		uint chunkWidth = uint(tex_params.z);
		orderId = vertex_id_attrib + uint(vertex_position.z);
		if (orderId >= numSplats) {
			return false;
		}
		ivec2 orderUV = ivec2(
			int(orderId % packedWidth),
			int(orderId / packedWidth)
		);
		splatId = texelFetch(splatOrder, orderUV, 0).r;
		packedUV = ivec2(
			int(splatId % packedWidth),
			int(splatId / packedWidth)
		);
		uint chunkId = splatId / 256u;
		chunkUV = ivec2(
			int((chunkId % chunkWidth) * 3u),
			int(chunkId / chunkWidth)
		);
		return true;
	}
	void readData() {
		chunkDataA = texelFetch(chunkTexture, chunkUV, 0);
		chunkDataB = texelFetch(chunkTexture, ivec2(chunkUV.x + 1, chunkUV.y), 0);
		chunkDataC = texelFetch(chunkTexture, ivec2(chunkUV.x + 2, chunkUV.y), 0);
		packedData = texelFetch(packedTexture, packedUV, 0);
	}
	vec3 unpack111011(uint bits) {
		return vec3(
			float(bits >> 21u) / 2047.0,
			float((bits >> 11u) & 0x3ffu) / 1023.0,
			float(bits & 0x7ffu) / 2047.0
		);
	}
	vec4 unpack8888(uint bits) {
		return vec4(
			float(bits >> 24u) / 255.0,
			float((bits >> 16u) & 0xffu) / 255.0,
			float((bits >> 8u) & 0xffu) / 255.0,
			float(bits & 0xffu) / 255.0
		);
	}
	float norm = 1.0 / (sqrt(2.0) * 0.5);
	vec4 unpackRotation(uint bits) {
		float a = (float((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm;
		float b = (float((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm;
		float c = (float(bits & 0x3ffu) / 1023.0 - 0.5) * norm;
		float m = sqrt(1.0 - (a * a + b * b + c * c));
		uint mode = bits >> 30u;
		if (mode == 0u) return vec4(m, a, b, c);
		if (mode == 1u) return vec4(a, m, b, c);
		if (mode == 2u) return vec4(a, b, m, c);
		return vec4(a, b, c, m);
	}
	vec3 getPosition() {
		return mix(chunkDataA.xyz, vec3(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));
	}
	vec4 getRotation() {
		return unpackRotation(packedData.y);
	}
	vec3 getScale() {
		return exp(mix(vec3(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));
	}
	vec4 getColor() {
		return unpack8888(packedData.w);
	}
	mat3 quatToMat3(vec4 R) {
		float x = R.x;
		float y = R.y;
		float z = R.z;
		float w = R.w;
		return mat3(
			1.0 - 2.0 * (z * z + w * w),
				2.0 * (y * z + x * w),
				2.0 * (y * w - x * z),
				2.0 * (y * z - x * w),
			1.0 - 2.0 * (y * y + w * w),
				2.0 * (z * w + x * y),
				2.0 * (y * w + x * z),
				2.0 * (z * w - x * y),
			1.0 - 2.0 * (y * y + z * z)
		);
	}
	void calcCov3d(mat3 rot, vec3 scale, out vec3 covA, out vec3 covB) {
		mat3 M = transpose(mat3(
			scale.x * rot[0],
			scale.y * rot[1],
			scale.z * rot[2]
		));
		covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));
		covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));
	}
	vec4 calcV1V2(vec3 centerView, vec3 covA, vec3 covB, float focal, mat3 W) {
		mat3 Vrk = mat3(
			covA.x, covA.y, covA.z, 
			covA.y, covB.x, covB.y,
			covA.z, covB.y, covB.z
		);
		float J1 = focal / centerView.z;
		vec2 J2 = -J1 / centerView.z * centerView.xy;
		mat3 J = mat3(
			J1, 0.0, J2.x, 
			0.0, J1, J2.y, 
			0.0, 0.0, 0.0
		);
		mat3 T = W * J;
		mat3 cov = transpose(T) * Vrk * T;
		float diagonal1 = cov[0][0] + 0.3;
		float offDiagonal = cov[0][1];
		float diagonal2 = cov[1][1] + 0.3;
		float mid = 0.5 * (diagonal1 + diagonal2);
		float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));
		float lambda1 = mid + radius;
		float lambda2 = max(mid - radius, 0.1);
		vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));
		vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
		vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);
		return vec4(v1, v2);
	}
	bool evalSplat(out vec4 result) {
		mat4 modelView = matrix_view * matrix_model;
		vec4 centerView = modelView * vec4(getPosition(), 1.0);
		vec4 centerClip = matrix_projection * centerView;
		if (centerClip.z < -centerClip.w) {
			return false;
		}
		vec3 covA, covB;
		calcCov3d(quatToMat3(getRotation()), getScale(), covA, covB);
		vec4 v1v2 = calcV1V2(centerView.xyz, covA, covB, viewport.x * matrix_projection[0][0], transpose(mat3(modelView)));
		if (dot(v1v2.xy, v1v2.xy) < 4.0 && dot(v1v2.zw, v1v2.zw) < 4.0) {
			return false;
		}
		result = centerClip + vec4((vertex_position.x * v1v2.xy + vertex_position.y * v1v2.zw) / viewport * centerClip.w, 0, 0);
		return true;
	}
`;
var splatCoreFS2 = `
	varying vec2 texCoord;
	varying vec4 color;
	#ifndef DITHER_NONE
		varying float id;
	#endif
	#ifdef PICK_PASS
		uniform vec4 uColor;
	#endif
	vec4 evalSplat() {
		float A = -dot(texCoord, texCoord);
		if (A < -4.0) discard;
		float B = exp(A) * color.a;
		#ifdef PICK_PASS
			if (B < 0.3) discard;
			return(uColor);
		#endif
		#ifndef DITHER_NONE
			opacityDither(B, id * 0.013);
		#endif
		#ifdef TONEMAP_ENABLED
			return vec4(gammaCorrectOutput(toneMap(decodeGamma(color.rgb))), B);
		#else
			return vec4(color.rgb, B);
		#endif
	}
`;
var GSplatCompressedShaderGenerator = class {
  generateKey(options2) {
    const vsHash = hashCode(options2.vertex);
    const fsHash = hashCode(options2.fragment);
    const definesHash = ShaderGenerator.definesHash(options2.defines);
    return `splat-${options2.pass}-${options2.gamma}-${options2.toneMapping}-${vsHash}-${fsHash}-${options2.dither}-${definesHash}}`;
  }
  createShaderDefinition(device, options2) {
    const shaderPassInfo = ShaderPass.get(device).getByIndex(options2.pass);
    const shaderPassDefines = shaderPassInfo.shaderDefines;
    const defines = `${shaderPassDefines}#define DITHER_${options2.dither.toUpperCase()}
#define TONEMAP_${options2.toneMapping === TONEMAP_LINEAR ? "DISABLED" : "ENABLED"}
`;
    const vs = defines + splatCoreVS2 + options2.vertex;
    const fs3 = defines + shaderChunks.decodePS + (options2.dither === DITHER_NONE ? "" : shaderChunks.bayerPS + shaderChunks.opacityDitherPS) + ShaderGenerator.tonemapCode(options2.toneMapping) + ShaderGenerator.gammaCode(options2.gamma) + splatCoreFS2 + options2.fragment;
    const defineMap = /* @__PURE__ */ new Map();
    options2.defines.forEach((value) => defineMap.set(value, true));
    return ShaderUtils.createDefinition(device, {
      name: "SplatShader",
      attributes: {
        vertex_position: SEMANTIC_POSITION,
        vertex_id_attrib: SEMANTIC_ATTR13
      },
      vertexCode: vs,
      fragmentCode: fs3,
      fragmentDefines: defineMap,
      vertexDefines: defineMap
    });
  }
};
var gsplatCompressed = new GSplatCompressedShaderGenerator();
var splatMainVS2 = `
		vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);

		void main(void)
		{
				// calculate splat uv
				if (!calcSplatUV()) {
						gl_Position = discardVec;
						return;
				}

				// read data
				readData();

				vec4 pos;
				if (!evalSplat(pos)) {
						gl_Position = discardVec;
						return;
				}

				gl_Position = pos;

				texCoord = vertex_position.xy;
				color = getColor();

				#ifndef DITHER_NONE
						id = float(splatId);
				#endif
		}
`;
var splatMainFS2 = `
		void main(void)
		{
				gl_FragColor = evalSplat();
		}
`;
var createGSplatCompressedMaterial = (options2 = {}) => {
  var _options$dither;
  const ditherEnum = (_options$dither = options2.dither) != null ? _options$dither : DITHER_NONE;
  const dither = ditherEnum !== DITHER_NONE;
  const material = new ShaderMaterial();
  material.name = "compressedSplatMaterial";
  material.cull = CULLFACE_NONE;
  material.blendType = dither ? BLEND_NONE : BLEND_NORMAL;
  material.depthWrite = dither;
  material.getShaderVariant = function(params) {
    var _options$vertex, _options$fragment;
    const programOptions = {
      defines: material.defines,
      pass: params.pass,
      gamma: params.renderParams.shaderOutputGamma,
      toneMapping: params.renderParams.toneMapping,
      vertex: (_options$vertex = options2.vertex) != null ? _options$vertex : splatMainVS2,
      fragment: (_options$fragment = options2.fragment) != null ? _options$fragment : splatMainFS2,
      dither: ditherEnum
    };
    const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat);
    const library = getProgramLibrary(params.device);
    library.register("splat-compressed", gsplatCompressed);
    return library.getProgram("splat-compressed", programOptions, processingOptions);
  };
  material.update();
  return material;
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-compressed.js
var GSplatCompressed = class {
  constructor(device, gsplatData) {
    this.device = void 0;
    this.numSplats = void 0;
    this.aabb = void 0;
    this.centers = void 0;
    this.packedTexture = void 0;
    this.chunkTexture = void 0;
    const numSplats = gsplatData.numSplats;
    const numChunks = Math.ceil(numSplats / 256);
    this.device = device;
    this.numSplats = numSplats;
    this.aabb = new BoundingBox();
    gsplatData.calcAabb(this.aabb);
    this.centers = new Float32Array(gsplatData.numSplats * 3);
    gsplatData.getCenters(this.centers);
    this.packedTexture = this.createTexture("packedData", PIXELFORMAT_RGBA32U, this.evalTextureSize(numSplats), gsplatData.vertexData);
    const chunkSize = this.evalTextureSize(numChunks);
    chunkSize.x *= 3;
    this.chunkTexture = this.createTexture("chunkData", PIXELFORMAT_RGBA32F, chunkSize, gsplatData.chunkData);
  }
  destroy() {
    var _this$packedTexture, _this$chunkTexture;
    (_this$packedTexture = this.packedTexture) == null || _this$packedTexture.destroy();
    (_this$chunkTexture = this.chunkTexture) == null || _this$chunkTexture.destroy();
  }
  createMaterial(options2) {
    const result = createGSplatCompressedMaterial(options2);
    result.setParameter("packedTexture", this.packedTexture);
    result.setParameter("chunkTexture", this.chunkTexture);
    result.setParameter("tex_params", new Float32Array([this.numSplats, this.packedTexture.width, this.chunkTexture.width / 3, 0]));
    return result;
  }
  evalTextureSize(count) {
    const width = Math.ceil(Math.sqrt(count));
    const height = Math.ceil(count / width);
    return new Vec2(width, height);
  }
  createTexture(name, format, size, data2) {
    return new Texture(this.device, _extends({
      name,
      width: size.x,
      height: size.y,
      format,
      cubemap: false,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    }, data2 ? {
      levels: [data2]
    } : {}));
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/gsplat-resource.js
var GSplatResource = class {
  constructor(device, splatData) {
    this.device = void 0;
    this.splatData = void 0;
    this.splat = null;
    this.device = device;
    this.splatData = splatData;
  }
  destroy() {
    var _this$splat;
    this.device = null;
    this.splatData = null;
    (_this$splat = this.splat) == null || _this$splat.destroy();
    this.splat = null;
  }
  createSplat() {
    if (!this.splat) {
      this.splat = this.splatData.isCompressed ? new GSplatCompressed(this.device, this.splatData) : new GSplat(this.device, this.splatData);
    }
    return this.splat;
  }
  instantiate(options2 = {}) {
    const splatInstance = this.createInstance(options2);
    const entity = new Entity();
    const component = entity.addComponent("gsplat", {
      instance: splatInstance
    });
    component.customAabb = splatInstance.splat.aabb.clone();
    return entity;
  }
  createInstance(options2 = {}) {
    const splat = this.createSplat();
    return new GSplatInstance(splat, options2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/ply.js
var magicBytes = new Uint8Array([112, 108, 121, 10]);
var endHeaderBytes = new Uint8Array([10, 101, 110, 100, 95, 104, 101, 97, 100, 101, 114, 10]);
var dataTypeMap = /* @__PURE__ */ new Map([["char", Int8Array], ["uchar", Uint8Array], ["short", Int16Array], ["ushort", Uint16Array], ["int", Int32Array], ["uint", Uint32Array], ["float", Float32Array], ["double", Float64Array]]);
var StreamBuf = class {
  constructor(reader) {
    this.reader = void 0;
    this.data = void 0;
    this.view = void 0;
    this.head = 0;
    this.tail = 0;
    this.reader = reader;
  }
  async read() {
    const {
      value,
      done
    } = await this.reader.read();
    if (done) {
      throw new Error("Stream finished before end of header");
    }
    this.push(value);
  }
  push(data2) {
    if (!this.data) {
      this.data = data2;
      this.view = new DataView(this.data.buffer);
      this.tail = data2.length;
    } else {
      const remaining = this.tail - this.head;
      const newSize = remaining + data2.length;
      if (this.data.length >= newSize) {
        if (this.head > 0) {
          this.data.copyWithin(0, this.head, this.tail);
          this.data.set(data2, remaining);
          this.head = 0;
          this.tail = newSize;
        } else {
          this.data.set(data2, this.tail);
          this.tail += data2.length;
        }
      } else {
        const tmp = new Uint8Array(newSize);
        if (this.head > 0 || this.tail < this.data.length) {
          tmp.set(this.data.subarray(this.head, this.tail), 0);
        } else {
          tmp.set(this.data, 0);
        }
        tmp.set(data2, remaining);
        this.data = tmp;
        this.view = new DataView(this.data.buffer);
        this.head = 0;
        this.tail = newSize;
      }
    }
  }
  compact() {
    if (this.head > 0) {
      this.data.copyWithin(0, this.head, this.tail);
      this.tail -= this.head;
      this.head = 0;
    }
  }
  get remaining() {
    return this.tail - this.head;
  }
  getInt8() {
    const result = this.view.getInt8(this.head);
    this.head++;
    return result;
  }
  getUint8() {
    const result = this.view.getUint8(this.head);
    this.head++;
    return result;
  }
  getInt16() {
    const result = this.view.getInt16(this.head, true);
    this.head += 2;
    return result;
  }
  getUint16() {
    const result = this.view.getUint16(this.head, true);
    this.head += 2;
    return result;
  }
  getInt32() {
    const result = this.view.getInt32(this.head, true);
    this.head += 4;
    return result;
  }
  getUint32() {
    const result = this.view.getUint32(this.head, true);
    this.head += 4;
    return result;
  }
  getFloat32() {
    const result = this.view.getFloat32(this.head, true);
    this.head += 4;
    return result;
  }
  getFloat64() {
    const result = this.view.getFloat64(this.head, true);
    this.head += 8;
    return result;
  }
};
var parseHeader = (lines) => {
  const elements = [];
  let format;
  for (let i = 1; i < lines.length; ++i) {
    const words = lines[i].split(" ");
    switch (words[0]) {
      case "format":
        format = words[1];
        break;
      case "element":
        elements.push({
          name: words[1],
          count: parseInt(words[2], 10),
          properties: []
        });
        break;
      case "property": {
        if (!dataTypeMap.has(words[1])) {
          throw new Error(`Unrecognized property data type '${words[1]}' in ply header`);
        }
        const element = elements[elements.length - 1];
        element.properties.push({
          type: words[1],
          name: words[2],
          storage: null,
          byteSize: dataTypeMap.get(words[1]).BYTES_PER_ELEMENT
        });
        break;
      }
      default:
        throw new Error(`Unrecognized header value '${words[0]}' in ply header`);
    }
  }
  return {
    elements,
    format
  };
};
var isCompressedPly = (elements) => {
  const chunkProperties = ["min_x", "min_y", "min_z", "max_x", "max_y", "max_z", "min_scale_x", "min_scale_y", "min_scale_z", "max_scale_x", "max_scale_y", "max_scale_z"];
  const vertexProperties = ["packed_position", "packed_rotation", "packed_scale", "packed_color"];
  return elements.length === 2 && elements[0].name === "chunk" && elements[0].properties.every((p, i) => p.name === chunkProperties[i] && p.type === "float") && elements[1].name === "vertex" && elements[1].properties.every((p, i) => p.name === vertexProperties[i] && p.type === "uint");
};
var readCompressedPly = async (streamBuf, elements, littleEndian) => {
  const result = new GSplatCompressedData();
  const numChunks = elements[0].count;
  const chunkSize = 12 * 4;
  const numVertices = elements[1].count;
  const vertexSize = 4 * 4;
  const evalStorageSize = (count) => {
    const width = Math.ceil(Math.sqrt(count));
    const height = Math.ceil(count / width);
    return width * height;
  };
  result.numSplats = elements[1].count;
  result.chunkData = new Float32Array(evalStorageSize(numChunks) * 12);
  result.vertexData = new Uint32Array(evalStorageSize(numVertices) * 4);
  let uint32StreamData;
  const uint32ChunkData = new Uint32Array(result.chunkData.buffer);
  const uint32VertexData = result.vertexData;
  let chunks = 0;
  while (chunks < numChunks) {
    var _uint32StreamData;
    while (streamBuf.remaining < chunkSize) {
      await streamBuf.read();
    }
    if (((_uint32StreamData = uint32StreamData) == null ? void 0 : _uint32StreamData.buffer) !== streamBuf.data.buffer) {
      uint32StreamData = new Uint32Array(streamBuf.data.buffer, 0, Math.floor(streamBuf.data.buffer.byteLength / 4));
    }
    const toRead = Math.min(numChunks - chunks, Math.floor(streamBuf.remaining / chunkSize));
    const dstOffset = chunks * 12;
    const srcOffset = streamBuf.head / 4;
    for (let i = 0; i < toRead * 12; ++i) {
      uint32ChunkData[dstOffset + i] = uint32StreamData[srcOffset + i];
    }
    streamBuf.head += toRead * chunkSize;
    chunks += toRead;
  }
  let vertices = 0;
  while (vertices < numVertices) {
    var _uint32StreamData2;
    while (streamBuf.remaining < vertexSize) {
      await streamBuf.read();
    }
    if (((_uint32StreamData2 = uint32StreamData) == null ? void 0 : _uint32StreamData2.buffer) !== streamBuf.data.buffer) {
      uint32StreamData = new Uint32Array(streamBuf.data.buffer, 0, Math.floor(streamBuf.data.buffer.byteLength / 4));
    }
    const toRead = Math.min(numVertices - vertices, Math.floor(streamBuf.remaining / vertexSize));
    const dstOffset = vertices * 4;
    const srcOffset = streamBuf.head / 4;
    for (let i = 0; i < toRead * 4; ++i) {
      uint32VertexData[dstOffset + i] = uint32StreamData[srcOffset + i];
    }
    streamBuf.head += toRead * vertexSize;
    vertices += toRead;
  }
  return result;
};
var readPly = async (reader, propertyFilter = null) => {
  const find = (buf, search) => {
    const endIndex = buf.length - search.length;
    let i, j;
    for (i = 0; i <= endIndex; ++i) {
      for (j = 0; j < search.length; ++j) {
        if (buf[i + j] !== search[j]) {
          break;
        }
      }
      if (j === search.length) {
        return i;
      }
    }
    return -1;
  };
  const startsWith = (a, b) => {
    if (a.length < b.length) {
      return false;
    }
    for (let i = 0; i < b.length; ++i) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };
  const streamBuf = new StreamBuf(reader);
  let headerLength;
  while (true) {
    await streamBuf.read();
    if (streamBuf.tail >= magicBytes.length && !startsWith(streamBuf.data, magicBytes)) {
      throw new Error("Invalid ply header");
    }
    headerLength = find(streamBuf.data, endHeaderBytes);
    if (headerLength !== -1) {
      break;
    }
  }
  const lines = new TextDecoder("ascii").decode(streamBuf.data.subarray(0, headerLength)).split("\n").filter((line) => !line.startsWith("comment "));
  const {
    elements,
    format
  } = parseHeader(lines);
  if (format !== "binary_little_endian" && format !== "binary_big_endian") {
    throw new Error("Unsupported ply format");
  }
  streamBuf.head = headerLength + endHeaderBytes.length;
  streamBuf.compact();
  if (isCompressedPly(elements)) {
    return await readCompressedPly(streamBuf, elements);
  }
  elements.forEach((e) => {
    e.properties.forEach((p) => {
      const storageType = dataTypeMap.get(p.type);
      if (storageType) {
        const storage = !propertyFilter || propertyFilter(p.name) ? new storageType(e.count) : null;
        p.storage = storage;
      }
    });
  });
  for (let i = 0; i < elements.length; ++i) {
    const element = elements[i];
    const inputSize = element.properties.reduce((a, p) => a + p.byteSize, 0);
    let c2 = 0;
    while (c2 < element.count) {
      while (streamBuf.remaining < inputSize) {
        await streamBuf.read();
      }
      const toRead = Math.min(element.count - c2, Math.floor(streamBuf.remaining / inputSize));
      for (let n = 0; n < toRead; ++n) {
        for (let j = 0; j < element.properties.length; ++j) {
          const property = element.properties[j];
          if (property.storage) {
            switch (property.type) {
              case "char":
                property.storage[c2] = streamBuf.getInt8();
                break;
              case "uchar":
                property.storage[c2] = streamBuf.getUint8();
                break;
              case "short":
                property.storage[c2] = streamBuf.getInt16();
                break;
              case "ushort":
                property.storage[c2] = streamBuf.getUint16();
                break;
              case "int":
                property.storage[c2] = streamBuf.getInt32();
                break;
              case "uint":
                property.storage[c2] = streamBuf.getUint32();
                break;
              case "float":
                property.storage[c2] = streamBuf.getFloat32();
                break;
              case "double":
                property.storage[c2] = streamBuf.getFloat64();
                break;
            }
          } else {
            streamBuf.head += property.byteSize;
          }
        }
        c2++;
      }
    }
  }
  return new GSplatData(elements);
};
var defaultElements = ["x", "y", "z", "f_dc_0", "f_dc_1", "f_dc_2", "opacity", "rot_0", "rot_1", "rot_2", "rot_3", "scale_0", "scale_1", "scale_2", "min_x", "min_y", "min_z", "max_x", "max_y", "max_z", "min_scale_x", "min_scale_y", "min_scale_z", "max_scale_x", "max_scale_y", "max_scale_z", "packed_position", "packed_rotation", "packed_scale", "packed_color"];
var defaultElementsSet = new Set(defaultElements);
var defaultElementFilter = (val) => defaultElementsSet.has(val);
var mat43 = new Mat4();
var PlyParser = class {
  constructor(device, assets, maxRetries) {
    this.device = void 0;
    this.assets = void 0;
    this.maxRetries = void 0;
    this.device = device;
    this.assets = assets;
    this.maxRetries = maxRetries;
  }
  async load(url, callback, asset) {
    const response = await fetch(url.load);
    if (!response || !response.body) {
      callback("Error loading resource", null);
    } else {
      var _asset$data$elementFi;
      readPly(response.body.getReader(), (_asset$data$elementFi = asset.data.elementFilter) != null ? _asset$data$elementFi : defaultElementFilter).then((gsplatData) => {
        if (!gsplatData.isCompressed) {
          var _asset$data$performZS, _asset$data$reorder;
          if ((_asset$data$performZS = asset.data.performZScale) != null ? _asset$data$performZS : true) {
            mat43.setScale(-1, -1, 1);
            gsplatData.transform(mat43);
          }
          if ((_asset$data$reorder = asset.data.reorder) != null ? _asset$data$reorder : true) {
            gsplatData.reorderData();
          }
        }
        const resource = new GSplatResource(this.device, gsplatData.isCompressed && asset.data.decompress ? gsplatData.decompress() : gsplatData);
        callback(null, resource);
      }).catch((err3) => {
        callback(err3, null);
      });
    }
  }
  open(url, data2) {
    return data2;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/gsplat.js
var GSplatHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "gsplat");
    this.parser = new PlyParser(app2.graphicsDevice, app2.assets, 3);
  }
  load(url, callback, asset) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    this.parser.load(url, callback, asset);
  }
  open(url, data2, asset) {
    return this.parser.open(url, data2, asset);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/compress/compress-utils.js
var CompressUtils = class {
  static setCompressedPRS(entity, data2, compressed) {
    const a = compressed.singleVecs;
    let b, i;
    const v = data2.___1;
    if (!v) {
      b = compressed.tripleVecs;
      i = data2.___2;
    }
    let n = v ? v[0] : b[i];
    entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);
    n = v ? v[1] : b[i + 1];
    entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);
    n = v ? v[2] : b[i + 2];
    entity.setLocalScale(a[n], a[n + 1], a[n + 2]);
  }
  static oneCharToKey(s2, data2) {
    const i = s2.charCodeAt(0) - data2.fieldFirstCode;
    return data2.fieldArray[i];
  }
  static multCharToKey(s2, data2) {
    let ind = 0;
    for (let i = 0; i < s2.length; i++) {
      ind = ind * data2.fieldCodeBase + s2.charCodeAt(i) - data2.fieldFirstCode;
    }
    return data2.fieldArray[ind];
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/compress/decompress.js
var Decompress = class _Decompress {
  constructor(node, data2) {
    this._node = node;
    this._data = data2;
  }
  run() {
    const type = Object.prototype.toString.call(this._node);
    if (type === "[object Object]") {
      this._handleMap();
    } else if (type === "[object Array]") {
      this._handleArray();
    } else {
      this._result = this._node;
    }
    return this._result;
  }
  _handleMap() {
    this._result = {};
    const a = Object.keys(this._node);
    a.forEach(this._handleKey, this);
  }
  _handleKey(origKey) {
    let newKey = origKey;
    const len = origKey.length;
    if (len === 1) {
      newKey = CompressUtils.oneCharToKey(origKey, this._data);
    } else if (len === 2) {
      newKey = CompressUtils.multCharToKey(origKey, this._data);
    }
    this._result[newKey] = new _Decompress(this._node[origKey], this._data).run();
  }
  _handleArray() {
    this._result = [];
    this._node.forEach(this._handleArElt, this);
  }
  _handleArElt(elt) {
    const v = new _Decompress(elt, this._data).run();
    this._result.push(v);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/scene.js
var SceneParser = class {
  constructor(app2, isTemplate) {
    this._app = app2;
    this._isTemplate = isTemplate;
  }
  parse(data2) {
    const entities = {};
    let parent = null;
    const compressed = data2.compressedFormat;
    if (compressed && !data2.entDecompressed) {
      data2.entDecompressed = true;
      data2.entities = new Decompress(data2.entities, compressed).run();
    }
    for (const id13 in data2.entities) {
      const curData = data2.entities[id13];
      const curEnt = this._createEntity(curData, compressed);
      entities[id13] = curEnt;
      if (curData.parent === null) {
        parent = curEnt;
      }
    }
    for (const id13 in data2.entities) {
      const curEnt = entities[id13];
      const children = data2.entities[id13].children;
      const len = children.length;
      for (let i = 0; i < len; i++) {
        const childEnt = entities[children[i]];
        if (childEnt) {
          curEnt.addChild(childEnt);
        }
      }
    }
    this._openComponentData(parent, data2.entities);
    return parent;
  }
  _createEntity(data2, compressed) {
    var _data$enabled;
    const entity = new Entity(data2.name, this._app);
    entity.setGuid(data2.resource_id);
    this._setPosRotScale(entity, data2, compressed);
    entity._enabled = (_data$enabled = data2.enabled) != null ? _data$enabled : true;
    if (this._isTemplate) {
      entity._template = true;
    } else {
      entity._enabledInHierarchy = entity._enabled;
    }
    entity.template = data2.template;
    if (data2.tags) {
      for (let i = 0; i < data2.tags.length; i++) {
        entity.tags.add(data2.tags[i]);
      }
    }
    return entity;
  }
  _setPosRotScale(entity, data2, compressed) {
    if (compressed) {
      CompressUtils.setCompressedPRS(entity, data2, compressed);
    } else {
      const p = data2.position;
      const r = data2.rotation;
      const s2 = data2.scale;
      entity.setLocalPosition(p[0], p[1], p[2]);
      entity.setLocalEulerAngles(r[0], r[1], r[2]);
      entity.setLocalScale(s2[0], s2[1], s2[2]);
    }
  }
  _openComponentData(entity, entities) {
    const systemsList = this._app.systems.list;
    let len = systemsList.length;
    const entityData = entities[entity.getGuid()];
    for (let i = 0; i < len; i++) {
      const system = systemsList[i];
      const componentData = entityData.components[system.id];
      if (componentData) {
        system.addComponent(entity, componentData);
      }
    }
    len = entityData.children.length;
    const children = entity._children;
    for (let i = 0; i < len; i++) {
      if (children[i]) {
        children[i] = this._openComponentData(children[i], entities);
      }
    }
    return entity;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/scene-utils.js
var SceneUtils = class {
  static load(url, maxRetries, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    http.get(url.load, {
      retry: maxRetries > 0,
      maxRetries
    }, (err3, response) => {
      if (!err3) {
        callback(err3, response);
      } else {
        let errMsg = `Error while loading scene JSON ${url.original}`;
        if (err3.message) {
          errMsg += `: ${err3.message}`;
          if (err3.stack) {
            errMsg += `
${err3.stack}`;
          }
        } else {
          errMsg += `: ${err3}`;
        }
        callback(errMsg);
      }
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/hierarchy.js
var HierarchyHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "hierarchy");
  }
  load(url, callback) {
    SceneUtils.load(url, this.maxRetries, callback);
  }
  open(url, data2) {
    this._app.systems.script.preloading = true;
    const parser = new SceneParser(this._app, false);
    const parent = parser.parse(data2);
    this._app.systems.script.preloading = false;
    return parent;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/html.js
var HtmlHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "html");
    this.decoder = null;
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    http.get(url.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, (err3, response) => {
      if (!err3) {
        callback(null, response);
      } else {
        callback(`Error loading html resource: ${url.original} [${err3}]`);
      }
    });
  }
  openBinary(data2) {
    var _this$decoder;
    (_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder("utf-8");
    return this.decoder.decode(data2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/json.js
var JsonHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "json");
    this.decoder = null;
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const options2 = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    if (url.load.startsWith("blob:")) {
      options2.responseType = Http.ResponseType.JSON;
    }
    http.get(url.load, options2, (err3, response) => {
      if (!err3) {
        callback(null, response);
      } else {
        callback(`Error loading JSON resource: ${url.original} [${err3}]`);
      }
    });
  }
  openBinary(data2) {
    var _this$decoder;
    (_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder("utf-8");
    return JSON.parse(this.decoder.decode(data2));
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material-validator.js
var StandardMaterialValidator = class {
  constructor() {
    this.removeInvalid = true;
    this.valid = true;
    this.enumValidators = {
      occludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),
      cull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),
      blendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),
      depthFunc: this._createEnumValidator([FUNC_NEVER, FUNC_LESS, FUNC_EQUAL, FUNC_LESSEQUAL, FUNC_GREATER, FUNC_NOTEQUAL, FUNC_GREATEREQUAL, FUNC_ALWAYS])
    };
  }
  setInvalid(key, data2) {
    this.valid = false;
    if (this.removeInvalid) {
      delete data2[key];
    }
  }
  validate(data2) {
    const TYPES = standardMaterialParameterTypes;
    const REMOVED = standardMaterialRemovedParameters;
    const pathMapping = data2.mappingFormat === "path";
    for (const key in data2) {
      const type = TYPES[key];
      if (!type) {
        if (REMOVED[key]) {
          delete data2[key];
        } else {
          this.valid = false;
        }
        continue;
      }
      if (type.startsWith("enum")) {
        const enumType = type.split(":")[1];
        if (this.enumValidators[enumType]) {
          if (!this.enumValidators[enumType](data2[key])) {
            this.setInvalid(key, data2);
          }
        }
      } else if (type === "number") {
        if (typeof data2[key] !== "number") {
          this.setInvalid(key, data2);
        }
      } else if (type === "boolean") {
        if (typeof data2[key] !== "boolean") {
          this.setInvalid(key, data2);
        }
      } else if (type === "string") {
        if (typeof data2[key] !== "string") {
          this.setInvalid(key, data2);
        }
      } else if (type === "vec2") {
        if (!(data2[key] instanceof Array && data2[key].length === 2)) {
          this.setInvalid(key, data2);
        }
      } else if (type === "rgb") {
        if (!(data2[key] instanceof Array && data2[key].length === 3)) {
          this.setInvalid(key, data2);
        }
      } else if (type === "texture") {
        if (!pathMapping) {
          if (!(typeof data2[key] === "number" || data2[key] === null)) {
            if (!(data2[key] instanceof Texture)) {
              this.setInvalid(key, data2);
            }
          }
        } else {
          if (!(typeof data2[key] === "string" || data2[key] === null)) {
            if (!(data2[key] instanceof Texture)) {
              this.setInvalid(key, data2);
            }
          }
        }
      } else if (type === "boundingbox") {
        if (!(data2[key].center && data2[key].center instanceof Array && data2[key].center.length === 3)) {
          this.setInvalid(key, data2);
        }
        if (!(data2[key].halfExtents && data2[key].halfExtents instanceof Array && data2[key].halfExtents.length === 3)) {
          this.setInvalid(key, data2);
        }
      } else if (type === "cubemap") {
        if (!(typeof data2[key] === "number" || data2[key] === null || data2[key] === void 0)) {
          if (!(data2[key] instanceof Texture && data2[key].cubemap)) {
            this.setInvalid(key, data2);
          }
        }
      } else if (type === "chunks") {
        const chunkNames = Object.keys(data2[key]);
        for (let i = 0; i < chunkNames.length; i++) {
          if (typeof data2[key][chunkNames[i]] !== "string") {
            this.setInvalid(chunkNames[i], data2[key]);
          }
        }
      } else {
        console.error(`Unknown material type: ${type}`);
      }
    }
    data2.validated = true;
    return this.valid;
  }
  _createEnumValidator(values) {
    return function(value) {
      return values.indexOf(value) >= 0;
    };
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/material/json-standard-material.js
var JsonStandardMaterialParser = class {
  constructor() {
    this._validator = null;
  }
  parse(input) {
    const migrated = this.migrate(input);
    const validated = this._validate(migrated);
    const material = new StandardMaterial();
    this.initialize(material, validated);
    return material;
  }
  initialize(material, data2) {
    if (!data2.validated) {
      data2 = this._validate(data2);
    }
    if (data2.chunks) {
      material.chunks = _extends({}, data2.chunks);
    }
    for (const key in data2) {
      const type = standardMaterialParameterTypes[key];
      const value = data2[key];
      if (type === "vec2") {
        material[key] = new Vec2(value[0], value[1]);
      } else if (type === "rgb") {
        material[key] = new Color(value[0], value[1], value[2]);
      } else if (type === "texture") {
        if (value instanceof Texture) {
          material[key] = value;
        } else if (!(material[key] instanceof Texture && typeof value === "number" && value > 0)) {
          material[key] = null;
        }
      } else if (type === "cubemap") {
        if (value instanceof Texture) {
          material[key] = value;
        } else if (!(material[key] instanceof Texture && typeof value === "number" && value > 0)) {
          material[key] = null;
        }
        if (key === "cubeMap" && !value) {
          material.prefilteredCubemaps = null;
        }
      } else if (type === "boundingbox") {
        const center2 = new Vec3(value.center[0], value.center[1], value.center[2]);
        const halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
        material[key] = new BoundingBox(center2, halfExtents);
      } else {
        material[key] = data2[key];
      }
    }
    material.update();
  }
  migrate(data2) {
    if (data2.shader) delete data2.shader;
    if (data2.mapping_format) {
      data2.mappingFormat = data2.mapping_format;
      delete data2.mapping_format;
    }
    let i;
    const RENAMED_PROPERTIES = [["bumpMapFactor", "bumpiness"], ["aoUvSet", "aoMapUv"], ["aoMapVertexColor", "aoVertexColor"], ["diffuseMapVertexColor", "diffuseVertexColor"], ["emissiveMapVertexColor", "emissiveVertexColor"], ["specularMapVertexColor", "specularVertexColor"], ["metalnessMapVertexColor", "metalnessVertexColor"], ["opacityMapVertexColor", "opacityVertexColor"], ["glossMapVertexColor", "glossVertexColor"], ["lightMapVertexColor", "lightVertexColor"], ["specularMapTint", "specularTint"], ["metalnessMapTint", "metalnessTint"], ["clearCoatGlossiness", "clearCoatGloss"]];
    for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
      const _old = RENAMED_PROPERTIES[i][0];
      const _new = RENAMED_PROPERTIES[i][1];
      if (data2[_old] !== void 0) {
        if (data2[_new] === void 0) {
          data2[_new] = data2[_old];
        }
        delete data2[_old];
      }
    }
    const DEPRECATED_PROPERTIES = ["fresnelFactor", "shadowSampleType"];
    for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
      const name = DEPRECATED_PROPERTIES[i];
      if (data2.hasOwnProperty(name)) {
        delete data2[name];
      }
    }
    return data2;
  }
  _validate(data2) {
    if (!data2.validated) {
      if (!this._validator) {
        this._validator = new StandardMaterialValidator();
      }
      this._validator.validate(data2);
    }
    return data2;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/material.js
var PLACEHOLDER_MAP = {
  aoMap: "white",
  diffuseMap: "gray",
  specularMap: "gray",
  specularityFactorMap: "white",
  metalnessMap: "black",
  glossMap: "gray",
  sheenMap: "black",
  sheenGlossinessMap: "gray",
  clearCoatMap: "black",
  clearCoatGlossMap: "gray",
  clearCoatNormalMap: "normal",
  refractionMap: "white",
  emissiveMap: "gray",
  normalMap: "normal",
  heightMap: "gray",
  opacityMap: "gray",
  sphereMap: "gray",
  lightMap: "white"
};
var MaterialHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "material");
    this._assets = app2.assets;
    this._device = app2.graphicsDevice;
    this._placeholderTextures = null;
    this._parser = new JsonStandardMaterialParser();
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    http.get(url.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, (err3, response) => {
      if (!err3) {
        if (callback) {
          response._engine = true;
          callback(null, response);
        }
      } else {
        if (callback) {
          callback(`Error loading material: ${url.original} [${err3}]`);
        }
      }
    });
  }
  open(url, data2) {
    const material = this._parser.parse(data2);
    if (data2._engine) {
      material._data = data2;
      delete data2._engine;
    }
    return material;
  }
  _createPlaceholders() {
    this._placeholderTextures = {};
    const textures = {
      white: [255, 255, 255, 255],
      gray: [128, 128, 128, 255],
      black: [0, 0, 0, 255],
      normal: [128, 128, 255, 255]
    };
    for (const key in textures) {
      if (!textures.hasOwnProperty(key)) {
        continue;
      }
      this._placeholderTextures[key] = new Texture(this._device, {
        width: 2,
        height: 2,
        format: PIXELFORMAT_RGBA8,
        name: "material_placeholder"
      });
      const pixels = this._placeholderTextures[key].lock();
      for (let i = 0; i < 4; i++) {
        for (let c2 = 0; c2 < 4; c2++) {
          pixels[i * 4 + c2] = textures[key][c2];
        }
      }
      this._placeholderTextures[key].unlock();
    }
  }
  patch(asset, assets) {
    if (asset.resource._data) {
      asset._data = asset.resource._data;
      delete asset.resource._data;
    }
    asset.data.name = asset.name;
    asset.resource.name = asset.name;
    this._bindAndAssignAssets(asset, assets);
    asset.off("unload", this._onAssetUnload, this);
    asset.on("unload", this._onAssetUnload, this);
  }
  _onAssetUnload(asset) {
    delete asset.data.parameters;
    delete asset.data.chunks;
    delete asset.data.name;
  }
  _assignTexture(parameterName, materialAsset, texture) {
    materialAsset.resource[parameterName] = texture;
  }
  _getPlaceholderTexture(parameterName) {
    if (!this._placeholderTextures) {
      this._createPlaceholders();
    }
    const placeholder = PLACEHOLDER_MAP[parameterName];
    const texture = this._placeholderTextures[placeholder];
    return texture;
  }
  _assignPlaceholderTexture(parameterName, materialAsset) {
    materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName);
  }
  _onTextureLoad(parameterName, materialAsset, textureAsset) {
    this._assignTexture(parameterName, materialAsset, textureAsset.resource);
    materialAsset.resource.update();
  }
  _onTextureAdd(parameterName, materialAsset, textureAsset) {
    this._assets.load(textureAsset);
  }
  _onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {
    const material = materialAsset.resource;
    if (material) {
      if (materialAsset.resource[parameterName] === textureAsset.resource) {
        this._assignPlaceholderTexture(parameterName, materialAsset);
        material.update();
      }
    }
  }
  _assignCubemap(parameterName, materialAsset, textures) {
    materialAsset.resource[parameterName] = textures[0];
    if (parameterName === "cubeMap") {
      const prefiltered = textures.slice(1);
      if (prefiltered.every((t) => t)) {
        materialAsset.resource.prefilteredCubemaps = prefiltered;
      } else if (prefiltered[0]) {
        materialAsset.resource.envAtlas = prefiltered[0];
      }
    }
  }
  _onCubemapLoad(parameterName, materialAsset, cubemapAsset) {
    this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);
    this._parser.initialize(materialAsset.resource, materialAsset.data);
  }
  _onCubemapAdd(parameterName, materialAsset, cubemapAsset) {
    this._assets.load(cubemapAsset);
  }
  _onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {
    const material = materialAsset.resource;
    if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {
      this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);
      material.update();
    }
  }
  _bindAndAssignAssets(materialAsset, assets) {
    const data2 = this._parser.migrate(materialAsset.data);
    const material = materialAsset.resource;
    const pathMapping = data2.mappingFormat === "path";
    const TEXTURES = standardMaterialTextureParameters;
    let i, name, assetReference;
    for (i = 0; i < TEXTURES.length; i++) {
      name = TEXTURES[i];
      assetReference = material._assetReferences[name];
      const dataAssetId = data2[name];
      const materialTexture = material[name];
      const isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name);
      const dataValidated = data2.validated;
      if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {
        if (!assetReference) {
          assetReference = new AssetReference(name, materialAsset, assets, {
            load: this._onTextureLoad,
            add: this._onTextureAdd,
            remove: this._onTextureRemoveOrUnload,
            unload: this._onTextureRemoveOrUnload
          }, this);
          material._assetReferences[name] = assetReference;
        }
        if (pathMapping) {
          assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);
        } else {
          assetReference.id = dataAssetId;
        }
        if (assetReference.asset) {
          if (assetReference.asset.resource) {
            this._assignTexture(name, materialAsset, assetReference.asset.resource);
          } else {
            this._assignPlaceholderTexture(name, materialAsset);
          }
          assets.load(assetReference.asset);
        }
      } else {
        if (assetReference) {
          if (pathMapping) {
            assetReference.url = null;
          } else {
            assetReference.id = null;
          }
        }
      }
    }
    const CUBEMAPS = standardMaterialCubemapParameters;
    for (i = 0; i < CUBEMAPS.length; i++) {
      name = CUBEMAPS[i];
      assetReference = material._assetReferences[name];
      if (data2[name] && !materialAsset.data.prefilteredCubeMap128) {
        if (!assetReference) {
          assetReference = new AssetReference(name, materialAsset, assets, {
            load: this._onCubemapLoad,
            add: this._onCubemapAdd,
            remove: this._onCubemapRemoveOrUnload,
            unload: this._onCubemapRemoveOrUnload
          }, this);
          material._assetReferences[name] = assetReference;
        }
        if (pathMapping) {
          assetReference.url = data2[name];
        } else {
          assetReference.id = data2[name];
        }
        if (assetReference.asset) {
          if (assetReference.asset.loaded) {
            this._assignCubemap(name, materialAsset, assetReference.asset.resources);
          }
          assets.load(assetReference.asset);
        }
      }
    }
    this._parser.initialize(material, data2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/glb-model.js
var GlbModelParser = class {
  constructor(modelHandler) {
    this._device = modelHandler.device;
    this._defaultMaterial = modelHandler.defaultMaterial;
    this._assets = modelHandler.assets;
  }
  parse(data2, callback, asset) {
    var _asset$options;
    GlbParser.parse("filename.glb", "", data2, this._device, this._assets, (_asset$options = asset == null ? void 0 : asset.options) != null ? _asset$options : {}, (err3, result) => {
      if (err3) {
        callback(err3);
      } else {
        const model = GlbContainerResource.createModel(result, this._defaultMaterial);
        result.destroy();
        callback(null, model);
      }
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/json-model.js
var JSON_PRIMITIVE_TYPE = {
  "points": PRIMITIVE_POINTS,
  "lines": PRIMITIVE_LINES,
  "lineloop": PRIMITIVE_LINELOOP,
  "linestrip": PRIMITIVE_LINESTRIP,
  "triangles": PRIMITIVE_TRIANGLES,
  "trianglestrip": PRIMITIVE_TRISTRIP,
  "trianglefan": PRIMITIVE_TRIFAN
};
var JSON_VERTEX_ELEMENT_TYPE = {
  "int8": TYPE_INT8,
  "uint8": TYPE_UINT8,
  "int16": TYPE_INT16,
  "uint16": TYPE_UINT16,
  "int32": TYPE_INT32,
  "uint32": TYPE_UINT32,
  "float32": TYPE_FLOAT32
};
var JsonModelParser = class {
  constructor(modelHandler) {
    this._device = modelHandler.device;
    this._defaultMaterial = modelHandler.defaultMaterial;
  }
  parse(data2, callback) {
    const modelData = data2.model;
    if (!modelData) {
      callback(null, null);
      return;
    }
    if (modelData.version <= 1) {
      callback("JsonModelParser#parse: Trying to parse unsupported model format.");
      return;
    }
    const nodes = this._parseNodes(data2);
    const skins = this._parseSkins(data2, nodes);
    const vertexBuffers = this._parseVertexBuffers(data2);
    const indices = this._parseIndexBuffers(data2, vertexBuffers);
    const morphs = this._parseMorphs(data2, nodes, vertexBuffers);
    const meshes = this._parseMeshes(data2, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);
    const meshInstances = this._parseMeshInstances(data2, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);
    const model = new Model();
    model.graph = nodes[0];
    model.meshInstances = meshInstances;
    model.skinInstances = skins.instances;
    model.morphInstances = morphs.instances;
    model.getGraph().syncHierarchy();
    callback(null, model);
  }
  _parseNodes(data2) {
    const modelData = data2.model;
    const nodes = [];
    let i;
    for (i = 0; i < modelData.nodes.length; i++) {
      const nodeData = modelData.nodes[i];
      const node = new GraphNode(nodeData.name);
      node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
      node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
      node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
      node.scaleCompensation = !!nodeData.scaleCompensation;
      nodes.push(node);
    }
    for (i = 1; i < modelData.parents.length; i++) {
      nodes[modelData.parents[i]].addChild(nodes[i]);
    }
    return nodes;
  }
  _parseSkins(data2, nodes) {
    const modelData = data2.model;
    const skins = [];
    const skinInstances = [];
    let i, j;
    for (i = 0; i < modelData.skins.length; i++) {
      const skinData = modelData.skins[i];
      const inverseBindMatrices = [];
      for (j = 0; j < skinData.inverseBindMatrices.length; j++) {
        const ibm = skinData.inverseBindMatrices[j];
        inverseBindMatrices[j] = new Mat4().set(ibm);
      }
      const skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
      skins.push(skin);
      const skinInstance = new SkinInstance(skin);
      const bones = [];
      for (j = 0; j < skin.boneNames.length; j++) {
        const boneName = skin.boneNames[j];
        const bone = nodes[0].findByName(boneName);
        bones.push(bone);
      }
      skinInstance.bones = bones;
      skinInstances.push(skinInstance);
    }
    return {
      skins,
      instances: skinInstances
    };
  }
  _getMorphVertexCount(modelData, morphIndex, vertexBuffers) {
    for (let i = 0; i < modelData.meshes.length; i++) {
      const meshData = modelData.meshes[i];
      if (meshData.morph === morphIndex) {
        const vertexBuffer = vertexBuffers[meshData.vertices];
        return vertexBuffer.numVertices;
      }
    }
    return void 0;
  }
  _parseMorphs(data2, nodes, vertexBuffers) {
    const modelData = data2.model;
    const morphs = [];
    const morphInstances = [];
    let i, j, vertexCount;
    let targets, morphTarget, morphTargetArray;
    if (modelData.morphs) {
      const sparseToFull = function sparseToFull2(data3, indices, totalCount) {
        const full = new Float32Array(totalCount * 3);
        for (let s2 = 0; s2 < indices.length; s2++) {
          const dstIndex = indices[s2] * 3;
          full[dstIndex] = data3[s2 * 3];
          full[dstIndex + 1] = data3[s2 * 3 + 1];
          full[dstIndex + 2] = data3[s2 * 3 + 2];
        }
        return full;
      };
      for (i = 0; i < modelData.morphs.length; i++) {
        targets = modelData.morphs[i].targets;
        morphTargetArray = [];
        vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);
        for (j = 0; j < targets.length; j++) {
          const targetAabb = targets[j].aabb;
          const min = targetAabb.min;
          const max = targetAabb.max;
          const aabb3 = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
          const indices = targets[j].indices;
          let deltaPositions = targets[j].deltaPositions;
          let deltaNormals = targets[j].deltaNormals;
          if (indices) {
            deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
            deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
          }
          morphTarget = new MorphTarget({
            deltaPositions,
            deltaNormals,
            name: targets[j].name,
            aabb: aabb3
          });
          morphTargetArray.push(morphTarget);
        }
        const morph = new Morph(morphTargetArray, this._device);
        morphs.push(morph);
        const morphInstance = new MorphInstance(morph);
        morphInstances.push(morphInstance);
      }
    }
    return {
      morphs,
      instances: morphInstances
    };
  }
  _parseVertexBuffers(data2) {
    const modelData = data2.model;
    const vertexBuffers = [];
    const attributeMap = {
      position: SEMANTIC_POSITION,
      normal: SEMANTIC_NORMAL,
      tangent: SEMANTIC_TANGENT,
      blendWeight: SEMANTIC_BLENDWEIGHT,
      blendIndices: SEMANTIC_BLENDINDICES,
      color: SEMANTIC_COLOR,
      texCoord0: SEMANTIC_TEXCOORD0,
      texCoord1: SEMANTIC_TEXCOORD1,
      texCoord2: SEMANTIC_TEXCOORD2,
      texCoord3: SEMANTIC_TEXCOORD3,
      texCoord4: SEMANTIC_TEXCOORD4,
      texCoord5: SEMANTIC_TEXCOORD5,
      texCoord6: SEMANTIC_TEXCOORD6,
      texCoord7: SEMANTIC_TEXCOORD7
    };
    for (let i = 0; i < modelData.vertices.length; i++) {
      const vertexData = modelData.vertices[i];
      const formatDesc = [];
      for (const attributeName in vertexData) {
        const attribute = vertexData[attributeName];
        formatDesc.push({
          semantic: attributeMap[attributeName],
          components: attribute.components,
          type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
          normalize: attributeMap[attributeName] === SEMANTIC_COLOR
        });
      }
      const vertexFormat = new VertexFormat(this._device, formatDesc);
      const numVertices = vertexData.position.data.length / vertexData.position.components;
      const vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
      const iterator = new VertexIterator(vertexBuffer);
      for (let j = 0; j < numVertices; j++) {
        for (const attributeName in vertexData) {
          const attribute = vertexData[attributeName];
          switch (attribute.components) {
            case 1:
              iterator.element[attributeMap[attributeName]].set(attribute.data[j]);
              break;
            case 2:
              iterator.element[attributeMap[attributeName]].set(attribute.data[j * 2], 1 - attribute.data[j * 2 + 1]);
              break;
            case 3:
              iterator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);
              break;
            case 4:
              iterator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);
              break;
          }
        }
        iterator.next();
      }
      iterator.end();
      vertexBuffers.push(vertexBuffer);
    }
    return vertexBuffers;
  }
  _parseIndexBuffers(data2, vertexBuffers) {
    const modelData = data2.model;
    let indexBuffer = null;
    let indexData = null;
    let i;
    let numIndices = 0;
    for (i = 0; i < modelData.meshes.length; i++) {
      const meshData = modelData.meshes[i];
      if (meshData.indices !== void 0) {
        numIndices += meshData.indices.length;
      }
    }
    let maxVerts = 0;
    for (i = 0; i < vertexBuffers.length; i++) {
      maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
    }
    if (numIndices > 0) {
      if (maxVerts > 65535) {
        indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
        indexData = new Uint32Array(indexBuffer.lock());
      } else {
        indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
        indexData = new Uint16Array(indexBuffer.lock());
      }
    }
    return {
      buffer: indexBuffer,
      data: indexData
    };
  }
  _parseMeshes(data2, skins, morphs, vertexBuffers, indexBuffer, indexData) {
    const modelData = data2.model;
    const meshes = [];
    let indexBase = 0;
    for (let i = 0; i < modelData.meshes.length; i++) {
      const meshData = modelData.meshes[i];
      const meshAabb = meshData.aabb;
      const min = meshAabb.min;
      const max = meshAabb.max;
      const aabb3 = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
      const indexed = meshData.indices !== void 0;
      const mesh = new Mesh(this._device);
      mesh.vertexBuffer = vertexBuffers[meshData.vertices];
      mesh.indexBuffer[0] = indexed ? indexBuffer : null;
      mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
      mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
      mesh.primitive[0].count = meshData.count;
      mesh.primitive[0].indexed = indexed;
      mesh.skin = meshData.skin !== void 0 ? skins[meshData.skin] : null;
      mesh.morph = meshData.morph !== void 0 ? morphs[meshData.morph] : null;
      mesh.aabb = aabb3;
      if (indexed) {
        indexData.set(meshData.indices, indexBase);
        indexBase += meshData.indices.length;
      }
      meshes.push(mesh);
    }
    if (indexBuffer !== null) {
      indexBuffer.unlock();
    }
    return meshes;
  }
  _parseMeshInstances(data2, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
    const modelData = data2.model;
    const meshInstances = [];
    let i;
    for (i = 0; i < modelData.meshInstances.length; i++) {
      const meshInstanceData = modelData.meshInstances[i];
      const node = nodes[meshInstanceData.node];
      const mesh = meshes[meshInstanceData.mesh];
      const meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);
      if (mesh.skin) {
        const skinIndex = skins.indexOf(mesh.skin);
        meshInstance.skinInstance = skinInstances[skinIndex];
      }
      if (mesh.morph) {
        const morphIndex = morphs.indexOf(mesh.morph);
        meshInstance.morphInstance = morphInstances[morphIndex];
      }
      meshInstances.push(meshInstance);
    }
    return meshInstances;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/model.js
var ModelHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "model");
    this._parsers = [];
    this.device = app2.graphicsDevice;
    this.assets = app2.assets;
    this.defaultMaterial = getDefaultMaterial(this.device);
    this.addParser(new JsonModelParser(this), (url, data2) => {
      return path.getExtension(url) === ".json";
    });
    this.addParser(new GlbModelParser(this), (url, data2) => {
      return path.getExtension(url) === ".glb";
    });
  }
  load(url, callback, asset) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const options2 = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    if (url.load.startsWith("blob:") || url.load.startsWith("data:")) {
      if (path.getExtension(url.original).toLowerCase() === ".glb") {
        options2.responseType = Http.ResponseType.ARRAY_BUFFER;
      } else {
        options2.responseType = Http.ResponseType.JSON;
      }
    }
    http.get(url.load, options2, (err3, response) => {
      if (!callback) {
        return;
      }
      if (!err3) {
        for (let i = 0; i < this._parsers.length; i++) {
          const p = this._parsers[i];
          if (p.decider(url.original, response)) {
            p.parser.parse(response, (err4, parseResult) => {
              if (err4) {
                callback(err4);
              } else {
                callback(null, parseResult);
              }
            }, asset);
            return;
          }
        }
        callback("No parsers found");
      } else {
        callback(`Error loading model: ${url.original} [${err3}]`);
      }
    });
  }
  open(url, data2) {
    return data2;
  }
  patch(asset, assets) {
    if (!asset.resource) {
      return;
    }
    const data2 = asset.data;
    const self2 = this;
    asset.resource.meshInstances.forEach((meshInstance, i) => {
      if (data2.mapping) {
        const handleMaterial = function handleMaterial2(asset2) {
          if (asset2.resource) {
            meshInstance.material = asset2.resource;
          } else {
            asset2.once("load", handleMaterial2);
            assets.load(asset2);
          }
          asset2.once("remove", (asset3) => {
            if (meshInstance.material === asset3.resource) {
              meshInstance.material = self2.defaultMaterial;
            }
          });
        };
        if (!data2.mapping[i]) {
          meshInstance.material = self2.defaultMaterial;
          return;
        }
        const id13 = data2.mapping[i].material;
        const url = data2.mapping[i].path;
        let material;
        if (id13 !== void 0) {
          if (!id13) {
            meshInstance.material = self2.defaultMaterial;
          } else {
            material = assets.get(id13);
            if (material) {
              handleMaterial(material);
            } else {
              assets.once(`add:${id13}`, handleMaterial);
            }
          }
        } else if (url) {
          const path2 = asset.getAbsoluteUrl(data2.mapping[i].path);
          material = assets.getByUrl(path2);
          if (material) {
            handleMaterial(material);
          } else {
            assets.once(`add:url:${path2}`, handleMaterial);
          }
        }
      }
    });
  }
  addParser(parser, decider) {
    this._parsers.push({
      parser,
      decider
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/scene.js
var SceneHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "scene");
  }
  load(url, callback) {
    SceneUtils.load(url, this.maxRetries, callback);
  }
  open(url, data2) {
    this._app.systems.script.preloading = true;
    const parser = new SceneParser(this._app, false);
    const parent = parser.parse(data2);
    const scene = this._app.scene;
    scene.root = parent;
    this._app.applySceneSettings(data2.settings);
    this._app.systems.script.preloading = false;
    return scene;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/script/script-types.js
var ScriptTypes = class _ScriptTypes {
  static push(Type) {
    _ScriptTypes._types.push(Type);
  }
};
ScriptTypes._types = [];

// ../node_modules/playcanvas/build/playcanvas/src/framework/script/script-create.js
var reservedScriptNames = /* @__PURE__ */ new Set(["system", "entity", "create", "destroy", "swap", "move", "data", "scripts", "_scripts", "_scriptsIndex", "_scriptsData", "enabled", "_oldState", "onEnable", "onDisable", "onPostStateChange", "_onSetEnabled", "_checkState", "_onBeforeRemove", "_onInitializeAttributes", "_onInitialize", "_onPostInitialize", "_onUpdate", "_onPostUpdate", "_callbacks", "_callbackActive", "has", "get", "on", "off", "fire", "once", "hasEvent"]);
function getReservedScriptNames() {
  return reservedScriptNames;
}
function createScript(name, app2) {
  if (reservedScriptNames.has(name)) {
    throw new Error(`Script name '${name}' is reserved, please rename the script`);
  }
  const scriptType = function scriptType2(args) {
    EventHandler.prototype.initEventHandler.call(this);
    ScriptType.prototype.initScriptType.call(this, args);
  };
  scriptType.prototype = Object.create(ScriptType.prototype);
  scriptType.prototype.constructor = scriptType;
  scriptType.extend = ScriptType.extend;
  scriptType.attributes = new ScriptAttributes(scriptType);
  registerScript(scriptType, name, app2);
  return scriptType;
}
var reservedAttributes = {};
ScriptAttributes.reservedNames.forEach((value, value2, set) => {
  reservedAttributes[value] = 1;
});
createScript.reservedAttributes = reservedAttributes;
function registerScript(script2, name, app2) {
  if (typeof script2 !== "function") {
    throw new Error(`script class: '${script2}' must be a constructor function (i.e. class).`);
  }
  if (!(script2.prototype instanceof Script)) {
    throw new Error(`script class: '${ScriptType.__getScriptName(script2)}' does not extend pc.Script.`);
  }
  name = name || script2.__name || ScriptType.__getScriptName(script2);
  if (reservedScriptNames.has(name)) {
    throw new Error(`script name: '${name}' is reserved, please change script name`);
  }
  script2.__name = name;
  const registry = app2 ? app2.scripts : AppBase.getApplication().scripts;
  registry.add(script2);
  ScriptTypes.push(script2);
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/script.js
var toLowerCamelCase2 = (str) => str[0].toLowerCase() + str.substring(1);
var ScriptHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "script");
    this._scripts = {};
    this._cache = {};
  }
  clearCache() {
    for (const key in this._cache) {
      const element = this._cache[key];
      const parent = element.parentNode;
      if (parent) {
        parent.removeChild(element);
      }
    }
    this._cache = {};
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const self2 = this;
    script.app = this._app;
    const onScriptLoad = (url.load, (err3, url2, extra) => {
      if (!err3) {
        const obj = {};
        for (let i = 0; i < ScriptTypes._types.length; i++) {
          obj[ScriptTypes._types[i].name] = ScriptTypes._types[i];
        }
        ScriptTypes._types.length = 0;
        callback(null, obj, extra);
        delete self2._loader._cache[ResourceLoader.makeKey(url2, "script")];
      } else {
        callback(err3);
      }
    });
    const [basePath, search] = url.load.split("?");
    const isEsmScript = basePath.endsWith(".mjs");
    if (isEsmScript) {
      let path2 = url.load;
      if (path2.startsWith(this._app.assets.prefix)) {
        path2 = path2.replace(this._app.assets.prefix, "");
      }
      const hash = this._app.assets.getByUrl(path2).file.hash;
      const searchParams = new URLSearchParams(search);
      searchParams.set("hash", hash);
      const urlWithHash = `${basePath}?${searchParams.toString()}`;
      this._loadModule(urlWithHash, onScriptLoad);
    } else {
      this._loadScript(url.load, onScriptLoad);
    }
  }
  open(url, data2) {
    return data2;
  }
  patch(asset, assets) {
  }
  _loadScript(url, callback) {
    const head = document.head;
    const element = document.createElement("script");
    this._cache[url] = element;
    element.async = false;
    element.addEventListener("error", (e) => {
      callback(`Script: ${e.target.src} failed to load`);
    }, false);
    let done = false;
    element.onload = element.onreadystatechange = function() {
      if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
        done = true;
        callback(null, url, element);
      }
    };
    element.src = url;
    head.appendChild(element);
  }
  _loadModule(url, callback) {
    const baseUrl = platform.browser ? window.location.origin + window.location.pathname : import.meta.url;
    const importUrl = new URL(url, baseUrl);
    import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      importUrl.toString()
    ).then((module) => {
      const filename = importUrl.pathname.split("/").pop();
      const scriptSchema = this._app.assets.find(filename, "script").data.scripts;
      for (const key in module) {
        const scriptClass = module[key];
        const extendsScriptType = scriptClass.prototype instanceof Script;
        if (extendsScriptType) {
          const scriptName = toLowerCamelCase2(scriptClass.name);
          registerScript(scriptClass, scriptName);
          this._app.scripts.addSchema(scriptName, scriptSchema[scriptName]);
        }
      }
      callback(null, url, null);
    }).catch((err3) => {
      callback(err3);
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/shader.js
var ShaderHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "shader");
    this.decoder = null;
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    http.get(url.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, (err3, response) => {
      if (!err3) {
        callback(null, response);
      } else {
        callback(`Error loading shader resource: ${url.original} [${err3}]`);
      }
    });
  }
  openBinary(data2) {
    var _this$decoder;
    (_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder("utf-8");
    return this.decoder.decode(data2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/sprite.js
function onTextureAtlasLoaded(atlasAsset) {
  const spriteAsset = this;
  if (spriteAsset.resource) {
    spriteAsset.resource.atlas = atlasAsset.resource;
  }
}
function onTextureAtlasAdded(atlasAsset) {
  const spriteAsset = this;
  spriteAsset.registry.load(atlasAsset);
}
var SpriteHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "sprite");
    this._assets = app2.assets;
    this._device = app2.graphicsDevice;
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    if (path.getExtension(url.original) === ".json") {
      http.get(url.load, {
        retry: this.maxRetries > 0,
        maxRetries: this.maxRetries
      }, (err3, response) => {
        if (!err3) {
          callback(null, response);
        } else {
          callback(err3);
        }
      });
    }
  }
  open(url, data2) {
    const sprite = new Sprite(this._device);
    if (url) {
      sprite.__data = data2;
    }
    return sprite;
  }
  patch(asset, assets) {
    const sprite = asset.resource;
    if (sprite.__data) {
      asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
      asset.data.renderMode = sprite.__data.renderMode;
      asset.data.frameKeys = sprite.__data.frameKeys;
      if (sprite.__data.textureAtlasAsset) {
        const atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);
        if (atlas) {
          asset.data.textureAtlasAsset = atlas.id;
        } else {
          console.warn(`Could not find textureatlas with url: ${sprite.__data.textureAtlasAsset}`);
        }
      }
    }
    sprite.startUpdate();
    sprite.renderMode = asset.data.renderMode;
    sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
    sprite.frameKeys = asset.data.frameKeys;
    this._updateAtlas(asset);
    sprite.endUpdate();
    asset.off("change", this._onAssetChange, this);
    asset.on("change", this._onAssetChange, this);
  }
  _updateAtlas(asset) {
    const sprite = asset.resource;
    if (!asset.data.textureAtlasAsset) {
      sprite.atlas = null;
      return;
    }
    this._assets.off(`load:${asset.data.textureAtlasAsset}`, onTextureAtlasLoaded, asset);
    this._assets.on(`load:${asset.data.textureAtlasAsset}`, onTextureAtlasLoaded, asset);
    const atlasAsset = this._assets.get(asset.data.textureAtlasAsset);
    if (atlasAsset && atlasAsset.resource) {
      sprite.atlas = atlasAsset.resource;
    } else {
      if (!atlasAsset) {
        this._assets.off(`add:${asset.data.textureAtlasAsset}`, onTextureAtlasAdded, asset);
        this._assets.on(`add:${asset.data.textureAtlasAsset}`, onTextureAtlasAdded, asset);
      } else {
        this._assets.load(atlasAsset);
      }
    }
  }
  _onAssetChange(asset, attribute, value, oldValue) {
    if (attribute === "data") {
      if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
        this._assets.off(`load:${oldValue.textureAtlasAsset}`, onTextureAtlasLoaded, asset);
        this._assets.off(`add:${oldValue.textureAtlasAsset}`, onTextureAtlasAdded, asset);
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/template.js
var Template = class {
  constructor(app2, data2) {
    this._app = void 0;
    this._data = void 0;
    this._templateRoot = null;
    this._app = app2;
    this._data = data2;
  }
  instantiate() {
    if (!this._templateRoot) {
      this._parseTemplate();
    }
    return this._templateRoot.clone();
  }
  _parseTemplate() {
    const parser = new SceneParser(this._app, true);
    this._templateRoot = parser.parse(this._data);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/template.js
var TemplateHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "template");
    this.decoder = null;
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const options2 = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    http.get(url.load, options2, (err3, response) => {
      if (err3) {
        callback(`Error requesting template: ${url.original}`);
      } else {
        callback(err3, response);
      }
    });
  }
  open(url, data2) {
    return new Template(this._app, data2);
  }
  openBinary(data2) {
    var _this$decoder;
    (_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder("utf-8");
    return new Template(this._app, JSON.parse(this.decoder.decode(data2)));
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/text.js
var TextHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "text");
    this.decoder = null;
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    http.get(url.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, (err3, response) => {
      if (!err3) {
        callback(null, response);
      } else {
        callback(`Error loading text resource: ${url.original} [${err3}]`);
      }
    });
  }
  openBinary(data2) {
    var _this$decoder;
    (_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder("utf-8");
    return this.decoder.decode(data2);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/texture-atlas.js
var JSON_ADDRESS_MODE = {
  "repeat": ADDRESS_REPEAT,
  "clamp": ADDRESS_CLAMP_TO_EDGE,
  "mirror": ADDRESS_MIRRORED_REPEAT
};
var JSON_FILTER_MODE = {
  "nearest": FILTER_NEAREST,
  "linear": FILTER_LINEAR,
  "nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
  "linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
  "nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
  "linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
};
var regexFrame = /^data\.frames\.(\d+)$/;
var TextureAtlasHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "textureatlas");
    this._loader = app2.loader;
  }
  load(url, callback) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    const self2 = this;
    const handler = this._loader.getHandler("texture");
    if (path.getExtension(url.original) === ".json") {
      http.get(url.load, {
        retry: this.maxRetries > 0,
        maxRetries: this.maxRetries
      }, (err3, response) => {
        if (!err3) {
          const textureUrl = url.original.replace(".json", ".png");
          self2._loader.load(textureUrl, "texture", (err4, texture) => {
            if (err4) {
              callback(err4);
            } else {
              callback(null, {
                data: response,
                texture
              });
            }
          });
        } else {
          callback(err3);
        }
      });
    } else {
      handler.load(url, callback);
    }
  }
  open(url, data2) {
    const resource = new TextureAtlas();
    if (data2.texture && data2.data) {
      resource.texture = data2.texture;
      resource.__data = data2.data;
    } else {
      const handler = this._loader.getHandler("texture");
      const texture = handler.open(url, data2);
      if (!texture) return null;
      resource.texture = texture;
    }
    return resource;
  }
  patch(asset, assets) {
    if (!asset.resource) {
      return;
    }
    if (asset.resource.__data) {
      if (asset.resource.__data.minfilter !== void 0) asset.data.minfilter = asset.resource.__data.minfilter;
      if (asset.resource.__data.magfilter !== void 0) asset.data.magfilter = asset.resource.__data.magfilter;
      if (asset.resource.__data.addressu !== void 0) asset.data.addressu = asset.resource.__data.addressu;
      if (asset.resource.__data.addressv !== void 0) asset.data.addressv = asset.resource.__data.addressv;
      if (asset.resource.__data.mipmaps !== void 0) asset.data.mipmaps = asset.resource.__data.mipmaps;
      if (asset.resource.__data.anisotropy !== void 0) asset.data.anisotropy = asset.resource.__data.anisotropy;
      if (asset.resource.__data.rgbm !== void 0) asset.data.rgbm = !!asset.resource.__data.rgbm;
      asset.data.frames = asset.resource.__data.frames;
      delete asset.resource.__data;
    }
    const texture = asset.resource.texture;
    if (texture) {
      texture.name = asset.name;
      if (asset.data.hasOwnProperty("minfilter") && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter]) {
        texture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];
      }
      if (asset.data.hasOwnProperty("magfilter") && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter]) {
        texture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];
      }
      if (asset.data.hasOwnProperty("addressu") && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu]) {
        texture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];
      }
      if (asset.data.hasOwnProperty("addressv") && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv]) {
        texture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];
      }
      if (asset.data.hasOwnProperty("mipmaps") && texture.mipmaps !== asset.data.mipmaps) {
        texture.mipmaps = asset.data.mipmaps;
      }
      if (asset.data.hasOwnProperty("anisotropy") && texture.anisotropy !== asset.data.anisotropy) {
        texture.anisotropy = asset.data.anisotropy;
      }
      if (asset.data.hasOwnProperty("rgbm")) {
        const type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
        if (texture.type !== type) {
          texture.type = type;
        }
      }
    }
    asset.resource.texture = texture;
    const frames = {};
    for (const key in asset.data.frames) {
      const frame = asset.data.frames[key];
      frames[key] = {
        rect: new Vec4(frame.rect),
        pivot: new Vec2(frame.pivot),
        border: new Vec4(frame.border)
      };
    }
    asset.resource.frames = frames;
    asset.off("change", this._onAssetChange, this);
    asset.on("change", this._onAssetChange, this);
  }
  _onAssetChange(asset, attribute, value) {
    let frame;
    if (attribute === "data" || attribute === "data.frames") {
      const frames = {};
      for (const key in value.frames) {
        frame = value.frames[key];
        frames[key] = {
          rect: new Vec4(frame.rect),
          pivot: new Vec2(frame.pivot),
          border: new Vec4(frame.border)
        };
      }
      asset.resource.frames = frames;
    } else {
      const match = attribute.match(regexFrame);
      if (match) {
        const frameKey = match[1];
        if (value) {
          if (!asset.resource.frames[frameKey]) {
            asset.resource.frames[frameKey] = {
              rect: new Vec4(value.rect),
              pivot: new Vec2(value.pivot),
              border: new Vec4(value.border)
            };
          } else {
            frame = asset.resource.frames[frameKey];
            frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
            frame.pivot.set(value.pivot[0], value.pivot[1]);
            frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
          }
          asset.resource.fire("set:frame", frameKey, asset.resource.frames[frameKey]);
        } else {
          if (asset.resource.frames[frameKey]) {
            delete asset.resource.frames[frameKey];
            asset.resource.fire("remove:frame", frameKey);
          }
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/basis-worker.js
function BasisWorker() {
  const BASIS_FORMAT = {
    cTFETC1: 0,
    cTFETC2: 1,
    cTFBC1: 2,
    cTFBC3: 3,
    cTFPVRTC1_4_RGB: 8,
    cTFPVRTC1_4_RGBA: 9,
    cTFASTC_4x4: 10,
    cTFATC_RGB: 11,
    cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
    cTFRGBA32: 13,
    cTFRGB565: 14,
    cTFRGBA4444: 16
  };
  const opaqueMapping = {
    astc: BASIS_FORMAT.cTFASTC_4x4,
    dxt: BASIS_FORMAT.cTFBC1,
    etc1: BASIS_FORMAT.cTFETC1,
    etc2: BASIS_FORMAT.cTFETC1,
    pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
    atc: BASIS_FORMAT.cTFATC_RGB,
    none: BASIS_FORMAT.cTFRGB565
  };
  const alphaMapping = {
    astc: BASIS_FORMAT.cTFASTC_4x4,
    dxt: BASIS_FORMAT.cTFBC3,
    etc1: BASIS_FORMAT.cTFRGBA4444,
    etc2: BASIS_FORMAT.cTFETC2,
    pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
    atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
    none: BASIS_FORMAT.cTFRGBA4444
  };
  const PIXEL_FORMAT = {
    ETC1: 21,
    ETC2_RGB: 22,
    ETC2_RGBA: 23,
    DXT1: 8,
    DXT5: 10,
    PVRTC_4BPP_RGB_1: 26,
    PVRTC_4BPP_RGBA_1: 27,
    ASTC_4x4: 28,
    ATC_RGB: 29,
    ATC_RGBA: 30,
    R8_G8_B8_A8: 7,
    R5_G6_B5: 3,
    R4_G4_B4_A4: 5
  };
  const basisToEngineMapping = (basisFormat, deviceDetails2) => {
    switch (basisFormat) {
      case BASIS_FORMAT.cTFETC1:
        return deviceDetails2.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;
      case BASIS_FORMAT.cTFETC2:
        return PIXEL_FORMAT.ETC2_RGBA;
      case BASIS_FORMAT.cTFBC1:
        return PIXEL_FORMAT.DXT1;
      case BASIS_FORMAT.cTFBC3:
        return PIXEL_FORMAT.DXT5;
      case BASIS_FORMAT.cTFPVRTC1_4_RGB:
        return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;
      case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
        return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;
      case BASIS_FORMAT.cTFASTC_4x4:
        return PIXEL_FORMAT.ASTC_4x4;
      case BASIS_FORMAT.cTFATC_RGB:
        return PIXEL_FORMAT.ATC_RGB;
      case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
        return PIXEL_FORMAT.ATC_RGBA;
      case BASIS_FORMAT.cTFRGBA32:
        return PIXEL_FORMAT.R8_G8_B8_A8;
      case BASIS_FORMAT.cTFRGB565:
        return PIXEL_FORMAT.R5_G6_B5;
      case BASIS_FORMAT.cTFRGBA4444:
        return PIXEL_FORMAT.R4_G4_B4_A4;
    }
  };
  const unswizzleGGGR = (data2) => {
    const genB = function genB2(R, G) {
      const r = R * (2 / 255) - 1;
      const g = G * (2 / 255) - 1;
      const b = Math.sqrt(1 - Math.min(1, r * r + g * g));
      return Math.max(0, Math.min(255, Math.floor((b + 1) * 0.5 * 255)));
    };
    for (let offset = 0; offset < data2.length; offset += 4) {
      const R = data2[offset + 3];
      const G = data2[offset + 1];
      data2[offset + 0] = R;
      data2[offset + 2] = genB(R, G);
      data2[offset + 3] = 255;
    }
    return data2;
  };
  const pack565 = (data2) => {
    const result = new Uint16Array(data2.length / 4);
    for (let offset = 0; offset < data2.length; offset += 4) {
      const R = data2[offset + 0];
      const G = data2[offset + 1];
      const B = data2[offset + 2];
      result[offset / 4] = (R & 248) << 8 | (G & 252) << 3 | B >> 3;
    }
    return result;
  };
  const isPOT = (width, height) => {
    return (width & width - 1) === 0 && (height & height - 1) === 0;
  };
  const performanceNow = () => {
    return typeof performance !== "undefined" ? performance.now() : 0;
  };
  let basis;
  let rgbPriority;
  let rgbaPriority;
  const chooseTargetFormat = (deviceDetails2, hasAlpha, isUASTC) => {
    if (isUASTC) {
      if (deviceDetails2.formats.astc) {
        return "astc";
      }
    } else {
      if (hasAlpha) {
        if (deviceDetails2.formats.etc2) {
          return "etc2";
        }
      } else {
        if (deviceDetails2.formats.etc1 || deviceDetails2.formats.etc2) {
          return "etc1";
        }
      }
    }
    const testInOrder = (priority) => {
      for (let i = 0; i < priority.length; ++i) {
        const format = priority[i];
        if (deviceDetails2.formats[format]) {
          return format;
        }
      }
      return "none";
    };
    return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);
  };
  const dimensionsValid = (width, height, format) => {
    switch (format) {
      case BASIS_FORMAT.cTFETC1:
      case BASIS_FORMAT.cTFETC2:
        return true;
      case BASIS_FORMAT.cTFBC1:
      case BASIS_FORMAT.cTFBC3:
        return (width & 3) === 0 && (height & 3) === 0;
      case BASIS_FORMAT.cTFPVRTC1_4_RGB:
      case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
        return isPOT(width, height);
      case BASIS_FORMAT.cTFASTC_4x4:
        return true;
      case BASIS_FORMAT.cTFATC_RGB:
      case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
        return true;
    }
    return false;
  };
  const transcodeKTX2 = (url, data2, options2) => {
    if (!basis.KTX2File) {
      throw new Error("Basis transcoder module does not include support for KTX2.");
    }
    const funcStart = performanceNow();
    const basisFile = new basis.KTX2File(new Uint8Array(data2));
    const width = basisFile.getWidth();
    const height = basisFile.getHeight();
    const levels = basisFile.getLevels();
    const hasAlpha = !!basisFile.getHasAlpha();
    const isUASTC = basisFile.isUASTC && basisFile.isUASTC();
    if (!width || !height || !levels) {
      basisFile.close();
      basisFile.delete();
      throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} levels=${levels}`);
    }
    const format = chooseTargetFormat(options2.deviceDetails, hasAlpha, isUASTC);
    const unswizzle = !!options2.isGGGR && format === "pvr";
    let basisFormat;
    if (unswizzle) {
      basisFormat = BASIS_FORMAT.cTFRGBA32;
    } else {
      basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
      if (!dimensionsValid(width, height, basisFormat)) {
        basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
      }
    }
    if (!basisFile.startTranscoding()) {
      basisFile.close();
      basisFile.delete();
      throw new Error(`Failed to start transcoding url=${url}`);
    }
    let i;
    const levelData = [];
    for (let mip = 0; mip < levels; ++mip) {
      const dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);
      const dst = new Uint8Array(dstSize);
      if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {
        basisFile.close();
        basisFile.delete();
        throw new Error(`Failed to transcode image url=${url}`);
      }
      const is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
      levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
    }
    basisFile.close();
    basisFile.delete();
    if (unswizzle) {
      basisFormat = BASIS_FORMAT.cTFRGB565;
      for (i = 0; i < levelData.length; ++i) {
        levelData[i] = pack565(unswizzleGGGR(levelData[i]));
      }
    }
    return {
      format: basisToEngineMapping(basisFormat, options2.deviceDetails),
      width,
      height,
      levels: levelData,
      cubemap: false,
      transcodeTime: performanceNow() - funcStart,
      url,
      unswizzledGGGR: unswizzle
    };
  };
  const transcodeBasis = (url, data2, options2) => {
    const funcStart = performanceNow();
    const basisFile = new basis.BasisFile(new Uint8Array(data2));
    const width = basisFile.getImageWidth(0, 0);
    const height = basisFile.getImageHeight(0, 0);
    const images = basisFile.getNumImages();
    const levels = basisFile.getNumLevels(0);
    const hasAlpha = !!basisFile.getHasAlpha();
    const isUASTC = basisFile.isUASTC && basisFile.isUASTC();
    if (!width || !height || !images || !levels) {
      basisFile.close();
      basisFile.delete();
      throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} images=${images} levels=${levels}`);
    }
    const format = chooseTargetFormat(options2.deviceDetails, hasAlpha, isUASTC);
    const unswizzle = !!options2.isGGGR && format === "pvr";
    let basisFormat;
    if (unswizzle) {
      basisFormat = BASIS_FORMAT.cTFRGBA32;
    } else {
      basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
      if (!dimensionsValid(width, height, basisFormat)) {
        basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
      }
    }
    if (!basisFile.startTranscoding()) {
      basisFile.close();
      basisFile.delete();
      throw new Error(`Failed to start transcoding url=${url}`);
    }
    let i;
    const levelData = [];
    for (let mip = 0; mip < levels; ++mip) {
      const dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
      const dst = new Uint8Array(dstSize);
      if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {
        if (mip === levels - 1 && dstSize === levelData[mip - 1].buffer.byteLength) {
          dst.set(new Uint8Array(levelData[mip - 1].buffer));
          console.warn(`Failed to transcode last mipmap level, using previous level instead url=${url}`);
        } else {
          basisFile.close();
          basisFile.delete();
          throw new Error(`Failed to transcode image url=${url}`);
        }
      }
      const is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
      levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
    }
    basisFile.close();
    basisFile.delete();
    if (unswizzle) {
      basisFormat = BASIS_FORMAT.cTFRGB565;
      for (i = 0; i < levelData.length; ++i) {
        levelData[i] = pack565(unswizzleGGGR(levelData[i]));
      }
    }
    return {
      format: basisToEngineMapping(basisFormat, options2.deviceDetails),
      width,
      height,
      levels: levelData,
      cubemap: false,
      transcodeTime: performanceNow() - funcStart,
      url,
      unswizzledGGGR: unswizzle
    };
  };
  const transcode = (url, data2, options2) => {
    return options2.isKTX2 ? transcodeKTX2(url, data2, options2) : transcodeBasis(url, data2, options2);
  };
  const workerTranscode = (url, data2, options2) => {
    try {
      const result = transcode(url, data2, options2);
      result.levels = result.levels.map((v) => v.buffer);
      self.postMessage({
        url,
        data: result
      }, result.levels);
    } catch (err3) {
      self.postMessage({
        url,
        err: err3
      }, null);
    }
  };
  const workerInit = (config, callback) => {
    const instantiateWasmFunc = (imports, successCallback) => {
      WebAssembly.instantiate(config.module, imports).then((result) => {
        successCallback(result);
      }).catch((reason) => {
        console.error(`instantiate failed + ${reason}`);
      });
      return {};
    };
    self.BASIS(config.module ? {
      instantiateWasm: instantiateWasmFunc
    } : null).then((instance) => {
      instance.initializeBasis();
      basis = instance;
      rgbPriority = config.rgbPriority;
      rgbaPriority = config.rgbaPriority;
      callback(null);
    });
  };
  const queue2 = [];
  self.onmessage = (message) => {
    const data2 = message.data;
    switch (data2.type) {
      case "init":
        workerInit(data2.config, () => {
          for (let i = 0; i < queue2.length; ++i) {
            workerTranscode(queue2[i].url, queue2[i].data, queue2[i].options);
          }
          queue2.length = 0;
        });
        break;
      case "transcode":
        if (basis) {
          workerTranscode(data2.url, data2.data, data2.options);
        } else {
          queue2.push(data2);
        }
        break;
    }
  };
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/basis.js
var getCompressionFormats = (device) => {
  return {
    astc: !!device.extCompressedTextureASTC,
    atc: !!device.extCompressedTextureATC,
    dxt: !!device.extCompressedTextureS3TC,
    etc1: !!device.extCompressedTextureETC1,
    etc2: !!device.extCompressedTextureETC,
    pvr: !!device.extCompressedTexturePVRTC
  };
};
var prepareWorkerModules = (config, callback) => {
  const getWorkerBlob = (basisCode) => {
    const code = ["/* basis */", basisCode, "", `(${BasisWorker.toString()})()

`].join("\n");
    return new Blob([code], {
      type: "application/javascript"
    });
  };
  const wasmSupported = () => {
    try {
      if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
        const module = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
        if (module instanceof WebAssembly.Module) {
          return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
        }
      }
    } catch (e) {
    }
    return false;
  };
  const sendResponse = (basisCode, module) => {
    callback(null, {
      workerUrl: URL.createObjectURL(getWorkerBlob(basisCode)),
      module,
      rgbPriority: config.rgbPriority,
      rgbaPriority: config.rgbaPriority
    });
  };
  const options2 = {
    cache: true,
    responseType: "text",
    retry: config.maxRetries > 0,
    maxRetries: config.maxRetries
  };
  if (config.glueUrl && config.wasmUrl && wasmSupported()) {
    let basisCode = null;
    let module = null;
    http.get(config.glueUrl, options2, (err3, response) => {
      if (err3) {
        callback(err3);
      } else {
        if (module) {
          sendResponse(response, module);
        } else {
          basisCode = response;
        }
      }
    });
    const fetchPromise = fetch(config.wasmUrl);
    const compileManual = () => {
      fetchPromise.then((result) => result.arrayBuffer()).then((buffer) => WebAssembly.compile(buffer)).then((module_) => {
        if (basisCode) {
          sendResponse(basisCode, module_);
        } else {
          module = module_;
        }
      }).catch((err3) => {
        callback(err3, null);
      });
    };
    if (WebAssembly.compileStreaming) {
      WebAssembly.compileStreaming(fetchPromise).then((module_) => {
        if (basisCode) {
          sendResponse(basisCode, module_);
        } else {
          module = module_;
        }
      }).catch((err3) => {
        compileManual();
      });
    } else {
      compileManual();
    }
  } else {
    http.get(config.fallbackUrl, options2, (err3, response) => {
      if (err3) {
        callback(err3, null);
      } else {
        sendResponse(response, null);
      }
    });
  }
};
var BasisQueue = class {
  constructor() {
    this.callbacks = {};
    this.queue = [];
    this.clients = [];
  }
  enqueueJob(url, data2, callback, options2) {
    if (this.callbacks.hasOwnProperty(url)) {
      this.callbacks[url].push(callback);
    } else {
      this.callbacks[url] = [callback];
      const job = {
        url,
        data: data2,
        options: options2
      };
      if (this.clients.length > 0) {
        this.clients.shift().run(job);
      } else {
        this.queue.push(job);
      }
    }
  }
  enqueueClient(client) {
    if (this.queue.length > 0) {
      client.run(this.queue.shift());
    } else {
      this.clients.push(client);
    }
  }
  handleResponse(url, err3, data2) {
    const callback = this.callbacks[url];
    if (err3) {
      for (let i = 0; i < callback.length; ++i) {
        callback[i](err3);
      }
    } else {
      if (data2.format === PIXELFORMAT_RGB565 || data2.format === PIXELFORMAT_RGBA4) {
        data2.levels = data2.levels.map((v) => {
          return new Uint16Array(v);
        });
      } else {
        data2.levels = data2.levels.map((v) => {
          return new Uint8Array(v);
        });
      }
      for (let i = 0; i < callback.length; ++i) {
        callback[i](null, data2);
      }
    }
    delete this.callbacks[url];
  }
};
var BasisClient = class {
  constructor(queue2, config, eager) {
    this.queue = queue2;
    this.worker = new Worker(config.workerUrl);
    this.worker.addEventListener("message", (message) => {
      const data2 = message.data;
      this.queue.handleResponse(data2.url, data2.err, data2.data);
      if (!this.eager) {
        this.queue.enqueueClient(this);
      }
    });
    this.worker.postMessage({
      type: "init",
      config
    });
    this.eager = eager;
  }
  run(job) {
    const transfer = [];
    if (job.data instanceof ArrayBuffer) {
      transfer.push(job.data);
    }
    this.worker.postMessage({
      type: "transcode",
      url: job.url,
      format: job.format,
      data: job.data,
      options: job.options
    }, transfer);
    if (this.eager) {
      this.queue.enqueueClient(this);
    }
  }
};
var defaultNumWorkers2 = 1;
var defaultRgbPriority = ["etc1", "etc2", "astc", "dxt", "pvr", "atc"];
var defaultRgbaPriority = ["astc", "dxt", "etc2", "pvr", "atc"];
var defaultMaxRetries = 5;
var queue = new BasisQueue();
var lazyConfig2 = null;
var initializing = false;
function basisInitialize(config) {
  if (initializing) {
    return;
  }
  if (!config) {
    config = lazyConfig2 || {};
  } else if (config.lazyInit) {
    lazyConfig2 = config;
    return;
  }
  if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {
    const moduleConfig = WasmModule.getConfig("BASIS");
    if (moduleConfig) {
      config = {
        glueUrl: moduleConfig.glueUrl,
        wasmUrl: moduleConfig.wasmUrl,
        fallbackUrl: moduleConfig.fallbackUrl,
        numWorkers: moduleConfig.numWorkers
      };
    }
  }
  if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
    initializing = true;
    const numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers2));
    const eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty("eagerWorkers") ? config.eagerWorkers : true);
    config.rgbPriority = config.rgbPriority || defaultRgbPriority;
    config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;
    config.maxRetries = config.hasOwnProperty("maxRetries") ? config.maxRetries : defaultMaxRetries;
    prepareWorkerModules(config, (err3, clientConfig) => {
      if (err3) {
        console.error(`failed to initialize basis worker: ${err3}`);
      } else {
        for (let i = 0; i < numWorkers; ++i) {
          queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));
        }
      }
    });
  }
}
var deviceDetails = null;
function basisTranscode(device, url, data2, callback, options2) {
  basisInitialize();
  if (!deviceDetails) {
    deviceDetails = {
      formats: getCompressionFormats(device)
    };
  }
  queue.enqueueJob(url, data2, callback, {
    deviceDetails,
    isGGGR: !!(options2 != null && options2.isGGGR),
    isKTX2: !!(options2 != null && options2.isKTX2)
  });
  return initializing;
}

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/texture.js
var TextureParser = class {
  load(url, callback, asset) {
    throw new Error("not implemented");
  }
  open(url, data2, device) {
    throw new Error("not implemented");
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/basis.js
var BasisParser = class extends TextureParser {
  constructor(registry, device) {
    super();
    this.device = device;
    this.maxRetries = 0;
  }
  load(url, callback, asset) {
    const device = this.device;
    const transcode = (data2) => {
      var _asset$file;
      const basisModuleFound = basisTranscode(device, url.load, data2, callback, {
        isGGGR: ((asset == null || (_asset$file = asset.file) == null || (_asset$file = _asset$file.variants) == null || (_asset$file = _asset$file.basis) == null ? void 0 : _asset$file.opt) & 8) !== 0
      });
      if (!basisModuleFound) {
        callback(`Basis module not found. Asset '${asset.name}' basis texture variant will not be loaded.`);
      }
    };
    Asset.fetchArrayBuffer(url.load, (err3, result) => {
      if (err3) {
        callback(err3);
      } else {
        transcode(result);
      }
    }, asset, this.maxRetries);
  }
  open(url, data2, device, textureOptions = {}) {
    const format = textureOptions.srgb ? pixelFormatLinearToGamma(data2.format) : data2.format;
    const texture = new Texture(device, _extends({
      name: url,
      addressU: data2.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
      addressV: data2.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
      width: data2.width,
      height: data2.height,
      format,
      cubemap: data2.cubemap,
      levels: data2.levels
    }, textureOptions));
    texture.upload();
    return texture;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/img.js
var ImgParser = class extends TextureParser {
  constructor(registry, device) {
    super();
    this.crossOrigin = registry.prefix ? "anonymous" : null;
    this.maxRetries = 0;
    this.device = device;
  }
  load(url, callback, asset) {
    var _asset$file;
    const hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);
    if (hasContents) {
      if (this.device.supportsImageBitmap) {
        this._loadImageBitmapFromBlob(new Blob([asset.file.contents]), callback);
        return;
      }
      url = {
        load: URL.createObjectURL(new Blob([asset.file.contents])),
        original: url.original
      };
    }
    const handler = (err3, result) => {
      if (hasContents) {
        URL.revokeObjectURL(url.load);
      }
      callback(err3, result);
    };
    let crossOrigin;
    if (asset && asset.options && asset.options.hasOwnProperty("crossOrigin")) {
      crossOrigin = asset.options.crossOrigin;
    } else if (ABSOLUTE_URL.test(url.load)) {
      crossOrigin = this.crossOrigin;
    }
    if (this.device.supportsImageBitmap) {
      this._loadImageBitmap(url.load, url.original, crossOrigin, handler);
    } else {
      this._loadImage(url.load, url.original, crossOrigin, handler);
    }
  }
  open(url, data2, device, textureOptions = {}) {
    const texture = new Texture(device, _extends({
      name: url,
      width: data2.width,
      height: data2.height,
      format: textureOptions.srgb ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8
    }, textureOptions));
    texture.setSource(data2);
    return texture;
  }
  _loadImage(url, originalUrl, crossOrigin, callback) {
    const image = new Image();
    if (crossOrigin) {
      image.crossOrigin = crossOrigin;
    }
    let retries = 0;
    const maxRetries = this.maxRetries;
    let retryTimeout;
    image.onload = function() {
      callback(null, image);
    };
    image.onerror = function() {
      if (retryTimeout) return;
      if (maxRetries > 0 && ++retries <= maxRetries) {
        const retryDelay = Math.pow(2, retries) * 100;
        console.log(`Error loading Texture from: '${originalUrl}' - Retrying in ${retryDelay}ms...`);
        const idx = url.indexOf("?");
        const separator = idx >= 0 ? "&" : "?";
        retryTimeout = setTimeout(() => {
          image.src = `${url + separator}retry=${Date.now()}`;
          retryTimeout = null;
        }, retryDelay);
      } else {
        callback(`Error loading Texture from: '${originalUrl}'`);
      }
    };
    image.src = url;
  }
  _loadImageBitmap(url, originalUrl, crossOrigin, callback) {
    const options2 = {
      cache: true,
      responseType: "blob",
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    http.get(url, options2, (err3, blob) => {
      if (err3) {
        callback(err3);
      } else {
        this._loadImageBitmapFromBlob(blob, callback);
      }
    });
  }
  _loadImageBitmapFromBlob(blob, callback) {
    createImageBitmap(blob, {
      premultiplyAlpha: "none",
      colorSpaceConversion: "none"
    }).then((imageBitmap) => callback(null, imageBitmap)).catch((e) => callback(e));
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/ktx.js
var IDENTIFIER2 = [1481919403, 3140563232, 169478669];
var KNOWN_FORMATS = {
  33776: PIXELFORMAT_DXT1,
  33778: PIXELFORMAT_DXT3,
  33779: PIXELFORMAT_DXT5,
  36196: PIXELFORMAT_ETC1,
  37492: PIXELFORMAT_ETC2_RGB,
  37496: PIXELFORMAT_ETC2_RGBA,
  35840: PIXELFORMAT_PVRTC_4BPP_RGB_1,
  35841: PIXELFORMAT_PVRTC_2BPP_RGB_1,
  35842: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
  35843: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
  32849: PIXELFORMAT_RGB8,
  32856: PIXELFORMAT_RGBA8,
  35905: PIXELFORMAT_SRGB8,
  35907: PIXELFORMAT_SRGBA8,
  35898: PIXELFORMAT_111110F,
  34843: PIXELFORMAT_RGB16F,
  34842: PIXELFORMAT_RGBA16F
};
function createContainer(pixelFormat, buffer, byteOffset, byteSize) {
  return pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);
}
var KtxParser = class extends TextureParser {
  constructor(registry) {
    super();
    this.maxRetries = 0;
  }
  load(url, callback, asset) {
    Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
  }
  open(url, data2, device, textureOptions = {}) {
    const textureData = this.parse(data2);
    if (!textureData) {
      return null;
    }
    const format = textureOptions.srgb ? pixelFormatLinearToGamma(textureData.format) : textureData.format;
    const texture = new Texture(device, _extends({
      name: url,
      addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
      addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
      width: textureData.width,
      height: textureData.height,
      format,
      cubemap: textureData.cubemap,
      levels: textureData.levels
    }, textureOptions));
    texture.upload();
    return texture;
  }
  parse(data2) {
    const dataU32 = new Uint32Array(data2);
    if (IDENTIFIER2[0] !== dataU32[0] || IDENTIFIER2[1] !== dataU32[1] || IDENTIFIER2[2] !== dataU32[2]) {
      return null;
    }
    const header2 = {
      endianness: dataU32[3],
      glType: dataU32[4],
      glTypeSize: dataU32[5],
      glFormat: dataU32[6],
      glInternalFormat: dataU32[7],
      glBaseInternalFormat: dataU32[8],
      pixelWidth: dataU32[9],
      pixelHeight: dataU32[10],
      pixelDepth: dataU32[11],
      numberOfArrayElements: dataU32[12],
      numberOfFaces: dataU32[13],
      numberOfMipmapLevels: dataU32[14],
      bytesOfKeyValueData: dataU32[15]
    };
    if (header2.pixelDepth > 1) {
      return null;
    }
    if (header2.numberOfArrayElements !== 0) {
      return null;
    }
    const format = KNOWN_FORMATS[header2.glInternalFormat];
    if (format === void 0) {
      return null;
    }
    let offset = 16 + header2.bytesOfKeyValueData / 4;
    const isCubemap = header2.numberOfFaces > 1;
    const levels = [];
    for (let mipmapLevel = 0; mipmapLevel < (header2.numberOfMipmapLevels || 1); mipmapLevel++) {
      const imageSizeInBytes = dataU32[offset++];
      if (isCubemap) {
        levels.push([]);
      }
      const target2 = isCubemap ? levels[mipmapLevel] : levels;
      for (let face = 0; face < (isCubemap ? 6 : 1); ++face) {
        target2.push(createContainer(format, data2, offset * 4, imageSizeInBytes));
        offset += imageSizeInBytes + 3 >> 2;
      }
    }
    return {
      format,
      width: header2.pixelWidth,
      height: header2.pixelHeight,
      levels,
      cubemap: isCubemap
    };
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/ktx2.js
var KHRConstants = {
  KHR_DF_MODEL_ETC1S: 163,
  KHR_DF_MODEL_UASTC: 166
};
var Ktx2Parser = class extends TextureParser {
  constructor(registry, device) {
    super();
    this.maxRetries = 0;
    this.device = device;
  }
  load(url, callback, asset) {
    Asset.fetchArrayBuffer(url.load, (err3, result) => {
      if (err3) {
        callback(err3, result);
      } else {
        this.parse(result, url, callback, asset);
      }
    }, asset, this.maxRetries);
  }
  open(url, data2, device, textureOptions = {}) {
    const format = textureOptions.srgb ? pixelFormatLinearToGamma(data2.format) : data2.format;
    const texture = new Texture(device, _extends({
      name: url,
      addressU: data2.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
      addressV: data2.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
      width: data2.width,
      height: data2.height,
      format,
      cubemap: data2.cubemap,
      levels: data2.levels
    }, textureOptions));
    texture.upload();
    return texture;
  }
  parse(arraybuffer, url, callback, asset) {
    const rs = new ReadStream(arraybuffer);
    const magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];
    if (magic[0] !== 2873840728 || magic[1] !== 540160187 || magic[2] !== 218765834) {
      return null;
    }
    const header2 = {
      vkFormat: rs.readU32(),
      typeSize: rs.readU32(),
      pixelWidth: rs.readU32(),
      pixelHeight: rs.readU32(),
      pixelDepth: rs.readU32(),
      layerCount: rs.readU32(),
      faceCount: rs.readU32(),
      levelCount: rs.readU32(),
      supercompressionScheme: rs.readU32()
    };
    const index = {
      dfdByteOffset: rs.readU32(),
      dfdByteLength: rs.readU32(),
      kvdByteOffset: rs.readU32(),
      kvdByteLength: rs.readU32(),
      sgdByteOffset: rs.readU64(),
      sgdByteLength: rs.readU64()
    };
    const levels = [];
    for (let i = 0; i < Math.max(1, header2.levelCount); ++i) {
      levels.push({
        byteOffset: rs.readU64(),
        byteLength: rs.readU64(),
        uncompressedByteLength: rs.readU64()
      });
    }
    const dfdTotalSize = rs.readU32();
    if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {
      return null;
    }
    rs.skip(8);
    const colorModel = rs.readU8();
    rs.skip(index.dfdByteLength - 9);
    rs.skip(index.kvdByteLength);
    if (header2.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {
      var _asset$file;
      const basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {
        isGGGR: ((asset == null || (_asset$file = asset.file) == null || (_asset$file = _asset$file.variants) == null || (_asset$file = _asset$file.basis) == null ? void 0 : _asset$file.opt) & 8) !== 0,
        isKTX2: true
      });
      if (!basisModuleFound) {
        callback(`Basis module not found. Asset "${asset.name}" basis texture variant will not be loaded.`);
      }
    } else {
      callback("unsupported KTX2 pixel format");
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/dds.js
var DdsParser = class extends TextureParser {
  constructor(registry) {
    super();
    this.maxRetries = 0;
  }
  load(url, callback, asset) {
    Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
  }
  open(url, data2, device, textureOptions = {}) {
    const header2 = new Uint32Array(data2, 0, 128 / 4);
    const width = header2[4];
    const height = header2[3];
    const mips = Math.max(header2[7], 1);
    const isFourCc = header2[20] === 4;
    const fcc = header2[21];
    const bpp = header2[22];
    const isCubemap = header2[28] === 65024;
    const FCC_DXT1 = 827611204;
    const FCC_DXT5 = 894720068;
    const FCC_FP16 = 113;
    const FCC_FP32 = 116;
    const FCC_ETC1 = 826496069;
    const FCC_PVRTC_2BPP_RGB_1 = 825438800;
    const FCC_PVRTC_2BPP_RGBA_1 = 825504336;
    const FCC_PVRTC_4BPP_RGB_1 = 825439312;
    const FCC_PVRTC_4BPP_RGBA_1 = 825504848;
    let compressed = false;
    let etc1 = false;
    let pvrtc2 = false;
    let pvrtc4 = false;
    let format = null;
    let componentSize = 1;
    let texture;
    if (isFourCc) {
      if (fcc === FCC_DXT1) {
        format = PIXELFORMAT_DXT1;
        compressed = true;
      } else if (fcc === FCC_DXT5) {
        format = PIXELFORMAT_DXT5;
        compressed = true;
      } else if (fcc === FCC_FP16) {
        format = PIXELFORMAT_RGBA16F;
        componentSize = 2;
      } else if (fcc === FCC_FP32) {
        format = PIXELFORMAT_RGBA32F;
        componentSize = 4;
      } else if (fcc === FCC_ETC1) {
        format = PIXELFORMAT_ETC1;
        compressed = true;
        etc1 = true;
      } else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
        format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
        compressed = true;
        pvrtc2 = true;
      } else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
        format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
        compressed = true;
        pvrtc4 = true;
      }
    } else {
      if (bpp === 32) {
        format = PIXELFORMAT_RGBA8;
      }
    }
    if (!format) {
      texture = new Texture(device, {
        width: 4,
        height: 4,
        format: PIXELFORMAT_RGB8,
        name: "dds-legacy-empty"
      });
      return texture;
    }
    texture = new Texture(device, _extends({
      name: url,
      addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
      addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
      width,
      height,
      format,
      cubemap: isCubemap,
      mipmaps: mips > 1
    }, textureOptions));
    let offset = 128;
    const faces = isCubemap ? 6 : 1;
    let mipSize;
    const DXT_BLOCK_WIDTH = 4;
    const DXT_BLOCK_HEIGHT = 4;
    const blockSize = fcc === FCC_DXT1 ? 8 : 16;
    let numBlocksAcross, numBlocksDown, numBlocks;
    for (let face = 0; face < faces; face++) {
      let mipWidth = width;
      let mipHeight = height;
      for (let i = 0; i < mips; i++) {
        if (compressed) {
          if (etc1) {
            mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
          } else if (pvrtc2) {
            mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
          } else if (pvrtc4) {
            mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
          } else {
            numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
            numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
            numBlocks = numBlocksAcross * numBlocksDown;
            mipSize = numBlocks * blockSize;
          }
        } else {
          mipSize = mipWidth * mipHeight * 4;
        }
        const mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data2, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data2, offset, mipSize) : new Uint8Array(data2, offset, mipSize);
        if (!isCubemap) {
          texture._levels[i] = mipBuff;
        } else {
          if (!texture._levels[i]) texture._levels[i] = [];
          texture._levels[i][face] = mipBuff;
        }
        offset += mipSize * componentSize;
        mipWidth = Math.max(mipWidth * 0.5, 1);
        mipHeight = Math.max(mipHeight * 0.5, 1);
      }
    }
    texture.upload();
    return texture;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/hdr.js
var HdrParser = class extends TextureParser {
  constructor(registry) {
    super();
    this.maxRetries = 0;
  }
  load(url, callback, asset) {
    Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
  }
  open(url, data2, device, textureOptions = {}) {
    const textureData = this.parse(data2);
    if (!textureData) {
      return null;
    }
    const texture = new Texture(device, _extends({
      name: url,
      addressU: ADDRESS_REPEAT,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      width: textureData.width,
      height: textureData.height,
      levels: textureData.levels,
      format: PIXELFORMAT_RGBA8,
      type: TEXTURETYPE_RGBE,
      mipmaps: false
    }, textureOptions));
    texture.upload();
    return texture;
  }
  parse(data2) {
    const readStream = new ReadStream(data2);
    const magic = readStream.readLine();
    if (!magic.startsWith("#?RADIANCE")) {
      return null;
    }
    const variables = {};
    while (true) {
      const line = readStream.readLine();
      if (line.length === 0) {
        break;
      } else {
        const parts = line.split("=");
        if (parts.length === 2) {
          variables[parts[0]] = parts[1];
        }
      }
    }
    if (!variables.hasOwnProperty("FORMAT")) {
      return null;
    }
    const resolution = readStream.readLine().split(" ");
    if (resolution.length !== 4) {
      return null;
    }
    const height = parseInt(resolution[1], 10);
    const width = parseInt(resolution[3], 10);
    const pixels = this._readPixels(readStream, width, height, resolution[0] === "-Y");
    if (!pixels) {
      return null;
    }
    return {
      width,
      height,
      levels: [pixels]
    };
  }
  _readPixels(readStream, width, height, flipY) {
    if (width < 8 || width > 32767) {
      return this._readPixelsFlat(readStream, width, height);
    }
    const rgbe = [0, 0, 0, 0];
    readStream.readArray(rgbe);
    if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 128) !== 0) {
      readStream.skip(-4);
      return this._readPixelsFlat(readStream, width, height);
    }
    const buffer = new ArrayBuffer(width * height * 4);
    const view = new Uint8Array(buffer);
    let scanstart = flipY ? 0 : width * 4 * (height - 1);
    let x2, y2, i, channel, count, value;
    for (y2 = 0; y2 < height; ++y2) {
      if (y2) {
        readStream.readArray(rgbe);
      }
      if ((rgbe[2] << 8) + rgbe[3] !== width) {
        return null;
      }
      for (channel = 0; channel < 4; ++channel) {
        x2 = 0;
        while (x2 < width) {
          count = readStream.readU8();
          if (count > 128) {
            count -= 128;
            if (x2 + count > width) {
              return null;
            }
            value = readStream.readU8();
            for (i = 0; i < count; ++i) {
              view[scanstart + channel + 4 * x2++] = value;
            }
          } else {
            if (count === 0 || x2 + count > width) {
              return null;
            }
            for (i = 0; i < count; ++i) {
              view[scanstart + channel + 4 * x2++] = readStream.readU8();
            }
          }
        }
      }
      scanstart += width * 4 * (flipY ? 1 : -1);
    }
    return view;
  }
  _readPixelsFlat(readStream, width, height) {
    return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/texture.js
var JSON_ADDRESS_MODE2 = {
  "repeat": ADDRESS_REPEAT,
  "clamp": ADDRESS_CLAMP_TO_EDGE,
  "mirror": ADDRESS_MIRRORED_REPEAT
};
var JSON_FILTER_MODE2 = {
  "nearest": FILTER_NEAREST,
  "linear": FILTER_LINEAR,
  "nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
  "linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
  "nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
  "linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
};
var JSON_TEXTURE_TYPE = {
  "default": TEXTURETYPE_DEFAULT,
  "rgbm": TEXTURETYPE_RGBM,
  "rgbe": TEXTURETYPE_RGBE,
  "rgbp": TEXTURETYPE_RGBP,
  "swizzleGGGR": TEXTURETYPE_SWIZZLEGGGR
};
var _completePartialMipmapChain = function _completePartialMipmapChain2(texture) {
  const requiredMipLevels = TextureUtils.calcMipLevelsCount(texture._width, texture._height);
  const isHtmlElement = function isHtmlElement2(object) {
    return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;
  };
  if (!(texture._format === PIXELFORMAT_RGBA8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
    return;
  }
  const downsample = function downsample2(width, height, data2) {
    const sampledWidth = Math.max(1, width >> 1);
    const sampledHeight = Math.max(1, height >> 1);
    const sampledData = new data2.constructor(sampledWidth * sampledHeight * 4);
    const xs = Math.floor(width / sampledWidth);
    const ys = Math.floor(height / sampledHeight);
    const xsys = xs * ys;
    for (let y2 = 0; y2 < sampledHeight; ++y2) {
      for (let x2 = 0; x2 < sampledWidth; ++x2) {
        for (let e = 0; e < 4; ++e) {
          let sum = 0;
          for (let sy = 0; sy < ys; ++sy) {
            for (let sx = 0; sx < xs; ++sx) {
              sum += data2[(x2 * xs + sx + (y2 * ys + sy) * width) * 4 + e];
            }
          }
          sampledData[(x2 + y2 * sampledWidth) * 4 + e] = sum / xsys;
        }
      }
    }
    return sampledData;
  };
  for (let level = texture._levels.length; level < requiredMipLevels; ++level) {
    const width = Math.max(1, texture._width >> level - 1);
    const height = Math.max(1, texture._height >> level - 1);
    if (texture._cubemap) {
      const mips = [];
      for (let face = 0; face < 6; ++face) {
        mips.push(downsample(width, height, texture._levels[level - 1][face]));
      }
      texture._levels.push(mips);
    } else {
      texture._levels.push(downsample(width, height, texture._levels[level - 1]));
    }
  }
  texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];
};
var TextureHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "texture");
    const assets = app2.assets;
    const device = app2.graphicsDevice;
    this._device = device;
    this._assets = assets;
    this.imgParser = new ImgParser(assets, device);
    this.parsers = {
      dds: new DdsParser(assets),
      ktx: new KtxParser(assets),
      ktx2: new Ktx2Parser(assets, device),
      basis: new BasisParser(assets, device),
      hdr: new HdrParser(assets)
    };
  }
  set crossOrigin(value) {
    this.imgParser.crossOrigin = value;
  }
  get crossOrigin() {
    return this.imgParser.crossOrigin;
  }
  set maxRetries(value) {
    this.imgParser.maxRetries = value;
    for (const parser in this.parsers) {
      if (this.parsers.hasOwnProperty(parser)) {
        this.parsers[parser].maxRetries = value;
      }
    }
  }
  get maxRetries() {
    return this.imgParser.maxRetries;
  }
  _getUrlWithoutParams(url) {
    return url.indexOf("?") >= 0 ? url.split("?")[0] : url;
  }
  _getParser(url) {
    const ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace(".", "");
    return this.parsers[ext] || this.imgParser;
  }
  _getTextureOptions(asset) {
    const options2 = {};
    if (asset) {
      var _asset$name;
      if (((_asset$name = asset.name) == null ? void 0 : _asset$name.length) > 0) {
        options2.name = asset.name;
      }
      const assetData = asset.data;
      if (assetData.hasOwnProperty("minfilter")) {
        options2.minFilter = JSON_FILTER_MODE2[assetData.minfilter];
      }
      if (assetData.hasOwnProperty("magfilter")) {
        options2.magFilter = JSON_FILTER_MODE2[assetData.magfilter];
      }
      if (assetData.hasOwnProperty("addressu")) {
        options2.addressU = JSON_ADDRESS_MODE2[assetData.addressu];
      }
      if (assetData.hasOwnProperty("addressv")) {
        options2.addressV = JSON_ADDRESS_MODE2[assetData.addressv];
      }
      if (assetData.hasOwnProperty("mipmaps")) {
        options2.mipmaps = assetData.mipmaps;
      }
      if (assetData.hasOwnProperty("anisotropy")) {
        options2.anisotropy = assetData.anisotropy;
      }
      if (assetData.hasOwnProperty("flipY")) {
        options2.flipY = !!assetData.flipY;
      }
      if (assetData.hasOwnProperty("srgb")) {
        options2.srgb = !!assetData.srgb;
      }
      if (assetData.hasOwnProperty("type")) {
        options2.type = JSON_TEXTURE_TYPE[assetData.type];
      } else if (assetData.hasOwnProperty("rgbm") && assetData.rgbm) {
        options2.type = TEXTURETYPE_RGBM;
      } else if (asset.file && (asset.file.opt & 8) !== 0) {
        options2.type = TEXTURETYPE_SWIZZLEGGGR;
      }
    }
    return options2;
  }
  load(url, callback, asset) {
    if (typeof url === "string") {
      url = {
        load: url,
        original: url
      };
    }
    this._getParser(url.original).load(url, callback, asset);
  }
  open(url, data2, asset) {
    if (!url) {
      return void 0;
    }
    const textureOptions = this._getTextureOptions(asset);
    let texture = this._getParser(url).open(url, data2, this._device, textureOptions);
    if (texture === null) {
      texture = new Texture(this._device, {
        width: 4,
        height: 4,
        format: PIXELFORMAT_RGB8
      });
    } else {
      _completePartialMipmapChain(texture);
      if (data2.unswizzledGGGR) {
        asset.file.variants.basis.opt &= ~8;
      }
    }
    return texture;
  }
  patch(asset, assets) {
    const texture = asset.resource;
    if (!texture) {
      return;
    }
    const options2 = this._getTextureOptions(asset);
    for (const key of Object.keys(options2)) {
      texture[key] = options2[key];
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/constants.js
var XRTYPE_INLINE = "inline";
var XRTYPE_VR = "immersive-vr";
var XRTYPE_AR = "immersive-ar";
var XRSPACE_VIEWER = "viewer";
var XRSPACE_LOCAL = "local";
var XRSPACE_LOCALFLOOR = "local-floor";
var XRSPACE_BOUNDEDFLOOR = "bounded-floor";
var XRSPACE_UNBOUNDED = "unbounded";
var XRTARGETRAY_GAZE = "gaze";
var XRTARGETRAY_SCREEN = "screen";
var XRTARGETRAY_POINTER = "tracked-pointer";
var XREYE_NONE = "none";
var XREYE_LEFT = "left";
var XREYE_RIGHT = "right";
var XRHAND_NONE = "none";
var XRHAND_LEFT = "left";
var XRHAND_RIGHT = "right";
var XRTRACKABLE_POINT = "point";
var XRTRACKABLE_PLANE = "plane";
var XRTRACKABLE_MESH = "mesh";
var XRDEPTHSENSINGUSAGE_CPU = "cpu-optimized";
var XRDEPTHSENSINGUSAGE_GPU = "gpu-optimized";
var XRDEPTHSENSINGFORMAT_L8A8 = "luminance-alpha";
var XRDEPTHSENSINGFORMAT_F32 = "float32";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-dom-overlay.js
var XrDomOverlay = class {
  constructor(manager) {
    this._manager = void 0;
    this._supported = platform.browser && !!window.XRDOMOverlayState;
    this._root = null;
    this._manager = manager;
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
  }
  get state() {
    if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) {
      return null;
    }
    return this._manager._session.domOverlayState.type;
  }
  set root(value) {
    if (!this._supported || this._manager.active) {
      return;
    }
    this._root = value;
  }
  get root() {
    return this._root;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-hit-test-source.js
var poolVec3 = [];
var poolQuat = [];
var XrHitTestSource = class extends EventHandler {
  constructor(manager, xrHitTestSource, transient, inputSource = null) {
    super();
    this.manager = void 0;
    this._xrHitTestSource = void 0;
    this._transient = void 0;
    this._inputSource = void 0;
    this.manager = manager;
    this._xrHitTestSource = xrHitTestSource;
    this._transient = transient;
    this._inputSource = inputSource;
  }
  remove() {
    if (!this._xrHitTestSource) {
      return;
    }
    const sources = this.manager.hitTest.sources;
    const ind = sources.indexOf(this);
    if (ind !== -1) sources.splice(ind, 1);
    this.onStop();
  }
  onStop() {
    this._xrHitTestSource.cancel();
    this._xrHitTestSource = null;
    this.fire("remove");
    this.manager.hitTest.fire("remove", this);
  }
  update(frame) {
    if (this._transient) {
      const transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);
      for (let i = 0; i < transientResults.length; i++) {
        const transientResult = transientResults[i];
        if (!transientResult.results.length) {
          continue;
        }
        let inputSource;
        if (transientResult.inputSource) {
          inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
        }
        this.updateHitResults(transientResult.results, inputSource);
      }
    } else {
      const results = frame.getHitTestResults(this._xrHitTestSource);
      if (!results.length) {
        return;
      }
      this.updateHitResults(results);
    }
  }
  updateHitResults(results, inputSource) {
    var _poolVec3$pop, _poolVec3$pop2, _poolQuat$pop;
    if (this._inputSource && this._inputSource !== inputSource) {
      return;
    }
    const origin = (_poolVec3$pop = poolVec3.pop()) != null ? _poolVec3$pop : new Vec3();
    if (inputSource) {
      origin.copy(inputSource.getOrigin());
    } else {
      origin.copy(this.manager.camera.getPosition());
    }
    let candidateDistance = Infinity;
    let candidateHitTestResult = null;
    const position3 = (_poolVec3$pop2 = poolVec3.pop()) != null ? _poolVec3$pop2 : new Vec3();
    const rotation2 = (_poolQuat$pop = poolQuat.pop()) != null ? _poolQuat$pop : new Quat();
    for (let i = 0; i < results.length; i++) {
      const pose = results[i].getPose(this.manager._referenceSpace);
      const distance = origin.distance(pose.transform.position);
      if (distance >= candidateDistance) {
        continue;
      }
      candidateDistance = distance;
      candidateHitTestResult = results[i];
      position3.copy(pose.transform.position);
      rotation2.copy(pose.transform.orientation);
    }
    this.fire("result", position3, rotation2, inputSource || this._inputSource, candidateHitTestResult);
    this.manager.hitTest.fire("result", this, position3, rotation2, inputSource || this._inputSource, candidateHitTestResult);
    poolVec3.push(origin);
    poolVec3.push(position3);
    poolQuat.push(rotation2);
  }
};
XrHitTestSource.EVENT_REMOVE = "remove";
XrHitTestSource.EVENT_RESULT = "result";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-hit-test.js
var XrHitTest = class extends EventHandler {
  constructor(manager) {
    super();
    this.manager = void 0;
    this._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);
    this._available = false;
    this._checkingAvailability = false;
    this.sources = [];
    this.manager = manager;
    if (this._supported) {
      this.manager.on("start", this._onSessionStart, this);
      this.manager.on("end", this._onSessionEnd, this);
    }
  }
  _onSessionStart() {
    if (this.manager.session.enabledFeatures) {
      const available = this.manager.session.enabledFeatures.indexOf("hit-test") !== -1;
      if (!available) return;
      this._available = available;
      this.fire("available");
    } else if (!this._checkingAvailability) {
      this._checkingAvailability = true;
      this.manager.session.requestReferenceSpace(XRSPACE_VIEWER).then((referenceSpace) => {
        this.manager.session.requestHitTestSource({
          space: referenceSpace
        }).then((hitTestSource) => {
          hitTestSource.cancel();
          if (this.manager.active) {
            this._available = true;
            this.fire("available");
          }
        }).catch(() => {
        });
      }).catch(() => {
      });
    }
  }
  _onSessionEnd() {
    if (!this._available) return;
    this._available = false;
    for (let i = 0; i < this.sources.length; i++) {
      this.sources[i].onStop();
    }
    this.sources = [];
    this.fire("unavailable");
  }
  start(options2 = {}) {
    if (!this._supported) {
      options2.callback == null || options2.callback(new Error("XR HitTest is not supported"), null);
      return;
    }
    if (!this._available) {
      options2.callback == null || options2.callback(new Error("XR HitTest is not available"), null);
      return;
    }
    if (!options2.profile && !options2.spaceType) {
      options2.spaceType = XRSPACE_VIEWER;
    }
    let xrRay;
    const offsetRay = options2.offsetRay;
    if (offsetRay) {
      const origin = new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z, 1);
      const direction = new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z, 0);
      xrRay = new XRRay(origin, direction);
    }
    const callback = options2.callback;
    if (options2.spaceType) {
      this.manager.session.requestReferenceSpace(options2.spaceType).then((referenceSpace) => {
        if (!this.manager.session) {
          const err3 = new Error("XR Session is not started (2)");
          if (callback) callback(err3);
          this.fire("error", err3);
          return;
        }
        this.manager.session.requestHitTestSource({
          space: referenceSpace,
          entityTypes: options2.entityTypes || void 0,
          offsetRay: xrRay
        }).then((xrHitTestSource) => {
          this._onHitTestSource(xrHitTestSource, false, options2.inputSource, callback);
        }).catch((ex) => {
          if (callback) callback(ex);
          this.fire("error", ex);
        });
      }).catch((ex) => {
        if (callback) callback(ex);
        this.fire("error", ex);
      });
    } else {
      this.manager.session.requestHitTestSourceForTransientInput({
        profile: options2.profile,
        entityTypes: options2.entityTypes || void 0,
        offsetRay: xrRay
      }).then((xrHitTestSource) => {
        this._onHitTestSource(xrHitTestSource, true, options2.inputSource, callback);
      }).catch((ex) => {
        if (callback) callback(ex);
        this.fire("error", ex);
      });
    }
  }
  _onHitTestSource(xrHitTestSource, transient, inputSource, callback) {
    if (!this.manager.session) {
      xrHitTestSource.cancel();
      const err3 = new Error("XR Session is not started (3)");
      if (callback) callback(err3);
      this.fire("error", err3);
      return;
    }
    const hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient, inputSource != null ? inputSource : null);
    this.sources.push(hitTestSource);
    if (callback) callback(null, hitTestSource);
    this.fire("add", hitTestSource);
  }
  update(frame) {
    if (!this._available) {
      return;
    }
    for (let i = 0; i < this.sources.length; i++) {
      this.sources[i].update(frame);
    }
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._available;
  }
};
XrHitTest.EVENT_AVAILABLE = "available";
XrHitTest.EVENT_UNAVAILABLE = "unavailable";
XrHitTest.EVENT_ADD = "add";
XrHitTest.EVENT_REMOVE = "remove";
XrHitTest.EVENT_RESULT = "result";
XrHitTest.EVENT_ERROR = "error";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-tracked-image.js
var XrTrackedImage = class extends EventHandler {
  constructor(image, width) {
    super();
    this._image = void 0;
    this._width = void 0;
    this._bitmap = null;
    this._measuredWidth = 0;
    this._trackable = false;
    this._tracking = false;
    this._emulated = false;
    this._pose = null;
    this._position = new Vec3();
    this._rotation = new Quat();
    this._image = image;
    this._width = width;
  }
  get image() {
    return this._image;
  }
  set width(value) {
    this._width = value;
  }
  get width() {
    return this._width;
  }
  get trackable() {
    return this._trackable;
  }
  get tracking() {
    return this._tracking;
  }
  get emulated() {
    return this._emulated;
  }
  prepare() {
    if (this._bitmap) {
      return {
        image: this._bitmap,
        widthInMeters: this._width
      };
    }
    return createImageBitmap(this._image).then((bitmap) => {
      this._bitmap = bitmap;
      return {
        image: this._bitmap,
        widthInMeters: this._width
      };
    });
  }
  destroy() {
    this._image = null;
    this._pose = null;
    if (this._bitmap) {
      this._bitmap.close();
      this._bitmap = null;
    }
  }
  getPosition() {
    if (this._pose) this._position.copy(this._pose.transform.position);
    return this._position;
  }
  getRotation() {
    if (this._pose) this._rotation.copy(this._pose.transform.orientation);
    return this._rotation;
  }
};
XrTrackedImage.EVENT_TRACKED = "tracked";
XrTrackedImage.EVENT_UNTRACKED = "untracked";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-image-tracking.js
var XrImageTracking = class extends EventHandler {
  constructor(manager) {
    super();
    this._manager = void 0;
    this._supported = platform.browser && !!window.XRImageTrackingResult;
    this._available = false;
    this._images = [];
    this._manager = manager;
    if (this._supported) {
      this._manager.on("start", this._onSessionStart, this);
      this._manager.on("end", this._onSessionEnd, this);
    }
  }
  add(image, width) {
    if (!this._supported || this._manager.active) return null;
    const trackedImage = new XrTrackedImage(image, width);
    this._images.push(trackedImage);
    return trackedImage;
  }
  remove(trackedImage) {
    if (this._manager.active) return;
    const ind = this._images.indexOf(trackedImage);
    if (ind !== -1) {
      trackedImage.destroy();
      this._images.splice(ind, 1);
    }
  }
  _onSessionStart() {
    this._manager.session.getTrackedImageScores().then((images) => {
      this._available = true;
      for (let i = 0; i < images.length; i++) {
        this._images[i]._trackable = images[i] === "trackable";
      }
    }).catch((err3) => {
      this._available = false;
      this.fire("error", err3);
    });
  }
  _onSessionEnd() {
    this._available = false;
    for (let i = 0; i < this._images.length; i++) {
      const image = this._images[i];
      image._pose = null;
      image._measuredWidth = 0;
      if (image._tracking) {
        image._tracking = false;
        image.fire("untracked");
      }
    }
  }
  prepareImages(callback) {
    if (this._images.length) {
      Promise.all(this._images.map((trackedImage) => {
        return trackedImage.prepare();
      })).then((bitmaps) => {
        callback(null, bitmaps);
      }).catch((err3) => {
        callback(err3, null);
      });
    } else {
      callback(null, null);
    }
  }
  update(frame) {
    if (!this._available) return;
    const results = frame.getImageTrackingResults();
    const index = {};
    for (let i = 0; i < results.length; i++) {
      index[results[i].index] = results[i];
      const trackedImage = this._images[results[i].index];
      trackedImage._emulated = results[i].trackingState === "emulated";
      trackedImage._measuredWidth = results[i].measuredWidthInMeters;
      trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);
    }
    for (let i = 0; i < this._images.length; i++) {
      if (this._images[i]._tracking && !index[i]) {
        this._images[i]._tracking = false;
        this._images[i].fire("untracked");
      } else if (!this._images[i]._tracking && index[i]) {
        this._images[i]._tracking = true;
        this._images[i].fire("tracked");
      }
    }
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._available;
  }
  get images() {
    return this._images;
  }
};
XrImageTracking.EVENT_ERROR = "error";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-finger.js
var XrFinger = class {
  constructor(index, hand) {
    this._index = void 0;
    this._hand = void 0;
    this._joints = [];
    this._tip = null;
    this._index = index;
    this._hand = hand;
    this._hand._fingers.push(this);
  }
  get index() {
    return this._index;
  }
  get hand() {
    return this._hand;
  }
  get joints() {
    return this._joints;
  }
  get tip() {
    return this._tip;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-joint.js
var tipJointIds = platform.browser && window.XRHand ? ["thumb-tip", "index-finger-tip", "middle-finger-tip", "ring-finger-tip", "pinky-finger-tip"] : [];
var tipJointIdsIndex = {};
for (let i = 0; i < tipJointIds.length; i++) {
  tipJointIdsIndex[tipJointIds[i]] = true;
}
var XrJoint = class {
  constructor(index, id13, hand, finger = null) {
    this._index = void 0;
    this._id = void 0;
    this._hand = void 0;
    this._finger = void 0;
    this._wrist = void 0;
    this._tip = void 0;
    this._radius = null;
    this._localTransform = new Mat4();
    this._worldTransform = new Mat4();
    this._localPosition = new Vec3();
    this._localRotation = new Quat();
    this._position = new Vec3();
    this._rotation = new Quat();
    this._dirtyLocal = true;
    this._index = index;
    this._id = id13;
    this._hand = hand;
    this._finger = finger;
    this._wrist = id13 === "wrist";
    this._tip = this._finger && !!tipJointIdsIndex[id13];
  }
  update(pose) {
    this._dirtyLocal = true;
    this._radius = pose.radius;
    this._localPosition.copy(pose.transform.position);
    this._localRotation.copy(pose.transform.orientation);
  }
  _updateTransforms() {
    if (this._dirtyLocal) {
      this._dirtyLocal = false;
      this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
    }
    const manager = this._hand._manager;
    const parent = manager.camera.parent;
    if (parent) {
      this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
    } else {
      this._worldTransform.copy(this._localTransform);
    }
  }
  getPosition() {
    this._updateTransforms();
    this._worldTransform.getTranslation(this._position);
    return this._position;
  }
  getRotation() {
    this._updateTransforms();
    this._rotation.setFromMat4(this._worldTransform);
    return this._rotation;
  }
  get index() {
    return this._index;
  }
  get hand() {
    return this._hand;
  }
  get finger() {
    return this._finger;
  }
  get wrist() {
    return this._wrist;
  }
  get tip() {
    return this._tip;
  }
  get radius() {
    return this._radius || 5e-3;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-hand.js
var fingerJointIds = [];
var vecA2 = new Vec3();
var vecB2 = new Vec3();
var vecC = new Vec3();
if (platform.browser && window.XRHand) {
  fingerJointIds = [["thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip"], ["index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip"], ["middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip"], ["ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip"], ["pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"]];
}
var XrHand = class extends EventHandler {
  constructor(inputSource) {
    super();
    this._manager = void 0;
    this._inputSource = void 0;
    this._tracking = false;
    this._fingers = [];
    this._joints = [];
    this._jointsById = {};
    this._tips = [];
    this._wrist = null;
    const xrHand = inputSource._xrInputSource.hand;
    this._manager = inputSource._manager;
    this._inputSource = inputSource;
    if (xrHand.get("wrist")) {
      const joint = new XrJoint(0, "wrist", this, null);
      this._wrist = joint;
      this._joints.push(joint);
      this._jointsById.wrist = joint;
    }
    for (let f = 0; f < fingerJointIds.length; f++) {
      const finger = new XrFinger(f, this);
      for (let j = 0; j < fingerJointIds[f].length; j++) {
        const jointId = fingerJointIds[f][j];
        if (!xrHand.get(jointId)) continue;
        const joint = new XrJoint(j, jointId, this, finger);
        this._joints.push(joint);
        this._jointsById[jointId] = joint;
        if (joint.tip) {
          this._tips.push(joint);
          finger._tip = joint;
        }
        finger._joints.push(joint);
      }
    }
  }
  update(frame) {
    const xrInputSource = this._inputSource._xrInputSource;
    for (let j = 0; j < this._joints.length; j++) {
      const joint = this._joints[j];
      const jointSpace = xrInputSource.hand.get(joint._id);
      if (jointSpace) {
        let pose;
        if (frame.session.visibilityState !== "hidden") {
          pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);
        }
        if (pose) {
          joint.update(pose);
          if (joint.wrist && !this._tracking) {
            this._tracking = true;
            this.fire("tracking");
          }
        } else if (joint.wrist) {
          if (this._tracking) {
            this._tracking = false;
            this.fire("trackinglost");
          }
          break;
        }
      }
    }
    const j1 = this._jointsById["thumb-metacarpal"];
    const j4 = this._jointsById["thumb-tip"];
    const j6 = this._jointsById["index-finger-phalanx-proximal"];
    const j9 = this._jointsById["index-finger-tip"];
    const j16 = this._jointsById["ring-finger-phalanx-proximal"];
    const j21 = this._jointsById["pinky-finger-phalanx-proximal"];
    if (j1 && j4 && j6 && j9 && j16 && j21) {
      this._inputSource._dirtyRay = true;
      this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);
      let jointL = j1;
      let jointR = j21;
      if (this._inputSource.handedness === XRHAND_LEFT) {
        const t = jointL;
        jointL = jointR;
        jointR = t;
      }
      vecA2.sub2(jointL._localPosition, this._wrist._localPosition);
      vecB2.sub2(jointR._localPosition, this._wrist._localPosition);
      vecC.cross(vecA2, vecB2).normalize();
      vecA2.lerp(j6._localPosition, j16._localPosition, 0.5);
      vecA2.sub(this._wrist._localPosition).normalize();
      this._inputSource._rayLocal.direction.lerp(vecC, vecA2, 0.5).normalize();
    }
    const squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);
    if (squeezing) {
      if (!this._inputSource._squeezing) {
        this._inputSource._squeezing = true;
        this._inputSource.fire("squeezestart");
        this._manager.input.fire("squeezestart", this._inputSource);
      }
    } else {
      if (this._inputSource._squeezing) {
        this._inputSource._squeezing = false;
        this._inputSource.fire("squeeze");
        this._manager.input.fire("squeeze", this._inputSource);
        this._inputSource.fire("squeezeend");
        this._manager.input.fire("squeezeend", this._inputSource);
      }
    }
  }
  _fingerIsClosed(index) {
    const finger = this._fingers[index];
    vecA2.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();
    vecB2.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();
    return vecA2.dot(vecB2) < -0.8;
  }
  getJointById(id13) {
    return this._jointsById[id13] || null;
  }
  get fingers() {
    return this._fingers;
  }
  get joints() {
    return this._joints;
  }
  get tips() {
    return this._tips;
  }
  get wrist() {
    return this._wrist;
  }
  get tracking() {
    return this._tracking;
  }
};
XrHand.EVENT_TRACKING = "tracking";
XrHand.EVENT_TRACKINGLOST = "trackinglost";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-input-source.js
var vec3A = new Vec3();
var quat4 = new Quat();
var ids = 0;
var XrInputSource = class extends EventHandler {
  constructor(manager, xrInputSource) {
    super();
    this._id = void 0;
    this._manager = void 0;
    this._xrInputSource = void 0;
    this._ray = new Ray();
    this._rayLocal = new Ray();
    this._grip = false;
    this._hand = null;
    this._velocitiesAvailable = false;
    this._velocitiesTimestamp = now();
    this._localTransform = null;
    this._worldTransform = null;
    this._position = new Vec3();
    this._rotation = new Quat();
    this._localPosition = null;
    this._localPositionLast = null;
    this._localRotation = null;
    this._linearVelocity = null;
    this._dirtyLocal = true;
    this._dirtyRay = false;
    this._selecting = false;
    this._squeezing = false;
    this._elementInput = true;
    this._elementEntity = null;
    this._hitTestSources = [];
    this._id = ++ids;
    this._manager = manager;
    this._xrInputSource = xrInputSource;
    if (xrInputSource.hand) {
      this._hand = new XrHand(this);
    }
  }
  get id() {
    return this._id;
  }
  get inputSource() {
    return this._xrInputSource;
  }
  get targetRayMode() {
    return this._xrInputSource.targetRayMode;
  }
  get handedness() {
    return this._xrInputSource.handedness;
  }
  get profiles() {
    return this._xrInputSource.profiles;
  }
  get grip() {
    return this._grip;
  }
  get hand() {
    return this._hand;
  }
  get gamepad() {
    return this._xrInputSource.gamepad || null;
  }
  get selecting() {
    return this._selecting;
  }
  get squeezing() {
    return this._squeezing;
  }
  set elementInput(value) {
    if (this._elementInput === value) {
      return;
    }
    this._elementInput = value;
    if (!this._elementInput) {
      this._elementEntity = null;
    }
  }
  get elementInput() {
    return this._elementInput;
  }
  get elementEntity() {
    return this._elementEntity;
  }
  get hitTestSources() {
    return this._hitTestSources;
  }
  update(frame) {
    if (this._hand) {
      this._hand.update(frame);
    } else {
      const gripSpace = this._xrInputSource.gripSpace;
      if (gripSpace) {
        const gripPose = frame.getPose(gripSpace, this._manager._referenceSpace);
        if (gripPose) {
          if (!this._grip) {
            this._grip = true;
            this._localTransform = new Mat4();
            this._worldTransform = new Mat4();
            this._localPositionLast = new Vec3();
            this._localPosition = new Vec3();
            this._localRotation = new Quat();
            this._linearVelocity = new Vec3();
          }
          const timestamp = now();
          const dt = (timestamp - this._velocitiesTimestamp) / 1e3;
          this._velocitiesTimestamp = timestamp;
          this._dirtyLocal = true;
          this._localPositionLast.copy(this._localPosition);
          this._localPosition.copy(gripPose.transform.position);
          this._localRotation.copy(gripPose.transform.orientation);
          this._velocitiesAvailable = true;
          if (this._manager.input.velocitiesSupported && gripPose.linearVelocity) {
            this._linearVelocity.copy(gripPose.linearVelocity);
          } else if (dt > 0) {
            vec3A.sub2(this._localPosition, this._localPositionLast).divScalar(dt);
            this._linearVelocity.lerp(this._linearVelocity, vec3A, 0.15);
          }
        } else {
          this._velocitiesAvailable = false;
        }
      }
      const targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);
      if (targetRayPose) {
        this._dirtyRay = true;
        this._rayLocal.origin.copy(targetRayPose.transform.position);
        this._rayLocal.direction.set(0, 0, -1);
        quat4.copy(targetRayPose.transform.orientation);
        quat4.transformVector(this._rayLocal.direction, this._rayLocal.direction);
      }
    }
  }
  _updateTransforms() {
    if (this._dirtyLocal) {
      this._dirtyLocal = false;
      this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
    }
    const parent = this._manager.camera.parent;
    if (parent) {
      this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
    } else {
      this._worldTransform.copy(this._localTransform);
    }
  }
  _updateRayTransforms() {
    const dirty = this._dirtyRay;
    this._dirtyRay = false;
    const parent = this._manager.camera.parent;
    if (parent) {
      const parentTransform = this._manager.camera.parent.getWorldTransform();
      parentTransform.getTranslation(this._position);
      this._rotation.setFromMat4(parentTransform);
      this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);
      this._ray.origin.add(this._position);
      this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
    } else if (dirty) {
      this._ray.origin.copy(this._rayLocal.origin);
      this._ray.direction.copy(this._rayLocal.direction);
    }
  }
  getPosition() {
    if (!this._position) return null;
    this._updateTransforms();
    this._worldTransform.getTranslation(this._position);
    return this._position;
  }
  getLocalPosition() {
    return this._localPosition;
  }
  getRotation() {
    if (!this._rotation) return null;
    this._updateTransforms();
    this._rotation.setFromMat4(this._worldTransform);
    return this._rotation;
  }
  getLocalRotation() {
    return this._localRotation;
  }
  getLinearVelocity() {
    if (!this._velocitiesAvailable) {
      return null;
    }
    return this._linearVelocity;
  }
  getOrigin() {
    this._updateRayTransforms();
    return this._ray.origin;
  }
  getDirection() {
    this._updateRayTransforms();
    return this._ray.direction;
  }
  hitTestStart(options2 = {}) {
    options2.inputSource = this;
    options2.profile = this._xrInputSource.profiles[0];
    const callback = options2.callback;
    options2.callback = (err3, hitTestSource) => {
      if (hitTestSource) this.onHitTestSourceAdd(hitTestSource);
      if (callback) callback(err3, hitTestSource);
    };
    this._manager.hitTest.start(options2);
  }
  onHitTestSourceAdd(hitTestSource) {
    this._hitTestSources.push(hitTestSource);
    this.fire("hittest:add", hitTestSource);
    hitTestSource.on("result", (position3, rotation2, inputSource, hitTestResult) => {
      if (inputSource !== this) return;
      this.fire("hittest:result", hitTestSource, position3, rotation2, hitTestResult);
    });
    hitTestSource.once("remove", () => {
      this.onHitTestSourceRemove(hitTestSource);
      this.fire("hittest:remove", hitTestSource);
    });
  }
  onHitTestSourceRemove(hitTestSource) {
    const ind = this._hitTestSources.indexOf(hitTestSource);
    if (ind !== -1) this._hitTestSources.splice(ind, 1);
  }
};
XrInputSource.EVENT_REMOVE = "remove";
XrInputSource.EVENT_SELECT = "select";
XrInputSource.EVENT_SELECTSTART = "selectstart";
XrInputSource.EVENT_SELECTEND = "selectend";
XrInputSource.EVENT_SQUEEZE = "squeeze";
XrInputSource.EVENT_SQUEEZESTART = "squeezestart";
XrInputSource.EVENT_SQUEEZEEND = "squeezeend";
XrInputSource.EVENT_HITTESTADD = "hittest:add";
XrInputSource.EVENT_HITTESTREMOVE = "hittest:remove";
XrInputSource.EVENT_HITTESTRESULT = "hittest:result";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-input.js
var XrInput = class extends EventHandler {
  constructor(manager) {
    var _window$XRPose;
    super();
    this.manager = void 0;
    this._inputSources = [];
    this._onInputSourcesChangeEvt = void 0;
    this.velocitiesSupported = false;
    this.manager = manager;
    this.velocitiesSupported = !!(platform.browser && (_window$XRPose = window.XRPose) != null && (_window$XRPose = _window$XRPose.prototype) != null && _window$XRPose.hasOwnProperty("linearVelocity"));
    this._onInputSourcesChangeEvt = (evt) => {
      this._onInputSourcesChange(evt);
    };
    this.manager.on("start", this._onSessionStart, this);
    this.manager.on("end", this._onSessionEnd, this);
  }
  _onSessionStart() {
    const session = this.manager.session;
    session.addEventListener("inputsourceschange", this._onInputSourcesChangeEvt);
    session.addEventListener("select", (evt) => {
      const inputSource = this._getByInputSource(evt.inputSource);
      inputSource.update(evt.frame);
      inputSource.fire("select", evt);
      this.fire("select", inputSource, evt);
    });
    session.addEventListener("selectstart", (evt) => {
      const inputSource = this._getByInputSource(evt.inputSource);
      inputSource.update(evt.frame);
      inputSource._selecting = true;
      inputSource.fire("selectstart", evt);
      this.fire("selectstart", inputSource, evt);
    });
    session.addEventListener("selectend", (evt) => {
      const inputSource = this._getByInputSource(evt.inputSource);
      inputSource.update(evt.frame);
      inputSource._selecting = false;
      inputSource.fire("selectend", evt);
      this.fire("selectend", inputSource, evt);
    });
    session.addEventListener("squeeze", (evt) => {
      const inputSource = this._getByInputSource(evt.inputSource);
      inputSource.update(evt.frame);
      inputSource.fire("squeeze", evt);
      this.fire("squeeze", inputSource, evt);
    });
    session.addEventListener("squeezestart", (evt) => {
      const inputSource = this._getByInputSource(evt.inputSource);
      inputSource.update(evt.frame);
      inputSource._squeezing = true;
      inputSource.fire("squeezestart", evt);
      this.fire("squeezestart", inputSource, evt);
    });
    session.addEventListener("squeezeend", (evt) => {
      const inputSource = this._getByInputSource(evt.inputSource);
      inputSource.update(evt.frame);
      inputSource._squeezing = false;
      inputSource.fire("squeezeend", evt);
      this.fire("squeezeend", inputSource, evt);
    });
    const inputSources = session.inputSources;
    for (let i = 0; i < inputSources.length; i++) {
      this._addInputSource(inputSources[i]);
    }
  }
  _onSessionEnd() {
    let i = this._inputSources.length;
    while (i--) {
      const inputSource = this._inputSources[i];
      this._inputSources.splice(i, 1);
      inputSource.fire("remove");
      this.fire("remove", inputSource);
    }
    const session = this.manager.session;
    session.removeEventListener("inputsourceschange", this._onInputSourcesChangeEvt);
  }
  _onInputSourcesChange(evt) {
    for (let i = 0; i < evt.removed.length; i++) {
      this._removeInputSource(evt.removed[i]);
    }
    for (let i = 0; i < evt.added.length; i++) {
      this._addInputSource(evt.added[i]);
    }
  }
  _getByInputSource(xrInputSource) {
    for (let i = 0; i < this._inputSources.length; i++) {
      if (this._inputSources[i].inputSource === xrInputSource) {
        return this._inputSources[i];
      }
    }
    return null;
  }
  _addInputSource(xrInputSource) {
    if (this._getByInputSource(xrInputSource)) {
      return;
    }
    const inputSource = new XrInputSource(this.manager, xrInputSource);
    this._inputSources.push(inputSource);
    this.fire("add", inputSource);
  }
  _removeInputSource(xrInputSource) {
    for (let i = 0; i < this._inputSources.length; i++) {
      if (this._inputSources[i].inputSource !== xrInputSource) {
        continue;
      }
      const inputSource = this._inputSources[i];
      this._inputSources.splice(i, 1);
      let h2 = inputSource.hitTestSources.length;
      while (h2--) {
        inputSource.hitTestSources[h2].remove();
      }
      inputSource.fire("remove");
      this.fire("remove", inputSource);
      return;
    }
  }
  update(frame) {
    for (let i = 0; i < this._inputSources.length; i++) {
      this._inputSources[i].update(frame);
    }
  }
  get inputSources() {
    return this._inputSources;
  }
};
XrInput.EVENT_ADD = "add";
XrInput.EVENT_REMOVE = "remove";
XrInput.EVENT_SELECT = "select";
XrInput.EVENT_SELECTSTART = "selectstart";
XrInput.EVENT_SELECTEND = "selectend";
XrInput.EVENT_SQUEEZE = "squeeze";
XrInput.EVENT_SQUEEZESTART = "squeezestart";
XrInput.EVENT_SQUEEZEEND = "squeezeend";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-light-estimation.js
var vec3A2 = new Vec3();
var vec3B = new Vec3();
var mat4A = new Mat4();
var mat4B = new Mat4();
var XrLightEstimation = class extends EventHandler {
  constructor(manager) {
    super();
    this._manager = void 0;
    this._supported = false;
    this._available = false;
    this._lightProbeRequested = false;
    this._lightProbe = null;
    this._intensity = 0;
    this._rotation = new Quat();
    this._color = new Color();
    this._sphericalHarmonics = new Float32Array(27);
    this._manager = manager;
    this._manager.on("start", this._onSessionStart, this);
    this._manager.on("end", this._onSessionEnd, this);
  }
  _onSessionStart() {
    const supported = !!this._manager.session.requestLightProbe;
    if (!supported) return;
    this._supported = true;
  }
  _onSessionEnd() {
    this._supported = false;
    this._available = false;
    this._lightProbeRequested = false;
    this._lightProbe = null;
  }
  start() {
    let err3;
    if (!this._manager.session) {
      err3 = new Error("XR session is not running");
    }
    if (!err3 && this._manager.type !== XRTYPE_AR) {
      err3 = new Error("XR session type is not AR");
    }
    if (!err3 && !this._supported) {
      err3 = new Error("light-estimation is not supported");
    }
    if (!err3 && this._lightProbe || this._lightProbeRequested) {
      err3 = new Error("light estimation is already requested");
    }
    if (err3) {
      this.fire("error", err3);
      return;
    }
    this._lightProbeRequested = true;
    this._manager.session.requestLightProbe().then((lightProbe) => {
      const wasRequested = this._lightProbeRequested;
      this._lightProbeRequested = false;
      if (this._manager.active) {
        if (wasRequested) {
          this._lightProbe = lightProbe;
        }
      } else {
        this.fire("error", new Error("XR session is not active"));
      }
    }).catch((ex) => {
      this._lightProbeRequested = false;
      this.fire("error", ex);
    });
  }
  end() {
    this._lightProbeRequested = false;
    this._lightProbe = null;
    this._available = false;
  }
  update(frame) {
    if (!this._lightProbe) return;
    const lightEstimate = frame.getLightEstimate(this._lightProbe);
    if (!lightEstimate) return;
    if (!this._available) {
      this._available = true;
      this.fire("available");
    }
    const pli = lightEstimate.primaryLightIntensity;
    this._intensity = Math.max(1, Math.max(pli.x, Math.max(pli.y, pli.z)));
    vec3A2.copy(pli).mulScalar(1 / this._intensity);
    this._color.set(vec3A2.x, vec3A2.y, vec3A2.z);
    vec3A2.set(0, 0, 0);
    vec3B.copy(lightEstimate.primaryLightDirection);
    mat4A.setLookAt(vec3B, vec3A2, Vec3.UP);
    mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
    mat4A.mul(mat4B);
    this._rotation.setFromMat4(mat4A);
    this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._available;
  }
  get intensity() {
    return this._available ? this._intensity : null;
  }
  get color() {
    return this._available ? this._color : null;
  }
  get rotation() {
    return this._available ? this._rotation : null;
  }
  get sphericalHarmonics() {
    return this._available ? this._sphericalHarmonics : null;
  }
};
XrLightEstimation.EVENT_AVAILABLE = "available";
XrLightEstimation.EVENT_ERROR = "error";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-plane.js
var ids2 = 0;
var XrPlane = class extends EventHandler {
  constructor(planeDetection, xrPlane) {
    super();
    this._id = void 0;
    this._planeDetection = void 0;
    this._xrPlane = void 0;
    this._lastChangedTime = void 0;
    this._orientation = void 0;
    this._position = new Vec3();
    this._rotation = new Quat();
    this._id = ++ids2;
    this._planeDetection = planeDetection;
    this._xrPlane = xrPlane;
    this._lastChangedTime = xrPlane.lastChangedTime;
    this._orientation = xrPlane.orientation;
  }
  destroy() {
    if (!this._xrPlane) return;
    this._xrPlane = null;
    this.fire("remove");
  }
  update(frame) {
    const manager = this._planeDetection._manager;
    const pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);
    if (pose) {
      this._position.copy(pose.transform.position);
      this._rotation.copy(pose.transform.orientation);
    }
    if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {
      this._lastChangedTime = this._xrPlane.lastChangedTime;
      this.fire("change");
    }
  }
  getPosition() {
    return this._position;
  }
  getRotation() {
    return this._rotation;
  }
  get id() {
    return this._id;
  }
  get orientation() {
    return this._orientation;
  }
  get points() {
    return this._xrPlane.polygon;
  }
  get label() {
    return this._xrPlane.semanticLabel || "";
  }
};
XrPlane.EVENT_REMOVE = "remove";
XrPlane.EVENT_CHANGE = "change";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-plane-detection.js
var XrPlaneDetection = class extends EventHandler {
  constructor(manager) {
    super();
    this._manager = void 0;
    this._supported = platform.browser && !!window.XRPlane;
    this._available = false;
    this._planesIndex = /* @__PURE__ */ new Map();
    this._planes = [];
    this._manager = manager;
    if (this._supported) {
      this._manager.on("start", this._onSessionStart, this);
      this._manager.on("end", this._onSessionEnd, this);
    }
  }
  _onSessionStart() {
    if (this._manager.session.enabledFeatures) {
      const available = this._manager.session.enabledFeatures.indexOf("plane-detection") !== -1;
      if (available) {
        this._available = true;
        this.fire("available");
      }
    }
  }
  _onSessionEnd() {
    for (let i = 0; i < this._planes.length; i++) {
      this._planes[i].destroy();
      this.fire("remove", this._planes[i]);
    }
    this._planesIndex.clear();
    this._planes.length = 0;
    if (this._available) {
      this._available = false;
      this.fire("unavailable");
    }
  }
  update(frame) {
    if (!this._available) {
      if (!this._manager.session.enabledFeatures && frame.detectedPlanes.size) {
        this._available = true;
        this.fire("available");
      } else {
        return;
      }
    }
    const detectedPlanes = frame.detectedPlanes;
    for (const [xrPlane, plane] of this._planesIndex) {
      if (detectedPlanes.has(xrPlane)) {
        continue;
      }
      this._planesIndex.delete(xrPlane);
      this._planes.splice(this._planes.indexOf(plane), 1);
      plane.destroy();
      this.fire("remove", plane);
    }
    for (const xrPlane of detectedPlanes) {
      let plane = this._planesIndex.get(xrPlane);
      if (!plane) {
        plane = new XrPlane(this, xrPlane);
        this._planesIndex.set(xrPlane, plane);
        this._planes.push(plane);
        plane.update(frame);
        this.fire("add", plane);
      } else {
        plane.update(frame);
      }
    }
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._available;
  }
  get planes() {
    return this._planes;
  }
};
XrPlaneDetection.EVENT_AVAILABLE = "available";
XrPlaneDetection.EVENT_UNAVAILABLE = "unavailable";
XrPlaneDetection.EVENT_ADD = "add";
XrPlaneDetection.EVENT_REMOVE = "remove";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-anchor.js
var XrAnchor = class extends EventHandler {
  constructor(anchors, xrAnchor, uuid = null) {
    super();
    this._position = new Vec3();
    this._rotation = new Quat();
    this._uuid = null;
    this._uuidRequests = null;
    this._anchors = anchors;
    this._xrAnchor = xrAnchor;
    this._uuid = uuid;
  }
  destroy() {
    if (!this._xrAnchor) return;
    const xrAnchor = this._xrAnchor;
    this._xrAnchor.delete();
    this._xrAnchor = null;
    this.fire("destroy", xrAnchor, this);
  }
  update(frame) {
    if (!this._xrAnchor) {
      return;
    }
    const pose = frame.getPose(this._xrAnchor.anchorSpace, this._anchors.manager._referenceSpace);
    if (pose) {
      if (this._position.equals(pose.transform.position) && this._rotation.equals(pose.transform.orientation)) {
        return;
      }
      this._position.copy(pose.transform.position);
      this._rotation.copy(pose.transform.orientation);
      this.fire("change");
    }
  }
  getPosition() {
    return this._position;
  }
  getRotation() {
    return this._rotation;
  }
  persist(callback) {
    if (!this._anchors.persistence) {
      callback == null || callback(new Error("Persistent Anchors are not supported"), null);
      return;
    }
    if (this._uuid) {
      callback == null || callback(null, this._uuid);
      return;
    }
    if (this._uuidRequests) {
      if (callback) this._uuidRequests.push(callback);
      return;
    }
    this._uuidRequests = [];
    this._xrAnchor.requestPersistentHandle().then((uuid) => {
      this._uuid = uuid;
      this._anchors._indexByUuid.set(this._uuid, this);
      callback == null || callback(null, uuid);
      for (const uuidRequest of this._uuidRequests) {
        uuidRequest(null, uuid);
      }
      this._uuidRequests = null;
      this.fire("persist", uuid);
    }).catch((ex) => {
      callback == null || callback(ex, null);
      for (const uuidRequest of this._uuidRequests) {
        uuidRequest(ex, null);
      }
      this._uuidRequests = null;
    });
  }
  forget(callback) {
    if (!this._uuid) {
      callback == null || callback(new Error("Anchor is not persistent"));
      return;
    }
    this._anchors.forget(this._uuid, (ex) => {
      this._uuid = null;
      callback == null || callback(ex);
      this.fire("forget");
    });
  }
  get uuid() {
    return this._uuid;
  }
  get persistent() {
    return !!this._uuid;
  }
};
XrAnchor.EVENT_DESTROY = "destroy";
XrAnchor.EVENT_CHANGE = "change";
XrAnchor.EVENT_PERSIST = "persist";
XrAnchor.EVENT_FORGET = "forget";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-anchors.js
var XrAnchors = class extends EventHandler {
  constructor(manager) {
    var _window;
    super();
    this.manager = void 0;
    this._supported = platform.browser && !!window.XRAnchor;
    this._available = false;
    this._checkingAvailability = false;
    this._persistence = platform.browser && !!((_window = window) != null && (_window = _window.XRSession) != null && _window.prototype.restorePersistentAnchor);
    this._creationQueue = [];
    this._index = /* @__PURE__ */ new Map();
    this._indexByUuid = /* @__PURE__ */ new Map();
    this._list = [];
    this._callbacksAnchors = /* @__PURE__ */ new Map();
    this.manager = manager;
    if (this._supported) {
      this.manager.on("start", this._onSessionStart, this);
      this.manager.on("end", this._onSessionEnd, this);
    }
  }
  _onSessionStart() {
    const available = this.manager.session.enabledFeatures.indexOf("anchors") !== -1;
    if (!available) return;
    this._available = available;
    this.fire("available");
  }
  _onSessionEnd() {
    if (!this._available) return;
    this._available = false;
    for (let _i = 0; _i < this._creationQueue.length; _i++) {
      if (!this._creationQueue[_i].callback) {
        continue;
      }
      this._creationQueue[_i].callback(new Error("session ended"), null);
    }
    this._creationQueue.length = 0;
    this._index.clear();
    this._indexByUuid.clear();
    let i = this._list.length;
    while (i--) {
      this._list[i].destroy();
    }
    this._list.length = 0;
    this.fire("unavailable");
  }
  _createAnchor(xrAnchor, uuid = null) {
    const anchor = new XrAnchor(this, xrAnchor, uuid);
    this._index.set(xrAnchor, anchor);
    if (uuid) this._indexByUuid.set(uuid, anchor);
    this._list.push(anchor);
    anchor.once("destroy", this._onAnchorDestroy, this);
    return anchor;
  }
  _onAnchorDestroy(xrAnchor, anchor) {
    this._index.delete(xrAnchor);
    if (anchor.uuid) this._indexByUuid.delete(anchor.uuid);
    const ind = this._list.indexOf(anchor);
    if (ind !== -1) this._list.splice(ind, 1);
    this.fire("destroy", anchor);
  }
  create(position3, rotation2, callback) {
    if (!this._available) {
      callback == null || callback(new Error("Anchors API is not available"), null);
      return;
    }
    if (window.XRHitTestResult && position3 instanceof XRHitTestResult) {
      const hitResult = position3;
      callback = rotation2;
      if (!this._supported) {
        callback == null || callback(new Error("Anchors API is not supported"), null);
        return;
      }
      if (!hitResult.createAnchor) {
        callback == null || callback(new Error("Creating Anchor from Hit Test is not supported"), null);
        return;
      }
      hitResult.createAnchor().then((xrAnchor) => {
        const anchor = this._createAnchor(xrAnchor);
        callback == null || callback(null, anchor);
        this.fire("add", anchor);
      }).catch((ex) => {
        callback == null || callback(ex, null);
        this.fire("error", ex);
      });
    } else {
      this._creationQueue.push({
        transform: new XRRigidTransform(position3, rotation2),
        callback
      });
    }
  }
  restore(uuid, callback) {
    if (!this._available) {
      callback == null || callback(new Error("Anchors API is not available"), null);
      return;
    }
    if (!this._persistence) {
      callback == null || callback(new Error("Anchor Persistence is not supported"), null);
      return;
    }
    if (!this.manager.active) {
      callback == null || callback(new Error("WebXR session is not active"), null);
      return;
    }
    this.manager.session.restorePersistentAnchor(uuid).then((xrAnchor) => {
      const anchor = this._createAnchor(xrAnchor, uuid);
      callback == null || callback(null, anchor);
      this.fire("add", anchor);
    }).catch((ex) => {
      callback == null || callback(ex, null);
      this.fire("error", ex);
    });
  }
  forget(uuid, callback) {
    if (!this._available) {
      callback == null || callback(new Error("Anchors API is not available"));
      return;
    }
    if (!this._persistence) {
      callback == null || callback(new Error("Anchor Persistence is not supported"));
      return;
    }
    if (!this.manager.active) {
      callback == null || callback(new Error("WebXR session is not active"));
      return;
    }
    this.manager.session.deletePersistentAnchor(uuid).then(() => {
      callback == null || callback(null);
    }).catch((ex) => {
      callback == null || callback(ex);
      this.fire("error", ex);
    });
  }
  update(frame) {
    if (!this._available) {
      if (!this.manager.session.enabledFeatures && !this._checkingAvailability) {
        this._checkingAvailability = true;
        frame.createAnchor(new XRRigidTransform(), this.manager._referenceSpace).then((xrAnchor) => {
          xrAnchor.delete();
          if (this.manager.active) {
            this._available = true;
            this.fire("available");
          }
        }).catch(() => {
        });
      }
      return;
    }
    if (this._creationQueue.length) {
      for (let i = 0; i < this._creationQueue.length; i++) {
        const request = this._creationQueue[i];
        frame.createAnchor(request.transform, this.manager._referenceSpace).then((xrAnchor) => {
          if (request.callback) {
            this._callbacksAnchors.set(xrAnchor, request.callback);
          }
        }).catch((ex) => {
          if (request.callback) {
            request.callback(ex, null);
          }
          this.fire("error", ex);
        });
      }
      this._creationQueue.length = 0;
    }
    for (const [xrAnchor, anchor] of this._index) {
      if (frame.trackedAnchors.has(xrAnchor)) {
        continue;
      }
      this._index.delete(xrAnchor);
      anchor.destroy();
    }
    for (let i = 0; i < this._list.length; i++) {
      this._list[i].update(frame);
    }
    for (const xrAnchor of frame.trackedAnchors) {
      if (this._index.has(xrAnchor)) {
        continue;
      }
      try {
        const tmp = xrAnchor.anchorSpace;
      } catch (ex) {
        continue;
      }
      const anchor = this._createAnchor(xrAnchor);
      anchor.update(frame);
      const callback = this._callbacksAnchors.get(xrAnchor);
      if (callback) {
        this._callbacksAnchors.delete(xrAnchor);
        callback(null, anchor);
      }
      this.fire("add", anchor);
    }
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._available;
  }
  get persistence() {
    return this._persistence;
  }
  get uuids() {
    if (!this._available) {
      return null;
    }
    if (!this._persistence) {
      return null;
    }
    if (!this.manager.active) {
      return null;
    }
    return this.manager.session.persistentAnchors;
  }
  get list() {
    return this._list;
  }
};
XrAnchors.EVENT_AVAILABLE = "available";
XrAnchors.EVENT_UNAVAILABLE = "unavailable";
XrAnchors.EVENT_ERROR = "error";
XrAnchors.EVENT_ADD = "add";
XrAnchors.EVENT_DESTROY = "destroy";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-mesh.js
var XrMesh = class extends EventHandler {
  constructor(meshDetection, xrMesh) {
    super();
    this._meshDetection = void 0;
    this._xrMesh = void 0;
    this._lastChanged = 0;
    this._position = new Vec3();
    this._rotation = new Quat();
    this._meshDetection = meshDetection;
    this._xrMesh = xrMesh;
    this._lastChanged = this._xrMesh.lastChangedTime;
  }
  get xrMesh() {
    return this._xrMesh;
  }
  get label() {
    return this._xrMesh.semanticLabel || "";
  }
  get vertices() {
    return this._xrMesh.vertices;
  }
  get indices() {
    return this._xrMesh.indices;
  }
  destroy() {
    if (!this._xrMesh) return;
    this._xrMesh = null;
    this.fire("remove");
  }
  update(frame) {
    const manager = this._meshDetection._manager;
    const pose = frame.getPose(this._xrMesh.meshSpace, manager._referenceSpace);
    if (pose) {
      this._position.copy(pose.transform.position);
      this._rotation.copy(pose.transform.orientation);
    }
    if (this._lastChanged !== this._xrMesh.lastChangedTime) {
      this._lastChanged = this._xrMesh.lastChangedTime;
      this.fire("change");
    }
  }
  getPosition() {
    return this._position;
  }
  getRotation() {
    return this._rotation;
  }
};
XrMesh.EVENT_REMOVE = "remove";
XrMesh.EVENT_CHANGE = "change";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-mesh-detection.js
var XrMeshDetection = class extends EventHandler {
  constructor(manager) {
    super();
    this._manager = void 0;
    this._supported = platform.browser && !!window.XRMesh;
    this._available = false;
    this._index = /* @__PURE__ */ new Map();
    this._list = [];
    this._manager = manager;
    if (this._supported) {
      this._manager.on("start", this._onSessionStart, this);
      this._manager.on("end", this._onSessionEnd, this);
    }
  }
  update(frame) {
    if (!this._available) {
      if (!this._manager.session.enabledFeatures && frame.detectedMeshes.size) {
        this._available = true;
        this.fire("available");
      } else {
        return;
      }
    }
    for (const xrMesh of frame.detectedMeshes) {
      let mesh = this._index.get(xrMesh);
      if (!mesh) {
        mesh = new XrMesh(this, xrMesh);
        this._index.set(xrMesh, mesh);
        this._list.push(mesh);
        mesh.update(frame);
        this.fire("add", mesh);
      } else {
        mesh.update(frame);
      }
    }
    for (const mesh of this._index.values()) {
      if (frame.detectedMeshes.has(mesh.xrMesh)) {
        continue;
      }
      this._removeMesh(mesh);
    }
  }
  _removeMesh(mesh) {
    this._index.delete(mesh.xrMesh);
    this._list.splice(this._list.indexOf(mesh), 1);
    mesh.destroy();
    this.fire("remove", mesh);
  }
  _onSessionStart() {
    if (this._manager.session.enabledFeatures) {
      const available = this._manager.session.enabledFeatures.indexOf("mesh-detection") !== -1;
      if (!available) return;
      this._available = available;
      this.fire("available");
    }
  }
  _onSessionEnd() {
    if (!this._available) return;
    this._available = false;
    for (const mesh of this._index.values()) {
      this._removeMesh(mesh);
    }
    this.fire("unavailable");
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._available;
  }
  get meshes() {
    return this._list;
  }
};
XrMeshDetection.EVENT_AVAILABLE = "available";
XrMeshDetection.EVENT_UNAVAILABLE = "unavailable";
XrMeshDetection.EVENT_ADD = "add";
XrMeshDetection.EVENT_REMOVE = "remove";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-view.js
var XrView = class extends EventHandler {
  constructor(manager, xrView, viewsCount) {
    super();
    this._manager = void 0;
    this._xrView = void 0;
    this._positionData = new Float32Array(3);
    this._viewport = new Vec4();
    this._projMat = new Mat4();
    this._projViewOffMat = new Mat4();
    this._viewMat = new Mat4();
    this._viewOffMat = new Mat4();
    this._viewMat3 = new Mat3();
    this._viewInvMat = new Mat4();
    this._viewInvOffMat = new Mat4();
    this._xrCamera = null;
    this._textureColor = null;
    this._textureDepth = null;
    this._depthInfo = null;
    this._emptyDepthBuffer = new Uint8Array(32);
    this._depthMatrix = new Mat4();
    this._manager = manager;
    this._xrView = xrView;
    const device = this._manager.app.graphicsDevice;
    if (this._manager.views.supportedColor) {
      this._xrCamera = this._xrView.camera;
      if (this._manager.views.availableColor && this._xrCamera) {
        this._textureColor = new Texture(device, {
          format: PIXELFORMAT_RGB8,
          mipmaps: false,
          addressU: ADDRESS_CLAMP_TO_EDGE,
          addressV: ADDRESS_CLAMP_TO_EDGE,
          minFilter: FILTER_LINEAR,
          magFilter: FILTER_LINEAR,
          width: this._xrCamera.width,
          height: this._xrCamera.height,
          name: `XrView-${this._xrView.eye}-Color`
        });
      }
    }
    if (this._manager.views.supportedDepth && this._manager.views.availableDepth) {
      const filtering = this._manager.views.depthGpuOptimized ? FILTER_NEAREST : FILTER_LINEAR;
      this._textureDepth = new Texture(device, {
        format: this._manager.views.depthPixelFormat,
        arrayLength: viewsCount === 1 ? 0 : viewsCount,
        mipmaps: false,
        addressU: ADDRESS_CLAMP_TO_EDGE,
        addressV: ADDRESS_CLAMP_TO_EDGE,
        minFilter: filtering,
        magFilter: filtering,
        width: 4,
        height: 4,
        name: `XrView-${this._xrView.eye}-Depth`
      });
      for (let i = 0; i < this._textureDepth._levels.length; i++) {
        this._textureDepth._levels[i] = this._emptyDepthBuffer;
      }
      this._textureDepth.upload();
    }
    if (this._textureColor || this._textureDepth) {
      device.on("devicelost", this._onDeviceLost, this);
    }
  }
  get textureColor() {
    return this._textureColor;
  }
  get textureDepth() {
    return this._textureDepth;
  }
  get depthUvMatrix() {
    return this._depthMatrix;
  }
  get depthValueToMeters() {
    var _this$_depthInfo;
    return ((_this$_depthInfo = this._depthInfo) == null ? void 0 : _this$_depthInfo.rawValueToMeters) || 0;
  }
  get eye() {
    return this._xrView.eye;
  }
  get viewport() {
    return this._viewport;
  }
  get projMat() {
    return this._projMat;
  }
  get projViewOffMat() {
    return this._projViewOffMat;
  }
  get viewOffMat() {
    return this._viewOffMat;
  }
  get viewInvOffMat() {
    return this._viewInvOffMat;
  }
  get viewMat3() {
    return this._viewMat3;
  }
  get positionData() {
    return this._positionData;
  }
  update(frame, xrView) {
    this._xrView = xrView;
    if (this._manager.views.availableColor) {
      this._xrCamera = this._xrView.camera;
    }
    const layer = frame.session.renderState.baseLayer;
    const viewport2 = layer.getViewport(this._xrView);
    this._viewport.x = viewport2.x;
    this._viewport.y = viewport2.y;
    this._viewport.z = viewport2.width;
    this._viewport.w = viewport2.height;
    this._projMat.set(this._xrView.projectionMatrix);
    this._viewMat.set(this._xrView.transform.inverse.matrix);
    this._viewInvMat.set(this._xrView.transform.matrix);
    this._updateTextureColor();
    this._updateDepth(frame);
  }
  _updateTextureColor() {
    if (!this._manager.views.availableColor || !this._xrCamera || !this._textureColor) {
      return;
    }
    const binding = this._manager.webglBinding;
    if (!binding) {
      return;
    }
    const texture = binding.getCameraImage(this._xrCamera);
    if (!texture) {
      return;
    }
    const device = this._manager.app.graphicsDevice;
    const gl = device.gl;
    if (!this._frameBufferSource) {
      this._frameBufferSource = gl.createFramebuffer();
      this._frameBuffer = gl.createFramebuffer();
    } else {
      const attachmentBaseConstant = gl.COLOR_ATTACHMENT0;
      const width = this._xrCamera.width;
      const height = this._xrCamera.height;
      device.setFramebuffer(this._frameBufferSource);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, texture, 0);
      device.setFramebuffer(this._frameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, this._textureColor.impl._glTexture, 0);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._frameBufferSource);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
      gl.blitFramebuffer(0, height, width, 0, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    }
  }
  _updateDepth(frame) {
    var _this$_depthInfo2, _this$_depthInfo3;
    if (!this._manager.views.availableDepth || !this._textureDepth) {
      return;
    }
    const gpu = this._manager.views.depthGpuOptimized;
    const infoSource = gpu ? this._manager.webglBinding : frame;
    if (!infoSource) {
      this._depthInfo = null;
      return;
    }
    const depthInfo = infoSource.getDepthInformation(this._xrView);
    if (!depthInfo) {
      this._depthInfo = null;
      return;
    }
    let matrixDirty = !this._depthInfo !== !depthInfo;
    this._depthInfo = depthInfo;
    const width = ((_this$_depthInfo2 = this._depthInfo) == null ? void 0 : _this$_depthInfo2.width) || 4;
    const height = ((_this$_depthInfo3 = this._depthInfo) == null ? void 0 : _this$_depthInfo3.height) || 4;
    let resized = false;
    if (this._textureDepth.width !== width || this._textureDepth.height !== height) {
      this._textureDepth._width = width;
      this._textureDepth._height = height;
      matrixDirty = true;
      resized = true;
    }
    if (matrixDirty) {
      if (this._depthInfo) {
        this._depthMatrix.data.set(this._depthInfo.normDepthBufferFromNormView.matrix);
      } else {
        this._depthMatrix.setIdentity();
      }
    }
    if (this._depthInfo) {
      if (gpu) {
        if (this._depthInfo.texture) {
          const gl = this._manager.app.graphicsDevice.gl;
          this._textureDepth.impl._glTexture = this._depthInfo.texture;
          this._textureDepth.impl._glTarget = gl.TEXTURE_2D_ARRAY;
          this._textureDepth.impl._glFormat = gl.RED;
          this._textureDepth.impl._glInternalFormat = gl.R32F;
          this._textureDepth.impl._glPixelType = gl.FLOAT;
          this._textureDepth.impl._glCreated = true;
        }
      } else {
        this._textureDepth._levels[0] = new Uint8Array(this._depthInfo.data);
        this._textureDepth.upload();
      }
    } else {
      this._textureDepth._levels[0] = this._emptyDepthBuffer;
      this._textureDepth.upload();
    }
    if (resized) this.fire("depth:resize", width, height);
  }
  updateTransforms(transform) {
    if (transform) {
      this._viewInvOffMat.mul2(transform, this._viewInvMat);
      this.viewOffMat.copy(this._viewInvOffMat).invert();
    } else {
      this._viewInvOffMat.copy(this._viewInvMat);
      this.viewOffMat.copy(this._viewMat);
    }
    this._viewMat3.setFromMat4(this._viewOffMat);
    this._projViewOffMat.mul2(this._projMat, this._viewOffMat);
    this._positionData[0] = this._viewInvOffMat.data[12];
    this._positionData[1] = this._viewInvOffMat.data[13];
    this._positionData[2] = this._viewInvOffMat.data[14];
  }
  _onDeviceLost() {
    this._frameBufferSource = null;
    this._frameBuffer = null;
    this._depthInfo = null;
  }
  getDepth(u, v) {
    var _this$_depthInfo$getD, _this$_depthInfo4;
    if (this._manager.views.depthGpuOptimized) {
      return null;
    }
    return (_this$_depthInfo$getD = (_this$_depthInfo4 = this._depthInfo) == null ? void 0 : _this$_depthInfo4.getDepthInMeters(u, v)) != null ? _this$_depthInfo$getD : null;
  }
  destroy() {
    this._depthInfo = null;
    if (this._textureColor) {
      this._textureColor.destroy();
      this._textureColor = null;
    }
    if (this._textureDepth) {
      this._textureDepth.destroy();
      this._textureDepth = null;
    }
    if (this._frameBufferSource) {
      const gl = this._manager.app.graphicsDevice.gl;
      gl.deleteFramebuffer(this._frameBufferSource);
      this._frameBufferSource = null;
      gl.deleteFramebuffer(this._frameBuffer);
      this._frameBuffer = null;
    }
  }
};
XrView.EVENT_DEPTHRESIZE = "depth:resize";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-views.js
var XrViews = class extends EventHandler {
  constructor(manager) {
    super();
    this._manager = void 0;
    this._index = /* @__PURE__ */ new Map();
    this._indexTmp = /* @__PURE__ */ new Map();
    this._list = [];
    this._supportedColor = platform.browser && !!window.XRCamera && !!window.XRWebGLBinding;
    this._supportedDepth = platform.browser && !!window.XRDepthInformation;
    this._availableColor = false;
    this._availableDepth = false;
    this._depthUsage = "";
    this._depthFormat = "";
    this._depthFormats = {
      [XRDEPTHSENSINGFORMAT_L8A8]: PIXELFORMAT_LA8,
      [XRDEPTHSENSINGFORMAT_F32]: PIXELFORMAT_R32F
    };
    this._manager = manager;
    this._manager.on("start", this._onSessionStart, this);
    this._manager.on("end", this._onSessionEnd, this);
  }
  get list() {
    return this._list;
  }
  get supportedColor() {
    return this._supportedColor;
  }
  get supportedDepth() {
    return this._supportedDepth;
  }
  get availableColor() {
    return this._availableColor;
  }
  get availableDepth() {
    return this._availableDepth;
  }
  get depthUsage() {
    return this._depthUsage;
  }
  get depthGpuOptimized() {
    return this._depthUsage === XRDEPTHSENSINGUSAGE_GPU;
  }
  get depthFormat() {
    return this._depthFormat;
  }
  get depthPixelFormat() {
    var _this$_depthFormats$t;
    return (_this$_depthFormats$t = this._depthFormats[this._depthFormat]) != null ? _this$_depthFormats$t : null;
  }
  update(frame, xrViews) {
    for (let i = 0; i < xrViews.length; i++) {
      this._indexTmp.set(xrViews[i].eye, xrViews[i]);
    }
    for (const [eye, xrView] of this._indexTmp) {
      let view = this._index.get(eye);
      if (!view) {
        view = new XrView(this._manager, xrView, xrViews.length);
        this._index.set(eye, view);
        this._list.push(view);
        view.update(frame, xrView);
        this.fire("add", view);
      } else {
        view.update(frame, xrView);
      }
    }
    for (const [eye, view] of this._index) {
      if (this._indexTmp.has(eye)) {
        continue;
      }
      view.destroy();
      this._index.delete(eye);
      const ind = this._list.indexOf(view);
      if (ind !== -1) this._list.splice(ind, 1);
      this.fire("remove", view);
    }
    this._indexTmp.clear();
  }
  get(eye) {
    return this._index.get(eye) || null;
  }
  _onSessionStart() {
    if (this._manager.type !== XRTYPE_AR) {
      return;
    }
    if (!this._manager.session.enabledFeatures) {
      return;
    }
    this._availableColor = this._manager.session.enabledFeatures.indexOf("camera-access") !== -1;
    this._availableDepth = this._manager.session.enabledFeatures.indexOf("depth-sensing") !== -1;
    if (this._availableDepth) {
      const session = this._manager.session;
      this._depthUsage = session.depthUsage;
      this._depthFormat = session.depthDataFormat;
    }
  }
  _onSessionEnd() {
    for (const view of this._index.values()) {
      view.destroy();
    }
    this._index.clear();
    this._availableColor = false;
    this._availableDepth = false;
    this._depthUsage = "";
    this._depthFormat = "";
    this._list.length = 0;
  }
};
XrViews.EVENT_ADD = "add";
XrViews.EVENT_REMOVE = "remove";

// ../node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-manager.js
var XrManager = class extends EventHandler {
  constructor(app2) {
    super();
    this.app = void 0;
    this._supported = platform.browser && !!navigator.xr;
    this._available = {};
    this._type = null;
    this._spaceType = null;
    this._session = null;
    this._baseLayer = null;
    this.webglBinding = null;
    this._referenceSpace = null;
    this.domOverlay = void 0;
    this.hitTest = void 0;
    this.imageTracking = void 0;
    this.planeDetection = void 0;
    this.meshDetection = void 0;
    this.input = void 0;
    this.lightEstimation = void 0;
    this.views = void 0;
    this.anchors = void 0;
    this._camera = null;
    this._localPosition = new Vec3();
    this._localRotation = new Quat();
    this._depthNear = 0.1;
    this._depthFar = 1e3;
    this._supportedFrameRates = null;
    this._width = 0;
    this._height = 0;
    this._framebufferScaleFactor = 1;
    this.app = app2;
    this._available[XRTYPE_INLINE] = false;
    this._available[XRTYPE_VR] = false;
    this._available[XRTYPE_AR] = false;
    this.views = new XrViews(this);
    this.domOverlay = new XrDomOverlay(this);
    this.hitTest = new XrHitTest(this);
    this.imageTracking = new XrImageTracking(this);
    this.planeDetection = new XrPlaneDetection(this);
    this.meshDetection = new XrMeshDetection(this);
    this.input = new XrInput(this);
    this.lightEstimation = new XrLightEstimation(this);
    this.anchors = new XrAnchors(this);
    this.views = new XrViews(this);
    if (this._supported) {
      navigator.xr.addEventListener("devicechange", () => {
        this._deviceAvailabilityCheck();
      });
      this._deviceAvailabilityCheck();
      this.app.graphicsDevice.on("devicelost", this._onDeviceLost, this);
      this.app.graphicsDevice.on("devicerestored", this._onDeviceRestored, this);
    }
  }
  destroy() {
  }
  start(camera, type, spaceType, options2) {
    var _options$framebufferS, _this$app$graphicsDev;
    let callback = options2;
    if (typeof options2 === "object") {
      callback = options2.callback;
    }
    if (!this._available[type]) {
      if (callback) callback(new Error("XR is not available"));
      return;
    }
    if (this._session) {
      if (callback) callback(new Error("XR session is already started"));
      return;
    }
    this._camera = camera;
    this._camera.camera.xr = this;
    this._type = type;
    this._spaceType = spaceType;
    this._framebufferScaleFactor = (_options$framebufferS = options2 == null ? void 0 : options2.framebufferScaleFactor) != null ? _options$framebufferS : 1;
    this._setClipPlanes(camera.nearClip, camera.farClip);
    const opts = {
      requiredFeatures: [spaceType],
      optionalFeatures: []
    };
    const webgl = (_this$app$graphicsDev = this.app.graphicsDevice) == null ? void 0 : _this$app$graphicsDev.isWebGL2;
    if (type === XRTYPE_AR) {
      opts.optionalFeatures.push("light-estimation");
      opts.optionalFeatures.push("hit-test");
      if (options2) {
        if (options2.imageTracking && this.imageTracking.supported) {
          opts.optionalFeatures.push("image-tracking");
        }
        if (options2.planeDetection) {
          opts.optionalFeatures.push("plane-detection");
        }
        if (options2.meshDetection) {
          opts.optionalFeatures.push("mesh-detection");
        }
      }
      if (this.domOverlay.supported && this.domOverlay.root) {
        opts.optionalFeatures.push("dom-overlay");
        opts.domOverlay = {
          root: this.domOverlay.root
        };
      }
      if (options2 && options2.anchors && this.anchors.supported) {
        opts.optionalFeatures.push("anchors");
      }
      if (options2 && options2.depthSensing && this.depthSensing.supported) {
        opts.optionalFeatures.push("depth-sensing");
        const usagePreference = [];
        const dataFormatPreference = [];
        if (!navigator.userAgent.includes("OculusBrowser")) {
          usagePreference.push(XRDEPTHSENSINGUSAGE_CPU);
          dataFormatPreference.push(XRDEPTHSENSINGFORMAT_L8A8);
          if (options2.depthSensing.usagePreference) {
            const ind = usagePreference.indexOf(options2.depthSensing.usagePreference);
            if (ind !== -1) usagePreference.splice(ind, 1);
            usagePreference.unshift(options2.depthSensing.usagePreference);
          }
          if (options2.depthSensing.dataFormatPreference) {
            const ind = dataFormatPreference.indexOf(options2.depthSensing.dataFormatPreference);
            if (ind !== -1) dataFormatPreference.splice(ind, 1);
            dataFormatPreference.unshift(options2.depthSensing.dataFormatPreference);
          }
        }
        opts.depthSensing = {
          usagePreference,
          dataFormatPreference
        };
      }
      if (webgl && options2 && options2.cameraColor && this.views.supportedColor) {
        opts.optionalFeatures.push("camera-access");
      }
    }
    opts.optionalFeatures.push("hand-tracking");
    if (options2 && options2.optionalFeatures) {
      opts.optionalFeatures = opts.optionalFeatures.concat(options2.optionalFeatures);
    }
    if (this.imageTracking.supported && this.imageTracking.images.length) {
      this.imageTracking.prepareImages((err3, trackedImages) => {
        if (err3) {
          if (callback) callback(err3);
          this.fire("error", err3);
          return;
        }
        if (trackedImages !== null) {
          opts.trackedImages = trackedImages;
        }
        this._onStartOptionsReady(type, spaceType, opts, callback);
      });
    } else {
      this._onStartOptionsReady(type, spaceType, opts, callback);
    }
  }
  _onStartOptionsReady(type, spaceType, options2, callback) {
    navigator.xr.requestSession(type, options2).then((session) => {
      this._onSessionStart(session, spaceType, callback);
    }).catch((ex) => {
      this._camera.camera.xr = null;
      this._camera = null;
      this._type = null;
      this._spaceType = null;
      if (callback) callback(ex);
      this.fire("error", ex);
    });
  }
  end(callback) {
    if (!this._session) {
      if (callback) callback(new Error("XR Session is not initialized"));
      return;
    }
    this.webglBinding = null;
    if (callback) this.once("end", callback);
    this._session.end();
  }
  isAvailable(type) {
    return this._available[type];
  }
  _deviceAvailabilityCheck() {
    for (const key in this._available) {
      this._sessionSupportCheck(key);
    }
  }
  initiateRoomCapture(callback) {
    if (!this._session) {
      callback(new Error("Session is not active"));
      return;
    }
    if (!this._session.initiateRoomCapture) {
      callback(new Error("Session does not support manual room capture"));
      return;
    }
    this._session.initiateRoomCapture().then(() => {
      if (callback) callback(null);
    }).catch((err3) => {
      if (callback) callback(err3);
    });
  }
  updateTargetFrameRate(frameRate, callback) {
    var _this$_session;
    if (!((_this$_session = this._session) != null && _this$_session.updateTargetFrameRate)) {
      callback == null || callback(new Error("unable to update frameRate"));
      return;
    }
    this._session.updateTargetFrameRate(frameRate).then(() => {
      callback == null || callback();
    }).catch((err3) => {
      callback == null || callback(err3);
    });
  }
  _sessionSupportCheck(type) {
    navigator.xr.isSessionSupported(type).then((available) => {
      if (this._available[type] === available) {
        return;
      }
      this._available[type] = available;
      this.fire("available", type, available);
      this.fire(`available:${type}`, available);
    }).catch((ex) => {
      this.fire("error", ex);
    });
  }
  _onSessionStart(session, spaceType, callback) {
    let failed = false;
    this._session = session;
    const onVisibilityChange = () => {
      this.fire("visibility:change", session.visibilityState);
    };
    const onClipPlanesChange = () => {
      this._setClipPlanes(this._camera.nearClip, this._camera.farClip);
    };
    const onEnd = () => {
      if (this._camera) {
        this._camera.off("set_nearClip", onClipPlanesChange);
        this._camera.off("set_farClip", onClipPlanesChange);
        this._camera.camera.xr = null;
        this._camera = null;
      }
      session.removeEventListener("end", onEnd);
      session.removeEventListener("visibilitychange", onVisibilityChange);
      if (!failed) this.fire("end");
      this._session = null;
      this._referenceSpace = null;
      this._width = 0;
      this._height = 0;
      this._type = null;
      this._spaceType = null;
      if (this.app.systems) {
        this.app.tick();
      }
    };
    session.addEventListener("end", onEnd);
    session.addEventListener("visibilitychange", onVisibilityChange);
    this._camera.on("set_nearClip", onClipPlanesChange);
    this._camera.on("set_farClip", onClipPlanesChange);
    this._createBaseLayer();
    if (this.session.supportedFrameRates) {
      this._supportedFrameRates = Array.from(this.session.supportedFrameRates);
    } else {
      this._supportedFrameRates = null;
    }
    this._session.addEventListener("frameratechange", () => {
      var _this$_session2;
      this.fire("frameratechange", (_this$_session2 = this._session) == null ? void 0 : _this$_session2.frameRate);
    });
    session.requestReferenceSpace(spaceType).then((referenceSpace) => {
      this._referenceSpace = referenceSpace;
      this.app.tick();
      if (callback) callback(null);
      this.fire("start");
    }).catch((ex) => {
      failed = true;
      session.end();
      if (callback) callback(ex);
      this.fire("error", ex);
    });
  }
  _setClipPlanes(near, far) {
    if (this._depthNear === near && this._depthFar === far) {
      return;
    }
    this._depthNear = near;
    this._depthFar = far;
    if (!this._session) {
      return;
    }
    this._session.updateRenderState({
      depthNear: this._depthNear,
      depthFar: this._depthFar
    });
  }
  _createBaseLayer() {
    const device = this.app.graphicsDevice;
    const framebufferScaleFactor = device.maxPixelRatio / window.devicePixelRatio * this._framebufferScaleFactor;
    this._baseLayer = new XRWebGLLayer(this._session, device.gl, {
      alpha: true,
      depth: true,
      stencil: true,
      framebufferScaleFactor,
      antialias: false
    });
    if (device != null && device.isWebGL2 && window.XRWebGLBinding) {
      try {
        this.webglBinding = new XRWebGLBinding(this._session, device.gl);
      } catch (ex) {
        this.fire("error", ex);
      }
    }
    this._session.updateRenderState({
      baseLayer: this._baseLayer,
      depthNear: this._depthNear,
      depthFar: this._depthFar
    });
  }
  _onDeviceLost() {
    if (!this._session) {
      return;
    }
    if (this.webglBinding) {
      this.webglBinding = null;
    }
    this._baseLayer = null;
    this._session.updateRenderState({
      baseLayer: this._baseLayer,
      depthNear: this._depthNear,
      depthFar: this._depthFar
    });
  }
  _onDeviceRestored() {
    if (!this._session) {
      return;
    }
    setTimeout(() => {
      this.app.graphicsDevice.gl.makeXRCompatible().then(() => {
        this._createBaseLayer();
      }).catch((ex) => {
        this.fire("error", ex);
      });
    }, 0);
  }
  update(frame) {
    if (!this._session) return false;
    const width = frame.session.renderState.baseLayer.framebufferWidth;
    const height = frame.session.renderState.baseLayer.framebufferHeight;
    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      this.app.graphicsDevice.setResolution(width, height);
    }
    const pose = frame.getViewerPose(this._referenceSpace);
    if (!pose) return false;
    const lengthOld = this.views.list.length;
    this.views.update(frame, pose.views);
    const posePosition = pose.transform.position;
    const poseOrientation = pose.transform.orientation;
    this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);
    this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);
    if (lengthOld === 0 && this.views.list.length > 0) {
      const viewProjMat2 = new Mat4();
      const view = this.views.list[0];
      viewProjMat2.copy(view.projMat);
      const data2 = viewProjMat2.data;
      const fov = 2 * Math.atan(1 / data2[5]) * 180 / Math.PI;
      const aspectRatio = data2[5] / data2[0];
      const farClip = data2[14] / (data2[10] + 1);
      const nearClip = data2[14] / (data2[10] - 1);
      const horizontalFov = false;
      const camera = this._camera.camera;
      camera.setXrProperties({
        aspectRatio,
        farClip,
        fov,
        horizontalFov,
        nearClip
      });
    }
    this._camera.camera._node.setLocalPosition(this._localPosition);
    this._camera.camera._node.setLocalRotation(this._localRotation);
    this.input.update(frame);
    if (this._type === XRTYPE_AR) {
      if (this.hitTest.supported) {
        this.hitTest.update(frame);
      }
      if (this.lightEstimation.supported) {
        this.lightEstimation.update(frame);
      }
      if (this.imageTracking.supported) {
        this.imageTracking.update(frame);
      }
      if (this.anchors.supported) {
        this.anchors.update(frame);
      }
      if (this.planeDetection.supported) {
        this.planeDetection.update(frame);
      }
      if (this.depthSensing.supported) {
        this.depthSensing.update();
      }
      if (this.meshDetection.supported) {
        this.meshDetection.update(frame);
      }
    }
    this.fire("update", frame);
    return true;
  }
  get supported() {
    return this._supported;
  }
  get active() {
    return !!this._session;
  }
  get type() {
    return this._type;
  }
  get spaceType() {
    return this._spaceType;
  }
  get session() {
    return this._session;
  }
  get frameRate() {
    var _this$_session$frameR, _this$_session3;
    return (_this$_session$frameR = (_this$_session3 = this._session) == null ? void 0 : _this$_session3.frameRate) != null ? _this$_session$frameR : null;
  }
  get supportedFrameRates() {
    return this._supportedFrameRates;
  }
  get framebufferScaleFactor() {
    return this._framebufferScaleFactor;
  }
  set fixedFoveation(value) {
    var _this$_baseLayer$fixe, _this$_baseLayer;
    if (((_this$_baseLayer$fixe = (_this$_baseLayer = this._baseLayer) == null ? void 0 : _this$_baseLayer.fixedFoveation) != null ? _this$_baseLayer$fixe : null) !== null) {
      if (this.app.graphicsDevice.samples > 1) ;
      this._baseLayer.fixedFoveation = value;
    }
  }
  get fixedFoveation() {
    var _this$_baseLayer$fixe2, _this$_baseLayer2;
    return (_this$_baseLayer$fixe2 = (_this$_baseLayer2 = this._baseLayer) == null ? void 0 : _this$_baseLayer2.fixedFoveation) != null ? _this$_baseLayer$fixe2 : null;
  }
  get camera() {
    return this._camera ? this._camera.entity : null;
  }
  get visibilityState() {
    if (!this._session) {
      return null;
    }
    return this._session.visibilityState;
  }
};
XrManager.EVENT_AVAILABLE = "available";
XrManager.EVENT_START = "start";
XrManager.EVENT_END = "end";
XrManager.EVENT_UPDATE = "update";
XrManager.EVENT_ERROR = "error";

// ../node_modules/playcanvas/build/playcanvas/src/framework/application.js
var Application = class extends AppBase {
  constructor(canvas, options2 = {}) {
    var _options$graphicsDevi;
    super(canvas);
    const appOptions = new AppOptions();
    appOptions.graphicsDevice = (_options$graphicsDevi = options2.graphicsDevice) != null ? _options$graphicsDevi : this.createDevice(canvas, options2);
    this.addComponentSystems(appOptions);
    this.addResourceHandles(appOptions);
    appOptions.elementInput = options2.elementInput;
    appOptions.keyboard = options2.keyboard;
    appOptions.mouse = options2.mouse;
    appOptions.touch = options2.touch;
    appOptions.gamepads = options2.gamepads;
    appOptions.scriptPrefix = options2.scriptPrefix;
    appOptions.assetPrefix = options2.assetPrefix;
    appOptions.scriptsOrder = options2.scriptsOrder;
    appOptions.soundManager = new SoundManager();
    appOptions.lightmapper = Lightmapper;
    appOptions.batchManager = BatchManager;
    appOptions.xr = XrManager;
    this.init(appOptions);
  }
  createDevice(canvas, options2) {
    if (!options2.graphicsDeviceOptions) {
      options2.graphicsDeviceOptions = {};
    }
    if (platform.browser && !!navigator.xr) {
      options2.graphicsDeviceOptions.xrCompatible = true;
    }
    options2.graphicsDeviceOptions.alpha = options2.graphicsDeviceOptions.alpha || false;
    return new WebglGraphicsDevice(canvas, options2.graphicsDeviceOptions);
  }
  addComponentSystems(appOptions) {
    appOptions.componentSystems = [RigidBodyComponentSystem, CollisionComponentSystem, JointComponentSystem, AnimationComponentSystem, AnimComponentSystem, ModelComponentSystem, RenderComponentSystem, CameraComponentSystem, LightComponentSystem, ScriptComponentSystem, SoundComponentSystem, AudioListenerComponentSystem, ParticleSystemComponentSystem, ScreenComponentSystem, ElementComponentSystem, ButtonComponentSystem, ScrollViewComponentSystem, ScrollbarComponentSystem, SpriteComponentSystem, LayoutGroupComponentSystem, LayoutChildComponentSystem, ZoneComponentSystem, GSplatComponentSystem];
  }
  addResourceHandles(appOptions) {
    appOptions.resourceHandlers = [RenderHandler, AnimationHandler, AnimClipHandler, AnimStateGraphHandler, ModelHandler, MaterialHandler, TextureHandler, TextHandler, JsonHandler, AudioHandler, ScriptHandler, SceneHandler, CubemapHandler, HtmlHandler, CssHandler, ShaderHandler, HierarchyHandler, FolderHandler, FontHandler, BinaryHandler, TextureAtlasHandler, SpriteHandler, TemplateHandler, ContainerHandler, GSplatHandler];
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/asset/asset-list-loader.js
var AssetListLoader = class extends EventHandler {
  constructor(assetList, assetRegistry) {
    super();
    this._assets = /* @__PURE__ */ new Set();
    this._loadingAssets = /* @__PURE__ */ new Set();
    this._waitingAssets = /* @__PURE__ */ new Set();
    this._loading = false;
    this._loaded = false;
    this._failed = [];
    this._registry = assetRegistry;
    assetList.forEach((a) => {
      if (a instanceof Asset) {
        if (!a.registry) {
          a.registry = assetRegistry;
        }
        this._assets.add(a);
      } else {
        const asset = assetRegistry.get(a);
        if (asset) {
          this._assets.add(asset);
        } else {
          this._waitForAsset(a);
        }
      }
    });
  }
  destroy() {
    this._registry.off("load", this._onLoad);
    this._registry.off("error", this._onError);
    this._waitingAssets.forEach((id13) => {
      this._registry.off(`add:${id13}`, this._onAddAsset);
    });
    this.off("progress");
    this.off("load");
  }
  _assetHasDependencies(asset) {
    var _asset$file;
    return asset.type === "model" && ((_asset$file = asset.file) == null ? void 0 : _asset$file.url) && asset.file.url && asset.file.url.match(/.json$/g);
  }
  load(done, scope) {
    if (this._loading) {
      return;
    }
    this._loading = true;
    this._callback = done;
    this._scope = scope;
    this._registry.on("load", this._onLoad, this);
    this._registry.on("error", this._onError, this);
    let loadingAssets = false;
    this._assets.forEach((asset) => {
      if (!asset.loaded) {
        loadingAssets = true;
        if (this._assetHasDependencies(asset)) {
          this._registry.loadFromUrl(asset.file.url, asset.type, (err3, loadedAsset) => {
            if (err3) {
              this._onError(err3, asset);
              return;
            }
            this._onLoad(asset);
          });
        }
        this._loadingAssets.add(asset);
        this._registry.add(asset);
      }
    });
    this._loadingAssets.forEach((asset) => {
      if (!this._assetHasDependencies(asset)) {
        this._registry.load(asset);
      }
    });
    if (!loadingAssets && this._waitingAssets.size === 0) {
      this._loadingComplete();
    }
  }
  ready(done, scope = this) {
    if (this._loaded) {
      done.call(scope, Array.from(this._assets));
    } else {
      this.once("load", (assets) => {
        done.call(scope, assets);
      });
    }
  }
  _loadingComplete() {
    if (this._loaded) return;
    this._loaded = true;
    this._registry.off("load", this._onLoad, this);
    this._registry.off("error", this._onError, this);
    if (this._failed.length) {
      if (this._callback) {
        this._callback.call(this._scope, "Failed to load some assets", this._failed);
      }
      this.fire("error", this._failed);
    } else {
      if (this._callback) {
        this._callback.call(this._scope);
      }
      this.fire("load", Array.from(this._assets));
    }
  }
  _onLoad(asset) {
    if (this._loadingAssets.has(asset)) {
      this.fire("progress", asset);
      this._loadingAssets.delete(asset);
    }
    if (this._loadingAssets.size === 0) {
      setTimeout(() => {
        this._loadingComplete();
      }, 0);
    }
  }
  _onError(err3, asset) {
    if (this._loadingAssets.has(asset)) {
      this._failed.push(asset);
      this._loadingAssets.delete(asset);
    }
    if (this._loadingAssets.size === 0) {
      setTimeout(() => {
        this._loadingComplete();
      }, 0);
    }
  }
  _onAddAsset(asset) {
    this._waitingAssets.delete(asset);
    this._assets.add(asset);
    if (!asset.loaded) {
      this._loadingAssets.add(asset);
      this._registry.load(asset);
    }
  }
  _waitForAsset(assetId) {
    this._waitingAssets.add(assetId);
    this._registry.once(`add:${assetId}`, this._onAddAsset, this);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/font/canvas-font.js
var MAX_TEXTURE_SIZE = 4096;
var DEFAULT_TEXTURE_SIZE = 512;
var Atlas = class {
  constructor(device, width, height, name) {
    this.canvas = document.createElement("canvas");
    this.canvas.width = width;
    this.canvas.height = height;
    this.texture = new Texture(device, {
      name,
      format: PIXELFORMAT_RGBA8,
      width,
      height,
      mipmaps: true,
      minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
      magFilter: FILTER_LINEAR,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      levels: [this.canvas]
    });
    this.ctx = this.canvas.getContext("2d", {
      alpha: true
    });
  }
  destroy() {
    this.texture.destroy();
  }
  clear(clearColor) {
    const {
      width,
      height
    } = this.canvas;
    this.ctx.clearRect(0, 0, width, height);
    this.ctx.fillStyle = clearColor;
    this.ctx.fillRect(0, 0, width, height);
  }
};
var CanvasFont = class extends EventHandler {
  constructor(app2, options2 = {}) {
    super();
    this.type = "bitmap";
    this.app = app2;
    this.intensity = 0;
    this.fontWeight = options2.fontWeight || "normal";
    this.fontSize = parseInt(options2.fontSize, 10);
    this.glyphSize = this.fontSize;
    this.fontName = options2.fontName || "Arial";
    this.color = options2.color || new Color(1, 1, 1);
    this.padding = options2.padding || 0;
    this.width = Math.min(MAX_TEXTURE_SIZE, options2.width || DEFAULT_TEXTURE_SIZE);
    this.height = Math.min(MAX_TEXTURE_SIZE, options2.height || DEFAULT_TEXTURE_SIZE);
    this.atlases = [];
    this.chars = "";
    this.data = {};
  }
  createTextures(text) {
    const _chars = this._normalizeCharsSet(text);
    if (_chars.length !== this.chars.length) {
      this._renderAtlas(_chars);
      return;
    }
    for (let i = 0; i < _chars.length; i++) {
      if (_chars[i] !== this.chars[i]) {
        this._renderAtlas(_chars);
        return;
      }
    }
  }
  updateTextures(text) {
    const _chars = this._normalizeCharsSet(text);
    const newCharsSet = [];
    for (let i = 0; i < _chars.length; i++) {
      const char = _chars[i];
      if (!this.data.chars[char]) {
        newCharsSet.push(char);
      }
    }
    if (newCharsSet.length > 0) {
      this._renderAtlas(this.chars.concat(newCharsSet));
    }
  }
  destroy() {
    this.atlases.forEach((atlas) => atlas.destroy());
    this.chars = null;
    this.color = null;
    this.data = null;
    this.fontName = null;
    this.fontSize = null;
    this.glyphSize = null;
    this.intensity = null;
    this.atlases = null;
    this.type = null;
    this.fontWeight = null;
  }
  _colorToRgbString(color, alpha) {
    let str;
    const r = Math.round(255 * color.r);
    const g = Math.round(255 * color.g);
    const b = Math.round(255 * color.b);
    if (alpha) {
      str = `rgba(${r}, ${g}, ${b}, ${color.a})`;
    } else {
      str = `rgb(${r}, ${g}, ${b})`;
    }
    return str;
  }
  renderCharacter(context, char, x2, y2, color) {
    context.fillStyle = color;
    context.fillText(char, x2, y2);
  }
  _getAtlas(index) {
    if (index >= this.atlases.length) {
      this.atlases[index] = new Atlas(this.app.graphicsDevice, this.width, this.height, `font-atlas-${this.fontName}-${index}`);
    }
    return this.atlases[index];
  }
  _renderAtlas(charsArray) {
    this.chars = charsArray;
    const w = this.width;
    const h2 = this.height;
    const color = this._colorToRgbString(this.color, false);
    const a = this.color.a;
    this.color.a = 1 / 255;
    const transparent = this._colorToRgbString(this.color, true);
    this.color.a = a;
    const TEXT_ALIGN = "center";
    const TEXT_BASELINE = "alphabetic";
    let atlasIndex = 0;
    let atlas = this._getAtlas(atlasIndex++);
    atlas.clear(transparent);
    this.data = this._createJson(this.chars, this.fontName, w, h2);
    const symbols = string.getSymbols(this.chars.join(""));
    let maxHeight = 0;
    let maxDescent = 0;
    const metrics = {};
    for (let i = 0; i < symbols.length; i++) {
      const ch = symbols[i];
      metrics[ch] = this._getTextMetrics(ch);
      maxHeight = Math.max(maxHeight, metrics[ch].height);
      maxDescent = Math.max(maxDescent, metrics[ch].descent);
    }
    this.glyphSize = Math.max(this.glyphSize, maxHeight);
    const sx = this.glyphSize + this.padding * 2;
    const sy = this.glyphSize + this.padding * 2;
    const _xOffset = this.glyphSize / 2 + this.padding;
    const _yOffset = sy - maxDescent - this.padding;
    let _x = 0;
    let _y = 0;
    for (let i = 0; i < symbols.length; i++) {
      const ch = symbols[i];
      const code = string.getCodePoint(symbols[i]);
      let fs3 = this.fontSize;
      atlas.ctx.font = `${this.fontWeight} ${fs3.toString()}px ${this.fontName}`;
      atlas.ctx.textAlign = TEXT_ALIGN;
      atlas.ctx.textBaseline = TEXT_BASELINE;
      let width = atlas.ctx.measureText(ch).width;
      if (width > fs3) {
        fs3 = this.fontSize * this.fontSize / width;
        atlas.ctx.font = `${this.fontWeight} ${fs3.toString()}px ${this.fontName}`;
        width = this.fontSize;
      }
      this.renderCharacter(atlas.ctx, ch, _x + _xOffset, _y + _yOffset, color);
      const xoffset = this.padding + (this.glyphSize - width) / 2;
      const yoffset = -this.padding + metrics[ch].descent - maxDescent;
      const xadvance = width;
      this._addChar(this.data, ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, atlasIndex - 1, w, h2);
      _x += sx;
      if (_x + sx > w) {
        _x = 0;
        _y += sy;
        if (_y + sy > h2) {
          atlas = this._getAtlas(atlasIndex++);
          atlas.clear(transparent);
          _y = 0;
        }
      }
    }
    this.atlases.splice(atlasIndex).forEach((atlas2) => atlas2.destroy());
    this.atlases.forEach((atlas2) => atlas2.texture.upload());
    this.fire("render");
  }
  _createJson(chars, fontName, width, height) {
    const base = {
      "version": 3,
      "intensity": this.intensity,
      "info": {
        "face": fontName,
        "width": width,
        "height": height,
        "maps": [{
          "width": width,
          "height": height
        }]
      },
      "chars": {}
    };
    return base;
  }
  _addChar(json, char, charCode, x2, y2, w, h2, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
    if (json.info.maps.length < mapNum + 1) {
      json.info.maps.push({
        "width": mapW,
        "height": mapH
      });
    }
    const scale2 = this.fontSize / 32;
    json.chars[char] = {
      "id": charCode,
      "letter": char,
      "x": x2,
      "y": y2,
      "width": w,
      "height": h2,
      "xadvance": xadvance / scale2,
      "xoffset": xoffset / scale2,
      "yoffset": (yoffset + this.padding) / scale2,
      "scale": scale2,
      "range": 1,
      "map": mapNum,
      "bounds": [0, 0, w / scale2, h2 / scale2]
    };
  }
  _normalizeCharsSet(text) {
    const unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();
    if (unicodeConverterFunc) {
      text = unicodeConverterFunc(text);
    }
    const set = {};
    const symbols = string.getSymbols(text);
    for (let i = 0; i < symbols.length; i++) {
      const ch = symbols[i];
      if (set[ch]) continue;
      set[ch] = ch;
    }
    const chars = Object.keys(set);
    return chars.sort();
  }
  _getTextMetrics(text) {
    const textSpan = document.createElement("span");
    textSpan.id = "content-span";
    textSpan.innerHTML = text;
    const block = document.createElement("div");
    block.id = "content-block";
    block.style.display = "inline-block";
    block.style.width = "1px";
    block.style.height = "0px";
    const div = document.createElement("div");
    div.appendChild(textSpan);
    div.appendChild(block);
    div.style.font = `${this.fontSize}px ${this.fontName}`;
    const body = document.body;
    body.appendChild(div);
    let ascent = -1;
    let descent = -1;
    let height = -1;
    try {
      block.style["vertical-align"] = "baseline";
      ascent = block.offsetTop - textSpan.offsetTop;
      block.style["vertical-align"] = "bottom";
      height = block.offsetTop - textSpan.offsetTop;
      descent = height - ascent;
    } finally {
      document.body.removeChild(div);
    }
    return {
      ascent,
      descent,
      height
    };
  }
  get textures() {
    return this.atlases.map((atlas) => atlas.texture);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/graphics/render-pass-picker.js
var tempMeshInstances = [];
var lights = [[], [], []];
var RenderPassPicker = class extends RenderPass {
  constructor(device, renderer) {
    super(device);
    this.viewBindGroups = [];
    this.renderer = renderer;
  }
  destroy() {
    this.viewBindGroups.forEach((bg) => {
      bg.defaultUniformBuffer.destroy();
      bg.destroy();
    });
    this.viewBindGroups.length = 0;
  }
  update(camera, scene, layers, mapping) {
    this.camera = camera;
    this.scene = scene;
    this.layers = layers;
    this.mapping = mapping;
  }
  execute() {
    const device = this.device;
    const {
      renderer,
      camera,
      scene,
      layers,
      mapping,
      renderTarget
    } = this;
    const srcLayers = scene.layers.layerList;
    const subLayerEnabled = scene.layers.subLayerEnabled;
    const isTransparent = scene.layers.subLayerList;
    for (let i = 0; i < srcLayers.length; i++) {
      const srcLayer = srcLayers[i];
      if (layers && layers.indexOf(srcLayer) < 0) {
        continue;
      }
      if (srcLayer.enabled && subLayerEnabled[i]) {
        if (srcLayer.camerasSet.has(camera.camera)) {
          const transparent = isTransparent[i];
          if (srcLayer._clearDepthBuffer) {
            renderer.clear(camera.camera, false, true, false);
          }
          const meshInstances = srcLayer.meshInstances;
          for (let j = 0; j < meshInstances.length; j++) {
            const meshInstance = meshInstances[j];
            if (meshInstance.pick && meshInstance.transparent === transparent) {
              tempMeshInstances.push(meshInstance);
              mapping.set(meshInstance.id, meshInstance);
            }
          }
          if (tempMeshInstances.length > 0) {
            const clusteredLightingEnabled = scene.clusteredLightingEnabled;
            if (clusteredLightingEnabled) {
              const lightClusters = renderer.worldClustersAllocator.empty;
              lightClusters.activate();
            }
            renderer.setCameraUniforms(camera.camera, renderTarget);
            if (device.supportsUniformBuffers) {
              renderer.setupViewUniformBuffers(this.viewBindGroups, renderer.viewUniformFormat, renderer.viewBindGroupFormat, 1);
            }
            renderer.renderForward(camera.camera, renderTarget, tempMeshInstances, lights, SHADER_PICK, (meshInstance) => {
              device.setBlendState(BlendState.NOBLEND);
            });
            tempMeshInstances.length = 0;
          }
        }
      }
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/graphics/picker.js
var tempSet2 = /* @__PURE__ */ new Set();
var _rect = new Vec4();
var Picker = class {
  constructor(app2, width, height) {
    this.renderTarget = null;
    this.mapping = /* @__PURE__ */ new Map();
    this.deviceValid = true;
    this.renderer = app2.renderer;
    this.device = app2.graphicsDevice;
    this.renderPass = new RenderPassPicker(this.device, app2.renderer);
    this.width = 0;
    this.height = 0;
    this.resize(width, height);
    this.device.on("destroy", () => {
      this.deviceValid = false;
    });
  }
  getSelection(x2, y2, width = 1, height = 1) {
    const device = this.device;
    if (device.isWebGPU) {
      return [];
    }
    y2 = this.renderTarget.height - (y2 + height);
    const rect = this.sanitizeRect(x2, y2, width, height);
    device.setRenderTarget(this.renderTarget);
    device.updateBegin();
    const pixels = new Uint8Array(4 * rect.z * rect.w);
    device.readPixels(rect.x, rect.y, rect.z, rect.w, pixels);
    device.updateEnd();
    return this.decodePixels(pixels, this.mapping);
  }
  getSelectionAsync(x2, y2, width = 1, height = 1) {
    var _this$device;
    if ((_this$device = this.device) != null && _this$device.isWebGL2) {
      y2 = this.renderTarget.height - (y2 + height);
    }
    const rect = this.sanitizeRect(x2, y2, width, height);
    return this.renderTarget.colorBuffer.read(rect.x, rect.y, rect.z, rect.w, {
      renderTarget: this.renderTarget,
      immediate: true
    }).then((pixels) => {
      return this.decodePixels(pixels, this.mapping);
    });
  }
  sanitizeRect(x2, y2, width, height) {
    const maxWidth = this.renderTarget.width;
    const maxHeight = this.renderTarget.height;
    x2 = math.clamp(Math.floor(x2), 0, maxWidth - 1);
    y2 = math.clamp(Math.floor(y2), 0, maxHeight - 1);
    width = Math.floor(Math.max(width, 1));
    width = Math.min(width, maxWidth - x2);
    height = Math.floor(Math.max(height, 1));
    height = Math.min(height, maxHeight - y2);
    return _rect.set(x2, y2, width, height);
  }
  decodePixels(pixels, mapping) {
    const selection = [];
    if (this.deviceValid) {
      const count = pixels.length;
      for (let i = 0; i < count; i += 4) {
        const r = pixels[i + 0];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const a = pixels[i + 3];
        const index = a << 24 | r << 16 | g << 8 | b;
        if (index !== -1) {
          tempSet2.add(mapping.get(index));
        }
      }
      tempSet2.forEach((meshInstance) => {
        if (meshInstance) {
          selection.push(meshInstance);
        }
      });
      tempSet2.clear();
    }
    return selection;
  }
  allocateRenderTarget() {
    const colorBuffer = new Texture(this.device, {
      format: PIXELFORMAT_RGBA8,
      width: this.width,
      height: this.height,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE,
      name: "pick"
    });
    this.renderTarget = new RenderTarget({
      colorBuffer,
      depth: true
    });
  }
  releaseRenderTarget() {
    if (this.renderTarget) {
      this.renderTarget.destroyTextureBuffers();
      this.renderTarget.destroy();
      this.renderTarget = null;
    }
  }
  prepare(camera, scene, layers) {
    if (layers instanceof Layer) {
      layers = [layers];
    }
    if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
      this.releaseRenderTarget();
      this.allocateRenderTarget();
    }
    this.mapping.clear();
    const renderPass = this.renderPass;
    renderPass.init(this.renderTarget);
    renderPass.colorOps.clearValue = Color.WHITE;
    renderPass.colorOps.clear = true;
    renderPass.depthStencilOps.clearDepth = true;
    renderPass.update(camera, scene, layers, this.mapping);
    renderPass.render();
  }
  resize(width, height) {
    this.width = Math.floor(width);
    this.height = Math.floor(height);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/handlers/scene-settings.js
var SceneSettingsHandler = class extends ResourceHandler {
  constructor(app2) {
    super(app2, "scenesettings");
  }
  load(url, callback) {
    SceneUtils.load(url, this.maxRetries, callback);
  }
  open(url, data2) {
    return data2.settings;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/framework/input/element-input.js
var targetX;
var targetY;
var vecA3 = new Vec3();
var vecB3 = new Vec3();
var rayA = new Ray();
var rayB = new Ray();
var rayC = new Ray();
rayA.end = new Vec3();
rayB.end = new Vec3();
rayC.end = new Vec3();
var _pq = new Vec3();
var _pa = new Vec3();
var _pb = new Vec3();
var _pc = new Vec3();
var _pd = new Vec3();
var _m = new Vec3();
var _au = new Vec3();
var _bv = new Vec3();
var _cw = new Vec3();
var _ir = new Vec3();
var _sct = new Vec3();
var _accumulatedScale = new Vec3();
var _paddingTop = new Vec3();
var _paddingBottom = new Vec3();
var _paddingLeft = new Vec3();
var _paddingRight = new Vec3();
var _cornerBottomLeft = new Vec3();
var _cornerBottomRight = new Vec3();
var _cornerTopRight = new Vec3();
var _cornerTopLeft = new Vec3();
var ZERO_VEC4 = new Vec4();
function scalarTriple(p12, p22, p3) {
  return _sct.cross(p12, p22).dot(p3);
}
function intersectLineQuad(p, q3, corners) {
  _pq.sub2(q3, p);
  _pa.sub2(corners[0], p);
  _pb.sub2(corners[1], p);
  _pc.sub2(corners[2], p);
  _m.cross(_pc, _pq);
  let v = _pa.dot(_m);
  let u;
  let w;
  if (v >= 0) {
    u = -_pb.dot(_m);
    if (u < 0) {
      return -1;
    }
    w = scalarTriple(_pq, _pb, _pa);
    if (w < 0) {
      return -1;
    }
    const denom = 1 / (u + v + w);
    _au.copy(corners[0]).mulScalar(u * denom);
    _bv.copy(corners[1]).mulScalar(v * denom);
    _cw.copy(corners[2]).mulScalar(w * denom);
    _ir.copy(_au).add(_bv).add(_cw);
  } else {
    _pd.sub2(corners[3], p);
    u = _pd.dot(_m);
    if (u < 0) {
      return -1;
    }
    w = scalarTriple(_pq, _pa, _pd);
    if (w < 0) {
      return -1;
    }
    v = -v;
    const denom = 1 / (u + v + w);
    _au.copy(corners[0]).mulScalar(u * denom);
    _bv.copy(corners[3]).mulScalar(v * denom);
    _cw.copy(corners[2]).mulScalar(w * denom);
    _ir.copy(_au).add(_bv).add(_cw);
  }
  if (_pq.sub2(corners[0], corners[2]).lengthSq() < 1e-4 * 1e-4) return -1;
  if (_pq.sub2(corners[1], corners[3]).lengthSq() < 1e-4 * 1e-4) return -1;
  return _ir.sub(p).lengthSq();
}
var ElementInputEvent = class {
  constructor(event, element, camera) {
    this.event = event;
    this.element = element;
    this.camera = camera;
    this._stopPropagation = false;
  }
  stopPropagation() {
    this._stopPropagation = true;
    if (this.event) {
      this.event.stopImmediatePropagation();
      this.event.stopPropagation();
    }
  }
};
var ElementMouseEvent = class extends ElementInputEvent {
  constructor(event, element, camera, x2, y2, lastX, lastY) {
    super(event, element, camera);
    this.x = x2;
    this.y = y2;
    this.ctrlKey = event.ctrlKey || false;
    this.altKey = event.altKey || false;
    this.shiftKey = event.shiftKey || false;
    this.metaKey = event.metaKey || false;
    this.button = event.button;
    if (Mouse.isPointerLocked()) {
      this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
      this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
    } else {
      this.dx = x2 - lastX;
      this.dy = y2 - lastY;
    }
    this.wheelDelta = 0;
    if (event.type === "wheel") {
      if (event.deltaY > 0) {
        this.wheelDelta = 1;
      } else if (event.deltaY < 0) {
        this.wheelDelta = -1;
      }
    }
  }
};
var ElementTouchEvent = class extends ElementInputEvent {
  constructor(event, element, camera, x2, y2, touch2) {
    super(event, element, camera);
    this.touches = event.touches;
    this.changedTouches = event.changedTouches;
    this.x = x2;
    this.y = y2;
    this.touch = touch2;
  }
};
var ElementSelectEvent = class extends ElementInputEvent {
  constructor(event, element, camera, inputSource) {
    super(event, element, camera);
    this.inputSource = inputSource;
  }
};
var ElementInput = class _ElementInput {
  constructor(domElement, options2) {
    this._app = null;
    this._attached = false;
    this._target = null;
    this._enabled = true;
    this._lastX = 0;
    this._lastY = 0;
    this._upHandler = this._handleUp.bind(this);
    this._downHandler = this._handleDown.bind(this);
    this._moveHandler = this._handleMove.bind(this);
    this._wheelHandler = this._handleWheel.bind(this);
    this._touchstartHandler = this._handleTouchStart.bind(this);
    this._touchendHandler = this._handleTouchEnd.bind(this);
    this._touchcancelHandler = this._touchendHandler;
    this._touchmoveHandler = this._handleTouchMove.bind(this);
    this._sortHandler = this._sortElements.bind(this);
    this._elements = [];
    this._hoveredElement = null;
    this._pressedElement = null;
    this._touchedElements = {};
    this._touchesForWhichTouchLeaveHasFired = {};
    this._selectedElements = {};
    this._selectedPressedElements = {};
    this._useMouse = !options2 || options2.useMouse !== false;
    this._useTouch = !options2 || options2.useTouch !== false;
    this._useXr = !options2 || options2.useXr !== false;
    this._selectEventsAttached = false;
    if (platform.touch) {
      this._clickedEntities = {};
    }
    this.attach(domElement);
  }
  set enabled(value) {
    this._enabled = value;
  }
  get enabled() {
    return this._enabled;
  }
  set app(value) {
    this._app = value;
  }
  get app() {
    return this._app || getApplication();
  }
  attach(domElement) {
    if (this._attached) {
      this._attached = false;
      this.detach();
    }
    this._target = domElement;
    this._attached = true;
    const opts = platform.passiveEvents ? {
      passive: true
    } : false;
    if (this._useMouse) {
      window.addEventListener("mouseup", this._upHandler, opts);
      window.addEventListener("mousedown", this._downHandler, opts);
      window.addEventListener("mousemove", this._moveHandler, opts);
      window.addEventListener("wheel", this._wheelHandler, opts);
    }
    if (this._useTouch && platform.touch) {
      this._target.addEventListener("touchstart", this._touchstartHandler, opts);
      this._target.addEventListener("touchend", this._touchendHandler, false);
      this._target.addEventListener("touchmove", this._touchmoveHandler, false);
      this._target.addEventListener("touchcancel", this._touchcancelHandler, false);
    }
    this.attachSelectEvents();
  }
  attachSelectEvents() {
    if (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
      if (!this._clickedEntities) {
        this._clickedEntities = {};
      }
      this._selectEventsAttached = true;
      this.app.xr.on("start", this._onXrStart, this);
    }
  }
  detach() {
    if (!this._attached) return;
    this._attached = false;
    const opts = platform.passiveEvents ? {
      passive: true
    } : false;
    if (this._useMouse) {
      window.removeEventListener("mouseup", this._upHandler, opts);
      window.removeEventListener("mousedown", this._downHandler, opts);
      window.removeEventListener("mousemove", this._moveHandler, opts);
      window.removeEventListener("wheel", this._wheelHandler, opts);
    }
    if (this._useTouch) {
      this._target.removeEventListener("touchstart", this._touchstartHandler, opts);
      this._target.removeEventListener("touchend", this._touchendHandler, false);
      this._target.removeEventListener("touchmove", this._touchmoveHandler, false);
      this._target.removeEventListener("touchcancel", this._touchcancelHandler, false);
    }
    if (this._selectEventsAttached) {
      this._selectEventsAttached = false;
      this.app.xr.off("start", this._onXrStart, this);
      this.app.xr.off("end", this._onXrEnd, this);
      this.app.xr.off("update", this._onXrUpdate, this);
      this.app.xr.input.off("selectstart", this._onSelectStart, this);
      this.app.xr.input.off("selectend", this._onSelectEnd, this);
      this.app.xr.input.off("remove", this._onXrInputRemove, this);
    }
    this._target = null;
  }
  addElement(element) {
    if (this._elements.indexOf(element) === -1) {
      this._elements.push(element);
    }
  }
  removeElement(element) {
    const idx = this._elements.indexOf(element);
    if (idx !== -1) {
      this._elements.splice(idx, 1);
    }
  }
  _handleUp(event) {
    if (!this._enabled) return;
    if (Mouse.isPointerLocked()) {
      return;
    }
    this._calcMouseCoords(event);
    this._onElementMouseEvent("mouseup", event);
  }
  _handleDown(event) {
    if (!this._enabled) return;
    if (Mouse.isPointerLocked()) {
      return;
    }
    this._calcMouseCoords(event);
    this._onElementMouseEvent("mousedown", event);
  }
  _handleMove(event) {
    if (!this._enabled) return;
    this._calcMouseCoords(event);
    this._onElementMouseEvent("mousemove", event);
    this._lastX = targetX;
    this._lastY = targetY;
  }
  _handleWheel(event) {
    if (!this._enabled) return;
    this._calcMouseCoords(event);
    this._onElementMouseEvent("mousewheel", event);
  }
  _determineTouchedElements(event) {
    const touchedElements = {};
    const cameras = this.app.systems.camera.cameras;
    for (let i = cameras.length - 1; i >= 0; i--) {
      const camera = cameras[i];
      let done = 0;
      const len = event.changedTouches.length;
      for (let j = 0; j < len; j++) {
        if (touchedElements[event.changedTouches[j].identifier]) {
          done++;
          continue;
        }
        const coords = getTouchTargetCoords(event.changedTouches[j]);
        const element = this._getTargetElementByCoords(camera, coords.x, coords.y);
        if (element) {
          done++;
          touchedElements[event.changedTouches[j].identifier] = {
            element,
            camera,
            x: coords.x,
            y: coords.y
          };
        }
      }
      if (done === len) {
        break;
      }
    }
    return touchedElements;
  }
  _handleTouchStart(event) {
    if (!this._enabled) return;
    const newTouchedElements = this._determineTouchedElements(event);
    for (let i = 0, len = event.changedTouches.length; i < len; i++) {
      const touch2 = event.changedTouches[i];
      const newTouchInfo = newTouchedElements[touch2.identifier];
      const oldTouchInfo = this._touchedElements[touch2.identifier];
      if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
        this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch2));
        this._touchesForWhichTouchLeaveHasFired[touch2.identifier] = false;
      }
    }
    for (const touchId in newTouchedElements) {
      this._touchedElements[touchId] = newTouchedElements[touchId];
    }
  }
  _handleTouchEnd(event) {
    if (!this._enabled) return;
    const cameras = this.app.systems.camera.cameras;
    for (const key in this._clickedEntities) {
      delete this._clickedEntities[key];
    }
    for (let i = 0, len = event.changedTouches.length; i < len; i++) {
      const touch2 = event.changedTouches[i];
      const touchInfo = this._touchedElements[touch2.identifier];
      if (!touchInfo) {
        continue;
      }
      const element = touchInfo.element;
      const camera = touchInfo.camera;
      const x2 = touchInfo.x;
      const y2 = touchInfo.y;
      delete this._touchedElements[touch2.identifier];
      delete this._touchesForWhichTouchLeaveHasFired[touch2.identifier];
      const coords = getTouchTargetCoords(touch2);
      for (let c2 = cameras.length - 1; c2 >= 0; c2--) {
        const hovered = this._getTargetElementByCoords(cameras[c2], coords.x, coords.y);
        if (hovered === element) {
          if (!this._clickedEntities[element.entity.getGuid()]) {
            this._fireEvent("click", new ElementTouchEvent(event, element, camera, x2, y2, touch2));
            this._clickedEntities[element.entity.getGuid()] = Date.now();
          }
        }
      }
      this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x2, y2, touch2));
    }
  }
  _handleTouchMove(event) {
    event.preventDefault();
    if (!this._enabled) return;
    const newTouchedElements = this._determineTouchedElements(event);
    for (let i = 0, len = event.changedTouches.length; i < len; i++) {
      const touch2 = event.changedTouches[i];
      const newTouchInfo = newTouchedElements[touch2.identifier];
      const oldTouchInfo = this._touchedElements[touch2.identifier];
      if (oldTouchInfo) {
        const coords = getTouchTargetCoords(touch2);
        if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch2.identifier]) {
          this._fireEvent("touchleave", new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch2));
          this._touchesForWhichTouchLeaveHasFired[touch2.identifier] = true;
        }
        this._fireEvent("touchmove", new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch2));
      }
    }
  }
  _onElementMouseEvent(eventType, event) {
    let element = null;
    const lastHovered = this._hoveredElement;
    this._hoveredElement = null;
    const cameras = this.app.systems.camera.cameras;
    let camera;
    for (let i = cameras.length - 1; i >= 0; i--) {
      camera = cameras[i];
      element = this._getTargetElementByCoords(camera, targetX, targetY);
      if (element) {
        break;
      }
    }
    this._hoveredElement = element;
    if ((eventType === "mousemove" || eventType === "mouseup") && this._pressedElement) {
      this._fireEvent(eventType, new ElementMouseEvent(event, this._pressedElement, camera, targetX, targetY, this._lastX, this._lastY));
    } else if (element) {
      this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));
      if (eventType === "mousedown") {
        this._pressedElement = element;
      }
    }
    if (lastHovered !== this._hoveredElement) {
      if (lastHovered) {
        this._fireEvent("mouseleave", new ElementMouseEvent(event, lastHovered, camera, targetX, targetY, this._lastX, this._lastY));
      }
      if (this._hoveredElement) {
        this._fireEvent("mouseenter", new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
      }
    }
    if (eventType === "mouseup" && this._pressedElement) {
      if (this._pressedElement === this._hoveredElement) {
        const guid2 = this._hoveredElement.entity.getGuid();
        let fireClick = !this._clickedEntities;
        if (this._clickedEntities) {
          const lastTouchUp = this._clickedEntities[guid2] || 0;
          const dt = Date.now() - lastTouchUp;
          fireClick = dt > 300;
          delete this._clickedEntities[guid2];
        }
        if (fireClick) {
          this._fireEvent("click", new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
        }
      }
      this._pressedElement = null;
    }
  }
  _onXrStart() {
    this.app.xr.on("end", this._onXrEnd, this);
    this.app.xr.on("update", this._onXrUpdate, this);
    this.app.xr.input.on("selectstart", this._onSelectStart, this);
    this.app.xr.input.on("selectend", this._onSelectEnd, this);
    this.app.xr.input.on("remove", this._onXrInputRemove, this);
  }
  _onXrEnd() {
    this.app.xr.off("update", this._onXrUpdate, this);
    this.app.xr.input.off("selectstart", this._onSelectStart, this);
    this.app.xr.input.off("selectend", this._onSelectEnd, this);
    this.app.xr.input.off("remove", this._onXrInputRemove, this);
  }
  _onXrUpdate() {
    if (!this._enabled) return;
    const inputSources = this.app.xr.input.inputSources;
    for (let i = 0; i < inputSources.length; i++) {
      this._onElementSelectEvent("selectmove", inputSources[i], null);
    }
  }
  _onXrInputRemove(inputSource) {
    const hovered = this._selectedElements[inputSource.id];
    if (hovered) {
      inputSource._elementEntity = null;
      this._fireEvent("selectleave", new ElementSelectEvent(null, hovered, null, inputSource));
    }
    delete this._selectedElements[inputSource.id];
    delete this._selectedPressedElements[inputSource.id];
  }
  _onSelectStart(inputSource, event) {
    if (!this._enabled) return;
    this._onElementSelectEvent("selectstart", inputSource, event);
  }
  _onSelectEnd(inputSource, event) {
    if (!this._enabled) return;
    this._onElementSelectEvent("selectend", inputSource, event);
  }
  _onElementSelectEvent(eventType, inputSource, event) {
    let element;
    const hoveredBefore = this._selectedElements[inputSource.id];
    let hoveredNow;
    const cameras = this.app.systems.camera.cameras;
    let camera;
    if (inputSource.elementInput) {
      rayC.set(inputSource.getOrigin(), inputSource.getDirection());
      for (let i = cameras.length - 1; i >= 0; i--) {
        camera = cameras[i];
        element = this._getTargetElementByRay(rayC, camera);
        if (element) {
          break;
        }
      }
    }
    inputSource._elementEntity = element || null;
    if (element) {
      this._selectedElements[inputSource.id] = element;
      hoveredNow = element;
    } else {
      delete this._selectedElements[inputSource.id];
    }
    if (hoveredBefore !== hoveredNow) {
      if (hoveredBefore) this._fireEvent("selectleave", new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
      if (hoveredNow) this._fireEvent("selectenter", new ElementSelectEvent(event, hoveredNow, camera, inputSource));
    }
    const pressed = this._selectedPressedElements[inputSource.id];
    if (eventType === "selectmove" && pressed) {
      this._fireEvent("selectmove", new ElementSelectEvent(event, pressed, camera, inputSource));
    }
    if (eventType === "selectstart") {
      this._selectedPressedElements[inputSource.id] = hoveredNow;
      if (hoveredNow) this._fireEvent("selectstart", new ElementSelectEvent(event, hoveredNow, camera, inputSource));
    }
    if (!inputSource.elementInput && pressed) {
      delete this._selectedPressedElements[inputSource.id];
      if (hoveredBefore) {
        this._fireEvent("selectend", new ElementSelectEvent(event, pressed, camera, inputSource));
      }
    }
    if (eventType === "selectend" && inputSource.elementInput) {
      delete this._selectedPressedElements[inputSource.id];
      if (pressed) {
        this._fireEvent("selectend", new ElementSelectEvent(event, pressed, camera, inputSource));
      }
      if (pressed && pressed === hoveredBefore) {
        this._fireEvent("click", new ElementSelectEvent(event, pressed, camera, inputSource));
      }
    }
  }
  _fireEvent(name, evt) {
    let element = evt.element;
    while (true) {
      element.fire(name, evt);
      if (evt._stopPropagation) {
        break;
      }
      if (!element.entity.parent) {
        break;
      }
      element = element.entity.parent.element;
      if (!element) {
        break;
      }
    }
  }
  _calcMouseCoords(event) {
    const rect = this._target.getBoundingClientRect();
    const left = Math.floor(rect.left);
    const top = Math.floor(rect.top);
    targetX = event.clientX - left;
    targetY = event.clientY - top;
  }
  _sortElements(a, b) {
    const layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
    if (layerOrder !== 0) return layerOrder;
    if (a.screen && !b.screen) {
      return -1;
    }
    if (!a.screen && b.screen) {
      return 1;
    }
    if (!a.screen && !b.screen) {
      return 0;
    }
    if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) {
      return -1;
    }
    if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) {
      return 1;
    }
    return b.drawOrder - a.drawOrder;
  }
  _getTargetElementByCoords(camera, x2, y2) {
    const rayScreen = this._calculateRayScreen(x2, y2, camera, rayA) ? rayA : null;
    const ray3d = this._calculateRay3d(x2, y2, camera, rayB) ? rayB : null;
    return this._getTargetElement(camera, rayScreen, ray3d);
  }
  _getTargetElementByRay(ray, camera) {
    rayA.origin.copy(ray.origin);
    rayA.direction.copy(ray.direction);
    rayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);
    const ray3d = rayA;
    const screenPos = camera.worldToScreen(ray3d.origin, vecA3);
    const rayScreen = this._calculateRayScreen(screenPos.x, screenPos.y, camera, rayB) ? rayB : null;
    return this._getTargetElement(camera, rayScreen, ray3d);
  }
  _getTargetElement(camera, rayScreen, ray3d) {
    let result = null;
    let closestDistance3d = Infinity;
    this._elements.sort(this._sortHandler);
    for (let i = 0, len = this._elements.length; i < len; i++) {
      const element = this._elements[i];
      if (!element.layers.some((v) => camera.layersSet.has(v))) {
        continue;
      }
      if (element.screen && element.screen.screen.screenSpace) {
        if (!rayScreen) {
          continue;
        }
        const currentDistance = this._checkElement(rayScreen, element, true);
        if (currentDistance >= 0) {
          result = element;
          break;
        }
      } else {
        if (!ray3d) {
          continue;
        }
        const currentDistance = this._checkElement(ray3d, element, false);
        if (currentDistance >= 0) {
          if (currentDistance < closestDistance3d) {
            result = element;
            closestDistance3d = currentDistance;
          }
          if (element.screen) {
            result = element;
            break;
          }
        }
      }
    }
    return result;
  }
  _calculateRayScreen(x2, y2, camera, ray) {
    const sw = this.app.graphicsDevice.width;
    const sh = this.app.graphicsDevice.height;
    const cameraWidth = camera.rect.z * sw;
    const cameraHeight = camera.rect.w * sh;
    const cameraLeft = camera.rect.x * sw;
    const cameraRight = cameraLeft + cameraWidth;
    const cameraBottom = (1 - camera.rect.y) * sh;
    const cameraTop = cameraBottom - cameraHeight;
    let _x = x2 * sw / this._target.clientWidth;
    let _y = y2 * sh / this._target.clientHeight;
    if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
      _x = sw * (_x - cameraLeft) / cameraWidth;
      _y = sh * (_y - cameraTop) / cameraHeight;
      _y = sh - _y;
      ray.origin.set(_x, _y, 1);
      ray.direction.set(0, 0, -1);
      ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);
      return true;
    }
    return false;
  }
  _calculateRay3d(x2, y2, camera, ray) {
    const sw = this._target.clientWidth;
    const sh = this._target.clientHeight;
    const cameraWidth = camera.rect.z * sw;
    const cameraHeight = camera.rect.w * sh;
    const cameraLeft = camera.rect.x * sw;
    const cameraRight = cameraLeft + cameraWidth;
    const cameraBottom = (1 - camera.rect.y) * sh;
    const cameraTop = cameraBottom - cameraHeight;
    let _x = x2;
    let _y = y2;
    if (x2 >= cameraLeft && x2 <= cameraRight && y2 <= cameraBottom && _y >= cameraTop) {
      _x = sw * (_x - cameraLeft) / cameraWidth;
      _y = sh * (_y - cameraTop) / cameraHeight;
      camera.screenToWorld(_x, _y, camera.nearClip, vecA3);
      camera.screenToWorld(_x, _y, camera.farClip, vecB3);
      ray.origin.copy(vecA3);
      ray.direction.set(0, 0, -1);
      ray.end.copy(vecB3);
      return true;
    }
    return false;
  }
  _checkElement(ray, element, screen) {
    if (element.maskedBy) {
      if (this._checkElement(ray, element.maskedBy.element, screen) < 0) {
        return -1;
      }
    }
    let scale2;
    if (screen) {
      scale2 = _ElementInput.calculateScaleToScreen(element);
    } else {
      scale2 = _ElementInput.calculateScaleToWorld(element);
    }
    const corners = _ElementInput.buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale2);
    return intersectLineQuad(ray.origin, ray.end, corners);
  }
  static buildHitCorners(element, screenOrWorldCorners, scale2) {
    let hitCorners = screenOrWorldCorners;
    const button = element.entity && element.entity.button;
    if (button) {
      const hitPadding = element.entity.button.hitPadding || ZERO_VEC4;
      _paddingTop.copy(element.entity.up);
      _paddingBottom.copy(_paddingTop).mulScalar(-1);
      _paddingRight.copy(element.entity.right);
      _paddingLeft.copy(_paddingRight).mulScalar(-1);
      _paddingTop.mulScalar(hitPadding.w * scale2.y);
      _paddingBottom.mulScalar(hitPadding.y * scale2.y);
      _paddingRight.mulScalar(hitPadding.z * scale2.x);
      _paddingLeft.mulScalar(hitPadding.x * scale2.x);
      _cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);
      _cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);
      _cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);
      _cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);
      hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
    }
    if (scale2.x < 0) {
      const left = hitCorners[2].x;
      const right = hitCorners[0].x;
      hitCorners[0].x = left;
      hitCorners[1].x = right;
      hitCorners[2].x = right;
      hitCorners[3].x = left;
    }
    if (scale2.y < 0) {
      const bottom = hitCorners[2].y;
      const top = hitCorners[0].y;
      hitCorners[0].y = bottom;
      hitCorners[1].y = bottom;
      hitCorners[2].y = top;
      hitCorners[3].y = top;
    }
    if (scale2.z < 0) {
      const x2 = hitCorners[2].x;
      const y2 = hitCorners[2].y;
      const z2 = hitCorners[2].z;
      hitCorners[2].x = hitCorners[0].x;
      hitCorners[2].y = hitCorners[0].y;
      hitCorners[2].z = hitCorners[0].z;
      hitCorners[0].x = x2;
      hitCorners[0].y = y2;
      hitCorners[0].z = z2;
    }
    return hitCorners;
  }
  static calculateScaleToScreen(element) {
    let current = element.entity;
    const screenScale = element.screen.screen.scale;
    _accumulatedScale.set(screenScale, screenScale, screenScale);
    while (current && !current.screen) {
      _accumulatedScale.mul(current.getLocalScale());
      current = current.parent;
    }
    return _accumulatedScale;
  }
  static calculateScaleToWorld(element) {
    let current = element.entity;
    _accumulatedScale.set(1, 1, 1);
    while (current) {
      _accumulatedScale.mul(current.getLocalScale());
      current = current.parent;
    }
    return _accumulatedScale;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/deprecated/deprecated.js
Vec2.prototype.scale = Vec2.prototype.mulScalar;
Vec3.prototype.scale = Vec3.prototype.mulScalar;
Vec4.prototype.scale = Vec4.prototype.mulScalar;
var PIXELFORMAT_L8_A8 = PIXELFORMAT_LA8;
var PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_RGB565;
var PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_RGBA5551;
var PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_RGBA4;
var PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_RGB8;
var PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_RGBA8;
var PIXELFORMAT_SRGB = PIXELFORMAT_SRGB8;
var PIXELFORMAT_SRGBA = PIXELFORMAT_SRGBA8;
var BLENDMODE_CONSTANT_COLOR = BLENDMODE_CONSTANT;
var BLENDMODE_ONE_MINUS_CONSTANT_COLOR = BLENDMODE_ONE_MINUS_CONSTANT;
var BLENDMODE_CONSTANT_ALPHA = BLENDMODE_CONSTANT;
var BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = BLENDMODE_ONE_MINUS_CONSTANT;
var _viewport4 = new Vec4();
function createSphere(device, opts) {
  return Mesh.fromGeometry(device, new SphereGeometry(opts));
}
function createPlane(device, opts) {
  return Mesh.fromGeometry(device, new PlaneGeometry(opts));
}
function createBox(device, opts) {
  return Mesh.fromGeometry(device, new BoxGeometry(opts));
}
function createTorus(device, opts) {
  return Mesh.fromGeometry(device, new TorusGeometry(opts));
}
function createCapsule(device, opts) {
  return Mesh.fromGeometry(device, new CapsuleGeometry(opts));
}
function createCone(device, opts) {
  return Mesh.fromGeometry(device, new ConeGeometry(opts));
}
function createCylinder(device, opts) {
  return Mesh.fromGeometry(device, new CylinderGeometry(opts));
}
function createMesh2(device, positions, opts = {}) {
  const geom = new Geometry();
  geom.positions = positions;
  geom.normals = opts.normals;
  geom.tangents = opts.tangents;
  geom.colors = opts.colors;
  geom.uvs = opts.uvs;
  geom.uvs1 = opts.uvs1;
  geom.blendIndices = opts.blendIndices;
  geom.blendWeights = opts.blendWeights;
  geom.indices = opts.indices;
  return Mesh.fromGeometry(device, geom, opts);
}
function drawFullscreenQuad(device, target2, vertexBuffer, shader, rect) {
  let viewport2;
  if (rect) {
    const w = target2 ? target2.width : device.width;
    const h2 = target2 ? target2.height : device.height;
    viewport2 = _viewport4.set(rect.x * w, rect.y * h2, rect.z * w, rect.w * h2);
  }
  drawQuadWithShader(device, target2, shader, viewport2);
}
var deprecatedChunks = {
  "ambientPrefilteredCube.frag": "ambientEnv.frag",
  "ambientPrefilteredCubeLod.frag": "ambientEnv.frag",
  "dpAtlasQuad.frag": null,
  "genParaboloid.frag": null,
  "prefilterCubemap.frag": null,
  "reflectionDpAtlas.frag": "reflectionEnv.frag",
  "reflectionPrefilteredCube.frag": "reflectionEnv.frag",
  "reflectionPrefilteredCubeLod.frag": "reflectionEnv.frag"
};
Object.keys(deprecatedChunks).forEach((chunkName) => {
  Object.defineProperty(shaderChunks, chunkName, {
    get: function() {
      return null;
    },
    set: function() {
    }
  });
});
Object.defineProperties(RenderTarget.prototype, {
  _glFrameBuffer: {
    get: function() {
      return this.impl._glFrameBuffer;
    },
    set: function(rgbm) {
    }
  }
});
Object.defineProperty(VertexFormat, "defaultInstancingFormat", {
  get: function() {
    return null;
  }
});
Object.defineProperties(Texture.prototype, {
  rgbm: {
    get: function() {
      return this.type === TEXTURETYPE_RGBM;
    },
    set: function(rgbm) {
      this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
    }
  },
  swizzleGGGR: {
    get: function() {
      return this.type === TEXTURETYPE_SWIZZLEGGGR;
    },
    set: function(swizzleGGGR) {
      this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
    }
  },
  _glTexture: {
    get: function() {
      return this.impl._glTexture;
    }
  }
});
Object.defineProperty(GraphicsDevice.prototype, "boneLimit", {
  get: function() {
    return 1024;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "webgl2", {
  get: function() {
    return this.isWebGL2;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "textureFloatHighPrecision", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "extBlendMinmax", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "extTextureHalfFloat", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "extTextureLod", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "textureHalfFloatFilterable", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "supportsMrt", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "supportsVolumeTextures", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "supportsInstancing", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "textureHalfFloatUpdatable", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "extTextureFloat", {
  get: function() {
    return true;
  }
});
Object.defineProperty(GraphicsDevice.prototype, "extStandardDerivatives", {
  get: function() {
    return true;
  }
});
BlendState.DEFAULT = Object.freeze(new BlendState());
var _tempBlendState = new BlendState();
var _tempDepthState = new DepthState();
GraphicsDevice.prototype.setBlendFunction = function(blendSrc, blendDst) {
  const currentBlendState = this.blendState;
  _tempBlendState.copy(currentBlendState);
  _tempBlendState.setColorBlend(currentBlendState.colorOp, blendSrc, blendDst);
  _tempBlendState.setAlphaBlend(currentBlendState.alphaOp, blendSrc, blendDst);
  this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setBlendFunctionSeparate = function(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
  const currentBlendState = this.blendState;
  _tempBlendState.copy(currentBlendState);
  _tempBlendState.setColorBlend(currentBlendState.colorOp, blendSrc, blendDst);
  _tempBlendState.setAlphaBlend(currentBlendState.alphaOp, blendSrcAlpha, blendDstAlpha);
  this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setBlendEquation = function(blendEquation) {
  const currentBlendState = this.blendState;
  _tempBlendState.copy(currentBlendState);
  _tempBlendState.setColorBlend(blendEquation, currentBlendState.colorSrcFactor, currentBlendState.colorDstFactor);
  _tempBlendState.setAlphaBlend(blendEquation, currentBlendState.alphaSrcFactor, currentBlendState.alphaDstFactor);
  this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setBlendEquationSeparate = function(blendEquation, blendAlphaEquation) {
  const currentBlendState = this.blendState;
  _tempBlendState.copy(currentBlendState);
  _tempBlendState.setColorBlend(blendEquation, currentBlendState.colorSrcFactor, currentBlendState.colorDstFactor);
  _tempBlendState.setAlphaBlend(blendAlphaEquation, currentBlendState.alphaSrcFactor, currentBlendState.alphaDstFactor);
  this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setColorWrite = function(redWrite, greenWrite, blueWrite, alphaWrite) {
  const currentBlendState = this.blendState;
  _tempBlendState.copy(currentBlendState);
  _tempBlendState.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);
  this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.getBlending = function() {
  return this.blendState.blend;
};
GraphicsDevice.prototype.setBlending = function(blending) {
  _tempBlendState.copy(this.blendState);
  _tempBlendState.blend = blending;
  this.setBlendState(_tempBlendState);
};
GraphicsDevice.prototype.setDepthWrite = function(write) {
  _tempDepthState.copy(this.depthState);
  _tempDepthState.write = write;
  this.setDepthState(_tempDepthState);
};
GraphicsDevice.prototype.setDepthFunc = function(func) {
  _tempDepthState.copy(this.depthState);
  _tempDepthState.func = func;
  this.setDepthState(_tempDepthState);
};
GraphicsDevice.prototype.setDepthTest = function(test) {
  _tempDepthState.copy(this.depthState);
  _tempDepthState.test = test;
  this.setDepthState(_tempDepthState);
};
GraphicsDevice.prototype.getCullMode = function() {
  return this.cullMode;
};
var LitOptions = LitShaderOptions;
Object.defineProperty(Scene.prototype, "defaultMaterial", {
  get: function() {
    return getDefaultMaterial(getApplication().graphicsDevice);
  }
});
Object.defineProperty(Scene.prototype, "toneMapping", {
  set: function(value) {
    this.rendering.toneMapping = value;
  },
  get: function() {
    return this.rendering.toneMapping;
  }
});
Object.defineProperty(Scene.prototype, "gammaCorrection", {
  set: function(value) {
    this.rendering.gammaCorrection = value;
  },
  get: function() {
    return this.rendering.gammaCorrection;
  }
});
Object.defineProperty(LayerComposition.prototype, "_meshInstances", {
  get: function() {
    return null;
  }
});
Object.defineProperty(Scene.prototype, "drawCalls", {
  get: function() {
    return null;
  }
});
["128", "64", "32", "16", "8", "4"].forEach((size, index) => {
  Object.defineProperty(Scene.prototype, `skyboxPrefiltered${size}`, {
    get: function() {
      return this._prefilteredCubemaps[index];
    },
    set: function(value) {
      this._prefilteredCubemaps[index] = value;
      this.updateShaders = true;
    }
  });
});
Object.defineProperty(Scene.prototype, "models", {
  get: function() {
    if (!this._models) {
      this._models = [];
    }
    return this._models;
  }
});
function _removedLayerProperty(name) {
  Object.defineProperty(Layer.prototype, name, {
    set: function(value) {
    },
    get: function() {
      return void 0;
    }
  });
}
_removedLayerProperty("renderTarget");
_removedLayerProperty("onPreCull");
_removedLayerProperty("onPreRender");
_removedLayerProperty("onPreRenderOpaque");
_removedLayerProperty("onPreRenderTransparent");
_removedLayerProperty("onPostCull");
_removedLayerProperty("onPostRender");
_removedLayerProperty("onPostRenderOpaque");
_removedLayerProperty("onPostRenderTransparent");
_removedLayerProperty("onDrawCall");
_removedLayerProperty("layerReference");
Object.defineProperty(Batch.prototype, "model", {
  get: function() {
    return null;
  }
});
ForwardRenderer.prototype.renderComposition = function(comp) {
  getApplication().renderComposition(comp);
};
MeshInstance.prototype.syncAabb = function() {
};
Morph.prototype.getTarget = function(index) {
  return this.targets[index];
};
GraphNode.prototype.getChildren = function() {
  return this.children;
};
GraphNode.prototype.getName = function() {
  return this.name;
};
GraphNode.prototype.getPath = function() {
  return this.path;
};
GraphNode.prototype.getRoot = function() {
  return this.root;
};
GraphNode.prototype.getParent = function() {
  return this.parent;
};
GraphNode.prototype.setName = function(name) {
  this.name = name;
};
Object.defineProperty(Material.prototype, "shader", {
  set: function(value) {
  },
  get: function() {
    return null;
  }
});
Object.defineProperty(Material.prototype, "blend", {
  set: function(value) {
    this.blendState.blend = value;
  },
  get: function() {
    return this.blendState.blend;
  }
});
Object.defineProperty(StandardMaterial.prototype, "shininess", {
  get: function() {
    return this.gloss * 100;
  },
  set: function(value) {
    this.gloss = value * 0.01;
  }
});
Object.defineProperty(StandardMaterial.prototype, "useGammaTonemap", {
  get: function() {
    return this.useTonemap;
  },
  set: function(value) {
    this.useTonemap = value;
  }
});
function _defineAlias(newName, oldName) {
  Object.defineProperty(StandardMaterial.prototype, oldName, {
    get: function() {
      return this[newName];
    },
    set: function(value) {
      this[newName] = value;
    }
  });
}
function _deprecateTint(name) {
  Object.defineProperty(StandardMaterial.prototype, name, {
    get: function() {
      return true;
    },
    set: function(value) {
    }
  });
}
_deprecateTint("sheenTint");
_deprecateTint("diffuseTint");
_deprecateTint("emissiveTint");
_deprecateTint("ambientTint");
_defineAlias("specularTint", "specularMapTint");
_defineAlias("aoVertexColor", "aoMapVertexColor");
_defineAlias("diffuseVertexColor", "diffuseMapVertexColor");
_defineAlias("specularVertexColor", "specularMapVertexColor");
_defineAlias("emissiveVertexColor", "emissiveMapVertexColor");
_defineAlias("metalnessVertexColor", "metalnessMapVertexColor");
_defineAlias("glossVertexColor", "glossMapVertexColor");
_defineAlias("opacityVertexColor", "opacityMapVertexColor");
_defineAlias("lightVertexColor", "lightMapVertexColor");
_defineAlias("sheenGloss", "sheenGlossiess");
_defineAlias("clearCoatGloss", "clearCostGlossiness");
function _defineOption(name, newName) {
  if (name !== "pass") {
    Object.defineProperty(StandardMaterialOptions.prototype, name, {
      get: function() {
        return this.litOptions[newName || name];
      },
      set: function(value) {
        this.litOptions[newName || name] = value;
      }
    });
  }
}
_defineOption("refraction", "useRefraction");
var tempOptions = new LitShaderOptions();
var litOptionProperties = Object.getOwnPropertyNames(tempOptions);
for (const litOption in litOptionProperties) {
  _defineOption(litOptionProperties[litOption]);
}
AssetRegistry.prototype.getAssetById = function(id13) {
  return this.get(id13);
};
Object.defineProperty(XrInputSource.prototype, "ray", {
  get: function() {
    return this._rayLocal;
  }
});
Object.defineProperty(XrInputSource.prototype, "position", {
  get: function() {
    return this._localPosition;
  }
});
Object.defineProperty(XrInputSource.prototype, "rotation", {
  get: function() {
    return this._localRotation;
  }
});
Object.defineProperty(ElementInput.prototype, "wheel", {
  get: function() {
    return this.wheelDelta * -2;
  }
});
Object.defineProperty(MouseEvent.prototype, "wheel", {
  get: function() {
    return this.wheelDelta * -2;
  }
});
var RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;
var RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;
var RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;
var RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
var RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
var RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
var RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
var RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
var RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
var RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
var RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
AppBase.prototype.isFullscreen = function() {
  return !!document.fullscreenElement;
};
AppBase.prototype.enableFullscreen = function(element, success, error) {
  element = element || this.graphicsDevice.canvas;
  const s2 = function s3() {
    success();
    document.removeEventListener("fullscreenchange", s3);
  };
  const e = function e3() {
    error();
    document.removeEventListener("fullscreenerror", e3);
  };
  if (success) {
    document.addEventListener("fullscreenchange", s2, false);
  }
  if (error) {
    document.addEventListener("fullscreenerror", e, false);
  }
  if (element.requestFullscreen) {
    element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
  } else {
    error();
  }
};
AppBase.prototype.disableFullscreen = function(success) {
  const s2 = function s3() {
    success();
    document.removeEventListener("fullscreenchange", s3);
  };
  if (success) {
    document.addEventListener("fullscreenchange", s2, false);
  }
  document.exitFullscreen();
};
AppBase.prototype.getSceneUrl = function(name) {
  const entry = this.scenes.find(name);
  if (entry) {
    return entry.url;
  }
  return null;
};
AppBase.prototype.loadScene = function(url, callback) {
  this.scenes.loadScene(url, callback);
};
AppBase.prototype.loadSceneHierarchy = function(url, callback) {
  this.scenes.loadSceneHierarchy(url, callback);
};
AppBase.prototype.loadSceneSettings = function(url, callback) {
  this.scenes.loadSceneSettings(url, callback);
};
ModelComponent.prototype.setVisible = function(visible) {
  this.enabled = visible;
};
Object.defineProperty(RigidBodyComponent.prototype, "bodyType", {
  get: function() {
    return this.type;
  },
  set: function(type) {
    this.type = type;
  }
});
RigidBodyComponent.prototype.syncBodyToEntity = function() {
  this._updateDynamic();
};
RigidBodyComponentSystem.prototype.setGravity = function() {
  if (arguments.length === 1) {
    this.gravity.copy(arguments[0]);
  } else {
    this.gravity.set(arguments[0], arguments[1], arguments[2]);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/mini-stats/cpu-timer.js
var CpuTimer = class {
  constructor(app2) {
    this._frameIndex = 0;
    this._frameTimings = [];
    this._timings = [];
    this._prevTimings = [];
    this.unitsName = "ms";
    this.decimalPlaces = 1;
    this.enabled = true;
    app2.on("frameupdate", this.begin.bind(this, "update"));
    app2.on("framerender", this.mark.bind(this, "render"));
    app2.on("frameend", this.mark.bind(this, "other"));
  }
  begin(name) {
    if (!this.enabled) {
      return;
    }
    if (this._frameIndex < this._frameTimings.length) {
      this._frameTimings.splice(this._frameIndex);
    }
    const tmp = this._prevTimings;
    this._prevTimings = this._timings;
    this._timings = this._frameTimings;
    this._frameTimings = tmp;
    this._frameIndex = 0;
    this.mark(name);
  }
  mark(name) {
    if (!this.enabled) {
      return;
    }
    const timestamp = now();
    if (this._frameIndex > 0) {
      const prev = this._frameTimings[this._frameIndex - 1];
      prev[1] = timestamp - prev[1];
    } else if (this._timings.length > 0) {
      const prev = this._timings[this._timings.length - 1];
      prev[1] = timestamp - prev[1];
    }
    if (this._frameIndex >= this._frameTimings.length) {
      this._frameTimings.push([name, timestamp]);
    } else {
      const timing = this._frameTimings[this._frameIndex];
      timing[0] = name;
      timing[1] = timestamp;
    }
    this._frameIndex++;
  }
  get timings() {
    return this._timings.slice(0, -1).map((v) => v[1]);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/mini-stats/gpu-timer.js
var GpuTimer = class {
  constructor(device) {
    this.device = device;
    device.gpuProfiler.enabled = true;
    this.enabled = true;
    this.unitsName = "ms";
    this.decimalPlaces = 1;
    this._timings = [];
  }
  get timings() {
    this._timings[0] = this.device.gpuProfiler._frameTime;
    return this._timings;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/mini-stats/stats-timer.js
var StatsTimer = class {
  constructor(app2, statNames, decimalPlaces, unitsName, multiplier) {
    this.app = app2;
    this.values = [];
    this.statNames = statNames;
    if (this.statNames.length > 3) {
      this.statNames.length = 3;
    }
    this.unitsName = unitsName;
    this.decimalPlaces = decimalPlaces;
    this.multiplier = multiplier || 1;
    const resolve = (path2, obj) => {
      return path2.split(".").reduce((prev, curr) => {
        return prev ? prev[curr] : null;
      }, obj || this);
    };
    app2.on("frameupdate", (ms) => {
      for (let i = 0; i < this.statNames.length; i++) {
        this.values[i] = resolve(this.statNames[i], this.app.stats) * this.multiplier;
      }
    });
  }
  get timings() {
    return this.values;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/mini-stats/graph.js
var Graph = class {
  constructor(name, app2, watermark, textRefreshRate, timer) {
    this.app = app2;
    this.name = name;
    this.device = app2.graphicsDevice;
    this.timer = timer;
    this.watermark = watermark;
    this.enabled = false;
    this.textRefreshRate = textRefreshRate;
    this.avgTotal = 0;
    this.avgTimer = 0;
    this.avgCount = 0;
    this.timingText = "";
    this.texture = null;
    this.yOffset = 0;
    this.cursor = 0;
    this.sample = new Uint8ClampedArray(4);
    this.sample.set([0, 0, 0, 255]);
    this.counter = 0;
    this.app.on("frameupdate", this.update, this);
  }
  destroy() {
    this.app.off("frameupdate", this.update, this);
  }
  loseContext() {
    if (this.timer && typeof this.timer.loseContext === "function") {
      this.timer.loseContext();
    }
  }
  update(ms) {
    const timings = this.timer.timings;
    const total = timings.reduce((a, v) => a + v, 0);
    this.avgTotal += total;
    this.avgTimer += ms;
    this.avgCount++;
    if (this.avgTimer > this.textRefreshRate) {
      this.timingText = (this.avgTotal / this.avgCount).toFixed(this.timer.decimalPlaces);
      this.avgTimer = 0;
      this.avgTotal = 0;
      this.avgCount = 0;
    }
    if (this.enabled) {
      let value = 0;
      const range = 1.5 * this.watermark;
      for (let i = 0; i < timings.length; ++i) {
        value += Math.floor(timings[i] / range * 255);
        this.sample[i] = value;
      }
      this.sample[3] = this.watermark / range * 255;
      const data2 = this.texture.lock();
      data2.set(this.sample, (this.cursor + this.yOffset * this.texture.width) * 4);
      this.texture.unlock();
      this.cursor++;
      if (this.cursor === this.texture.width) {
        this.cursor = 0;
      }
    }
  }
  render(render2d, x2, y2, w, h2) {
    render2d.quad(x2 + w, y2, -w, h2, this.enabled ? this.cursor : 0, this.enabled ? 0.5 + this.yOffset : this.texture.height - 1, -w, 0, this.texture, 0);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/mini-stats/word-atlas.js
var WordAtlas = class {
  constructor(device, words) {
    const initContext = (context2) => {
      context2.font = '10px "Lucida Console", Monaco, monospace';
      context2.textAlign = "left";
      context2.textBaseline = "alphabetic";
    };
    const isNumber = (word) => {
      return word === "." || word.length === 1 && word.charCodeAt(0) >= 48 && word.charCodeAt(0) <= 57;
    };
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d", {
      alpha: true
    });
    initContext(context);
    const placements = /* @__PURE__ */ new Map();
    const padding = 5;
    const width = 512;
    let x2 = padding;
    let y2 = padding;
    words.forEach((word) => {
      const measurement = context.measureText(word);
      const l = Math.ceil(-measurement.actualBoundingBoxLeft);
      const r = Math.ceil(measurement.actualBoundingBoxRight);
      const a = Math.ceil(measurement.actualBoundingBoxAscent);
      const d = Math.ceil(measurement.actualBoundingBoxDescent);
      const w = l + r;
      const h2 = a + d;
      if (x2 + w + padding >= width) {
        x2 = padding;
        y2 += 16;
      }
      placements.set(word, {
        l,
        r,
        a,
        d,
        w,
        h: h2,
        x: x2,
        y: y2
      });
      x2 += w + padding;
    });
    canvas.width = 512;
    canvas.height = math.nextPowerOfTwo(y2 + 16 + padding);
    initContext(context);
    context.fillStyle = "rgb(0, 0, 0)";
    context.fillRect(0, 0, canvas.width, canvas.height);
    placements.forEach((m, word) => {
      context.fillStyle = isNumber(word) ? "rgb(255, 255, 255)" : "rgb(170, 170, 170)";
      context.fillText(word, m.x - m.l, m.y + m.a);
    });
    this.placements = placements;
    const data2 = context.getImageData(0, 0, canvas.width, canvas.height).data;
    for (let i = 0; i < data2.length; i += 4) {
      data2[i + 3] = data2[i + 0];
      data2[i + 0] = 255;
      data2[i + 1] = 255;
      data2[i + 2] = 255;
    }
    this.texture = new Texture(device, {
      name: "mini-stats-word-atlas",
      width: canvas.width,
      height: canvas.height,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      levels: [data2]
    });
  }
  destroy() {
    this.texture.destroy();
    this.texture = null;
  }
  render(render2d, word, x2, y2) {
    const p = this.placements.get(word);
    if (p) {
      const padding = 1;
      render2d.quad(x2 + p.l - padding, y2 - p.d + padding, p.w + padding * 2, p.h + padding * 2, p.x - padding, this.texture.height - p.y - p.h - padding, void 0, void 0, this.texture, 1);
      return p.w;
    }
    return 0;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/mini-stats/render2d.js
var vertexShader = `
attribute vec3 vertex_position;
attribute vec4 vertex_texCoord0;
varying vec4 uv0;
varying float wordFlag;
void main(void) {
	gl_Position = vec4(vertex_position.xy * 2.0 - 1.0, 0.5, 1.0);
	uv0 = vertex_texCoord0;
	wordFlag = vertex_position.z;
}`;
var fragmentShader = `
varying vec4 uv0;
varying float wordFlag;
uniform vec4 clr;
uniform sampler2D graphTex;
uniform sampler2D wordsTex;
void main (void) {
	vec4 graphSample = texture2D(graphTex, uv0.xy);
	vec4 graph;
	if (uv0.w < graphSample.r)
		graph = vec4(0.7, 0.2, 0.2, 1.0);
	else if (uv0.w < graphSample.g)
		graph = vec4(0.2, 0.7, 0.2, 1.0);
	else if (uv0.w < graphSample.b)
		graph = vec4(0.2, 0.2, 0.7, 1.0);
	else
		graph = vec4(0.0, 0.0, 0.0, 1.0 - 0.25 * sin(uv0.w * 3.14159));
	vec4 words = texture2D(wordsTex, vec2(uv0.x, 1.0 - uv0.y));
	gl_FragColor = mix(graph, words, wordFlag) * clr;
}`;
var Render2d = class {
  constructor(device, maxQuads = 512) {
    const format = new VertexFormat(device, [{
      semantic: SEMANTIC_POSITION,
      components: 3,
      type: TYPE_FLOAT32
    }, {
      semantic: SEMANTIC_TEXCOORD0,
      components: 4,
      type: TYPE_FLOAT32
    }]);
    const indices = new Uint16Array(maxQuads * 6);
    for (let i = 0; i < maxQuads; ++i) {
      indices[i * 6 + 0] = i * 4;
      indices[i * 6 + 1] = i * 4 + 1;
      indices[i * 6 + 2] = i * 4 + 2;
      indices[i * 6 + 3] = i * 4;
      indices[i * 6 + 4] = i * 4 + 2;
      indices[i * 6 + 5] = i * 4 + 3;
    }
    this.device = device;
    this.buffer = new VertexBuffer(device, format, maxQuads * 4, {
      usage: BUFFER_STREAM
    });
    this.data = new Float32Array(this.buffer.numBytes / 4);
    this.indexBuffer = new IndexBuffer(device, INDEXFORMAT_UINT16, maxQuads * 6, BUFFER_STATIC, indices);
    this.prim = {
      type: PRIMITIVE_TRIANGLES,
      indexed: true,
      base: 0,
      count: 0
    };
    this.quads = 0;
    this.mesh = new Mesh(device);
    this.mesh.vertexBuffer = this.buffer;
    this.mesh.indexBuffer[0] = this.indexBuffer;
    this.mesh.primitive = [this.prim];
    const material = new ShaderMaterial({
      uniqueName: "MiniStats",
      vertexCode: vertexShader,
      fragmentCode: fragmentShader
    });
    this.material = material;
    material.cull = CULLFACE_NONE;
    material.depthState = DepthState.NODEPTH;
    material.blendState = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);
    material.update();
    this.meshInstance = new MeshInstance(this.mesh, material, new GraphNode("MiniStatsMesh"));
    this.uniforms = {
      clr: new Float32Array(4)
    };
    this.targetSize = {
      width: device.width,
      height: device.height
    };
  }
  quad(x2, y2, w, h2, u, v, uw, uh, texture, wordFlag = 0) {
    const rw = this.targetSize.width;
    const rh = this.targetSize.height;
    const x0 = x2 / rw;
    const y0 = y2 / rh;
    const x1 = (x2 + w) / rw;
    const y1 = (y2 + h2) / rh;
    const tw = texture.width;
    const th = texture.height;
    const u0 = u / tw;
    const v0 = v / th;
    const u1 = (u + (uw != null ? uw : w)) / tw;
    const v1 = (v + (uh != null ? uh : h2)) / th;
    this.data.set([x0, y0, wordFlag, u0, v0, 0, 0, x1, y0, wordFlag, u1, v0, 1, 0, x1, y1, wordFlag, u1, v1, 1, 1, x0, y1, wordFlag, u0, v1, 0, 1], 4 * 7 * this.quads);
    this.quads++;
    this.prim.count += 6;
  }
  startFrame() {
    this.quads = 0;
    this.prim.count = 0;
    this.targetSize.width = this.device.canvas.scrollWidth;
    this.targetSize.height = this.device.canvas.scrollHeight;
  }
  render(app2, layer, graphTexture, wordsTexture, clr, height) {
    this.buffer.setData(this.data.buffer);
    this.uniforms.clr.set(clr, 0);
    this.material.setParameter("clr", this.uniforms.clr);
    this.material.setParameter("graphTex", graphTexture);
    this.material.setParameter("wordsTex", wordsTexture);
    app2.drawMeshInstance(this.meshInstance, layer);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/mini-stats/mini-stats.js
var MiniStats = class _MiniStats {
  constructor(app2, options2) {
    const device = app2.graphicsDevice;
    options2 = options2 || _MiniStats.getDefaultOptions();
    this.initGraphs(app2, device, options2);
    const words = new Set(["", "ms", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "."].concat(this.graphs.map((graph) => graph.name)).concat(options2.stats ? options2.stats.map((stat) => stat.unitsName) : []).filter((item) => !!item));
    this.wordAtlas = new WordAtlas(device, words);
    this.sizes = options2.sizes;
    this._activeSizeIndex = options2.startSizeIndex;
    const div = document.createElement("div");
    div.setAttribute("id", "mini-stats");
    div.style.cssText = "position:fixed;bottom:0;left:0;background:transparent;";
    document.body.appendChild(div);
    div.addEventListener("mouseenter", (event) => {
      this.opacity = 1;
    });
    div.addEventListener("mouseleave", (event) => {
      this.opacity = 0.7;
    });
    div.addEventListener("click", (event) => {
      event.preventDefault();
      if (this._enabled) {
        this.activeSizeIndex = (this.activeSizeIndex + 1) % this.sizes.length;
        this.resize(this.sizes[this.activeSizeIndex].width, this.sizes[this.activeSizeIndex].height, this.sizes[this.activeSizeIndex].graphs);
      }
    });
    device.on("resizecanvas", this.updateDiv, this);
    device.on("losecontext", this.loseContext, this);
    app2.on("postrender", this.postRender, this);
    this.app = app2;
    this.drawLayer = app2.scene.layers.getLayerById(LAYERID_UI);
    this.device = device;
    this.render2d = new Render2d(device);
    this.div = div;
    this.width = 0;
    this.height = 0;
    this.gspacing = 2;
    this.clr = [1, 1, 1, 0.5];
    this._enabled = true;
    this.activeSizeIndex = this._activeSizeIndex;
  }
  destroy() {
    this.device.off("resizecanvas", this.updateDiv, this);
    this.device.off("losecontext", this.loseContext, this);
    this.app.off("postrender", this.postRender, this);
    this.graphs.forEach((graph) => graph.destroy());
    this.wordAtlas.destroy();
    this.texture.destroy();
  }
  static getDefaultOptions() {
    return {
      sizes: [{
        width: 100,
        height: 16,
        spacing: 0,
        graphs: false
      }, {
        width: 128,
        height: 32,
        spacing: 2,
        graphs: true
      }, {
        width: 256,
        height: 64,
        spacing: 2,
        graphs: true
      }],
      startSizeIndex: 0,
      textRefreshRate: 500,
      cpu: {
        enabled: true,
        watermark: 33
      },
      gpu: {
        enabled: true,
        watermark: 33
      },
      stats: [{
        name: "Frame",
        stats: ["frame.ms"],
        decimalPlaces: 1,
        unitsName: "ms",
        watermark: 33
      }, {
        name: "DrawCalls",
        stats: ["drawCalls.total"],
        watermark: 1e3
      }]
    };
  }
  set activeSizeIndex(value) {
    this._activeSizeIndex = value;
    this.gspacing = this.sizes[value].spacing;
    this.resize(this.sizes[value].width, this.sizes[value].height, this.sizes[value].graphs);
  }
  get activeSizeIndex() {
    return this._activeSizeIndex;
  }
  set opacity(value) {
    this.clr[3] = value;
  }
  get opacity() {
    return this.clr[3];
  }
  get overallHeight() {
    const graphs = this.graphs;
    const spacing = this.gspacing;
    return this.height * graphs.length + spacing * (graphs.length - 1);
  }
  set enabled(value) {
    if (value !== this._enabled) {
      this._enabled = value;
      for (let i = 0; i < this.graphs.length; ++i) {
        this.graphs[i].enabled = value;
        this.graphs[i].timer.enabled = value;
      }
    }
  }
  get enabled() {
    return this._enabled;
  }
  initGraphs(app2, device, options2) {
    this.graphs = [];
    if (options2.cpu.enabled) {
      const timer = new CpuTimer(app2);
      const graph = new Graph("CPU", app2, options2.cpu.watermark, options2.textRefreshRate, timer);
      this.graphs.push(graph);
    }
    if (options2.gpu.enabled) {
      const timer = new GpuTimer(device);
      const graph = new Graph("GPU", app2, options2.gpu.watermark, options2.textRefreshRate, timer);
      this.graphs.push(graph);
    }
    if (options2.stats) {
      options2.stats.forEach((entry) => {
        const timer = new StatsTimer(app2, entry.stats, entry.decimalPlaces, entry.unitsName, entry.multiplier);
        const graph = new Graph(entry.name, app2, entry.watermark, options2.textRefreshRate, timer);
        this.graphs.push(graph);
      });
    }
    const maxWidth = options2.sizes.reduce((max, v) => {
      return v.width > max ? v.width : max;
    }, 0);
    this.texture = new Texture(device, {
      name: "mini-stats-graph-texture",
      width: math.nextPowerOfTwo(maxWidth),
      height: math.nextPowerOfTwo(this.graphs.length),
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_REPEAT,
      addressV: ADDRESS_REPEAT
    });
    this.graphs.forEach((graph, i) => {
      graph.texture = this.texture;
      graph.yOffset = i;
    });
  }
  render() {
    const graphs = this.graphs;
    const wordAtlas = this.wordAtlas;
    const render2d = this.render2d;
    const width = this.width;
    const height = this.height;
    const gspacing = this.gspacing;
    render2d.startFrame();
    for (let i = 0; i < graphs.length; ++i) {
      const graph = graphs[i];
      let y2 = i * (height + gspacing);
      graph.render(render2d, 0, y2, width, height);
      let x2 = 1;
      y2 += height - 13;
      x2 += wordAtlas.render(render2d, graph.name, x2, y2) + 10;
      const timingText = graph.timingText;
      for (let j = 0; j < timingText.length; ++j) {
        x2 += wordAtlas.render(render2d, timingText[j], x2, y2);
      }
      if (graph.timer.unitsName) {
        x2 += 3;
        wordAtlas.render(render2d, graph.timer.unitsName, x2, y2);
      }
    }
    render2d.render(this.app, this.drawLayer, this.texture, this.wordAtlas.texture, this.clr, height);
  }
  resize(width, height, showGraphs) {
    const graphs = this.graphs;
    for (let i = 0; i < graphs.length; ++i) {
      graphs[i].enabled = showGraphs;
    }
    this.width = width;
    this.height = height;
    this.updateDiv();
  }
  updateDiv() {
    const rect = this.device.canvas.getBoundingClientRect();
    this.div.style.left = `${rect.left}px`;
    this.div.style.bottom = `${window.innerHeight - rect.bottom}px`;
    this.div.style.width = `${this.width}px`;
    this.div.style.height = `${this.overallHeight}px`;
  }
  loseContext() {
    this.graphs.forEach((graph) => graph.loseContext());
  }
  postRender() {
    if (this._enabled) {
      this.render();
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/exporters/core-exporter.js
var textureBlitVertexShader2 = `
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
	}`;
var textureBlitFragmentShader2 = `
	varying vec2 uv0;
	uniform sampler2D blitTexture;
	void main(void) {
		gl_FragColor = texture2D(blitTexture, uv0);
	}`;
var CoreExporter = class {
  constructor() {
  }
  textureToCanvas(texture, options2 = {}) {
    const image = texture.getSource();
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && image instanceof OffscreenCanvas || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const {
        width: _width,
        height: _height
      } = this.calcTextureSize(image.width, image.height, options2.maxTextureSize);
      const canvas = document.createElement("canvas");
      canvas.width = _width;
      canvas.height = _height;
      const context = canvas.getContext("2d");
      if (context === null) {
        return Promise.resolve(void 0);
      }
      context.drawImage(image, 0, 0, canvas.width, canvas.height);
      if (options2.color) {
        const {
          r,
          g,
          b
        } = options2.color;
        const imagedata = context.getImageData(0, 0, _width, _height);
        const data2 = imagedata.data;
        for (let i = 0; i < data2.length; i += 4) {
          data2[i + 0] = data2[i + 0] * r;
          data2[i + 1] = data2[i + 1] * g;
          data2[i + 2] = data2[i + 2] * b;
        }
        context.putImageData(imagedata, 0, 0);
      }
      return Promise.resolve(canvas);
    }
    const device = texture.device;
    const {
      width,
      height
    } = this.calcTextureSize(texture.width, texture.height, options2.maxTextureSize);
    const format = isCompressedPixelFormat(texture.format) ? PIXELFORMAT_RGBA8 : texture.format;
    const dstTexture = new Texture(device, {
      name: "ExtractedTexture",
      width,
      height,
      format,
      cubemap: false,
      mipmaps: false,
      minFilter: FILTER_LINEAR,
      magFilter: FILTER_LINEAR,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
    const renderTarget = new RenderTarget({
      colorBuffer: dstTexture,
      depth: false
    });
    const shader = createShaderFromCode(device, textureBlitVertexShader2, textureBlitFragmentShader2, "ShaderCoreExporterBlit");
    device.scope.resolve("blitTexture").setValue(texture);
    device.setBlendState(BlendState.NOBLEND);
    drawQuadWithShader(device, renderTarget, shader);
    return dstTexture.read(0, 0, width, height, {
      renderTarget,
      immediate: true
    }).then((textureData) => {
      dstTexture.destroy();
      renderTarget.destroy();
      const pixels = new Uint8ClampedArray(width * height * 4);
      pixels.set(textureData);
      const newImage = new ImageData(pixels, width, height);
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const newContext = canvas.getContext("2d");
      if (!newContext) {
        return Promise.resolve(void 0);
      }
      newContext.putImageData(newImage, 0, 0);
      return Promise.resolve(canvas);
    });
  }
  calcTextureSize(width, height, maxTextureSize) {
    if (maxTextureSize) {
      const scale2 = Math.min(maxTextureSize / Math.max(width, height), 1);
      width = Math.round(width * scale2);
      height = Math.round(height * scale2);
    }
    return {
      width,
      height
    };
  }
};

// ../node_modules/playcanvas/build/playcanvas/modules/fflate/esm/browser.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function freb2(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return {
    b,
    r
  };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x2 = (i & 43690) >> 1 | (i & 21845) << 1;
  x2 = (x2 & 52428) >> 2 | (x2 & 13107) << 2;
  x2 = (x2 & 61680) >> 4 | (x2 & 3855) << 4;
  rev[i] = ((x2 & 65280) >> 8 | (x2 & 255) << 8) >> 1;
}
var x2;
var i;
var hMap = function hMap2(cd, mb, r) {
  var s2 = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s2; ++i) {
    if (cd[i]) ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s2; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i = 0; i < s2; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i) flt[i] = 8;
var i;
for (i = 144; i < 256; ++i) flt[i] = 9;
var i;
for (i = 256; i < 280; ++i) flt[i] = 7;
var i;
for (i = 280; i < 288; ++i) flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i) fdt[i] = 5;
var i;
var flm = hMap(flt, 9, 0);
hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
hMap(fdt, 5, 1);
var shft = function shft2(p) {
  return (p + 7) / 8 | 0;
};
var slc = function slc2(v, s2, e) {
  if (s2 == null || s2 < 0) s2 = 0;
  if (e == null || e > v.length) e = v.length;
  return new u8(v.subarray(s2, e));
};
var ec = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"];
var err = function err2(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace) Error.captureStackTrace(e, err2);
  if (!nt) throw e;
  return e;
};
var wbits = function wbits2(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
};
var wbits16 = function wbits162(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
  d[o + 2] |= v >> 16;
};
var hTree = function hTree2(d, mb) {
  var t = [];
  for (var i = 0; i < d.length; ++i) {
    if (d[i]) t.push({
      s: i,
      f: d[i]
    });
  }
  var s2 = t.length;
  var t2 = t.slice();
  if (!s2) return {
    t: et,
    l: 0
  };
  if (s2 == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return {
      t: v,
      l: 1
    };
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({
    s: -1,
    f: 25001
  });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
  t[0] = {
    s: -1,
    f: l.f + r.f,
    l,
    r
  };
  while (i1 != s2 - 1) {
    l = t[t[i0].f < t[i2].f ? i0++ : i2++];
    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
    t[i1++] = {
      s: -1,
      f: l.f + r.f,
      l,
      r
    };
  }
  var maxSym = t2[0].s;
  for (var i = 1; i < s2; ++i) {
    if (t2[i].s > maxSym) maxSym = t2[i].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (; i < s2; ++i) {
      var i2_1 = t2[i].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t2[i].s;
      if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;
      else ++i;
    }
    for (; i >= 0 && dt; --i) {
      var i2_3 = t2[i].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return {
    t: new u8(tr),
    l: mbt
  };
};
var ln = function ln2(n, l, d) {
  return n.s == -1 ? Math.max(ln2(n.l, l, d + 1), ln2(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function lc2(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2]) ;
  var cl = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w = function w2(v) {
    cl[cli++] = v;
  };
  for (var i = 1; i <= s2; ++i) {
    if (c2[i] == cln && i != s2) ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138) w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6) w(8304);
        if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--) w(cln);
      cls = 1;
      cln = c2[i];
    }
  }
  return {
    c: cl.subarray(0, cli),
    n: s2
  };
};
var clen = function clen2(cf, cl) {
  var l = 0;
  for (var i = 0; i < cl.length; ++i) l += cf[i] * cl[i];
  return l;
};
var wfblk = function wfblk2(out, pos, dat) {
  var s2 = dat.length;
  var o = shft(pos + 2);
  out[o] = s2 & 255;
  out[o + 1] = s2 >> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i = 0; i < s2; ++i) out[o + i + 4] = dat[i];
  return (o + 4 + s2) * 8;
};
var wblk = function wblk2(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i = 0; i < lclt.length; ++i) ++lcfreq[lclt[i] & 31];
  for (var i = 0; i < lcdt.length; ++i) ++lcfreq[lcdt[i] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc) ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15) wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i = 0; i < li; ++i) {
    var sym = syms[i];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[len];
      var dst = sym & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[sym]), p += ll[sym];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function dflt2(dat, lvl, plvl, pre, post, st) {
  var s2 = st.z || dat.length;
  var o = new u8(pre + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + post);
  var w = o.subarray(pre, o.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos) w[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n = opt >> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function hsh2(i2) {
      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (; i + 2 < s2; ++i) {
      var hv = hsh(i);
      var imod = i & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i) {
        var rem = s2 - i;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;
          for (var j = 0; j < 286; ++j) lf[j] = 0;
          for (var j = 0; j < 30; ++j) df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl) ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn) break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i - dif + j & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md) md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }
    for (i = Math.max(i, wi); i < s2; ++i) {
      syms[li++] = dat[i];
      ++lf[dat[i]];
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head, st.p = prev, st.i = i, st.w = wi;
    }
  } else {
    for (var i = st.w || 0; i < s2 + lst; i += 65535) {
      var e = i + 65535;
      if (e >= s2) {
        w[pos / 8 | 0] = lst;
        e = s2;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i, e));
    }
    st.i = s2;
  }
  return slc(o, 0, pre + shft(pos) + post);
};
var crct = function() {
  var t = new Int32Array(256);
  for (var i = 0; i < 256; ++i) {
    var c2 = i, k = 9;
    while (--k) c2 = (c2 & 1 && -306674912) ^ c2 >>> 1;
    t[i] = c2;
  }
  return t;
}();
var crc = function crc2() {
  var c2 = -1;
  return {
    p: function(d) {
      var cr = c2;
      for (var i = 0; i < d.length; ++i) cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
      c2 = cr;
    },
    d: function() {
      return ~c2;
    }
  };
};
var dopt = function dopt2(dat, opt, pre, post, st) {
  if (!st) {
    st = {
      l: 1
    };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
var mrg = function mrg2(a, b) {
  var o = {};
  for (var k in a) o[k] = a[k];
  for (var k in b) o[k] = b[k];
  return o;
};
var wbytes = function wbytes2(d, b, v) {
  for (; v; ++b) d[b] = v, v >>>= 8;
};
function deflateSync(data2, opts) {
  return dopt(data2, opts || {}, 0, 0);
}
var fltn = function fltn2(d, p, t, o) {
  for (var k in d) {
    var val = d[k], n = p + k, op = o;
    if (Array.isArray(val)) op = mrg(o, val[1]), val = val[0];
    if (val instanceof u8) t[n] = [val, op];
    else {
      t[n += "/"] = [new u8(0), op];
      fltn2(val, n, t, o);
    }
  }
};
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, {
    stream: true
  });
  tds = 1;
} catch (e) {
}
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i = 0; i < str.length; ++i) ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te) return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function w2(v) {
    ar[ai++] = v;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }
    var c2 = str.charCodeAt(i);
    if (c2 < 128 || latin1) w(c2);
    else if (c2 < 2048) w(192 | c2 >> 6), w(128 | c2 & 63);
    else if (c2 > 55295 && c2 < 57344) c2 = 65536 + (c2 & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c2 >> 18), w(128 | c2 >> 12 & 63), w(128 | c2 >> 6 & 63), w(128 | c2 & 63);
    else w(224 | c2 >> 12), w(128 | c2 >> 6 & 63), w(128 | c2 & 63);
  }
  return slc(ar, 0, ai);
}
var exfl = function exfl2(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535) err(9);
      le += l + 4;
    }
  }
  return le;
};
var wzh = function wzh2(d, b, f, fn, u, c2, ce, co) {
  var fl2 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
  if (ce != null) d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2;
  d[b++] = f.flag << 1 | (c2 < 0 && 8), d[b++] = u && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y2 = dt.getFullYear() - 1980;
  if (y2 < 0 || y2 > 119) err(10);
  wbytes(d, b, y2 << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
  if (c2 != -1) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c2 < 0 ? -c2 - 2 : c2);
    wbytes(d, b + 8, f.size);
  }
  wbytes(d, b + 12, fl2);
  wbytes(d, b + 14, exl), b += 16;
  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }
  d.set(fn, b);
  b += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }
  if (col) d.set(co, b), b += col;
  return b;
};
var wzf = function wzf2(o, b, c2, d, e) {
  wbytes(o, b, 101010256);
  wbytes(o, b + 8, c2);
  wbytes(o, b + 10, c2);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
function zipSync(data2, opts) {
  if (!opts) opts = {};
  var r = {};
  var files = [];
  fltn(data2, "", r, opts);
  var o = 0;
  var tot = 0;
  for (var fn in r) {
    var _a2 = r[fn], file = _a2[0], p = _a2[1];
    var compression = p.level == 0 ? 0 : 8;
    var f = strToU8(fn), s2 = f.length;
    var com = p.comment, m = com && strToU8(com), ms = m && m.length;
    var exl = exfl(p.extra);
    if (s2 > 65535) err(11);
    var d = compression ? deflateSync(file, p) : file, l = d.length;
    var c2 = crc();
    c2.p(file);
    files.push(mrg(p, {
      size: file.length,
      crc: c2.d(),
      c: d,
      f,
      m,
      u: s2 != fn.length || m && com.length != ms,
      o,
      compression
    }));
    o += 30 + s2 + exl + l;
    tot += 76 + 2 * (s2 + exl) + (ms || 0) + l;
  }
  var out = new u8(tot + 22), oe = o, cdl = tot - o;
  for (var i = 0; i < files.length; ++i) {
    var f = files[i];
    wzh(out, f.o, f, f.f, f.u, f.c.length);
    var badd = 30 + f.f.length + exfl(f.extra);
    out.set(f.c, f.o + badd);
    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
  }
  wzf(out, o, files.length, cdl, oe);
  return out;
}

// ../node_modules/playcanvas/build/playcanvas/src/extras/exporters/usdz-exporter.js
var ROOT_FILE_NAME = "root";
var header = `#usda 1.0
(
		customLayerData = {
				string creator = "PlayCanvas UsdzExporter"
		}
		metersPerUnit = 1
		upAxis = "Y"
)
`;
var materialListTemplate = (materials) => `
def "Materials"
{
		${materials.join("\n")}
}
`;
var meshTemplate = (faceVertexCounts, indices, normals, positions, uv0, uv1) => `
def "Mesh"
{
		def Mesh "Mesh"
		{
				int[] faceVertexCounts = [${faceVertexCounts}]
				int[] faceVertexIndices = [${indices}]
				normal3f[] normals = [${normals}] (
						interpolation = "vertex"
				)
				point3f[] points = [${positions}]
				texCoord2f[] primvars:st = [${uv0}] (
						interpolation = "vertex"
				)
				texCoord2f[] primvars:st1 = [${uv1}] (
						interpolation = "vertex"
				)
				uniform token subdivisionScheme = "none"
		}
}
`;
var meshInstanceTemplate = (nodeName, meshRefPath, worldMatrix, materialRefPath) => `
def Xform "${nodeName}" (
		prepend references = ${meshRefPath}
)
{
		matrix4d xformOp:transform = ${worldMatrix}
		uniform token[] xformOpOrder = ["xformOp:transform"]

		rel material:binding = ${materialRefPath}
}
`;
var materialValueTemplate = (type, name, value) => `                    ${type} inputs:${name} = ${value}`;
var UsdzExporter = class extends CoreExporter {
  constructor(...args) {
    super(...args);
    this.meshMap = void 0;
    this.materialMap = void 0;
    this.materials = void 0;
    this.textureMap = void 0;
    this.nodeNames = void 0;
    this.files = void 0;
  }
  init() {
    this.meshMap = /* @__PURE__ */ new Map();
    this.textureMap = /* @__PURE__ */ new Map();
    this.materialMap = /* @__PURE__ */ new Map();
    this.materials = [];
    this.files = {};
    this.nodeNames = /* @__PURE__ */ new Set();
  }
  done() {
    this.meshMap = null;
    this.textureMap = null;
    this.materialMap = null;
    this.materials = null;
    this.files = null;
    this.nodeNames = null;
  }
  build(entity, options2 = {}) {
    this.init();
    this.addFile(null, ROOT_FILE_NAME);
    const allMeshInstances = [];
    if (entity) {
      const renders = entity.findComponents("render");
      renders.forEach((render) => {
        allMeshInstances.push(...render.meshInstances);
      });
    }
    let rootContent = "";
    allMeshInstances.forEach((meshInstance) => {
      rootContent += this.buildMeshInstance(meshInstance);
    });
    rootContent += materialListTemplate(this.materials);
    this.addFile(null, ROOT_FILE_NAME, "", rootContent);
    const textureOptions = {
      maxTextureSize: options2.maxTextureSize
    };
    const textureArray = Array.from(this.textureMap.keys());
    const promises = [];
    for (let i = 0; i < textureArray.length; i++) {
      const mimeType = "image/png";
      const texture = textureArray[i];
      const texturePromise = this.textureToCanvas(texture, textureOptions).then((canvas) => {
        if (canvas) {
          return new Promise((resolve) => canvas.toBlob(resolve, mimeType, 1)).then((blob) => blob.arrayBuffer());
        }
        console.warn(`Export of texture ${texture.name} is not currently supported.`);
        return new Promise((resolve) => resolve(null));
      });
      promises.push(texturePromise);
    }
    const finalData = Promise.all(promises).then((values) => {
      values.forEach((textureArrayBuffer, index) => {
        const texture = textureArray[index];
        const ids3 = this.getTextureFileIds(texture);
        this.files[ids3.fileName] = new Uint8Array(textureArrayBuffer);
      });
      this.alignFiles();
      const arraybuffer = zipSync(this.files, {
        level: 0
      });
      this.done();
      return arraybuffer;
    });
    return finalData;
  }
  alignFiles() {
    let offset = 0;
    for (const filename in this.files) {
      const file = this.files[filename];
      const headerSize = 34 + filename.length;
      offset += headerSize;
      const offsetMod64 = offset & 63;
      if (offsetMod64 !== 4) {
        const padLength = 64 - offsetMod64;
        const padding = new Uint8Array(padLength);
        this.files[filename] = [file, {
          extra: {
            12345: padding
          }
        }];
      }
      offset = file.length;
    }
  }
  getFileIds(category, name, ref, extension = "usda") {
    const fileName = `${category ? `${category}/` : ""}${name}.${extension}`;
    const refName = `@./${fileName}@</${ref}>`;
    return {
      name,
      fileName,
      refName
    };
  }
  getTextureFileIds(texture) {
    return this.getFileIds("texture", `Texture_${texture.id}`, "Texture", "png");
  }
  addFile(category, uniqueId, refName = "", content = "") {
    let contentU8 = null;
    if (content) {
      content = `${header}
${content}`;
      contentU8 = strToU8(content);
    }
    const ids3 = this.getFileIds(category, uniqueId, refName);
    this.files[ids3.fileName] = contentU8;
    return ids3.refName;
  }
  getMaterialRef(material) {
    let materialRef = this.materialMap.get(material);
    if (!materialRef) {
      materialRef = this.buildMaterial(material);
      this.materialMap.set(material, materialRef);
    }
    return materialRef;
  }
  getMeshRef(mesh) {
    let meshRef = this.meshMap.get(mesh);
    if (!meshRef) {
      meshRef = this.buildMesh(mesh);
      this.meshMap.set(mesh, meshRef);
    }
    return meshRef;
  }
  buildArray2(array2) {
    const components2 = [];
    const count = array2.length;
    for (let i = 0; i < count; i += 2) {
      components2.push(`(${array2[i]}, ${1 - array2[i + 1]})`);
    }
    return components2.join(", ");
  }
  buildArray3(array2) {
    const components2 = [];
    const count = array2.length;
    for (let i = 0; i < count; i += 3) {
      components2.push(`(${array2[i]}, ${array2[i + 1]}, ${array2[i + 2]})`);
    }
    return components2.join(", ");
  }
  buildMat4(mat2) {
    const data2 = mat2.data;
    const vectors = [];
    for (let i = 0; i < 16; i += 4) {
      vectors.push(`(${data2[i]}, ${data2[i + 1]}, ${data2[i + 2]}, ${data2[i + 3]})`);
    }
    return `( ${vectors.join(", ")} )`;
  }
  buildMaterial(material) {
    const materialName = `Material_${material.id}`;
    const materialPath = `/Materials/${materialName}`;
    const materialPropertyPath = (property) => `<${materialPath}${property}>`;
    const buildTexture = (texture, textureIds, mapType, uvChannel, tiling, offset, rotation2, tintColor) => {
      return `
								def Shader "Transform2d_${mapType}" (
										sdrMetadata = {
												string role = "math"
										}
								)
								{
										uniform token info:id = "UsdTransform2d"
										float2 inputs:in.connect = ${materialPropertyPath(`/uvReader_${uvChannel}.outputs:result`)}
										float inputs:rotation = ${rotation2}
										float2 inputs:scale = (${tiling.x}, ${tiling.y})
										float2 inputs:translation = (${offset.x}, ${offset.y})
										float2 outputs:result
								}

								def Shader "Texture_${texture.id}_${mapType}"
								{
										uniform token info:id = "UsdUVTexture"
										asset inputs:file = @${textureIds.fileName}@
										float2 inputs:st.connect = ${materialPropertyPath(`/Transform2d_${mapType}.outputs:result`)}
										token inputs:wrapS = "repeat"
										token inputs:wrapT = "repeat"
										float4 inputs:scale = (${tintColor.r}, ${tintColor.g}, ${tintColor.b}, ${tintColor.a})
										float outputs:r
										float outputs:g
										float outputs:b
										float3 outputs:rgb
										float outputs:a
								}
						`;
    };
    const inputs = [];
    const samplers = [];
    const addTexture = (textureSlot, uniform, propType, propName, valueName, handleOpacity = false, tintTexture = false) => {
      const texture = material[textureSlot];
      if (texture) {
        const textureIds = this.getTextureFileIds(texture);
        this.textureMap.set(texture, textureIds.refName);
        const channel = material[`${textureSlot}Channel`] || "rgb";
        const textureValue = materialPropertyPath(`/${textureIds.name}_${valueName}.outputs:${channel}`);
        inputs.push(materialValueTemplate(propType, `${propName}.connect`, textureValue));
        if (handleOpacity) {
          if (material.alphaTest > 0) ;
        }
        const tiling = material[`${textureSlot}Tiling`];
        const offset = material[`${textureSlot}Offset`];
        const rotation2 = material[`${textureSlot}Rotation`];
        const uvChannel = material[`${textureSlot}Uv`] === 1 ? "st1" : "st";
        const tintColor = tintTexture && uniform ? uniform : Color.WHITE;
        samplers.push(buildTexture(texture, textureIds, valueName, uvChannel, tiling, offset, rotation2, tintColor));
      } else if (uniform) {
        const value = propType === "float" ? `${uniform}` : `(${uniform.r}, ${uniform.g}, ${uniform.b})`;
        inputs.push(materialValueTemplate(propType, propName, value));
      }
    };
    addTexture("diffuseMap", material.diffuse, "color3f", "diffuseColor", "diffuse", false, true);
    if (material.transparent || material.alphaTest > 0) {
      addTexture("opacityMap", material.opacity, "float", "opacity", "opacity", true);
    }
    addTexture("normalMap", null, "normal3f", "normal", "normal");
    addTexture("emissiveMap", material.emissive, "color3f", "emissiveColor", "emissive", false, true);
    addTexture("aoMap", null, "float", "occlusion", "occlusion");
    addTexture("metalnessMap", material.metalness, "float", "metallic", "metallic");
    addTexture("glossMap", material.gloss, "float", "roughness", "roughness");
    const materialObject = `
						def Material "${materialName}"
						{
								def Shader "PreviewSurface"
								{
										uniform token info:id = "UsdPreviewSurface"
${inputs.join("\n")}
										int inputs:useSpecularWorkflow = 0
										token outputs:surface
								}

								token outputs:surface.connect = ${materialPropertyPath("/PreviewSurface.outputs:surface")}

								def Shader "uvReader_st"
								{
										uniform token info:id = "UsdPrimvarReader_float2"
										token inputs:varname = "st"
										float2 inputs:fallback = (0.0, 0.0)
										float2 outputs:result
								}

								def Shader "uvReader_st1"
								{
										uniform token info:id = "UsdPrimvarReader_float2"
										token inputs:varname = "st1"
										float2 inputs:fallback = (0.0, 0.0)
										float2 outputs:result
								}

								${samplers.join("\n")}
						}
				`;
    this.materials.push(materialObject);
    return materialPropertyPath("");
  }
  buildMesh(mesh) {
    let positions = [];
    const indices = [];
    let normals = [];
    let uv0 = [];
    let uv1 = [];
    mesh.getVertexStream(SEMANTIC_POSITION, positions);
    mesh.getVertexStream(SEMANTIC_NORMAL, normals);
    mesh.getVertexStream(SEMANTIC_TEXCOORD0, uv0);
    mesh.getVertexStream(SEMANTIC_TEXCOORD1, uv1);
    mesh.getIndices(indices);
    const indicesCount = indices.length || positions.length;
    const faceVertexCounts = Array(indicesCount / 3).fill(3).join(", ");
    if (!indices.length) {
      for (let i = 0; i < indicesCount; i++) {
        indices[i] = i;
      }
    }
    const numVerts = positions.length / 3;
    normals = normals.length ? normals : Array(numVerts * 3).fill(0);
    uv0 = uv0.length ? uv0 : Array(numVerts * 2).fill(0);
    uv1 = uv1.length ? uv1 : Array(numVerts * 2).fill(0);
    positions = this.buildArray3(positions);
    normals = this.buildArray3(normals);
    uv0 = this.buildArray2(uv0);
    uv1 = this.buildArray2(uv1);
    const meshObject = meshTemplate(faceVertexCounts, indices, normals, positions, uv0, uv1);
    const refPath = this.addFile("mesh", `Mesh_${mesh.id}`, "Mesh", meshObject);
    return refPath;
  }
  buildMeshInstance(meshInstance) {
    const meshRefPath = this.getMeshRef(meshInstance.mesh);
    const materialRefPath = this.getMaterialRef(meshInstance.material);
    const worldMatrix = this.buildMat4(meshInstance.node.getWorldTransform());
    const name = meshInstance.node.name.replace(/[^a-z0-9]/gi, "_");
    let nodeName = name;
    while (this.nodeNames.has(nodeName)) {
      nodeName = `${name}_${Math.random().toString(36).slice(2, 7)}`;
    }
    this.nodeNames.add(nodeName);
    return meshInstanceTemplate(nodeName, meshRefPath, worldMatrix, materialRefPath);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/exporters/gltf-exporter.js
var ARRAY_BUFFER = 34962;
var ELEMENT_ARRAY_BUFFER = 34963;
var getIndexComponentType = (indexFormat) => {
  switch (indexFormat) {
    case INDEXFORMAT_UINT8:
      return 5121;
    case INDEXFORMAT_UINT16:
      return 5123;
    case INDEXFORMAT_UINT32:
      return 5125;
  }
  return 0;
};
var getComponentType2 = (dataType) => {
  switch (dataType) {
    case TYPE_INT8:
      return 5120;
    case TYPE_UINT8:
      return 5121;
    case TYPE_INT16:
      return 5122;
    case TYPE_UINT16:
      return 5123;
    case TYPE_INT32:
      return 5124;
    case TYPE_UINT32:
      return 5125;
    case TYPE_FLOAT32:
      return 5126;
  }
  return 0;
};
var getAccessorType = (componentCount) => {
  switch (componentCount) {
    case 1:
      return "SCALAR";
    case 2:
      return "VEC2";
    case 3:
      return "VEC3";
    case 4:
      return "VEC4";
  }
  return 0;
};
var getSemantic = (engineSemantic) => {
  switch (engineSemantic) {
    case SEMANTIC_POSITION:
      return "POSITION";
    case SEMANTIC_NORMAL:
      return "NORMAL";
    case SEMANTIC_TANGENT:
      return "TANGENT";
    case SEMANTIC_COLOR:
      return "COLOR_0";
    case SEMANTIC_BLENDINDICES:
      return "JOINTS_0";
    case SEMANTIC_BLENDWEIGHT:
      return "WEIGHTS_0";
    case SEMANTIC_TEXCOORD0:
      return "TEXCOORD_0";
    case SEMANTIC_TEXCOORD1:
      return "TEXCOORD_1";
    case SEMANTIC_TEXCOORD2:
      return "TEXCOORD_2";
    case SEMANTIC_TEXCOORD3:
      return "TEXCOORD_3";
    case SEMANTIC_TEXCOORD4:
      return "TEXCOORD_4";
    case SEMANTIC_TEXCOORD5:
      return "TEXCOORD_5";
    case SEMANTIC_TEXCOORD6:
      return "TEXCOORD_6";
    case SEMANTIC_TEXCOORD7:
      return "TEXCOORD_7";
  }
  return "";
};
var getFilter = function getFilter2(filter) {
  switch (filter) {
    case FILTER_NEAREST:
      return 9728;
    case FILTER_LINEAR:
      return 9729;
    case FILTER_NEAREST_MIPMAP_NEAREST:
      return 9984;
    case FILTER_LINEAR_MIPMAP_NEAREST:
      return 9985;
    case FILTER_NEAREST_MIPMAP_LINEAR:
      return 9986;
    case FILTER_LINEAR_MIPMAP_LINEAR:
      return 9987;
  }
  return 0;
};
var getWrap = function getWrap2(wrap) {
  switch (wrap) {
    case ADDRESS_CLAMP_TO_EDGE:
      return 33071;
    case ADDRESS_MIRRORED_REPEAT:
      return 33648;
    case ADDRESS_REPEAT:
      return 10497;
  }
  return 0;
};
function isCanvasTransparent(canvas) {
  const context = canvas.getContext("2d");
  const pixelData = context.getImageData(0, 0, canvas.width, canvas.height).data;
  for (let i = 3; i < pixelData.length; i += 4) {
    if (pixelData[i] < 255) {
      return true;
    }
  }
  return false;
}
var textureSemantics = ["diffuseMap", "colorMap", "normalMap", "metalnessMap", "emissiveMap"];
var GltfExporter = class _GltfExporter extends CoreExporter {
  collectResources(root) {
    const resources = {
      buffers: [],
      cameras: [],
      entities: [],
      materials: [],
      textures: [],
      entityMeshInstances: [],
      bufferViewMap: /* @__PURE__ */ new Map(),
      compressableTexture: /* @__PURE__ */ new Set()
    };
    const {
      materials,
      buffers,
      entityMeshInstances,
      textures
    } = resources;
    root.forEach((entity) => {
      resources.entities.push(entity);
    });
    const collectMeshInstances = (meshInstances) => {
      meshInstances.forEach((meshInstance) => {
        const material = meshInstance.material;
        if (materials.indexOf(material) < 0) {
          resources.materials.push(material);
          textureSemantics.forEach((semantic) => {
            const texture = material[semantic];
            if (texture && textures.indexOf(texture) < 0) {
              if (semantic !== "normalMap") {
                resources.compressableTexture.add(texture);
              }
              textures.push(texture);
            }
          });
        }
        const node = meshInstance.node;
        let nodeMeshInstances = entityMeshInstances.find((e) => e.node === node);
        if (!nodeMeshInstances) {
          nodeMeshInstances = {
            node,
            meshInstances: []
          };
          entityMeshInstances.push(nodeMeshInstances);
        }
        nodeMeshInstances.meshInstances.push(meshInstance);
        const mesh = meshInstance.mesh;
        const vertexBuffer = mesh.vertexBuffer;
        if (buffers.indexOf(vertexBuffer) < 0) {
          buffers.unshift(vertexBuffer);
        }
        const indexBuffer = mesh.indexBuffer[0];
        if (buffers.indexOf(indexBuffer) < 0) {
          buffers.push(indexBuffer);
        }
      });
    };
    resources.entities.forEach((entity) => {
      if (entity.camera) {
        resources.cameras.push(entity.camera);
      }
      if (entity.render && entity.render.enabled) {
        collectMeshInstances(entity.render.meshInstances);
      }
      if (entity.model && entity.model.enabled && entity.model.meshInstances) {
        collectMeshInstances(entity.model.meshInstances);
      }
    });
    return resources;
  }
  writeBufferViews(resources, json) {
    json.bufferViews = [];
    for (const buffer of resources.buffers) {
      _GltfExporter.writeBufferView(resources, json, buffer);
    }
  }
  static writeBufferView(resources, json, buffer) {
    var _json$buffers, _json$buffers$;
    json.buffers = (_json$buffers = json.buffers) != null ? _json$buffers : [];
    json.buffers[0] = (_json$buffers$ = json.buffers[0]) != null ? _json$buffers$ : {
      byteLength: 0
    };
    const bufferInfo = json.buffers[0];
    bufferInfo.byteLength = math.roundUp(bufferInfo.byteLength, 4);
    const offset = bufferInfo.byteLength;
    const addBufferView = (target2, byteLength, byteOffset, byteStride) => {
      const bufferView = {
        target: target2,
        buffer: 0,
        byteLength,
        byteOffset,
        byteStride
      };
      return json.bufferViews.push(bufferView) - 1;
    };
    let arrayBuffer;
    if (buffer instanceof VertexBuffer) {
      arrayBuffer = buffer.lock();
      const format = buffer.getFormat();
      if (format.interleaved) {
        const bufferViewIndex = addBufferView(ARRAY_BUFFER, arrayBuffer.byteLength, offset, format.size);
        resources.bufferViewMap.set(buffer, [bufferViewIndex]);
      } else {
        const bufferViewIndices = [];
        for (const element of format.elements) {
          const bufferViewIndex = addBufferView(ARRAY_BUFFER, element.size * format.vertexCount, offset + element.offset, element.size);
          bufferViewIndices.push(bufferViewIndex);
        }
        resources.bufferViewMap.set(buffer, bufferViewIndices);
      }
    } else if (buffer instanceof IndexBuffer) {
      arrayBuffer = buffer.lock();
      const bufferViewIndex = addBufferView(ARRAY_BUFFER, arrayBuffer.byteLength, offset);
      resources.bufferViewMap.set(buffer, [bufferViewIndex]);
    } else {
      arrayBuffer = buffer;
      const bufferViewIndex = addBufferView(ELEMENT_ARRAY_BUFFER, arrayBuffer.byteLength, offset);
      resources.bufferViewMap.set(buffer, [bufferViewIndex]);
    }
    bufferInfo.byteLength += arrayBuffer.byteLength;
  }
  writeCameras(resources, json) {
    if (resources.cameras.length > 0) {
      json.cameras = resources.cameras.map((cam) => {
        const projection = cam.projection;
        const nearClip = cam.nearClip;
        const farClip = cam.farClip;
        const camera = {};
        if (projection === PROJECTION_ORTHOGRAPHIC) {
          camera.type = "orthographic";
          camera.orthographic = {
            xmag: 1,
            ymag: 1,
            znear: nearClip,
            zfar: farClip
          };
        } else {
          const fov = cam.fov;
          camera.type = "perspective";
          camera.perspective = {
            yfov: fov * Math.PI / 180,
            znear: nearClip,
            zfar: farClip
          };
        }
        return camera;
      });
    }
  }
  attachTexture(resources, material, destination, name, textureSemantic, json) {
    const texture = material[textureSemantic];
    if (texture) {
      const textureIndex = resources.textures.indexOf(texture);
      if (textureIndex < 0) console.warn(`Texture ${texture.name} wasn't collected.`);
      destination[name] = {
        index: textureIndex
      };
      const scale2 = material[`${textureSemantic}Tiling`];
      const offset = material[`${textureSemantic}Offset`];
      const rotation2 = material[`${textureSemantic}Rotation`];
      if (scale2 && !scale2.equals(Vec2.ONE) || offset && !offset.equals(Vec2.ZERO) || rotation2 !== 0) {
        var _json$extensionsUsed, _json$extensionsRequi;
        destination[name].extensions = {
          KHR_texture_transform: {}
        };
        json.extensionsUsed = (_json$extensionsUsed = json.extensionsUsed) != null ? _json$extensionsUsed : [];
        if (json.extensionsUsed.indexOf("KHR_texture_transform") < 0) {
          json.extensionsUsed.push("KHR_texture_transform");
        }
        json.extensionsRequired = (_json$extensionsRequi = json.extensionsRequired) != null ? _json$extensionsRequi : [];
        if (json.extensionsRequired.indexOf("KHR_texture_transform") < 0) {
          json.extensionsRequired.push("KHR_texture_transform");
        }
        if (scale2 && !scale2.equals(Vec2.ONE)) {
          destination[name].extensions.KHR_texture_transform.scale = [scale2.x, scale2.y];
        }
        if (offset && !offset.equals(Vec2.ZERO)) {
          destination[name].extensions.KHR_texture_transform.offset = [offset.x, offset.y - 1 + scale2.y];
        }
        if (rotation2 !== 0) {
          destination[name].extensions.KHR_texture_transform.rotation = rotation2 * math.DEG_TO_RAD;
        }
      }
    }
  }
  writeStandardMaterial(resources, mat2, output, json) {
    const {
      diffuse,
      emissive,
      opacity,
      metalness,
      gloss,
      glossInvert
    } = mat2;
    const pbr = output.pbrMetallicRoughness;
    if (!diffuse.equals(Color.WHITE) || opacity !== 1) {
      pbr.baseColorFactor = [diffuse.r, diffuse.g, diffuse.b, opacity];
    }
    if (metalness !== 1) {
      pbr.metallicFactor = metalness;
    }
    const roughness = glossInvert ? gloss : 1 - gloss;
    if (roughness !== 1) {
      pbr.roughnessFactor = roughness;
    }
    this.attachTexture(resources, mat2, pbr, "baseColorTexture", "diffuseMap", json);
    this.attachTexture(resources, mat2, pbr, "metallicRoughnessTexture", "metalnessMap", json);
    if (!emissive.equals(Color.BLACK)) {
      output.emissiveFactor = [emissive.r, emissive.g, emissive.b];
    }
  }
  writeMaterials(resources, json) {
    if (resources.materials.length > 0) {
      json.materials = resources.materials.map((mat2) => {
        const {
          name,
          blendType,
          cull,
          alphaTest
        } = mat2;
        const material = {
          pbrMetallicRoughness: {}
        };
        if (name && name.length > 0) {
          material.name = name;
        }
        if (mat2 instanceof StandardMaterial) {
          this.writeStandardMaterial(resources, mat2, material, json);
        }
        if (blendType === BLEND_NORMAL) {
          material.alphaMode = "BLEND";
        } else if (blendType === BLEND_NONE) {
          if (alphaTest !== 0) {
            material.alphaMode = "MASK";
            material.alphaCutoff = alphaTest;
          }
        }
        if (cull === CULLFACE_NONE) {
          material.doubleSided = true;
        }
        this.attachTexture(resources, mat2, material, "normalTexture", "normalMap", json);
        this.attachTexture(resources, mat2, material, "occlusionTexture", "aoMap", json);
        this.attachTexture(resources, mat2, material, "emissiveTexture", "emissiveMap", json);
        return material;
      });
    }
  }
  writeNodes(resources, json) {
    if (resources.entities.length > 0) {
      json.nodes = resources.entities.map((entity) => {
        const name = entity.name;
        const t = entity.getLocalPosition();
        const r = entity.getLocalRotation();
        const s2 = entity.getLocalScale();
        const node = {};
        if (name && name.length > 0) {
          node.name = name;
        }
        if (!t.equals(Vec3.ZERO)) {
          node.translation = [t.x, t.y, t.z];
        }
        if (!r.equals(Quat.IDENTITY)) {
          node.rotation = [r.x, r.y, r.z, r.w];
        }
        if (!s2.equals(Vec3.ONE)) {
          node.scale = [s2.x, s2.y, s2.z];
        }
        if (entity.camera && entity.camera.enabled) {
          node.camera = resources.cameras.indexOf(entity.camera);
        }
        const entityMeshInstance = resources.entityMeshInstances.find((e) => e.node === entity);
        if (entityMeshInstance) {
          node.mesh = resources.entityMeshInstances.indexOf(entityMeshInstance);
        }
        if (entity.children.length > 0) {
          node.children = [];
          entity.children.forEach((child) => {
            node.children.push(resources.entities.indexOf(child));
          });
        }
        return node;
      });
    }
  }
  writeMeshes(resources, json) {
    if (resources.entityMeshInstances.length > 0) {
      json.accessors = [];
      json.meshes = [];
      resources.entityMeshInstances.forEach((entityMeshInstances) => {
        const mesh = {
          primitives: []
        };
        const meshInstances = entityMeshInstances.meshInstances;
        meshInstances.forEach((meshInstance) => {
          const primitive2 = _GltfExporter.createPrimitive(resources, json, meshInstance.mesh);
          primitive2.material = resources.materials.indexOf(meshInstance.material);
          mesh.primitives.push(primitive2);
        });
        json.meshes.push(mesh);
      });
    }
  }
  static createPrimitive(resources, json, mesh) {
    const primitive2 = {
      attributes: {}
    };
    const {
      vertexBuffer
    } = mesh;
    const {
      format
    } = vertexBuffer;
    const {
      interleaved,
      elements
    } = format;
    const numVertices = vertexBuffer.getNumVertices();
    elements.forEach((element, elementIndex) => {
      let bufferView = resources.bufferViewMap.get(vertexBuffer);
      if (!bufferView) {
        _GltfExporter.writeBufferView(resources, json, vertexBuffer);
        resources.buffers.push(vertexBuffer);
        bufferView = resources.bufferViewMap.get(vertexBuffer);
      }
      const viewIndex = bufferView[interleaved ? 0 : elementIndex];
      const accessor = {
        bufferView: viewIndex,
        byteOffset: interleaved ? element.offset : 0,
        componentType: getComponentType2(element.dataType),
        type: getAccessorType(element.numComponents),
        count: numVertices
      };
      const idx = json.accessors.push(accessor) - 1;
      primitive2.attributes[getSemantic(element.name)] = idx;
      if (element.name === SEMANTIC_POSITION) {
        const positions = [];
        mesh.getPositions(positions);
        const min = new Vec3();
        const max = new Vec3();
        BoundingBox.computeMinMax(positions, min, max);
        accessor.min = [min.x, min.y, min.z];
        accessor.max = [max.x, max.y, max.z];
      }
    });
    const indexBuffer = mesh.indexBuffer[0];
    if (indexBuffer) {
      let bufferView = resources.bufferViewMap.get(indexBuffer);
      if (!bufferView) {
        _GltfExporter.writeBufferView(resources, json, indexBuffer);
        resources.buffers.push(indexBuffer);
        bufferView = resources.bufferViewMap.get(indexBuffer);
      }
      const viewIndex = bufferView[0];
      const accessor = {
        bufferView: viewIndex,
        componentType: getIndexComponentType(indexBuffer.getFormat()),
        count: indexBuffer.getNumIndices(),
        type: "SCALAR"
      };
      const idx = json.accessors.push(accessor) - 1;
      primitive2.indices = idx;
    }
    return primitive2;
  }
  convertTextures(srcTextures, options2) {
    const textureOptions = {
      maxTextureSize: options2.maxTextureSize
    };
    const promises = [];
    srcTextures.forEach((srcTexture) => {
      const promise = this.textureToCanvas(srcTexture, textureOptions);
      promise.then((canvas) => {
        return new Promise((resolve) => resolve(canvas));
      });
      promises.push(promise);
    });
    return promises;
  }
  writeTextures(resources, textureCanvases, json, options2) {
    const textures = resources.textures;
    const promises = [];
    for (let i = 0; i < textureCanvases.length; i++) {
      const texture = textures[i];
      const canvas = textureCanvases[i];
      const isRGBA = isCanvasTransparent(canvas) || !resources.compressableTexture.has(texture);
      const mimeType = isRGBA ? "image/png" : "image/jpeg";
      promises.push(this.getBlob(canvas, mimeType).then((blob) => {
        const reader = new FileReader();
        reader.readAsArrayBuffer(blob);
        return new Promise((resolve) => {
          reader.onloadend = () => {
            resolve(reader);
          };
        });
      }).then((reader) => {
        const buffer = this.getPaddedArrayBuffer(reader.result);
        _GltfExporter.writeBufferView(resources, json, buffer);
        resources.buffers.push(buffer);
        const bufferView = resources.bufferViewMap.get(buffer);
        json.images[i] = {
          mimeType,
          bufferView: bufferView[0]
        };
        json.samplers[i] = {
          minFilter: getFilter(texture.minFilter),
          magFilter: getFilter(texture.magFilter),
          wrapS: getWrap(texture.addressU),
          wrapT: getWrap(texture.addressV)
        };
        json.textures[i] = {
          sampler: i,
          source: i
        };
      }));
    }
    return Promise.all(promises);
  }
  getBlob(canvas, mimeType) {
    if (canvas.toBlob !== void 0) {
      return new Promise((resolve) => {
        canvas.toBlob(resolve, mimeType);
      });
    }
    let quality = 1;
    if (mimeType === "image/jpeg") {
      quality = 0.92;
    }
    return canvas.convertToBlob({
      type: mimeType,
      quality
    });
  }
  getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
    const paddedLength = math.roundUp(arrayBuffer.byteLength, 4);
    if (paddedLength !== arrayBuffer.byteLength) {
      const array2 = new Uint8Array(paddedLength);
      array2.set(new Uint8Array(arrayBuffer));
      if (paddingByte !== 0) {
        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {
          array2[i] = paddingByte;
        }
      }
      return array2.buffer;
    }
    return arrayBuffer;
  }
  buildJson(resources, options2) {
    var _this = this;
    const promises = this.convertTextures(resources.textures, options2);
    return Promise.all(promises).then(async function(textureCanvases) {
      const json = {
        asset: {
          version: "2.0",
          generator: "PlayCanvas GltfExporter"
        },
        scenes: [{
          nodes: [0]
        }],
        images: [],
        samplers: [],
        textures: [],
        scene: 0
      };
      _this.writeBufferViews(resources, json);
      _this.writeCameras(resources, json);
      _this.writeMeshes(resources, json);
      _this.writeMaterials(resources, json);
      _this.writeNodes(resources, json, options2);
      await _this.writeTextures(resources, textureCanvases, json, options2);
      if (!json.images.length) delete json.images;
      if (!json.samplers.length) delete json.samplers;
      if (!json.textures.length) delete json.textures;
      return json;
    });
  }
  build(entity, options2 = {}) {
    const resources = this.collectResources(entity);
    return this.buildJson(resources, options2).then((json) => {
      const jsonText = JSON.stringify(json);
      const headerLength = 12;
      const jsonHeaderLength = 8;
      const jsonDataLength = jsonText.length;
      const jsonPaddingLength = 4 - (jsonDataLength & 3) & 3;
      const binaryHeaderLength = 8;
      const binaryDataLength = json.buffers.reduce((total, buffer) => math.roundUp(total + buffer.byteLength, 4), 0);
      let totalLength = headerLength + jsonHeaderLength + jsonDataLength + jsonPaddingLength;
      if (binaryDataLength > 0) {
        totalLength += binaryHeaderLength + binaryDataLength;
      }
      const glbBuffer = new ArrayBuffer(totalLength);
      const glbView = new DataView(glbBuffer);
      glbView.setUint32(0, 1179937895, true);
      glbView.setUint32(4, 2, true);
      glbView.setUint32(8, totalLength, true);
      glbView.setUint32(12, jsonDataLength + jsonPaddingLength, true);
      glbView.setUint32(16, 1313821514, true);
      let offset = headerLength + jsonHeaderLength;
      for (let i = 0; i < jsonDataLength; i++) {
        glbView.setUint8(offset + i, jsonText.charCodeAt(i));
      }
      offset += jsonDataLength;
      for (let i = 0; i < jsonPaddingLength; i++) {
        glbView.setUint8(offset + i, 32);
      }
      offset += jsonPaddingLength;
      if (binaryDataLength > 0) {
        glbView.setUint32(offset, binaryDataLength, true);
        glbView.setUint32(offset + 4, 5130562, true);
        offset += binaryHeaderLength;
        resources.buffers.forEach((buffer) => {
          let src;
          const bufferViewId = resources.bufferViewMap.get(buffer)[0];
          const bufferOffset = json.bufferViews[bufferViewId].byteOffset;
          if (buffer instanceof ArrayBuffer) {
            src = new Uint8Array(buffer);
          } else {
            const srcBuffer = buffer.lock();
            if (srcBuffer instanceof ArrayBuffer) {
              src = new Uint8Array(srcBuffer);
            } else {
              src = new Uint8Array(srcBuffer.buffer, srcBuffer.byteOffset, srcBuffer.byteLength);
            }
          }
          const dst = new Uint8Array(glbBuffer, offset + bufferOffset, src.byteLength);
          dst.set(src);
        });
      }
      return Promise.resolve(glbBuffer);
    });
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/render-passes/render-pass-downsample.js
var RenderPassDownsample = class extends RenderPassShaderQuad {
  constructor(device, sourceTexture) {
    super(device);
    this.sourceTexture = sourceTexture;
    this.shader = this.createQuadShader("DownSampleShader", `
			uniform sampler2D sourceTexture;
			uniform vec2 sourceInvResolution;
			varying vec2 uv0;
			void main()
			{
				float x = sourceInvResolution.x;
				float y = sourceInvResolution.y;
				vec3 a = texture2D (sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y + 2.0 * y)).rgb;
				vec3 b = texture2D (sourceTexture, vec2 (uv0.x,		   uv0.y + 2.0 * y)).rgb;
				vec3 c = texture2D (sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y + 2.0 * y)).rgb;
				vec3 d = texture2D (sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y)).rgb;
				vec3 e = texture2D (sourceTexture, vec2 (uv0.x,		   uv0.y)).rgb;
				vec3 f = texture2D (sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y)).rgb;
				vec3 g = texture2D (sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y - 2.0 * y)).rgb;
				vec3 h = texture2D (sourceTexture, vec2 (uv0.x,		   uv0.y - 2.0 * y)).rgb;
				vec3 i = texture2D (sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y - 2.0 * y)).rgb;
				vec3 j = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;
				vec3 k = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;
				vec3 l = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;
				vec3 m = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;
				vec3 value = e * 0.125;
				value += (a + c + g + i) * 0.03125;
				value += (b + d + f + h) * 0.0625;
				value += (j + k + l + m) * 0.125;
				gl_FragColor = vec4(value, 1.0);
			}`);
    this.sourceTextureId = device.scope.resolve("sourceTexture");
    this.sourceInvResolutionId = device.scope.resolve("sourceInvResolution");
    this.sourceInvResolutionValue = new Float32Array(2);
  }
  execute() {
    this.sourceTextureId.setValue(this.sourceTexture);
    this.sourceInvResolutionValue[0] = 1 / this.sourceTexture.width;
    this.sourceInvResolutionValue[1] = 1 / this.sourceTexture.height;
    this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
    super.execute();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/render-passes/render-pass-upsample.js
var RenderPassUpsample = class extends RenderPassShaderQuad {
  constructor(device, sourceTexture) {
    super(device);
    this.sourceTexture = sourceTexture;
    this.shader = this.createQuadShader("UpSampleShader", `
			uniform sampler2D sourceTexture;
			uniform vec2 sourceInvResolution;
			varying vec2 uv0;
			void main()
			{
				float x = sourceInvResolution.x;
				float y = sourceInvResolution.y;
				vec3 a = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;
				vec3 b = texture2D (sourceTexture, vec2 (uv0.x,	 uv0.y + y)).rgb;
				vec3 c = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;
				vec3 d = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y)).rgb;
				vec3 e = texture2D (sourceTexture, vec2 (uv0.x,	 uv0.y)).rgb;
				vec3 f = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y)).rgb;
				vec3 g = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;
				vec3 h = texture2D (sourceTexture, vec2 (uv0.x,	 uv0.y - y)).rgb;
				vec3 i = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;
				vec3 value = e * 4.0;
				value += (b + d + f + h) * 2.0;
				value += (a + c + g + i);
				value *= 1.0 / 16.0;
				gl_FragColor = vec4(value, 1.0);
			}`);
    this.sourceTextureId = device.scope.resolve("sourceTexture");
    this.sourceInvResolutionId = device.scope.resolve("sourceInvResolution");
    this.sourceInvResolutionValue = new Float32Array(2);
  }
  execute() {
    this.sourceTextureId.setValue(this.sourceTexture);
    this.sourceInvResolutionValue[0] = 1 / this.sourceTexture.width;
    this.sourceInvResolutionValue[1] = 1 / this.sourceTexture.height;
    this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
    super.execute();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/render-passes/render-pass-bloom.js
var RenderPassBloom = class extends RenderPass {
  constructor(device, sourceTexture, format) {
    super(device);
    this.bloomTexture = void 0;
    this.lastMipLevel = 1;
    this.bloomRenderTarget = void 0;
    this.textureFormat = void 0;
    this.renderTargets = [];
    this._sourceTexture = sourceTexture;
    this.textureFormat = format;
    this.bloomRenderTarget = this.createRenderTarget(0);
    this.bloomTexture = this.bloomRenderTarget.colorBuffer;
  }
  destroy() {
    this.destroyRenderPasses();
    this.destroyRenderTargets();
  }
  destroyRenderTargets(startIndex = 0) {
    for (let i = startIndex; i < this.renderTargets.length; i++) {
      const rt = this.renderTargets[i];
      rt.destroyTextureBuffers();
      rt.destroy();
    }
    this.renderTargets.length = 0;
  }
  destroyRenderPasses() {
    for (let i = 0; i < this.beforePasses.length; i++) {
      this.beforePasses[i].destroy();
    }
    this.beforePasses.length = 0;
  }
  createRenderTarget(index) {
    return new RenderTarget({
      depth: false,
      colorBuffer: new Texture(this.device, {
        name: `BloomTexture${index}`,
        width: 1,
        height: 1,
        format: this.textureFormat,
        mipmaps: false,
        minFilter: FILTER_LINEAR,
        magFilter: FILTER_LINEAR,
        addressU: ADDRESS_CLAMP_TO_EDGE,
        addressV: ADDRESS_CLAMP_TO_EDGE
      })
    });
  }
  createRenderTargets(count) {
    for (let i = 0; i < count; i++) {
      const rt = i === 0 ? this.bloomRenderTarget : this.createRenderTarget(i);
      this.renderTargets.push(rt);
    }
  }
  calcMipLevels(width, height, minSize) {
    const min = Math.min(width, height);
    return Math.floor(Math.log2(min) - Math.log2(minSize));
  }
  createRenderPasses(numPasses) {
    const device = this.device;
    let passSourceTexture = this._sourceTexture;
    for (let i = 0; i < numPasses; i++) {
      const pass = new RenderPassDownsample(device, passSourceTexture);
      const rt = this.renderTargets[i];
      pass.init(rt, {
        resizeSource: passSourceTexture,
        scaleX: 0.5,
        scaleY: 0.5
      });
      pass.setClearColor(Color.BLACK);
      this.beforePasses.push(pass);
      passSourceTexture = rt.colorBuffer;
    }
    passSourceTexture = this.renderTargets[numPasses - 1].colorBuffer;
    for (let i = numPasses - 2; i >= 0; i--) {
      const pass = new RenderPassUpsample(device, passSourceTexture);
      const rt = this.renderTargets[i];
      pass.init(rt);
      pass.blendState = BlendState.ADDBLEND;
      this.beforePasses.push(pass);
      passSourceTexture = rt.colorBuffer;
    }
  }
  onDisable() {
    var _this$renderTargets$;
    (_this$renderTargets$ = this.renderTargets[0]) == null || _this$renderTargets$.resize(1, 1);
    this.destroyRenderPasses();
    this.destroyRenderTargets(1);
  }
  set sourceTexture(value) {
    this._sourceTexture = value;
    if (this.beforePasses.length > 0) {
      const firstPass = this.beforePasses[0];
      firstPass.options.resizeSource = value;
      firstPass.sourceTexture = value;
    }
  }
  get sourceTexture() {
    return this._sourceTexture;
  }
  frameUpdate() {
    super.frameUpdate();
    let numPasses = this.calcMipLevels(this._sourceTexture.width, this._sourceTexture.height, 2 ** this.lastMipLevel);
    numPasses = Math.max(1, numPasses);
    if (this.renderTargets.length !== numPasses) {
      this.destroyRenderPasses();
      this.destroyRenderTargets(1);
      this.createRenderTargets(numPasses);
      this.createRenderPasses(numPasses);
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/render-passes/render-pass-compose.js
var fragmentShader2 = `
	varying vec2 uv0;
	uniform sampler2D sceneTexture;
	uniform vec2 sceneTextureInvRes;
	#ifdef BLOOM
		uniform sampler2D bloomTexture;
		uniform float bloomIntensity;
	#endif
	#ifdef SSAO
		uniform sampler2D ssaoTexture;
	#endif
	#ifdef GRADING
		uniform vec3 brightnessContrastSaturation;
		vec3 contrastSaturationBrightness(vec3 color, float brt, float sat, float con)
		{
			color = color * brt;
			float grey = dot(color, vec3(0.3, 0.59, 0.11));
			color  = mix(vec3(grey), color, sat);
			return max(mix(vec3(0.5), color, con), 0.0);
		}
	
	#endif
	#ifdef VIGNETTE
		uniform vec4 vignetterParams;
		float vignette(vec2 uv) {
			float inner = vignetterParams.x;
			float outer = vignetterParams.y;
			float curvature = vignetterParams.z;
			float intensity = vignetterParams.w;
			vec2 curve = pow(abs(uv * 2.0 -1.0), vec2(1.0 / curvature));
			float edge = pow(length(curve), curvature);
			return 1.0 - intensity * smoothstep(inner, outer, edge);
		}		
	#endif
	#ifdef FRINGING
		uniform float fringingIntensity;
		vec3 fringing(vec2 uv, vec3 color) {
			vec2 centerDistance = uv0 - 0.5;
			vec2 offset = fringingIntensity * pow(centerDistance, vec2(2.0, 2.0));
			color.r = texture2D(sceneTexture, uv0 - offset).r;
			color.b = texture2D(sceneTexture, uv0 + offset).b;
			return color;
		}
	#endif
	#ifdef CAS
		uniform float sharpness;
		float maxComponent(float x, float y, float z) { return max(x, max(y, z)); }
		vec3 toSDR(vec3 c) { return c / (1.0 + maxComponent(c.r, c.g, c.b)); }
		vec3 toHDR(vec3 c) { return c / (1.0 - maxComponent(c.r, c.g, c.b)); }
		vec3 cas(vec3 color, vec2 uv, float sharpness) {
			float x = sceneTextureInvRes.x;
			float y = sceneTextureInvRes.y;
			vec3 a = toSDR(texture2DLodEXT(sceneTexture, uv + vec2(0.0, -y), 0.0).rgb);
			vec3 b = toSDR(texture2DLodEXT(sceneTexture, uv + vec2(-x, 0.0), 0.0).rgb);
			vec3 c = toSDR(color.rgb);
			vec3 d = toSDR(texture2DLodEXT(sceneTexture, uv + vec2(x, 0.0), 0.0).rgb);
			vec3 e = toSDR(texture2DLodEXT(sceneTexture, uv + vec2(0.0, y), 0.0).rgb);
			float min_g = min(a.g, min(b.g, min(c.g, min(d.g, e.g))));
			float max_g = max(a.g, max(b.g, max(c.g, max(d.g, e.g))));
			float sharpening_amount = sqrt(min(1.0 - max_g, min_g) / max_g);
			float w = sharpening_amount * sharpness;
			vec3 res = (w * (a + b + d + e) + c) / (4.0 * w + 1.0);
			return toHDR(res);
		}
	#endif
	void main() {
		vec2 uv = uv0;
		#ifdef TAA
		#ifdef WEBGPU
			uv.y = 1.0 - uv.y;
		#endif
		#endif
		vec4 scene = texture2DLodEXT(sceneTexture, uv, 0.0);
		vec3 result = scene.rgb;
		#ifdef CAS
			result = cas(result, uv, sharpness);
		#endif
		#ifdef SSAO
			result *= texture2DLodEXT(ssaoTexture, uv0, 0.0).r;
		#endif
		#ifdef FRINGING
			result = fringing(uv, result);
		#endif
		#ifdef BLOOM
			vec3 bloom = texture2DLodEXT(bloomTexture, uv, 0.0).rgb;
			result += bloom * bloomIntensity;
		#endif
		#ifdef GRADING
			result = contrastSaturationBrightness(result, brightnessContrastSaturation.x, brightnessContrastSaturation.z, brightnessContrastSaturation.y);
		#endif
		result = toneMap(result);
		#ifdef VIGNETTE
			result *= vignette(uv);
		#endif
		#ifdef GAMMA_CORRECT_OUTPUT
			result = gammaCorrectOutput(result);
		#endif
		gl_FragColor = vec4(result, scene.a);
	}
`;
var RenderPassCompose = class extends RenderPassShaderQuad {
  constructor(graphicsDevice) {
    super(graphicsDevice);
    this.sceneTexture = null;
    this.bloomIntensity = 0.01;
    this._bloomTexture = null;
    this._ssaoTexture = null;
    this._toneMapping = TONEMAP_LINEAR;
    this._gradingEnabled = false;
    this.gradingSaturation = 1;
    this.gradingContrast = 1;
    this.gradingBrightness = 1;
    this._shaderDirty = true;
    this._vignetteEnabled = false;
    this.vignetteInner = 0.5;
    this.vignetteOuter = 1;
    this.vignetteCurvature = 0.5;
    this.vignetteIntensity = 0.3;
    this._fringingEnabled = false;
    this.fringingIntensity = 10;
    this._taaEnabled = false;
    this._sharpness = 0.5;
    this._srgb = false;
    this._key = "";
    const {
      scope
    } = graphicsDevice;
    this.sceneTextureId = scope.resolve("sceneTexture");
    this.bloomTextureId = scope.resolve("bloomTexture");
    this.ssaoTextureId = scope.resolve("ssaoTexture");
    this.bloomIntensityId = scope.resolve("bloomIntensity");
    this.bcsId = scope.resolve("brightnessContrastSaturation");
    this.vignetterParamsId = scope.resolve("vignetterParams");
    this.fringingIntensityId = scope.resolve("fringingIntensity");
    this.sceneTextureInvResId = scope.resolve("sceneTextureInvRes");
    this.sceneTextureInvResValue = new Float32Array(2);
    this.sharpnessId = scope.resolve("sharpness");
  }
  set bloomTexture(value) {
    if (this._bloomTexture !== value) {
      this._bloomTexture = value;
      this._shaderDirty = true;
    }
  }
  get bloomTexture() {
    return this._bloomTexture;
  }
  set ssaoTexture(value) {
    if (this._ssaoTexture !== value) {
      this._ssaoTexture = value;
      this._shaderDirty = true;
    }
  }
  get ssaoTexture() {
    return this._ssaoTexture;
  }
  set taaEnabled(value) {
    if (this._taaEnabled !== value) {
      this._taaEnabled = value;
      this._shaderDirty = true;
    }
  }
  get taaEnabled() {
    return this._taaEnabled;
  }
  set gradingEnabled(value) {
    if (this._gradingEnabled !== value) {
      this._gradingEnabled = value;
      this._shaderDirty = true;
    }
  }
  get gradingEnabled() {
    return this._gradingEnabled;
  }
  set vignetteEnabled(value) {
    if (this._vignetteEnabled !== value) {
      this._vignetteEnabled = value;
      this._shaderDirty = true;
    }
  }
  get vignetteEnabled() {
    return this._vignetteEnabled;
  }
  set fringingEnabled(value) {
    if (this._fringingEnabled !== value) {
      this._fringingEnabled = value;
      this._shaderDirty = true;
    }
  }
  get fringingEnabled() {
    return this._fringingEnabled;
  }
  set toneMapping(value) {
    if (this._toneMapping !== value) {
      this._toneMapping = value;
      this._shaderDirty = true;
    }
  }
  get toneMapping() {
    return this._toneMapping;
  }
  set sharpness(value) {
    if (this._sharpness !== value) {
      this._sharpness = value;
      this._shaderDirty = true;
    }
  }
  get sharpness() {
    return this._sharpness;
  }
  get isSharpnessEnabled() {
    return this._sharpness > 0;
  }
  postInit() {
    this.setClearColor(Color.BLACK);
    this.setClearDepth(1);
    this.setClearStencil(0);
  }
  frameUpdate() {
    var _this$renderTarget;
    const rt = (_this$renderTarget = this.renderTarget) != null ? _this$renderTarget : this.device.backBuffer;
    const srgb = rt.isColorBufferSrgb(0);
    if (this._srgb !== srgb) {
      this._srgb = srgb;
      this._shaderDirty = true;
    }
    if (this._shaderDirty) {
      this._shaderDirty = false;
      const key = `${this.toneMapping}-${this.bloomTexture ? "bloom" : "nobloom"}-${this.ssaoTexture ? "ssao" : "nossao"}-${this.gradingEnabled ? "grading" : "nograding"}-${this.vignetteEnabled ? "vignette" : "novignette"}-${this.fringingEnabled ? "fringing" : "nofringing"}-${this.taaEnabled ? "taa" : "notaa"}-${this.isSharpnessEnabled ? "cas" : "nocas"}-${this._srgb ? "srgb" : "linear"}`;
      if (this._key !== key) {
        this._key = key;
        const defines = (this.bloomTexture ? "#define BLOOM\n" : "") + (this.ssaoTexture ? "#define SSAO\n" : "") + (this.gradingEnabled ? "#define GRADING\n" : "") + (this.vignetteEnabled ? "#define VIGNETTE\n" : "") + (this.fringingEnabled ? "#define FRINGING\n" : "") + (this.taaEnabled ? "#define TAA\n" : "") + (this.isSharpnessEnabled ? "#define CAS\n" : "") + (this._srgb ? "" : "#define GAMMA_CORRECT_OUTPUT\n");
        const fsChunks = shaderChunks.decodePS + shaderChunks.gamma2_2PS + ShaderGenerator.tonemapCode(this.toneMapping);
        this.shader = this.createQuadShader(`ComposeShader-${key}`, defines + fsChunks + fragmentShader2);
      }
    }
  }
  execute() {
    this.sceneTextureId.setValue(this.sceneTexture);
    this.sceneTextureInvResValue[0] = 1 / this.sceneTexture.width;
    this.sceneTextureInvResValue[1] = 1 / this.sceneTexture.height;
    this.sceneTextureInvResId.setValue(this.sceneTextureInvResValue);
    if (this._bloomTexture) {
      this.bloomTextureId.setValue(this._bloomTexture);
      this.bloomIntensityId.setValue(this.bloomIntensity);
    }
    if (this._ssaoTexture) {
      this.ssaoTextureId.setValue(this._ssaoTexture);
    }
    if (this._gradingEnabled) {
      this.bcsId.setValue([this.gradingBrightness, this.gradingContrast, this.gradingSaturation]);
    }
    if (this._vignetteEnabled) {
      this.vignetterParamsId.setValue([this.vignetteInner, this.vignetteOuter, this.vignetteCurvature, this.vignetteIntensity]);
    }
    if (this._fringingEnabled) {
      this.fringingIntensityId.setValue(this.fringingIntensity / 1024);
    }
    if (this.isSharpnessEnabled) {
      this.sharpnessId.setValue(math.lerp(-0.125, -0.2, this.sharpness));
    }
    super.execute();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/render-passes/render-pass-taa.js
var fs = `
	uniform highp sampler2D uSceneDepthMap;
	uniform sampler2D sourceTexture;
	uniform sampler2D historyTexture;
	uniform mat4 matrix_viewProjectionPrevious;
	uniform mat4 matrix_viewProjectionInverse;
	uniform vec4 jitters;
	uniform vec2 textureSize;
	varying vec2 uv0;
	vec2 reproject(vec2 uv, float depth) {
		#ifndef WEBGPU
			depth = depth * 2.0 - 1.0;
		#endif
		vec4 ndc = vec4(uv * 2.0 - 1.0, depth, 1.0);
		ndc.xy -= jitters.xy;
		vec4 worldPosition = matrix_viewProjectionInverse * ndc;
		worldPosition /= worldPosition.w;
	
		vec4 screenPrevious = matrix_viewProjectionPrevious * worldPosition;
		return (screenPrevious.xy / screenPrevious.w) * 0.5 + 0.5;
	}
	vec4 colorClamp(vec2 uv, vec4 historyColor) {
		vec3 minColor = vec3(9999.0);
		vec3 maxColor = vec3(-9999.0);
 
		for(float x = -1.0; x <= 1.0; ++x)
		{
			for(float y = -1.0; y <= 1.0; ++y)
			{
				vec3 color = texture2D(sourceTexture, uv + vec2(x, y) / textureSize).rgb;
				minColor = min(minColor, color);
				maxColor = max(maxColor, color);
			}
		}
 
		vec3 clamped = clamp(historyColor.rgb, minColor, maxColor);
		return vec4(clamped, historyColor.a);
	}
	void main()
	{
		vec2 uv = uv0;
		#ifdef WEBGPU
			uv.y = 1.0 - uv.y;
		#endif
		vec4 srcColor = texture2D(sourceTexture, uv);
		float depth = texture2DLodEXT(uSceneDepthMap, uv, 0.0).r;
		vec2 historyUv = reproject(uv0, depth);
		#ifdef QUALITY_HIGH
			vec4 historyColor = SampleTextureCatmullRom(TEXTURE_PASS(historyTexture), historyUv, textureSize);
		#else
			vec4 historyColor = texture2D(historyTexture, historyUv);
		#endif
		vec4 historyColorClamped = colorClamp(uv, historyColor);
		float mixFactor = (historyUv.x < 0.0 || historyUv.x > 1.0 || historyUv.y < 0.0 || historyUv.y > 1.0) ?
			1.0 : 0.05;
		gl_FragColor = mix(historyColorClamped, srcColor, mixFactor);
	}
`;
var RenderPassTAA = class extends RenderPassShaderQuad {
  constructor(device, sourceTexture, cameraComponent) {
    super(device);
    this.historyIndex = 0;
    this.historyTexture = null;
    this.historyTextures = [];
    this.historyRenderTargets = [];
    this.sourceTexture = sourceTexture;
    this.cameraComponent = cameraComponent;
    const defines = `
			#define QUALITY_HIGH
		`;
    const fsChunks = shaderChunks.sampleCatmullRomPS;
    this.shader = this.createQuadShader("TaaResolveShader", defines + fsChunks + fs);
    const {
      scope
    } = device;
    this.sourceTextureId = scope.resolve("sourceTexture");
    this.textureSizeId = scope.resolve("textureSize");
    this.textureSize = new Float32Array(2);
    this.historyTextureId = scope.resolve("historyTexture");
    this.viewProjPrevId = scope.resolve("matrix_viewProjectionPrevious");
    this.viewProjInvId = scope.resolve("matrix_viewProjectionInverse");
    this.jittersId = scope.resolve("jitters");
    this.setup();
  }
  destroy() {
    if (this.renderTarget) {
      this.renderTarget.destroyTextureBuffers();
      this.renderTarget.destroy();
      this.renderTarget = null;
    }
  }
  setup() {
    for (let i = 0; i < 2; ++i) {
      this.historyTextures[i] = new Texture(this.device, {
        name: `TAA-History-${i}`,
        width: 4,
        height: 4,
        format: this.sourceTexture.format,
        mipmaps: false,
        minFilter: FILTER_LINEAR,
        magFilter: FILTER_LINEAR,
        addressU: ADDRESS_CLAMP_TO_EDGE,
        addressV: ADDRESS_CLAMP_TO_EDGE
      });
      this.historyRenderTargets[i] = new RenderTarget({
        colorBuffer: this.historyTextures[i],
        depth: false
      });
    }
    this.historyTexture = this.historyTextures[0];
    this.init(this.historyRenderTargets[0], {
      resizeSource: this.sourceTexture
    });
  }
  before() {
    this.sourceTextureId.setValue(this.sourceTexture);
    this.historyTextureId.setValue(this.historyTextures[1 - this.historyIndex]);
    this.textureSize[0] = this.sourceTexture.width;
    this.textureSize[1] = this.sourceTexture.height;
    this.textureSizeId.setValue(this.textureSize);
    const camera = this.cameraComponent.camera;
    this.viewProjPrevId.setValue(camera._viewProjPrevious.data);
    this.viewProjInvId.setValue(camera._viewProjInverse.data);
    this.jittersId.setValue(camera._jitters);
  }
  update() {
    this.historyIndex = 1 - this.historyIndex;
    this.historyTexture = this.historyTextures[this.historyIndex];
    this.renderTarget = this.historyRenderTargets[this.historyIndex];
    return this.historyTexture;
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/render-passes/render-pass-prepass.js
var tempMeshInstances2 = [];
var DEPTH_UNIFORM_NAME = "uSceneDepthMap";
var VELOCITY_UNIFORM_NAME = "uSceneVelocityMap";
var RenderPassPrepass = class extends RenderPass {
  constructor(device, scene, renderer, camera, depthBuffer, options2) {
    super(device);
    this.viewBindGroups = [];
    this.velocityTexture = void 0;
    this.scene = scene;
    this.renderer = renderer;
    this.camera = camera;
    this.setupRenderTarget(depthBuffer, options2);
  }
  destroy() {
    var _this$renderTarget, _this$velocityTexture;
    super.destroy();
    (_this$renderTarget = this.renderTarget) == null || _this$renderTarget.destroy();
    this.renderTarget = null;
    (_this$velocityTexture = this.velocityTexture) == null || _this$velocityTexture.destroy();
    this.velocityTexture = null;
    this.viewBindGroups.forEach((bg) => {
      bg.defaultUniformBuffer.destroy();
      bg.destroy();
    });
    this.viewBindGroups.length = 0;
  }
  setupRenderTarget(depthBuffer, options2) {
    const {
      device
    } = this;
    const velocityFormat = device.getRenderableHdrFormat([PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA16F]);
    this.velocityTexture = new Texture(device, {
      name: "VelocityTexture",
      width: 4,
      height: 4,
      format: velocityFormat,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
    const renderTarget = new RenderTarget({
      name: "PrepassRT",
      depthBuffer
    });
    this.init(renderTarget, options2);
    this.depthStencilOps.storeDepth = true;
  }
  after() {
    this.device.scope.resolve(DEPTH_UNIFORM_NAME).setValue(this.renderTarget.depthBuffer);
    this.device.scope.resolve(VELOCITY_UNIFORM_NAME).setValue(this.velocityTexture);
  }
  execute() {
    const {
      renderer,
      scene,
      renderTarget
    } = this;
    const camera = this.camera.camera;
    const layers = scene.layers.layerList;
    const subLayerEnabled = scene.layers.subLayerEnabled;
    const isTransparent = scene.layers.subLayerList;
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      if (layer.enabled && subLayerEnabled[i]) {
        if (layer.camerasSet.has(camera)) {
          if (layer.id === LAYERID_DEPTH) {
            break;
          }
          const culledInstances = layer.getCulledInstances(camera);
          const meshInstances = isTransparent[i] ? culledInstances.transparent : culledInstances.opaque;
          for (let j = 0; j < meshInstances.length; j++) {
            var _meshInstance$materia;
            const meshInstance = meshInstances[j];
            if ((_meshInstance$materia = meshInstance.material) != null && _meshInstance$materia.depthWrite) {
              tempMeshInstances2.push(meshInstance);
            }
          }
          renderer.renderForwardLayer(camera, renderTarget, null, void 0, SHADER_PREPASS_VELOCITY, this.viewBindGroups, {
            meshInstances: tempMeshInstances2
          });
          tempMeshInstances2.length = 0;
        }
      }
    }
  }
  frameUpdate() {
    super.frameUpdate();
    const {
      camera
    } = this;
    this.setClearDepth(camera.clearDepthBuffer ? 1 : void 0);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/render-passes/render-pass-depth-aware-blur.js
var RenderPassDepthAwareBlur = class extends RenderPassShaderQuad {
  constructor(device, sourceTexture, horizontal) {
    super(device);
    this.sourceTexture = sourceTexture;
    this.shader = this.createQuadShader(`DepthAware${horizontal ? "Horizontal" : "Vertical"}BlurShader`, `${shaderChunks.screenDepthPS}

						${horizontal ? "#define HORIZONTAL" : ""}

						varying vec2 uv0;

						uniform sampler2D sourceTexture;
						uniform vec2 sourceInvResolution;
						uniform int filterSize;

						float random(const highp vec2 w) {
								const vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);
								return fract(m.z * fract(dot(w, m.xy)));
						}

						float bilateralWeight(in float depth, in float sampleDepth) {
								float diff = (sampleDepth - depth);
								return max(0.0, 1.0 - diff * diff);
						}

						void tap(inout float sum, inout float totalWeight, float weight, float depth, vec2 position) {

								float color = texture2D(sourceTexture, position).r;
								float textureDepth = -getLinearScreenDepth(position);
						
								float bilateral = bilateralWeight(depth, textureDepth);

								bilateral *= weight;
								sum += color * bilateral;
								totalWeight += bilateral;
						}

						// TODO: weights of 1 are used for all samples. Test with gaussian weights
						void main() {

								// handle the center pixel separately because it doesn't participate in bilateral filtering
								float depth = -getLinearScreenDepth(uv0);
								float totalWeight = 1.0;
								float color = texture2D(sourceTexture, uv0 ).r;
								float sum = color * totalWeight;

								for (int i = -filterSize; i <= filterSize; i++) {
										float weight = 1.0;

										#ifdef HORIZONTAL
												vec2 offset = vec2(i, 0) * sourceInvResolution;
										#else
												vec2 offset = vec2(0, i) * sourceInvResolution;
										#endif

										tap(sum, totalWeight, weight, depth, uv0 + offset);
								}

								float ao = sum / totalWeight;

								// simple dithering helps a lot (assumes 8 bits target)
								// this is most useful with high quality/large blurs
								// ao += ((random(gl_FragCoord.xy) - 0.5) / 255.0);

								gl_FragColor.r = ao;
						}
				`);
    const scope = this.device.scope;
    this.sourceTextureId = scope.resolve("sourceTexture");
    this.sourceInvResolutionId = scope.resolve("sourceInvResolution");
    this.sourceInvResolutionValue = new Float32Array(2);
    this.filterSizeId = scope.resolve("filterSize");
  }
  execute() {
    this.filterSizeId.setValue(4);
    this.sourceTextureId.setValue(this.sourceTexture);
    const {
      width,
      height
    } = this.sourceTexture;
    this.sourceInvResolutionValue[0] = 1 / width;
    this.sourceInvResolutionValue[1] = 1 / height;
    this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
    super.execute();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/render-passes/render-pass-ssao.js
var fs2 = `
	varying vec2 uv0;
	uniform vec2 uInvResolution;
	uniform float uAspect;
	#define saturate(x) clamp(x,0.0,1.0)
	highp float getWFromProjectionMatrix(const mat4 p, const vec3 v) {
		return -v.z;
	}
	highp float getViewSpaceZFromW(const mat4 p, const float w) {
		return -w;
	}
	const float kLog2LodRate = 3.0;
	float random(const highp vec2 w) {
		const vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);
		return fract(m.z * fract(dot(w, m.xy)));
	}
	highp vec2 getFragCoord() {
		return gl_FragCoord.xy;
	}
	highp vec3 computeViewSpacePositionFromDepth(highp vec2 uv, highp float linearDepth) {
		return vec3((0.5 - uv) * vec2(uAspect, 1.0) * linearDepth, linearDepth);
	}
	highp vec3 faceNormal(highp vec3 dpdx, highp vec3 dpdy) {
		return normalize(cross(dpdx, dpdy));
	}
	highp vec3 computeViewSpaceNormal(const highp vec3 position) {
		return faceNormal(dFdx(position), dFdy(position));
	}
	highp vec3 computeViewSpaceNormal(const highp vec3 position, const highp vec2 uv) {
		highp vec2 uvdx = uv + vec2(uInvResolution.x, 0.0);
		highp vec2 uvdy = uv + vec2(0.0, uInvResolution.y);
		highp vec3 px = computeViewSpacePositionFromDepth(uvdx, -getLinearScreenDepth(uvdx));
		highp vec3 py = computeViewSpacePositionFromDepth(uvdy, -getLinearScreenDepth(uvdy));
		highp vec3 dpdx = px - position;
		highp vec3 dpdy = py - position;
		return faceNormal(dpdx, dpdy);
	}
	uniform vec2 uSampleCount;
	uniform float uSpiralTurns;
	#define PI (3.14159)
	vec3 tapLocation(float i, const float noise) {
		float offset = ((2.0 * PI) * 2.4) * noise;
		float angle = ((i * uSampleCount.y) * uSpiralTurns) * (2.0 * PI) + offset;
		float radius = (i + noise + 0.5) * uSampleCount.y;
		return vec3(cos(angle), sin(angle), radius * radius);
	}
	highp vec2 startPosition(const float noise) {
		float angle = ((2.0 * PI) * 2.4) * noise;
		return vec2(cos(angle), sin(angle));
	}
	uniform vec2 uAngleIncCosSin;
	highp mat2 tapAngleStep() {
		highp vec2 t = uAngleIncCosSin;
		return mat2(t.x, t.y, -t.y, t.x);
	}
	vec3 tapLocationFast(float i, vec2 p, const float noise) {
		float radius = (i + noise + 0.5) * uSampleCount.y;
		return vec3(p, radius * radius);
	}
	uniform float uMaxLevel;
	uniform float uInvRadiusSquared;
	uniform float uMinHorizonAngleSineSquared;
	uniform float uBias;
	uniform float uPeak2;
	void computeAmbientOcclusionSAO(inout float occlusion, float i, float ssDiskRadius,
			const highp vec2 uv, const highp vec3 origin, const vec3 normal,
			const vec2 tapPosition, const float noise) {
		vec3 tap = tapLocationFast(i, tapPosition, noise);
		float ssRadius = max(1.0, tap.z * ssDiskRadius);
		vec2 uvSamplePos = uv + vec2(ssRadius * tap.xy) * uInvResolution;
		float level = clamp(floor(log2(ssRadius)) - kLog2LodRate, 0.0, float(uMaxLevel));
		highp float occlusionDepth = -getLinearScreenDepth(uvSamplePos);
		highp vec3 p = computeViewSpacePositionFromDepth(uvSamplePos, occlusionDepth);
		vec3 v = p - origin;
		float vv = dot(v, v);
		float vn = dot(v, normal);
		float w = max(0.0, 1.0 - vv * uInvRadiusSquared);
		w = w * w;
		w *= step(vv * uMinHorizonAngleSineSquared, vn * vn);
		occlusion += w * max(0.0, vn + origin.z * uBias) / (vv + uPeak2);
	}
	uniform float uProjectionScaleRadius;
	uniform float uIntensity;
	float scalableAmbientObscurance(highp vec2 uv, highp vec3 origin, vec3 normal) {
		float noise = random(getFragCoord());
		highp vec2 tapPosition = startPosition(noise);
		highp mat2 angleStep = tapAngleStep();
		float ssDiskRadius = -(uProjectionScaleRadius / origin.z);
		float occlusion = 0.0;
		for (float i = 0.0; i < uSampleCount.x; i += 1.0) {
			computeAmbientOcclusionSAO(occlusion, i, ssDiskRadius, uv, origin, normal, tapPosition, noise);
			tapPosition = angleStep * tapPosition;
		}
		return occlusion;
	}
	uniform float uPower;
	void main() {
		highp vec2 uv = uv0;
		highp float depth = -getLinearScreenDepth(uv0);
		highp vec3 origin = computeViewSpacePositionFromDepth(uv, depth);
		vec3 normal = computeViewSpaceNormal(origin, uv);
		float occlusion = 0.0;
		if (uIntensity > 0.0) {
			occlusion = scalableAmbientObscurance(uv, origin, normal);
		}
		float ao = max(0.0, 1.0 - occlusion * uIntensity);
		ao = pow(ao, uPower);
		gl_FragColor = vec4(ao, ao, ao, 1.0);
	}
`;
var RenderPassSsao = class extends RenderPassShaderQuad {
  constructor(device, sourceTexture, cameraComponent, blurEnabled) {
    super(device);
    this.radius = 5;
    this.intensity = 1;
    this.power = 1;
    this.sampleCount = 10;
    this.minAngle = 5;
    this.ssaoTexture = void 0;
    this._scale = 1;
    this.sourceTexture = sourceTexture;
    this.cameraComponent = cameraComponent;
    this.shader = this.createQuadShader("SsaoShader", shaderChunks.screenDepthPS + fs2);
    const rt = this.createRenderTarget("SsaoFinalTexture");
    this.ssaoTexture = rt.colorBuffer;
    this.init(rt, {
      resizeSource: this.sourceTexture
    });
    if (blurEnabled) {
      const blurRT = this.createRenderTarget("SsaoTempTexture");
      const blurPassHorizontal = new RenderPassDepthAwareBlur(device, rt.colorBuffer, true);
      blurPassHorizontal.init(blurRT, {
        resizeSource: rt.colorBuffer
      });
      const blurPassVertical = new RenderPassDepthAwareBlur(device, blurRT.colorBuffer, false);
      blurPassVertical.init(rt, {
        resizeSource: rt.colorBuffer
      });
      this.afterPasses.push(blurPassHorizontal);
      this.afterPasses.push(blurPassVertical);
    }
  }
  destroy() {
    var _this$renderTarget, _this$renderTarget2;
    (_this$renderTarget = this.renderTarget) == null || _this$renderTarget.destroyTextureBuffers();
    (_this$renderTarget2 = this.renderTarget) == null || _this$renderTarget2.destroy();
    this.renderTarget = null;
    if (this.afterPasses.length > 0) {
      const blurRt = this.afterPasses[0].renderTarget;
      blurRt == null || blurRt.destroyTextureBuffers();
      blurRt == null || blurRt.destroy();
    }
    this.afterPasses.forEach((pass) => pass.destroy());
    this.afterPasses.length = 0;
    super.destroy();
  }
  set scale(value) {
    this._scale = value;
    this.options.scaleX = value;
    this.options.scaleY = value;
  }
  get scale() {
    return this._scale;
  }
  createRenderTarget(name) {
    return new RenderTarget({
      depth: false,
      colorBuffer: new Texture(this.device, {
        name,
        width: 1,
        height: 1,
        format: PIXELFORMAT_R8,
        mipmaps: false,
        minFilter: FILTER_NEAREST,
        magFilter: FILTER_NEAREST,
        addressU: ADDRESS_CLAMP_TO_EDGE,
        addressV: ADDRESS_CLAMP_TO_EDGE
      })
    });
  }
  execute() {
    const {
      device,
      sourceTexture,
      sampleCount,
      minAngle,
      scale: scale2
    } = this;
    const {
      width,
      height
    } = this.renderTarget.colorBuffer;
    const scope = device.scope;
    scope.resolve("uAspect").setValue(width / height);
    scope.resolve("uInvResolution").setValue([1 / width, 1 / height]);
    scope.resolve("uSampleCount").setValue([sampleCount, 1 / sampleCount]);
    const minAngleSin = Math.sin(minAngle * Math.PI / 180);
    scope.resolve("uMinHorizonAngleSineSquared").setValue(minAngleSin * minAngleSin);
    const spiralTurns = 10;
    const step = 1 / (sampleCount - 0.5) * spiralTurns * 2 * 3.141;
    const radius = this.radius * scale2;
    const bias = 1e-3;
    const peak = 0.1 * radius;
    const intensity = 2 * (peak * 2 * 3.141) * this.intensity / sampleCount;
    const projectionScale = 0.5 * sourceTexture.height * scale2;
    scope.resolve("uSpiralTurns").setValue(spiralTurns);
    scope.resolve("uAngleIncCosSin").setValue([Math.cos(step), Math.sin(step)]);
    scope.resolve("uMaxLevel").setValue(0);
    scope.resolve("uInvRadiusSquared").setValue(1 / (radius * radius));
    scope.resolve("uBias").setValue(bias);
    scope.resolve("uPeak2").setValue(peak * peak);
    scope.resolve("uIntensity").setValue(intensity);
    scope.resolve("uPower").setValue(this.power);
    scope.resolve("uProjectionScaleRadius").setValue(projectionScale * radius);
    super.execute();
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/render-passes/render-pass-camera-frame.js
var RenderPassCameraFrame = class extends RenderPass {
  constructor(app2, options2 = {}) {
    super(app2.graphicsDevice);
    this.app = void 0;
    this.prePass = void 0;
    this.scenePass = void 0;
    this.composePass = void 0;
    this.bloomPass = void 0;
    this.ssaoPass = void 0;
    this.taaPass = void 0;
    this._bloomEnabled = false;
    this._ssaoEnabled = false;
    this._renderTargetScale = 1;
    this.rt = null;
    this.app = app2;
    this.options = this.sanitizeOptions(options2);
    this.setupRenderPasses(this.options);
  }
  destroy() {
    this.sceneTexture = null;
    this.sceneDepth = null;
    if (this.rt) {
      this.rt.destroyTextureBuffers();
      this.rt.destroy();
      this.rt = null;
    }
    this.beforePasses.forEach((pass) => pass.destroy());
    this.beforePasses = null;
  }
  sanitizeOptions(options2) {
    const defaults = {
      camera: null,
      samples: 2,
      sceneColorMap: true,
      lastGrabLayerId: LAYERID_SKYBOX,
      lastGrabLayerIsTransparent: false,
      lastSceneLayerId: LAYERID_IMMEDIATE,
      lastSceneLayerIsTransparent: true,
      taaEnabled: false,
      bloomEnabled: false,
      ssaoEnabled: false,
      ssaoBlurEnabled: true
    };
    return Object.assign({}, defaults, options2);
  }
  set renderTargetScale(value) {
    this._renderTargetScale = value;
    if (this.scenePass) {
      this.scenePass.options.scaleX = value;
      this.scenePass.options.scaleY = value;
    }
  }
  get renderTargetScale() {
    return this._renderTargetScale;
  }
  get bloomEnabled() {
    return this._bloomEnabled;
  }
  set ssaoEnabled(value) {
    if (this._ssaoEnabled !== value) {
      this._ssaoEnabled = value;
      this.composePass.ssaoTexture = value ? this.ssaoPass.ssaoTexture : null;
      this.ssaoPass.enabled = value;
    }
  }
  get ssaoEnabled() {
    return this._ssaoEnabled;
  }
  set lastMipLevel(value) {
    this.bloomPass.lastMipLevel = value;
  }
  get lastMipLevel() {
    return this.bloomPass.lastMipLevel;
  }
  setupRenderPasses(options2) {
    const {
      device
    } = this;
    const cameraComponent = options2.camera;
    const targetRenderTarget = cameraComponent.renderTarget;
    this.hdrFormat = device.getRenderableHdrFormat() || PIXELFORMAT_RGBA8;
    if (!cameraComponent.rendering) {
      const renderingParams = new RenderingParams();
      renderingParams.gammaCorrection = GAMMA_NONE;
      renderingParams.toneMapping = TONEMAP_NONE;
      cameraComponent.rendering = renderingParams;
    }
    this.sceneTexture = new Texture(device, {
      name: "SceneColor",
      width: 4,
      height: 4,
      format: this.hdrFormat,
      mipmaps: false,
      minFilter: FILTER_LINEAR,
      magFilter: FILTER_LINEAR,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
    this.sceneDepth = new Texture(device, {
      name: "SceneDepth",
      width: 4,
      height: 4,
      format: PIXELFORMAT_DEPTH,
      mipmaps: false,
      minFilter: FILTER_NEAREST,
      magFilter: FILTER_NEAREST,
      addressU: ADDRESS_CLAMP_TO_EDGE,
      addressV: ADDRESS_CLAMP_TO_EDGE
    });
    this.rt = new RenderTarget({
      colorBuffer: this.sceneTexture,
      depthBuffer: this.sceneDepth,
      samples: options2.samples
    });
    this.sceneOptions = {
      resizeSource: targetRenderTarget,
      scaleX: this.renderTargetScale,
      scaleY: this.renderTargetScale
    };
    this.createPasses(options2);
    const allPasses = this.collectPasses();
    this.beforePasses = allPasses.filter((element) => element !== void 0);
  }
  collectPasses() {
    return [this.prePass, this.ssaoPass, this.scenePass, this.colorGrabPass, this.scenePassTransparent, this.taaPass, this.bloomPass, this.composePass, this.afterPass];
  }
  createPasses(options2) {
    this.setupScenePrepass(options2);
    this.setupSsaoPass(options2);
    const scenePassesInfo = this.setupScenePass(options2);
    const sceneTextureWithTaa = this.setupTaaPass(options2);
    this.setupBloomPass(options2, sceneTextureWithTaa);
    this.setupComposePass(options2);
    this.setupAfterPass(options2, scenePassesInfo);
  }
  setupScenePrepass(options2) {
    if (options2.prepassEnabled) {
      const {
        app: app2,
        device
      } = this;
      const {
        scene,
        renderer
      } = app2;
      const cameraComponent = options2.camera;
      this.prePass = new RenderPassPrepass(device, scene, renderer, cameraComponent, this.sceneDepth, this.sceneOptions);
    }
  }
  setupScenePass(options2) {
    const {
      app: app2,
      device
    } = this;
    const {
      scene,
      renderer
    } = app2;
    const composition = scene.layers;
    const cameraComponent = options2.camera;
    this.scenePass = new RenderPassForward(device, composition, scene, renderer);
    this.scenePass.init(this.rt, this.sceneOptions);
    if (options2.prepassEnabled) {
      this.scenePass.noDepthClear = true;
      this.scenePass.depthStencilOps.storeDepth = true;
    }
    const lastLayerId = options2.sceneColorMap ? options2.lastGrabLayerId : options2.lastSceneLayerId;
    const lastLayerIsTransparent = options2.sceneColorMap ? options2.lastGrabLayerIsTransparent : options2.lastSceneLayerIsTransparent;
    const ret = {
      lastAddedIndex: 0,
      clearRenderTarget: true
    };
    ret.lastAddedIndex = this.scenePass.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, lastLayerId, lastLayerIsTransparent);
    ret.clearRenderTarget = false;
    if (options2.sceneColorMap) {
      this.colorGrabPass = new RenderPassColorGrab(device);
      this.colorGrabPass.source = this.rt;
      this.scenePassTransparent = new RenderPassForward(device, composition, scene, renderer);
      this.scenePassTransparent.init(this.rt);
      ret.lastAddedIndex = this.scenePassTransparent.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, options2.lastSceneLayerId, options2.lastSceneLayerIsTransparent);
      if (options2.prepassEnabled) {
        this.scenePassTransparent.depthStencilOps.storeDepth = true;
      }
    }
    return ret;
  }
  setupSsaoPass(options2) {
    const {
      camera,
      ssaoBlurEnabled,
      ssaoEnabled
    } = options2;
    if (ssaoEnabled) {
      this.ssaoPass = new RenderPassSsao(this.device, this.sceneTexture, camera, ssaoBlurEnabled);
    }
  }
  setupBloomPass(options2, inputTexture) {
    if (options2.bloomEnabled) {
      this.bloomPass = new RenderPassBloom(this.device, inputTexture, this.hdrFormat);
    }
  }
  setupTaaPass(options2) {
    let textureWithTaa = this.sceneTexture;
    if (options2.taaEnabled) {
      const cameraComponent = options2.camera;
      this.taaPass = new RenderPassTAA(this.device, this.sceneTexture, cameraComponent);
      textureWithTaa = this.taaPass.historyTexture;
    }
    return textureWithTaa;
  }
  setupComposePass(options2) {
    var _this$bloomPass;
    this.composePass = new RenderPassCompose(this.device);
    this.composePass.bloomTexture = (_this$bloomPass = this.bloomPass) == null ? void 0 : _this$bloomPass.bloomTexture;
    this.composePass.taaEnabled = options2.taaEnabled;
    const cameraComponent = options2.camera;
    const targetRenderTarget = cameraComponent.renderTarget;
    this.composePass.init(targetRenderTarget);
  }
  setupAfterPass(options2, scenePassesInfo) {
    const {
      app: app2
    } = this;
    const {
      scene,
      renderer
    } = app2;
    const composition = scene.layers;
    const cameraComponent = options2.camera;
    const targetRenderTarget = cameraComponent.renderTarget;
    this.afterPass = new RenderPassForward(this.device, composition, scene, renderer);
    this.afterPass.init(targetRenderTarget);
    this.afterPass.addLayers(composition, cameraComponent, scenePassesInfo.lastAddedIndex, scenePassesInfo.clearRenderTarget);
  }
  frameUpdate() {
    var _this$taaPass$update, _this$taaPass;
    super.frameUpdate();
    const sceneTexture = (_this$taaPass$update = (_this$taaPass = this.taaPass) == null ? void 0 : _this$taaPass.update()) != null ? _this$taaPass$update : this.rt.colorBuffer;
    this.composePass.sceneTexture = sceneTexture;
    if (this.bloomEnabled) {
      this.bloomPass.sourceTexture = sceneTexture;
    }
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/gizmo/constants.js
var GIZMOSPACE_LOCAL = "local";
var GIZMOSPACE_WORLD = "world";
var GIZMOAXIS_X = "x";
var GIZMOAXIS_Y = "y";
var GIZMOAXIS_Z = "z";
var GIZMOAXIS_YZ = "yz";
var GIZMOAXIS_XZ = "xz";
var GIZMOAXIS_XY = "xy";
var GIZMOAXIS_XYZ = "xyz";
var GIZMOAXIS_FACE = "face";

// ../node_modules/playcanvas/build/playcanvas/src/extras/gizmo/gizmo.js
var tmpV1 = new Vec3();
var tmpM1 = new Mat4();
var tmpM2 = new Mat4();
var tmpR1 = new Ray();
var MIN_GIZMO_SCALE = 1e-4;
var PERS_SCALE_RATIO = 0.3;
var ORTHO_SCALE_RATIO = 0.32;
var Gizmo = class _Gizmo extends EventHandler {
  constructor(app2, camera, layer) {
    super();
    this._size = 1;
    this._scale = 1;
    this._coordSpace = GIZMOSPACE_WORLD;
    this._app = void 0;
    this._device = void 0;
    this._camera = void 0;
    this._layer = void 0;
    this.nodes = [];
    this.root = void 0;
    this.intersectData = [];
    this._app = app2;
    this._device = app2.graphicsDevice;
    this._camera = camera;
    this._layer = layer;
    this.root = new Entity("gizmo");
    this._app.root.addChild(this.root);
    this.root.enabled = false;
    this._updateScale();
    this._onPointerDown = this._onPointerDown.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerUp = this._onPointerUp.bind(this);
    this._device.canvas.addEventListener("pointerdown", this._onPointerDown, true);
    this._device.canvas.addEventListener("pointermove", this._onPointerMove, true);
    this._device.canvas.addEventListener("pointerup", this._onPointerUp);
    app2.on("update", () => this._updateScale());
    app2.on("destroy", () => this.destroy());
  }
  set coordSpace(value) {
    this._coordSpace = value != null ? value : GIZMOSPACE_WORLD;
    this._updateRotation();
  }
  get coordSpace() {
    return this._coordSpace;
  }
  set size(value) {
    this._size = value;
    this._updateScale();
  }
  get size() {
    return this._size;
  }
  _onPointerDown(e) {
    if (!this.root.enabled || document.pointerLockElement) {
      return;
    }
    const selection = this._getSelection(e.offsetX, e.offsetY);
    if (selection[0]) {
      e.preventDefault();
      e.stopPropagation();
    }
    this.fire(_Gizmo.EVENT_POINTERDOWN, e.offsetX, e.offsetY, selection[0]);
  }
  _onPointerMove(e) {
    if (!this.root.enabled || document.pointerLockElement) {
      return;
    }
    const selection = this._getSelection(e.offsetX, e.offsetY);
    if (selection[0]) {
      e.preventDefault();
      e.stopPropagation();
    }
    this.fire(_Gizmo.EVENT_POINTERMOVE, e.offsetX, e.offsetY, selection[0]);
  }
  _onPointerUp() {
    if (!this.root.enabled || document.pointerLockElement) {
      return;
    }
    this.fire(_Gizmo.EVENT_POINTERUP);
  }
  _updatePosition() {
    tmpV1.set(0, 0, 0);
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      tmpV1.add(node.getPosition());
    }
    tmpV1.mulScalar(1 / (this.nodes.length || 1));
    this.root.setPosition(tmpV1);
    this.fire(_Gizmo.EVENT_POSITIONUPDATE, tmpV1);
  }
  _updateRotation() {
    tmpV1.set(0, 0, 0);
    if (this._coordSpace === GIZMOSPACE_LOCAL && this.nodes.length !== 0) {
      tmpV1.copy(this.nodes[this.nodes.length - 1].getEulerAngles());
    }
    this.root.setEulerAngles(tmpV1);
    this.fire(_Gizmo.EVENT_ROTATIONUPDATE, tmpV1);
  }
  _updateScale() {
    if (this._camera.projection === PROJECTION_PERSPECTIVE) {
      const gizmoPos = this.root.getPosition();
      const cameraPos = this._camera.entity.getPosition();
      const dist = gizmoPos.distance(cameraPos);
      this._scale = Math.tan(0.5 * this._camera.fov * math.DEG_TO_RAD) * dist * PERS_SCALE_RATIO;
    } else {
      this._scale = this._camera.orthoHeight * ORTHO_SCALE_RATIO;
    }
    this._scale = Math.max(this._scale * this._size, MIN_GIZMO_SCALE);
    this.root.setLocalScale(this._scale, this._scale, this._scale);
    this.fire(_Gizmo.EVENT_SCALEUPDATE, this._scale);
  }
  _getSelection(x2, y2) {
    const start = this._camera.screenToWorld(x2, y2, this._camera.nearClip);
    const end = this._camera.screenToWorld(x2, y2, this._camera.farClip);
    const dir = end.clone().sub(start).normalize();
    const selection = [];
    for (let i = 0; i < this.intersectData.length; i++) {
      const {
        triData,
        parent,
        meshInstances
      } = this.intersectData[i];
      const parentTM = parent.getWorldTransform();
      for (let j = 0; j < triData.length; j++) {
        const {
          tris,
          transform,
          priority
        } = triData[j];
        const triWTM = tmpM1.copy(parentTM).mul(transform);
        const invTriWTM = tmpM2.copy(triWTM).invert();
        const ray = tmpR1;
        invTriWTM.transformPoint(start, ray.origin);
        invTriWTM.transformVector(dir, ray.direction);
        ray.direction.normalize();
        for (let k = 0; k < tris.length; k++) {
          if (tris[k].intersectsRay(ray, tmpV1)) {
            selection.push({
              dist: triWTM.transformPoint(tmpV1).sub(start).length(),
              meshInstances,
              priority
            });
          }
        }
      }
    }
    if (selection.length) {
      selection.sort((s0, s1) => {
        if (s0.priority !== 0 && s1.priority !== 0) {
          return s1.priority - s0.priority;
        }
        return s0.dist - s1.dist;
      });
      return selection[0].meshInstances;
    }
    return [];
  }
  attach(nodes = []) {
    if (nodes.length === 0) {
      return;
    }
    this.nodes = nodes;
    this._updatePosition();
    this._updateRotation();
    this.fire(_Gizmo.EVENT_NODESATTACH);
    this.root.enabled = true;
    this.fire(_Gizmo.EVENT_RENDERUPDATE);
  }
  detach() {
    this.root.enabled = false;
    this.fire(_Gizmo.EVENT_RENDERUPDATE);
    this.fire(_Gizmo.EVENT_NODESDETACH);
    this.nodes = [];
  }
  destroy() {
    this.detach();
    this._device.canvas.removeEventListener("pointerdown", this._onPointerDown, true);
    this._device.canvas.removeEventListener("pointermove", this._onPointerMove, true);
    this._device.canvas.removeEventListener("pointerup", this._onPointerUp);
    this.root.destroy();
  }
};
Gizmo.EVENT_POINTERDOWN = "pointer:down";
Gizmo.EVENT_POINTERMOVE = "pointer:move";
Gizmo.EVENT_POINTERUP = "pointer:up";
Gizmo.EVENT_POSITIONUPDATE = "position:update";
Gizmo.EVENT_ROTATIONUPDATE = "rotation:update";
Gizmo.EVENT_SCALEUPDATE = "scale:update";
Gizmo.EVENT_NODESATTACH = "nodes:attach";
Gizmo.EVENT_NODESDETACH = "nodes:detach";
Gizmo.EVENT_RENDERUPDATE = "render:update";

// ../node_modules/playcanvas/build/playcanvas/src/extras/gizmo/color.js
var COLOR_RED = Object.freeze(new Color(1, 0.3, 0.3));
var COLOR_GREEN = Object.freeze(new Color(0.3, 1, 0.3));
var COLOR_BLUE = Object.freeze(new Color(0.3, 0.3, 1));
var COLOR_YELLOW = Object.freeze(new Color(1, 1, 0.5));
var COLOR_GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 0.5));
var color3from4 = (color) => {
  return new Color(color.r, color.g, color.b);
};
var color4from3 = (color, a) => {
  return new Color(color.r, color.g, color.b, a);
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/gizmo/transform-gizmo.js
var tmpV12 = new Vec3();
var tmpV2 = new Vec3();
var tmpQ1 = new Quat();
var tmpR12 = new Ray();
var tmpP1 = new Plane();
var VEC3_AXES = Object.keys(tmpV12);
var SPANLINE_SIZE = 1e3;
var TransformGizmo = class _TransformGizmo extends Gizmo {
  constructor(app2, camera, layer) {
    super(app2, camera, layer);
    this._colorAlpha = 0.6;
    this._meshColors = {
      axis: {
        x: this._colorSemi(COLOR_RED),
        y: this._colorSemi(COLOR_GREEN),
        z: this._colorSemi(COLOR_BLUE),
        xyz: this._colorSemi(Color.WHITE),
        f: this._colorSemi(Color.WHITE)
      },
      hover: {
        x: COLOR_RED.clone(),
        y: COLOR_GREEN.clone(),
        z: COLOR_BLUE.clone(),
        xyz: Color.WHITE.clone(),
        f: COLOR_YELLOW.clone()
      },
      disabled: COLOR_GRAY.clone()
    };
    this._guideColors = {
      x: COLOR_RED.clone(),
      y: COLOR_GREEN.clone(),
      z: COLOR_BLUE.clone(),
      f: COLOR_YELLOW.clone()
    };
    this._pointDelta = new Vec3();
    this._rootStartPos = new Vec3();
    this._rootStartRot = new Quat();
    this._shapes = {};
    this._shapeMap = /* @__PURE__ */ new Map();
    this._hoverShape = null;
    this._hoverAxis = "";
    this._hoverIsPlane = false;
    this._selectedAxis = "";
    this._selectedIsPlane = false;
    this._selectionStartPoint = new Vec3();
    this._selectionStartAngle = 0;
    this._dragging = false;
    this._snap = false;
    this.snapIncrement = 1;
    app2.on("update", () => {
      if (!this.root.enabled) {
        return;
      }
      this._drawGuideLines();
    });
    this.on(Gizmo.EVENT_POINTERDOWN, (x2, y2, meshInstance) => {
      const shape = this._shapeMap.get(meshInstance);
      if (shape != null && shape.disabled) {
        return;
      }
      if (this._dragging) {
        return;
      }
      if (!meshInstance) {
        return;
      }
      this._selectedAxis = this._getAxis(meshInstance);
      this._selectedIsPlane = this._getIsPlane(meshInstance);
      this._rootStartPos.copy(this.root.getPosition());
      this._rootStartRot.copy(this.root.getRotation());
      const pointInfo = this._screenToPoint(x2, y2);
      this._selectionStartPoint.copy(pointInfo.point);
      this._selectionStartAngle = pointInfo.angle;
      this._dragging = true;
      this.fire(_TransformGizmo.EVENT_TRANSFORMSTART);
    });
    this.on(Gizmo.EVENT_POINTERMOVE, (x2, y2, meshInstance) => {
      const shape = this._shapeMap.get(meshInstance);
      if (shape != null && shape.disabled) {
        return;
      }
      this._hover(meshInstance);
      if (!this._dragging) {
        return;
      }
      const pointInfo = this._screenToPoint(x2, y2);
      this._pointDelta.copy(pointInfo.point).sub(this._selectionStartPoint);
      const angleDelta = pointInfo.angle - this._selectionStartAngle;
      this.fire(_TransformGizmo.EVENT_TRANSFORMMOVE, this._pointDelta, angleDelta);
      this._hoverAxis = "";
      this._hoverIsPlane = false;
    });
    this.on(Gizmo.EVENT_POINTERUP, () => {
      if (!this._dragging) {
        return;
      }
      this._dragging = false;
      this.fire(_TransformGizmo.EVENT_TRANSFORMEND);
      this._selectedAxis = "";
      this._selectedIsPlane = false;
    });
    this.on(Gizmo.EVENT_NODESDETACH, () => {
      this.snap = false;
      this._hoverAxis = "";
      this._hoverIsPlane = false;
      this._hover();
      this.fire(Gizmo.EVENT_POINTERUP);
    });
  }
  set snap(value) {
    this._snap = this.root.enabled && value;
  }
  get snap() {
    return this._snap;
  }
  set xAxisColor(value) {
    this._updateAxisColor(GIZMOAXIS_X, value);
  }
  get xAxisColor() {
    return this._meshColors.axis.x;
  }
  set yAxisColor(value) {
    this._updateAxisColor(GIZMOAXIS_Y, value);
  }
  get yAxisColor() {
    return this._meshColors.axis.y;
  }
  set zAxisColor(value) {
    this._updateAxisColor(GIZMOAXIS_Z, value);
  }
  get zAxisColor() {
    return this._meshColors.axis.z;
  }
  set colorAlpha(value) {
    this._colorAlpha = math.clamp(value, 0, 1);
    this._meshColors.axis.x.copy(this._colorSemi(this._meshColors.axis.x));
    this._meshColors.axis.y.copy(this._colorSemi(this._meshColors.axis.y));
    this._meshColors.axis.z.copy(this._colorSemi(this._meshColors.axis.z));
    this._meshColors.axis.xyz.copy(this._colorSemi(this._meshColors.axis.xyz));
    this._meshColors.axis.f.copy(this._colorSemi(this._meshColors.axis.f));
    for (const name in this._shapes) {
      this._shapes[name].hover(!!this._hoverAxis);
    }
  }
  get colorAlpha() {
    return this._colorAlpha;
  }
  _colorSemi(color) {
    return color4from3(color, this._colorAlpha);
  }
  _updateAxisColor(axis, value) {
    const color3 = color3from4(value);
    const color4 = this._colorSemi(value);
    this._guideColors[axis].copy(color3);
    this._meshColors.axis[axis].copy(color4);
    this._meshColors.hover[axis].copy(color3);
    for (const name in this._shapes) {
      this._shapes[name].hover(!!this._hoverAxis);
    }
  }
  _getAxis(meshInstance) {
    if (!meshInstance) {
      return "";
    }
    return meshInstance.node.name.split(":")[1];
  }
  _getIsPlane(meshInstance) {
    if (!meshInstance) {
      return false;
    }
    return meshInstance.node.name.indexOf("plane") !== -1;
  }
  _hover(meshInstance) {
    if (this._dragging) {
      return;
    }
    this._hoverAxis = this._getAxis(meshInstance);
    this._hoverIsPlane = this._getIsPlane(meshInstance);
    const shape = meshInstance ? this._shapeMap.get(meshInstance) || null : null;
    if (shape === this._hoverShape) {
      return;
    }
    if (this._hoverShape) {
      this._hoverShape.hover(false);
      this._hoverShape = null;
    }
    if (shape) {
      shape.hover(true);
      this._hoverShape = shape;
    }
    this.fire(Gizmo.EVENT_RENDERUPDATE);
  }
  _createRay(mouseWPos) {
    const cameraPos = this._camera.entity.getPosition();
    const cameraTransform = this._camera.entity.getWorldTransform();
    const ray = tmpR12.set(cameraPos, Vec3.ZERO);
    if (this._camera.projection === PROJECTION_PERSPECTIVE) {
      ray.direction.sub2(mouseWPos, ray.origin).normalize();
    } else {
      ray.origin.add(mouseWPos);
      cameraTransform.transformVector(tmpV12.set(0, 0, -1), ray.direction);
    }
    return ray;
  }
  _createPlane(axis, isFacing, isLine) {
    const cameraPos = this._camera.entity.getPosition();
    const facingDir = tmpV12.sub2(cameraPos, this._rootStartPos).normalize();
    const normal = tmpP1.normal.set(0, 0, 0);
    if (isFacing) {
      normal.copy(facingDir);
    } else {
      normal[axis] = 1;
      this._rootStartRot.transformVector(normal, normal);
      if (isLine) {
        tmpV2.cross(normal, facingDir).normalize();
        normal.cross(tmpV2, normal).normalize();
      }
    }
    return tmpP1.setFromPointNormal(this._rootStartPos, normal);
  }
  _projectToAxis(point, axis) {
    tmpV12.set(0, 0, 0);
    tmpV12[axis] = 1;
    point.copy(tmpV12.mulScalar(tmpV12.dot(point)));
    const v = point[axis];
    point.set(0, 0, 0);
    point[axis] = v;
  }
  _screenToPoint(x2, y2, isFacing = false, isLine = false) {
    const mouseWPos = this._camera.screenToWorld(x2, y2, 1);
    const axis = this._selectedAxis;
    const ray = this._createRay(mouseWPos);
    const plane = this._createPlane(axis, isFacing, isLine);
    const point = new Vec3();
    const angle = 0;
    plane.intersectsRay(ray, point);
    return {
      point,
      angle
    };
  }
  _drawGuideLines() {
    const gizmoPos = this.root.getPosition();
    const gizmoRot = tmpQ1.copy(this.root.getRotation());
    const checkAxis = this._hoverAxis || this._selectedAxis;
    const checkIsPlane = this._hoverIsPlane || this._selectedIsPlane;
    for (let i = 0; i < VEC3_AXES.length; i++) {
      const axis = VEC3_AXES[i];
      if (checkAxis === GIZMOAXIS_XYZ) {
        this._drawSpanLine(gizmoPos, gizmoRot, axis);
        continue;
      }
      if (checkIsPlane) {
        if (axis !== checkAxis) {
          this._drawSpanLine(gizmoPos, gizmoRot, axis);
        }
      } else {
        if (axis === checkAxis) {
          this._drawSpanLine(gizmoPos, gizmoRot, axis);
        }
      }
    }
  }
  _drawSpanLine(pos, rot, axis) {
    tmpV12.set(0, 0, 0);
    tmpV12[axis] = 1;
    tmpV12.mulScalar(SPANLINE_SIZE);
    tmpV2.copy(tmpV12).mulScalar(-1);
    rot.transformVector(tmpV12, tmpV12);
    rot.transformVector(tmpV2, tmpV2);
    this._app.drawLine(tmpV12.add(pos), tmpV2.add(pos), this._guideColors[axis], true);
  }
  _createTransform() {
    for (const key in this._shapes) {
      const shape = this._shapes[key];
      this.root.addChild(shape.entity);
      this.intersectData.push({
        triData: shape.triData,
        parent: shape.entity,
        meshInstances: shape.meshInstances
      });
      for (let i = 0; i < shape.meshInstances.length; i++) {
        this._shapeMap.set(shape.meshInstances[i], shape);
      }
    }
  }
  enableShape(shapeAxis, enabled) {
    if (!this._shapes.hasOwnProperty(shapeAxis)) {
      return;
    }
    this._shapes[shapeAxis].disabled = !enabled;
  }
  isShapeEnabled(shapeAxis) {
    if (!this._shapes.hasOwnProperty(shapeAxis)) {
      return false;
    }
    return !this._shapes[shapeAxis].disabled;
  }
  destroy() {
    for (const key in this._shapes) {
      this._shapes[key].destroy();
    }
    super.destroy();
  }
};
TransformGizmo.EVENT_TRANSFORMSTART = "transform:start";
TransformGizmo.EVENT_TRANSFORMMOVE = "transform:move";
TransformGizmo.EVENT_TRANSFORMEND = "transform:end";

// ../node_modules/playcanvas/build/playcanvas/src/extras/gizmo/tri-data.js
var tmpV13 = new Vec3();
var tmpV22 = new Vec3();
var tmpV3 = new Vec3();
var TriData = class {
  constructor(geometry, priority = 0) {
    this._priority = 0;
    this._transform = new Mat4();
    this.tris = [];
    this.fromGeometry(geometry);
    this._priority = priority;
  }
  get transform() {
    return this._transform;
  }
  get priority() {
    return this._priority;
  }
  setTransform(pos = new Vec3(), rot = new Quat(), scale2 = new Vec3()) {
    this.transform.setTRS(pos, rot, scale2);
  }
  calculateTris(geometry) {
    const positions = geometry.positions;
    const indices = geometry.indices;
    this.tris = [];
    for (let k = 0; k < indices.length; k += 3) {
      const i1 = indices[k];
      const i2 = indices[k + 1];
      const i3 = indices[k + 2];
      tmpV13.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
      tmpV22.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
      tmpV3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
      const tri = new Tri(tmpV13, tmpV22, tmpV3);
      this.tris.push(tri);
    }
  }
  fromGeometry(geometry) {
    if (!geometry || !(geometry instanceof Geometry)) {
      throw new Error("No geometry provided.");
    }
    this.calculateTris(geometry);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/gizmo/axis-shapes.js
var SHADOW_DAMP_SCALE = 0.25;
var SHADOW_DAMP_OFFSET = 0.75;
var SHADOW_MESH_MAP = /* @__PURE__ */ new Map();
var TORUS_RENDER_SEGMENTS = 80;
var TORUS_INTERSECT_SEGMENTS = 20;
var LIGHT_DIR = new Vec3(1, 2, 3);
var GEOMETRIES = {
  box: BoxGeometry,
  cone: ConeGeometry,
  cylinder: CylinderGeometry,
  plane: PlaneGeometry,
  sphere: SphereGeometry,
  torus: TorusGeometry
};
var shaderDesc = {
  uniqueName: "axis-shape",
  attributes: {
    vertex_position: SEMANTIC_POSITION,
    vertex_color: SEMANTIC_COLOR
  },
  vertexCode: `
		attribute vec3 vertex_position;
		attribute vec4 vertex_color;
		varying vec4 vColor;
		varying vec2 vZW;
		uniform mat4 matrix_model;
		uniform mat4 matrix_viewProjection;
		void main(void) {
			gl_Position = matrix_viewProjection * matrix_model * vec4(vertex_position, 1.0);
			vColor = vertex_color;
			vZW = gl_Position.zw;
		}
	`,
  fragmentCode: `
		precision highp float;
		varying vec4 vColor;
		varying vec2 vZW;
		void main(void) {
			gl_FragColor = vec4(gammaCorrectOutput(decodeGamma(vColor)), vColor.w);
			gl_FragDepth = max(0.0, min(1.0, (vZW.x / vZW.y + 1.0) * 0.5));
		}
	`
};
var tmpV14 = new Vec3();
var tmpV23 = new Vec3();
var tmpQ12 = new Quat();
function createShadowMesh(device, entity, type, color = Color.WHITE, templateOpts) {
  const Geometry2 = GEOMETRIES[type];
  if (!Geometry2) {
    throw new Error("Invalid primitive type.");
  }
  const geom = new Geometry2(templateOpts);
  geom.colors = [];
  const wtm = entity.getWorldTransform().clone().invert();
  tmpV14.copy(LIGHT_DIR);
  wtm.transformVector(tmpV14, tmpV14);
  tmpV14.normalize();
  const numVertices = geom.positions.length / 3;
  const shadow = calculateShadow(tmpV14, numVertices, geom.normals);
  for (let i = 0; i < shadow.length; i++) {
    geom.colors.push(shadow[i] * color.r * 255, shadow[i] * color.g * 255, shadow[i] * color.b * 255, color.a * 255);
  }
  const shadowMesh = Mesh.fromGeometry(device, geom);
  SHADOW_MESH_MAP.set(shadowMesh, shadow);
  return shadowMesh;
}
function calculateShadow(lightDir, numVertices, normals) {
  const shadow = [];
  for (let i = 0; i < numVertices; i++) {
    const x2 = normals[i * 3];
    const y2 = normals[i * 3 + 1];
    const z2 = normals[i * 3 + 2];
    tmpV23.set(x2, y2, z2);
    const dot = lightDir.dot(tmpV23);
    shadow.push(dot * SHADOW_DAMP_SCALE + SHADOW_DAMP_OFFSET);
  }
  return shadow;
}
function setShadowMeshColor(mesh, color) {
  if (!SHADOW_MESH_MAP.has(mesh)) {
    return;
  }
  const shadow = SHADOW_MESH_MAP.get(mesh);
  const colors = [];
  for (let i = 0; i < shadow.length; i++) {
    colors.push(shadow[i] * color.r * 255, shadow[i] * color.g * 255, shadow[i] * color.b * 255, color.a * 255);
  }
  mesh.setColors32(colors);
  mesh.update();
}
var AxisShape = class {
  constructor(device, options2) {
    var _options$axis, _options$position, _options$rotation, _options$scale, _options$disabled, _options$layers;
    this._position = void 0;
    this._rotation = void 0;
    this._scale = void 0;
    this._layers = [];
    this._disabled = void 0;
    this._defaultColor = Color.WHITE;
    this._hoverColor = Color.BLACK;
    this._disabledColor = COLOR_GRAY;
    this._cull = CULLFACE_BACK;
    this.device = void 0;
    this.axis = void 0;
    this.entity = void 0;
    this.triData = [];
    this.meshInstances = [];
    this.device = device;
    this.axis = (_options$axis = options2.axis) != null ? _options$axis : "x";
    this._position = (_options$position = options2.position) != null ? _options$position : new Vec3();
    this._rotation = (_options$rotation = options2.rotation) != null ? _options$rotation : new Vec3();
    this._scale = (_options$scale = options2.scale) != null ? _options$scale : new Vec3(1, 1, 1);
    this._disabled = (_options$disabled = options2.disabled) != null ? _options$disabled : false;
    this._layers = (_options$layers = options2.layers) != null ? _options$layers : this._layers;
    if (options2.defaultColor instanceof Color) {
      this._defaultColor = options2.defaultColor;
    }
    if (options2.hoverColor instanceof Color) {
      this._hoverColor = options2.hoverColor;
    }
    if (options2.disabledColor instanceof Color) {
      this._disabledColor = options2.disabledColor;
    }
  }
  set disabled(value) {
    for (let i = 0; i < this.meshInstances.length; i++) {
      setShadowMeshColor(this.meshInstances[i].mesh, value ? this._disabledColor : this._defaultColor);
    }
    this._disabled = value != null ? value : false;
  }
  get disabled() {
    return this._disabled;
  }
  _createRoot(name) {
    this.entity = new Entity(`${name}:${this.axis}`);
    this._updateRootTransform();
  }
  _updateRootTransform() {
    this.entity.setLocalPosition(this._position);
    this.entity.setLocalEulerAngles(this._rotation);
    this.entity.setLocalScale(this._scale);
  }
  _addRenderMeshes(entity, meshes) {
    const material = new ShaderMaterial(shaderDesc);
    material.cull = this._cull;
    material.blendType = BLEND_NORMAL;
    material.update();
    const meshInstances = [];
    for (let i = 0; i < meshes.length; i++) {
      const mi = new MeshInstance(meshes[i], material);
      meshInstances.push(mi);
      this.meshInstances.push(mi);
    }
    entity.addComponent("render", {
      meshInstances,
      layers: this._layers,
      castShadows: false
    });
  }
  _addRenderShadowMesh(entity, type) {
    const color = this._disabled ? this._disabledColor : this._defaultColor;
    const mesh = createShadowMesh(this.device, entity, type, color);
    this._addRenderMeshes(entity, [mesh]);
  }
  hover(state) {
    if (this._disabled) {
      return;
    }
    for (let i = 0; i < this.meshInstances.length; i++) {
      const color = state ? this._hoverColor : this._defaultColor;
      setShadowMeshColor(this.meshInstances[i].mesh, color);
    }
  }
  destroy() {
    this.entity.destroy();
  }
};
var AxisArrow = class extends AxisShape {
  constructor(device, options2 = {}) {
    super(device, options2);
    this._gap = 0;
    this._lineThickness = 0.02;
    this._lineLength = 0.5;
    this._arrowThickness = 0.12;
    this._arrowLength = 0.18;
    this._tolerance = 0.1;
    this.triData = [new TriData(new ConeGeometry()), new TriData(new CylinderGeometry(), 1)];
    this._createArrow();
  }
  set gap(value) {
    this._gap = value != null ? value : 0;
    this._updateHead();
    this._updateLine();
  }
  get gap() {
    return this._gap;
  }
  set lineThickness(value) {
    this._lineThickness = value != null ? value : 1;
    this._updateHead();
    this._updateLine();
  }
  get lineThickness() {
    return this._lineThickness;
  }
  set lineLength(value) {
    this._lineLength = value != null ? value : 1;
    this._updateHead();
    this._updateLine();
  }
  get lineLength() {
    return this._lineLength;
  }
  set arrowThickness(value) {
    this._arrowThickness = value != null ? value : 1;
    this._updateHead();
  }
  get arrowThickness() {
    return this._arrowThickness;
  }
  set arrowLength(value) {
    this._arrowLength = value != null ? value : 1;
    this._updateHead();
  }
  get arrowLength() {
    return this._arrowLength;
  }
  set tolerance(value) {
    this._tolerance = value;
    this._updateLine();
  }
  get tolerance() {
    return this._tolerance;
  }
  _createArrow() {
    this._createRoot("arrow");
    this._head = new Entity(`head:${this.axis}`);
    this.entity.addChild(this._head);
    this._updateHead();
    this._addRenderShadowMesh(this._head, "cone");
    this._line = new Entity(`line:${this.axis}`);
    this.entity.addChild(this._line);
    this._updateLine();
    this._addRenderShadowMesh(this._line, "cylinder");
  }
  _updateHead() {
    tmpV14.set(0, this._gap + this._arrowLength * 0.5 + this._lineLength, 0);
    tmpQ12.set(0, 0, 0, 1);
    tmpV23.set(this._arrowThickness, this._arrowLength, this._arrowThickness);
    this.triData[0].setTransform(tmpV14, tmpQ12, tmpV23);
    this._head.setLocalPosition(0, this._gap + this._arrowLength * 0.5 + this._lineLength, 0);
    this._head.setLocalScale(this._arrowThickness, this._arrowLength, this._arrowThickness);
  }
  _updateLine() {
    tmpV14.set(0, this._gap + this._lineLength * 0.5, 0);
    tmpQ12.set(0, 0, 0, 1);
    tmpV23.set(this._lineThickness + this._tolerance, this._lineLength, this._lineThickness + this._tolerance);
    this.triData[1].setTransform(tmpV14, tmpQ12, tmpV23);
    this._line.setLocalPosition(0, this._gap + this._lineLength * 0.5, 0);
    this._line.setLocalScale(this._lineThickness, this._lineLength, this._lineThickness);
  }
};
var AxisBoxCenter = class extends AxisShape {
  constructor(device, options2 = {}) {
    super(device, options2);
    this._size = 0.12;
    this._tolerance = 0.05;
    this.triData = [new TriData(new BoxGeometry(), 2)];
    this._createCenter();
  }
  _createCenter() {
    this._createRoot("boxCenter");
    this._updateTransform();
    this._addRenderShadowMesh(this.entity, "box");
  }
  set size(value) {
    this._size = value != null ? value : 1;
    this._updateTransform();
  }
  get size() {
    return this._size;
  }
  set tolerance(value) {
    this._tolerance = value;
    this._updateTransform();
  }
  get tolerance() {
    return this._tolerance;
  }
  _updateTransform() {
    this.entity.setLocalScale(this._size, this._size, this._size);
  }
};
var AxisBoxLine = class extends AxisShape {
  constructor(device, options2 = {}) {
    super(device, options2);
    this._gap = 0;
    this._lineThickness = 0.02;
    this._lineLength = 0.5;
    this._boxSize = 0.12;
    this._tolerance = 0.1;
    this.triData = [new TriData(new BoxGeometry()), new TriData(new CylinderGeometry(), 1)];
    this._createBoxLine();
  }
  set gap(value) {
    this._gap = value != null ? value : 0;
    this._updateLine();
    this._updateBox();
  }
  get gap() {
    return this._gap;
  }
  set lineThickness(value) {
    this._lineThickness = value != null ? value : 1;
    this._updateLine();
    this._updateBox();
  }
  get lineThickness() {
    return this._lineThickness;
  }
  set lineLength(value) {
    this._lineLength = value != null ? value : 1;
    this._updateLine();
    this._updateBox();
  }
  get lineLength() {
    return this._lineLength;
  }
  set boxSize(value) {
    this._boxSize = value != null ? value : 1;
    this._updateBox();
  }
  get boxSize() {
    return this._boxSize;
  }
  set tolerance(value) {
    this._tolerance = value;
    this._updateLine();
  }
  get tolerance() {
    return this._tolerance;
  }
  _createBoxLine() {
    this._createRoot("boxLine");
    this._box = new Entity(`box:${this.axis}`);
    this.entity.addChild(this._box);
    this._updateBox();
    this._addRenderShadowMesh(this._box, "box");
    this._line = new Entity(`line:${this.axis}`);
    this.entity.addChild(this._line);
    this._updateLine();
    this._addRenderShadowMesh(this._line, "cylinder");
  }
  _updateBox() {
    tmpV14.set(0, this._gap + this._boxSize * 0.5 + this._lineLength, 0);
    tmpQ12.set(0, 0, 0, 1);
    tmpV23.set(this._boxSize, this._boxSize, this._boxSize);
    this.triData[0].setTransform(tmpV14, tmpQ12, tmpV23);
    this._box.setLocalPosition(0, this._gap + this._boxSize * 0.5 + this._lineLength, 0);
    this._box.setLocalScale(this._boxSize, this._boxSize, this._boxSize);
  }
  _updateLine() {
    tmpV14.set(0, this._gap + this._lineLength * 0.5, 0);
    tmpQ12.set(0, 0, 0, 1);
    tmpV23.set(this._lineThickness + this._tolerance, this._lineLength, this._lineThickness + this._tolerance);
    this.triData[1].setTransform(tmpV14, tmpQ12, tmpV23);
    this._line.setLocalPosition(0, this._gap + this._lineLength * 0.5, 0);
    this._line.setLocalScale(this._lineThickness, this._lineLength, this._lineThickness);
  }
};
var AxisDisk = class extends AxisShape {
  constructor(device, options2 = {}) {
    var _options$tubeRadius, _options$ringRadius, _options$sectorAngle;
    super(device, options2);
    this._tubeRadius = 0.01;
    this._ringRadius = 0.5;
    this._sectorAngle = void 0;
    this._lightDir = void 0;
    this._tolerance = 0.05;
    this._tubeRadius = (_options$tubeRadius = options2.tubeRadius) != null ? _options$tubeRadius : this._tubeRadius;
    this._ringRadius = (_options$ringRadius = options2.ringRadius) != null ? _options$ringRadius : this._ringRadius;
    this._sectorAngle = (_options$sectorAngle = options2.sectorAngle) != null ? _options$sectorAngle : this._sectorAngle;
    this.triData = [new TriData(this._createTorusGeometry())];
    this._createDisk();
  }
  _createTorusGeometry() {
    return new TorusGeometry({
      tubeRadius: this._tubeRadius + this._tolerance,
      ringRadius: this._ringRadius,
      sectorAngle: this._sectorAngle,
      segments: TORUS_INTERSECT_SEGMENTS
    });
  }
  _createTorusMesh(sectorAngle) {
    const color = this._disabled ? this._disabledColor : this._defaultColor;
    return createShadowMesh(this.device, this.entity, "torus", color, {
      tubeRadius: this._tubeRadius,
      ringRadius: this._ringRadius,
      sectorAngle,
      segments: TORUS_RENDER_SEGMENTS
    });
  }
  _createDisk() {
    this._createRoot("disk");
    this._addRenderMeshes(this.entity, [this._createTorusMesh(this._sectorAngle), this._createTorusMesh(360)]);
    this.drag(false);
  }
  set tubeRadius(value) {
    this._tubeRadius = value != null ? value : 0.1;
    this._updateTransform();
  }
  get tubeRadius() {
    return this._tubeRadius;
  }
  set ringRadius(value) {
    this._ringRadius = value != null ? value : 0.1;
    this._updateTransform();
  }
  get ringRadius() {
    return this._ringRadius;
  }
  set tolerance(value) {
    this._tolerance = value;
    this._updateTransform();
  }
  get tolerance() {
    return this._tolerance;
  }
  _updateTransform() {
    this.triData[0].fromGeometry(this._createTorusGeometry());
    this.meshInstances[0].mesh = this._createTorusMesh(this._sectorAngle);
    this.meshInstances[1].mesh = this._createTorusMesh(360);
  }
  drag(state) {
    this.meshInstances[0].visible = !state;
    this.meshInstances[1].visible = state;
  }
  hide(state) {
    if (state) {
      this.meshInstances[0].visible = false;
      this.meshInstances[1].visible = false;
      return;
    }
    this.drag(false);
  }
};
var AxisPlane = class extends AxisShape {
  constructor(device, options2 = {}) {
    super(device, options2);
    this._cull = CULLFACE_NONE;
    this._size = 0.2;
    this._gap = 0.1;
    this.triData = [new TriData(new PlaneGeometry())];
    this._createPlane();
  }
  _getPosition() {
    const offset = this._size / 2 + this._gap;
    const position3 = new Vec3(offset, offset, offset);
    position3[this.axis] = 0;
    return position3;
  }
  _createPlane() {
    this._createRoot("plane");
    this._updateTransform();
    this._addRenderShadowMesh(this.entity, "plane");
  }
  set size(value) {
    this._size = value != null ? value : 1;
    this._updateTransform();
  }
  get size() {
    return this._size;
  }
  set gap(value) {
    this._gap = value != null ? value : 0;
    this._updateTransform();
  }
  get gap() {
    return this._gap;
  }
  _updateTransform() {
    this.entity.setLocalPosition(this._getPosition());
    this.entity.setLocalEulerAngles(this._rotation);
    this.entity.setLocalScale(this._size, this._size, this._size);
  }
};
var AxisSphereCenter = class extends AxisShape {
  constructor(device, options2 = {}) {
    super(device, options2);
    this._size = 0.12;
    this._tolerance = 0.05;
    this.triData = [new TriData(new SphereGeometry(), 2)];
    this._createCenter();
  }
  _createCenter() {
    this._createRoot("sphereCenter");
    this._updateTransform();
    this._addRenderShadowMesh(this.entity, "sphere");
  }
  set size(value) {
    this._size = value != null ? value : 1;
    this._updateTransform();
  }
  get size() {
    return this._size;
  }
  set tolerance(value) {
    this._tolerance = value;
    this._updateTransform();
  }
  get tolerance() {
    return this._tolerance;
  }
  _updateTransform() {
    this.entity.setLocalScale(this._size, this._size, this._size);
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/gizmo/translate-gizmo.js
var tmpV15 = new Vec3();
var tmpV24 = new Vec3();
var tmpQ13 = new Quat();
var TranslateGizmo = class extends TransformGizmo {
  constructor(app2, camera, layer) {
    super(app2, camera, layer);
    this._shapes = {
      face: new AxisSphereCenter(this._device, {
        axis: GIZMOAXIS_FACE,
        layers: [this._layer.id],
        defaultColor: this._meshColors.axis.xyz,
        hoverColor: this._meshColors.hover.xyz
      }),
      yz: new AxisPlane(this._device, {
        axis: GIZMOAXIS_X,
        flipAxis: GIZMOAXIS_Y,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, -90),
        defaultColor: this._meshColors.axis.x,
        hoverColor: this._meshColors.hover.x
      }),
      xz: new AxisPlane(this._device, {
        axis: GIZMOAXIS_Y,
        flipAxis: GIZMOAXIS_Z,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, 0),
        defaultColor: this._meshColors.axis.y,
        hoverColor: this._meshColors.hover.y
      }),
      xy: new AxisPlane(this._device, {
        axis: GIZMOAXIS_Z,
        flipAxis: GIZMOAXIS_X,
        layers: [this._layer.id],
        rotation: new Vec3(90, 0, 0),
        defaultColor: this._meshColors.axis.z,
        hoverColor: this._meshColors.hover.z
      }),
      x: new AxisArrow(this._device, {
        axis: GIZMOAXIS_X,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, -90),
        defaultColor: this._meshColors.axis.x,
        hoverColor: this._meshColors.hover.x
      }),
      y: new AxisArrow(this._device, {
        axis: GIZMOAXIS_Y,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, 0),
        defaultColor: this._meshColors.axis.y,
        hoverColor: this._meshColors.hover.y
      }),
      z: new AxisArrow(this._device, {
        axis: GIZMOAXIS_Z,
        layers: [this._layer.id],
        rotation: new Vec3(90, 0, 0),
        defaultColor: this._meshColors.axis.z,
        hoverColor: this._meshColors.hover.z
      })
    };
    this._nodeLocalPositions = /* @__PURE__ */ new Map();
    this._nodePositions = /* @__PURE__ */ new Map();
    this.snapIncrement = 1;
    this._createTransform();
    this.on(TransformGizmo.EVENT_TRANSFORMSTART, () => {
      this._storeNodePositions();
    });
    this.on(TransformGizmo.EVENT_TRANSFORMMOVE, (pointDelta) => {
      if (this.snap) {
        pointDelta.mulScalar(1 / this.snapIncrement);
        pointDelta.round();
        pointDelta.mulScalar(this.snapIncrement);
      }
      this._setNodePositions(pointDelta);
    });
    this.on(TransformGizmo.EVENT_NODESDETACH, () => {
      this._nodeLocalPositions.clear();
      this._nodePositions.clear();
    });
  }
  set axisGap(value) {
    this._setArrowProp("gap", value);
  }
  get axisGap() {
    return this._shapes.x.gap;
  }
  set axisLineThickness(value) {
    this._setArrowProp("lineThickness", value);
  }
  get axisLineThickness() {
    return this._shapes.x.lineThickness;
  }
  set axisLineLength(value) {
    this._setArrowProp("lineLength", value);
  }
  get axisLineLength() {
    return this._shapes.x.lineLength;
  }
  set axisLineTolerance(value) {
    this._setArrowProp("tolerance", value);
  }
  get axisLineTolerance() {
    return this._shapes.x.tolerance;
  }
  set axisArrowThickness(value) {
    this._setArrowProp("arrowThickness", value);
  }
  get axisArrowThickness() {
    return this._shapes.x.arrowThickness;
  }
  set axisArrowLength(value) {
    this._setArrowProp("arrowLength", value);
  }
  get axisArrowLength() {
    return this._shapes.x.arrowLength;
  }
  set axisPlaneSize(value) {
    this._setPlaneProp("size", value);
  }
  get axisPlaneSize() {
    return this._shapes.yz.size;
  }
  set axisPlaneGap(value) {
    this._setPlaneProp("gap", value);
  }
  get axisPlaneGap() {
    return this._shapes.yz.gap;
  }
  set axisCenterSize(value) {
    this._shapes.face.size = value;
  }
  get axisCenterSize() {
    return this._shapes.face.size;
  }
  set axisCenterTolerance(value) {
    this._shapes.face.tolerance = value;
  }
  get axisCenterTolerance() {
    return this._shapes.face.tolerance;
  }
  _setArrowProp(prop, value) {
    this._shapes.x[prop] = value;
    this._shapes.y[prop] = value;
    this._shapes.z[prop] = value;
  }
  _setPlaneProp(prop, value) {
    this._shapes.yz[prop] = value;
    this._shapes.xz[prop] = value;
    this._shapes.xy[prop] = value;
  }
  _storeNodePositions() {
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      this._nodeLocalPositions.set(node, node.getLocalPosition().clone());
      this._nodePositions.set(node, node.getPosition().clone());
    }
  }
  _setNodePositions(pointDelta) {
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      const pos = this._nodePositions.get(node);
      if (!pos) {
        continue;
      }
      if (this._coordSpace === GIZMOSPACE_LOCAL) {
        var _node$parent;
        tmpV15.copy(pointDelta);
        (_node$parent = node.parent) == null || _node$parent.getWorldTransform().getScale(tmpV24);
        tmpV24.x = 1 / tmpV24.x;
        tmpV24.y = 1 / tmpV24.y;
        tmpV24.z = 1 / tmpV24.z;
        tmpQ13.copy(node.getLocalRotation()).transformVector(tmpV15, tmpV15);
        tmpV15.mul(tmpV24);
        node.setLocalPosition(pos.clone().add(tmpV15));
      } else {
        node.setPosition(pos.clone().add(pointDelta));
      }
    }
    this._updatePosition();
  }
  _screenToPoint(x2, y2) {
    const mouseWPos = this._camera.screenToWorld(x2, y2, 1);
    const axis = this._selectedAxis;
    const isPlane = this._selectedIsPlane;
    const ray = this._createRay(mouseWPos);
    const plane = this._createPlane(axis, axis === GIZMOAXIS_FACE, !isPlane);
    const point = new Vec3();
    const angle = 0;
    plane.intersectsRay(ray, point);
    tmpQ13.copy(this._rootStartRot).invert().transformVector(point, point);
    if (!isPlane && axis !== GIZMOAXIS_FACE) {
      this._projectToAxis(point, axis);
    }
    return {
      point,
      angle
    };
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/gizmo/rotate-gizmo.js
var tmpV16 = new Vec3();
var tmpV25 = new Vec3();
var tmpM12 = new Mat4();
var tmpQ14 = new Quat();
var tmpQ2 = new Quat();
var FACING_THRESHOLD = 0.9;
var ROTATE_SCALE = 900;
var GUIDE_ANGLE_COLOR = new Color(0, 0, 0, 0.3);
var RotateGizmo = class extends TransformGizmo {
  constructor(app2, camera, layer) {
    super(app2, camera, layer);
    this._shapes = {
      z: new AxisDisk(this._device, {
        axis: GIZMOAXIS_Z,
        layers: [this._layer.id],
        rotation: new Vec3(90, 0, 90),
        defaultColor: this._meshColors.axis.z,
        hoverColor: this._meshColors.hover.z,
        sectorAngle: 180
      }),
      x: new AxisDisk(this._device, {
        axis: GIZMOAXIS_X,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, -90),
        defaultColor: this._meshColors.axis.x,
        hoverColor: this._meshColors.hover.x,
        sectorAngle: 180
      }),
      y: new AxisDisk(this._device, {
        axis: GIZMOAXIS_Y,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, 0),
        defaultColor: this._meshColors.axis.y,
        hoverColor: this._meshColors.hover.y,
        sectorAngle: 180
      }),
      face: new AxisDisk(this._device, {
        axis: GIZMOAXIS_FACE,
        layers: [this._layer.id],
        rotation: this._getLookAtEulerAngles(this._camera.entity.getPosition()),
        defaultColor: this._meshColors.axis.f,
        hoverColor: this._meshColors.hover.f,
        ringRadius: 0.55
      })
    };
    this._nodeLocalRotations = /* @__PURE__ */ new Map();
    this._nodeRotations = /* @__PURE__ */ new Map();
    this._nodeOffsets = /* @__PURE__ */ new Map();
    this._guideAngleStartColor = GUIDE_ANGLE_COLOR.clone();
    this._guideAngleStart = new Vec3();
    this._guideAngleEnd = new Vec3();
    this.snapIncrement = 5;
    this._createTransform();
    this.on(TransformGizmo.EVENT_TRANSFORMSTART, () => {
      this._storeNodeRotations();
      this._storeGuidePoints();
      this._drag(true);
    });
    this.on(TransformGizmo.EVENT_TRANSFORMMOVE, (pointDelta, angleDelta) => {
      const axis = this._selectedAxis;
      if (this.snap) {
        angleDelta = Math.round(angleDelta / this.snapIncrement) * this.snapIncrement;
      }
      this._setNodeRotations(axis, angleDelta);
      this._updateGuidePoints(angleDelta);
    });
    this.on(TransformGizmo.EVENT_TRANSFORMEND, () => {
      this._drag(false);
    });
    this.on(TransformGizmo.EVENT_NODESDETACH, () => {
      this._nodeLocalRotations.clear();
      this._nodeRotations.clear();
      this._nodeOffsets.clear();
    });
    app2.on("update", () => {
      this._faceAxisLookAtCamera();
      this._xyzAxisLookAtCamera();
      if (this._dragging) {
        const gizmoPos = this.root.getPosition();
        this._drawGuideAngleLine(gizmoPos, this._selectedAxis, this._guideAngleStart, this._guideAngleStartColor);
        this._drawGuideAngleLine(gizmoPos, this._selectedAxis, this._guideAngleEnd);
      }
    });
  }
  set xyzTubeRadius(value) {
    this._setDiskProp("tubeRadius", value);
  }
  get xyzTubeRadius() {
    return this._shapes.x.tubeRadius;
  }
  set xyzRingRadius(value) {
    this._setDiskProp("ringRadius", value);
  }
  get xyzRingRadius() {
    return this._shapes.x.ringRadius;
  }
  set faceTubeRadius(value) {
    this._shapes.face.tubeRadius = value;
  }
  get faceTubeRadius() {
    return this._shapes.face.tubeRadius;
  }
  set faceRingRadius(value) {
    this._shapes.face.ringRadius = value;
  }
  get faceRingRadius() {
    return this._shapes.face.ringRadius;
  }
  set ringTolerance(value) {
    this._setDiskProp("tolerance", value);
    this._shapes.face.tolerance = value;
  }
  get ringTolerance() {
    return this._shapes.x.tolerance;
  }
  _setDiskProp(prop, value) {
    this._shapes.x[prop] = value;
    this._shapes.y[prop] = value;
    this._shapes.z[prop] = value;
  }
  _storeGuidePoints() {
    const gizmoPos = this.root.getPosition();
    const axis = this._selectedAxis;
    const isFacing = axis === GIZMOAXIS_FACE;
    const scale2 = isFacing ? this.faceRingRadius : this.xyzRingRadius;
    this._guideAngleStart.copy(this._selectionStartPoint).sub(gizmoPos).normalize();
    this._guideAngleStart.mulScalar(scale2);
    this._guideAngleEnd.copy(this._guideAngleStart);
  }
  _updateGuidePoints(angleDelta) {
    const gizmoPos = this.root.getPosition();
    const cameraPos = this._camera.entity.getPosition();
    const axis = this._selectedAxis;
    const isFacing = axis === GIZMOAXIS_FACE;
    tmpV16.set(0, 0, 0);
    if (isFacing) {
      tmpV16.sub2(cameraPos, gizmoPos).normalize();
    } else {
      tmpV16[axis] = 1;
      this._rootStartRot.transformVector(tmpV16, tmpV16);
    }
    tmpQ14.setFromAxisAngle(tmpV16, angleDelta);
    tmpQ14.transformVector(this._guideAngleStart, this._guideAngleEnd);
  }
  _drawGuideAngleLine(pos, axis, point, color = this._guideColors[axis]) {
    tmpV16.set(0, 0, 0);
    tmpV25.copy(point).mulScalar(this._scale);
    this._app.drawLine(tmpV16.add(pos), tmpV25.add(pos), color, false, this._layer);
  }
  _getLookAtEulerAngles(position3) {
    tmpV16.set(0, 0, 0);
    tmpM12.setLookAt(tmpV16, position3, Vec3.UP);
    tmpQ14.setFromMat4(tmpM12);
    tmpQ14.getEulerAngles(tmpV16);
    tmpV16.x += 90;
    return tmpV16;
  }
  _faceAxisLookAtCamera() {
    if (this._camera.projection === PROJECTION_PERSPECTIVE) {
      this._shapes.face.entity.lookAt(this._camera.entity.getPosition());
      this._shapes.face.entity.rotateLocal(90, 0, 0);
    } else {
      tmpQ14.copy(this._camera.entity.getRotation());
      tmpQ14.getEulerAngles(tmpV16);
      this._shapes.face.entity.setEulerAngles(tmpV16);
      this._shapes.face.entity.rotateLocal(-90, 0, 0);
    }
  }
  _xyzAxisLookAtCamera() {
    if (this._camera.projection === PROJECTION_PERSPECTIVE) {
      const gizmoPos = this.root.getPosition();
      const cameraPos = this._camera.entity.getPosition();
      tmpV16.sub2(cameraPos, gizmoPos).normalize();
    } else {
      tmpV16.copy(this._camera.entity.forward).mulScalar(-1);
    }
    tmpQ14.copy(this.root.getRotation()).invert().transformVector(tmpV16, tmpV16);
    let angle = Math.atan2(tmpV16.z, tmpV16.y) * math.RAD_TO_DEG;
    this._shapes.x.entity.setLocalEulerAngles(0, angle - 90, -90);
    angle = Math.atan2(tmpV16.x, tmpV16.z) * math.RAD_TO_DEG;
    this._shapes.y.entity.setLocalEulerAngles(0, angle, 0);
    angle = Math.atan2(tmpV16.y, tmpV16.x) * math.RAD_TO_DEG;
    this._shapes.z.entity.setLocalEulerAngles(90, 0, angle + 90);
  }
  _drag(state) {
    for (const axis in this._shapes) {
      const shape = this._shapes[axis];
      if (axis === this._selectedAxis) {
        shape.drag(state);
      } else {
        shape.hide(state);
      }
    }
    this.fire(TransformGizmo.EVENT_RENDERUPDATE);
  }
  _storeNodeRotations() {
    const gizmoPos = this.root.getPosition();
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      this._nodeLocalRotations.set(node, node.getLocalRotation().clone());
      this._nodeRotations.set(node, node.getRotation().clone());
      this._nodeOffsets.set(node, node.getPosition().clone().sub(gizmoPos));
    }
  }
  _setNodeRotations(axis, angleDelta) {
    const gizmoPos = this.root.getPosition();
    const cameraPos = this._camera.entity.getPosition();
    const isFacing = axis === GIZMOAXIS_FACE;
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      const rot = this._nodeRotations.get(node);
      if (!rot) {
        continue;
      }
      if (isFacing) {
        tmpV16.copy(cameraPos).sub(gizmoPos).normalize();
      } else {
        tmpV16.set(0, 0, 0);
        tmpV16[axis] = 1;
      }
      tmpQ14.setFromAxisAngle(tmpV16, angleDelta);
      if (!isFacing && this._coordSpace === GIZMOSPACE_LOCAL) {
        tmpQ2.copy(rot).mul(tmpQ14);
        node.setLocalRotation(tmpQ2);
      } else {
        const offset = this._nodeOffsets.get(node);
        if (!offset) {
          continue;
        }
        tmpV16.copy(offset);
        tmpQ14.transformVector(tmpV16, tmpV16);
        tmpQ2.copy(tmpQ14).mul(rot);
        node.setEulerAngles(tmpQ2.getEulerAngles());
        node.setPosition(tmpV16.add(gizmoPos));
      }
    }
    if (this._coordSpace === GIZMOSPACE_LOCAL) {
      this._updateRotation();
    }
  }
  _screenToPoint(x2, y2) {
    const gizmoPos = this.root.getPosition();
    const mouseWPos = this._camera.screenToWorld(x2, y2, 1);
    const axis = this._selectedAxis;
    const ray = this._createRay(mouseWPos);
    const plane = this._createPlane(axis, axis === GIZMOAXIS_FACE, false);
    const point = new Vec3();
    let angle = 0;
    plane.intersectsRay(ray, point);
    const facingDir = tmpV16.sub2(ray.origin, gizmoPos).normalize();
    const facingDot = plane.normal.dot(facingDir);
    if (axis === GIZMOAXIS_FACE || Math.abs(facingDot) > FACING_THRESHOLD) {
      tmpQ14.copy(this._camera.entity.getRotation()).invert();
      tmpV16.sub2(point, gizmoPos);
      tmpQ14.transformVector(tmpV16, tmpV16);
      angle = Math.sign(facingDot) * Math.atan2(tmpV16.y, tmpV16.x) * math.RAD_TO_DEG;
    } else {
      tmpV16.cross(plane.normal, facingDir).normalize();
      angle = mouseWPos.dot(tmpV16) * ROTATE_SCALE;
      if (this._camera.projection === PROJECTION_ORTHOGRAPHIC) {
        angle /= this._camera.orthoHeight || 1;
      }
    }
    return {
      point,
      angle
    };
  }
};

// ../node_modules/playcanvas/build/playcanvas/src/extras/gizmo/scale-gizmo.js
var tmpV17 = new Vec3();
var tmpV26 = new Vec3();
var tmpQ15 = new Quat();
var ScaleGizmo = class extends TransformGizmo {
  constructor(app2, camera, layer) {
    super(app2, camera, layer);
    this._shapes = {
      xyz: new AxisBoxCenter(this._device, {
        axis: GIZMOAXIS_XYZ,
        layers: [this._layer.id],
        defaultColor: this._meshColors.axis.xyz,
        hoverColor: this._meshColors.hover.xyz
      }),
      yz: new AxisPlane(this._device, {
        axis: GIZMOAXIS_X,
        flipAxis: GIZMOAXIS_Y,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, -90),
        defaultColor: this._meshColors.axis.x,
        hoverColor: this._meshColors.hover.x
      }),
      xz: new AxisPlane(this._device, {
        axis: GIZMOAXIS_Y,
        flipAxis: GIZMOAXIS_Z,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, 0),
        defaultColor: this._meshColors.axis.y,
        hoverColor: this._meshColors.hover.y
      }),
      xy: new AxisPlane(this._device, {
        axis: GIZMOAXIS_Z,
        flipAxis: GIZMOAXIS_X,
        layers: [this._layer.id],
        rotation: new Vec3(90, 0, 0),
        defaultColor: this._meshColors.axis.z,
        hoverColor: this._meshColors.hover.z
      }),
      x: new AxisBoxLine(this._device, {
        axis: GIZMOAXIS_X,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, -90),
        defaultColor: this._meshColors.axis.x,
        hoverColor: this._meshColors.hover.x
      }),
      y: new AxisBoxLine(this._device, {
        axis: GIZMOAXIS_Y,
        layers: [this._layer.id],
        rotation: new Vec3(0, 0, 0),
        defaultColor: this._meshColors.axis.y,
        hoverColor: this._meshColors.hover.y
      }),
      z: new AxisBoxLine(this._device, {
        axis: GIZMOAXIS_Z,
        layers: [this._layer.id],
        rotation: new Vec3(90, 0, 0),
        defaultColor: this._meshColors.axis.z,
        hoverColor: this._meshColors.hover.z
      })
    };
    this._coordSpace = GIZMOSPACE_LOCAL;
    this._nodeScales = /* @__PURE__ */ new Map();
    this._useUniformScaling = false;
    this.snapIncrement = 1;
    this._createTransform();
    this.on(TransformGizmo.EVENT_TRANSFORMSTART, () => {
      this._selectionStartPoint.sub(Vec3.ONE);
      this._storeNodeScales();
    });
    this.on(TransformGizmo.EVENT_TRANSFORMMOVE, (pointDelta) => {
      if (this.snap) {
        pointDelta.mulScalar(1 / this.snapIncrement);
        pointDelta.round();
        pointDelta.mulScalar(this.snapIncrement);
      }
      this._setNodeScales(pointDelta);
    });
    this.on(TransformGizmo.EVENT_NODESDETACH, () => {
      this._nodeScales.clear();
    });
  }
  set coordSpace(value) {
  }
  get coordSpace() {
    return this._coordSpace;
  }
  set uniform(value) {
    this._useUniformScaling = value != null ? value : true;
  }
  get uniform() {
    return this._useUniformScaling;
  }
  set axisGap(value) {
    this._setArrowProp("gap", value);
  }
  get axisGap() {
    return this._shapes.x.gap;
  }
  set axisLineThickness(value) {
    this._setArrowProp("lineThickness", value);
  }
  get axisLineThickness() {
    return this._shapes.x.lineThickness;
  }
  set axisLineLength(value) {
    this._setArrowProp("lineLength", value);
  }
  get axisLineLength() {
    return this._shapes.x.lineLength;
  }
  set axisLineTolerance(value) {
    this._setArrowProp("tolerance", value);
  }
  get axisLineTolerance() {
    return this._shapes.x.tolerance;
  }
  set axisBoxSize(value) {
    this._setArrowProp("boxSize", value);
  }
  get axisBoxSize() {
    return this._shapes.x.boxSize;
  }
  set axisPlaneSize(value) {
    this._setPlaneProp("size", value);
  }
  get axisPlaneSize() {
    return this._shapes.yz.size;
  }
  set axisPlaneGap(value) {
    this._setPlaneProp("gap", value);
  }
  get axisPlaneGap() {
    return this._shapes.yz.gap;
  }
  set axisCenterSize(value) {
    this._shapes.xyz.size = value;
  }
  get axisCenterSize() {
    return this._shapes.xyz.size;
  }
  set axisCenterTolerance(value) {
    this._shapes.xyz.tolerance = value;
  }
  get axisCenterTolerance() {
    return this._shapes.xyz.tolerance;
  }
  _setArrowProp(prop, value) {
    this._shapes.x[prop] = value;
    this._shapes.y[prop] = value;
    this._shapes.z[prop] = value;
  }
  _setPlaneProp(prop, value) {
    this._shapes.yz[prop] = value;
    this._shapes.xz[prop] = value;
    this._shapes.xy[prop] = value;
  }
  _storeNodeScales() {
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      this._nodeScales.set(node, node.getLocalScale().clone());
    }
  }
  _setNodeScales(pointDelta) {
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      const scale2 = this._nodeScales.get(node);
      if (!scale2) {
        continue;
      }
      node.setLocalScale(scale2.clone().mul(pointDelta));
    }
  }
  _screenToPoint(x2, y2) {
    const gizmoPos = this.root.getPosition();
    const mouseWPos = this._camera.screenToWorld(x2, y2, 1);
    const axis = this._selectedAxis;
    const isPlane = this._selectedIsPlane;
    const isScaleUniform = this._useUniformScaling && isPlane || axis === GIZMOAXIS_XYZ;
    const ray = this._createRay(mouseWPos);
    const plane = this._createPlane(axis, isScaleUniform, !isPlane);
    const point = new Vec3();
    const angle = 0;
    plane.intersectsRay(ray, point);
    if (isScaleUniform) {
      switch (axis) {
        case GIZMOAXIS_X:
          tmpV17.copy(this.root.up);
          tmpV26.copy(this.root.forward).mulScalar(-1);
          break;
        case GIZMOAXIS_Y:
          tmpV17.copy(this.root.right);
          tmpV26.copy(this.root.forward).mulScalar(-1);
          break;
        case GIZMOAXIS_Z:
          tmpV17.copy(this.root.up);
          tmpV26.copy(this.root.right);
          break;
        default:
          tmpV17.copy(this._camera.entity.up);
          tmpV26.copy(this._camera.entity.right);
          break;
      }
      tmpV26.add(tmpV17).normalize();
      tmpV17.sub2(point, gizmoPos);
      const length = tmpV17.length();
      const v = length * tmpV17.normalize().dot(tmpV26);
      point.set(v, v, v);
      if (axis !== GIZMOAXIS_XYZ) {
        point[axis] = 1;
      }
      return {
        point,
        angle
      };
    }
    tmpQ15.copy(this._rootStartRot).invert().transformVector(point, point);
    if (!isPlane) {
      this._projectToAxis(point, axis);
    }
    return {
      point,
      angle
    };
  }
};
export {
  ABSOLUTE_URL,
  ACTION_GAMEPAD,
  ACTION_KEYBOARD,
  ACTION_MOUSE,
  ADDRESS_CLAMP_TO_EDGE,
  ADDRESS_MIRRORED_REPEAT,
  ADDRESS_REPEAT,
  ANIM_BLEND_1D,
  ANIM_BLEND_2D_CARTESIAN,
  ANIM_BLEND_2D_DIRECTIONAL,
  ANIM_BLEND_DIRECT,
  ANIM_CONTROL_STATES,
  ANIM_EQUAL_TO,
  ANIM_GREATER_THAN,
  ANIM_GREATER_THAN_EQUAL_TO,
  ANIM_INTERRUPTION_NEXT,
  ANIM_INTERRUPTION_NEXT_PREV,
  ANIM_INTERRUPTION_NONE,
  ANIM_INTERRUPTION_PREV,
  ANIM_INTERRUPTION_PREV_NEXT,
  ANIM_LAYER_ADDITIVE,
  ANIM_LAYER_OVERWRITE,
  ANIM_LESS_THAN,
  ANIM_LESS_THAN_EQUAL_TO,
  ANIM_NOT_EQUAL_TO,
  ANIM_PARAMETER_BOOLEAN,
  ANIM_PARAMETER_FLOAT,
  ANIM_PARAMETER_INTEGER,
  ANIM_PARAMETER_TRIGGER,
  ANIM_STATE_ANY,
  ANIM_STATE_END,
  ANIM_STATE_START,
  ASPECT_AUTO,
  ASPECT_MANUAL,
  ASSET_ANIMATION,
  ASSET_AUDIO,
  ASSET_CONTAINER,
  ASSET_CSS,
  ASSET_CUBEMAP,
  ASSET_HTML,
  ASSET_IMAGE,
  ASSET_JSON,
  ASSET_MATERIAL,
  ASSET_MODEL,
  ASSET_SCRIPT,
  ASSET_SHADER,
  ASSET_TEXT,
  ASSET_TEXTURE,
  ASSET_TEXTUREATLAS,
  AXIS_KEY,
  AXIS_MOUSE_X,
  AXIS_MOUSE_Y,
  AXIS_PAD_L_X,
  AXIS_PAD_L_Y,
  AXIS_PAD_R_X,
  AXIS_PAD_R_Y,
  AnimBinder,
  AnimClip,
  AnimClipHandler,
  AnimComponent,
  AnimComponentLayer,
  AnimComponentSystem,
  AnimController,
  AnimCurve,
  AnimData,
  AnimEvaluator,
  AnimEvents,
  AnimSnapshot,
  AnimStateGraph,
  AnimStateGraphHandler,
  AnimTarget,
  AnimTrack,
  Animation,
  AnimationComponent,
  AnimationComponentSystem,
  AnimationHandler,
  AppBase,
  AppOptions,
  Application,
  Asset,
  AssetListLoader,
  AssetReference,
  AssetRegistry,
  AudioHandler,
  AudioListenerComponent,
  AudioListenerComponentSystem,
  BAKE_COLOR,
  BAKE_COLORDIR,
  BINDGROUP_MESH,
  BINDGROUP_MESH_UB,
  BINDGROUP_VIEW,
  BLENDEQUATION_ADD,
  BLENDEQUATION_MAX,
  BLENDEQUATION_MIN,
  BLENDEQUATION_REVERSE_SUBTRACT,
  BLENDEQUATION_SUBTRACT,
  BLENDMODE_CONSTANT,
  BLENDMODE_CONSTANT_ALPHA,
  BLENDMODE_CONSTANT_COLOR,
  BLENDMODE_DST_ALPHA,
  BLENDMODE_DST_COLOR,
  BLENDMODE_ONE,
  BLENDMODE_ONE_MINUS_CONSTANT,
  BLENDMODE_ONE_MINUS_CONSTANT_ALPHA,
  BLENDMODE_ONE_MINUS_CONSTANT_COLOR,
  BLENDMODE_ONE_MINUS_DST_ALPHA,
  BLENDMODE_ONE_MINUS_DST_COLOR,
  BLENDMODE_ONE_MINUS_SRC_ALPHA,
  BLENDMODE_ONE_MINUS_SRC_COLOR,
  BLENDMODE_SRC_ALPHA,
  BLENDMODE_SRC_ALPHA_SATURATE,
  BLENDMODE_SRC_COLOR,
  BLENDMODE_ZERO,
  BLEND_ADDITIVE,
  BLEND_ADDITIVEALPHA,
  BLEND_MAX,
  BLEND_MIN,
  BLEND_MULTIPLICATIVE,
  BLEND_MULTIPLICATIVE2X,
  BLEND_NONE,
  BLEND_NORMAL,
  BLEND_PREMULTIPLIED,
  BLEND_SCREEN,
  BLEND_SUBTRACTIVE,
  BLUR_BOX,
  BLUR_GAUSSIAN,
  BODYFLAG_KINEMATIC_OBJECT,
  BODYFLAG_NORESPONSE_OBJECT,
  BODYFLAG_STATIC_OBJECT,
  BODYGROUP_DEFAULT,
  BODYGROUP_DYNAMIC,
  BODYGROUP_ENGINE_1,
  BODYGROUP_ENGINE_2,
  BODYGROUP_ENGINE_3,
  BODYGROUP_KINEMATIC,
  BODYGROUP_NONE,
  BODYGROUP_STATIC,
  BODYGROUP_TRIGGER,
  BODYGROUP_USER_1,
  BODYGROUP_USER_2,
  BODYGROUP_USER_3,
  BODYGROUP_USER_4,
  BODYGROUP_USER_5,
  BODYGROUP_USER_6,
  BODYGROUP_USER_7,
  BODYGROUP_USER_8,
  BODYMASK_ALL,
  BODYMASK_NONE,
  BODYMASK_NOT_STATIC,
  BODYMASK_NOT_STATIC_KINEMATIC,
  BODYMASK_STATIC,
  BODYSTATE_ACTIVE_TAG,
  BODYSTATE_DISABLE_DEACTIVATION,
  BODYSTATE_DISABLE_SIMULATION,
  BODYSTATE_ISLAND_SLEEPING,
  BODYSTATE_WANTS_DEACTIVATION,
  BODYTYPE_DYNAMIC,
  BODYTYPE_KINEMATIC,
  BODYTYPE_STATIC,
  BUFFERUSAGE_COPY_DST,
  BUFFERUSAGE_COPY_SRC,
  BUFFERUSAGE_INDEX,
  BUFFERUSAGE_INDIRECT,
  BUFFERUSAGE_READ,
  BUFFERUSAGE_STORAGE,
  BUFFERUSAGE_UNIFORM,
  BUFFERUSAGE_VERTEX,
  BUFFERUSAGE_WRITE,
  BUFFER_DYNAMIC,
  BUFFER_GPUDYNAMIC,
  BUFFER_STATIC,
  BUFFER_STREAM,
  BUTTON_TRANSITION_MODE_SPRITE_CHANGE,
  BUTTON_TRANSITION_MODE_TINT,
  Batch,
  BatchGroup,
  BatchManager,
  BinaryHandler,
  BindGroupFormat,
  BindStorageBufferFormat,
  BindStorageTextureFormat,
  BindTextureFormat,
  BindUniformBufferFormat,
  BlendState,
  BoundingBox,
  BoundingSphere,
  BoxGeometry,
  Bundle,
  BundleHandler,
  BundleRegistry,
  ButtonComponent,
  ButtonComponentSystem,
  CHUNKAPI_1_51,
  CHUNKAPI_1_55,
  CHUNKAPI_1_56,
  CHUNKAPI_1_57,
  CHUNKAPI_1_58,
  CHUNKAPI_1_60,
  CHUNKAPI_1_62,
  CHUNKAPI_1_65,
  CHUNKAPI_1_70,
  CLEARFLAG_COLOR,
  CLEARFLAG_DEPTH,
  CLEARFLAG_STENCIL,
  CUBEFACE_NEGX,
  CUBEFACE_NEGY,
  CUBEFACE_NEGZ,
  CUBEFACE_POSX,
  CUBEFACE_POSY,
  CUBEFACE_POSZ,
  CUBEPROJ_BOX,
  CUBEPROJ_NONE,
  CULLFACE_BACK,
  CULLFACE_FRONT,
  CULLFACE_FRONTANDBACK,
  CULLFACE_NONE,
  CURVE_LINEAR,
  CURVE_SMOOTHSTEP,
  CURVE_SPLINE,
  CURVE_STEP,
  Camera,
  CameraComponent,
  CameraComponentSystem,
  CanvasFont,
  CapsuleGeometry,
  ChunkBuilder,
  CollisionComponent,
  CollisionComponentSystem,
  Color,
  Component,
  ComponentSystem,
  ComponentSystemRegistry,
  Compute,
  ConeGeometry,
  ContactPoint,
  ContactResult,
  ContainerHandler,
  ContainerResource,
  Controller,
  CssHandler,
  CubemapHandler,
  Curve,
  CurveSet,
  CylinderGeometry,
  DETAILMODE_ADD,
  DETAILMODE_MAX,
  DETAILMODE_MIN,
  DETAILMODE_MUL,
  DETAILMODE_OVERLAY,
  DETAILMODE_SCREEN,
  DEVICETYPE_NULL,
  DEVICETYPE_WEBGL2,
  DEVICETYPE_WEBGPU,
  DISPLAYFORMAT_HDR,
  DISPLAYFORMAT_LDR,
  DISPLAYFORMAT_LDR_SRGB,
  DISTANCE_EXPONENTIAL,
  DISTANCE_INVERSE,
  DISTANCE_LINEAR,
  DITHER_BAYER8,
  DITHER_BLUENOISE,
  DITHER_IGNNOISE,
  DITHER_NONE,
  DefaultAnimBinder,
  DepthState,
  DomeGeometry,
  ELEMENTTYPE_GROUP,
  ELEMENTTYPE_IMAGE,
  ELEMENTTYPE_TEXT,
  EMITTERSHAPE_BOX,
  EMITTERSHAPE_SPHERE,
  EVENT_GAMEPADCONNECTED,
  EVENT_GAMEPADDISCONNECTED,
  EVENT_KEYDOWN,
  EVENT_KEYUP,
  EVENT_MOUSEDOWN,
  EVENT_MOUSEMOVE,
  EVENT_MOUSEUP,
  EVENT_MOUSEWHEEL,
  EVENT_SELECT,
  EVENT_SELECTEND,
  EVENT_SELECTSTART,
  EVENT_TOUCHCANCEL,
  EVENT_TOUCHEND,
  EVENT_TOUCHMOVE,
  EVENT_TOUCHSTART,
  ElementComponent,
  ElementComponentSystem,
  ElementDragHelper,
  ElementInput,
  ElementInputEvent,
  ElementMouseEvent,
  ElementSelectEvent,
  ElementTouchEvent,
  Entity,
  EntityReference,
  EnvLighting,
  EventHandle,
  EventHandler,
  FILLMODE_FILL_WINDOW,
  FILLMODE_KEEP_ASPECT,
  FILLMODE_NONE,
  FILTER_LINEAR,
  FILTER_LINEAR_MIPMAP_LINEAR,
  FILTER_LINEAR_MIPMAP_NEAREST,
  FILTER_NEAREST,
  FILTER_NEAREST_MIPMAP_LINEAR,
  FILTER_NEAREST_MIPMAP_NEAREST,
  FITMODE_CONTAIN,
  FITMODE_COVER,
  FITMODE_STRETCH,
  FITTING_BOTH,
  FITTING_NONE,
  FITTING_SHRINK,
  FITTING_STRETCH,
  FOG_EXP,
  FOG_EXP2,
  FOG_LINEAR,
  FOG_NONE,
  FONT_BITMAP,
  FONT_MSDF,
  FRESNEL_NONE,
  FRESNEL_SCHLICK,
  FUNC_ALWAYS,
  FUNC_EQUAL,
  FUNC_GREATER,
  FUNC_GREATEREQUAL,
  FUNC_LESS,
  FUNC_LESSEQUAL,
  FUNC_NEVER,
  FUNC_NOTEQUAL,
  FloatPacking,
  FolderHandler,
  Font,
  FontHandler,
  ForwardRenderer,
  Frustum,
  GAMMA_NONE,
  GAMMA_SRGB,
  GIZMOAXIS_FACE,
  GIZMOAXIS_X,
  GIZMOAXIS_XY,
  GIZMOAXIS_XYZ,
  GIZMOAXIS_XZ,
  GIZMOAXIS_Y,
  GIZMOAXIS_YZ,
  GIZMOAXIS_Z,
  GIZMOSPACE_LOCAL,
  GIZMOSPACE_WORLD,
  GSplat,
  GSplatComponent,
  GSplatComponentSystem,
  GSplatData,
  GSplatHandler,
  GSplatInstance,
  GSplatResource,
  GamePads,
  Geometry,
  Gizmo,
  GltfExporter,
  GraphNode,
  GraphicsDevice,
  HierarchyHandler,
  HtmlHandler,
  Http,
  I18n,
  INDEXFORMAT_UINT16,
  INDEXFORMAT_UINT32,
  INDEXFORMAT_UINT8,
  INTERPOLATION_CUBIC,
  INTERPOLATION_LINEAR,
  INTERPOLATION_STEP,
  ImageElement,
  IndexBuffer,
  IndexedList,
  JointComponent,
  JointComponentSystem,
  JsonHandler,
  JsonStandardMaterialParser,
  KEY_0,
  KEY_1,
  KEY_2,
  KEY_3,
  KEY_4,
  KEY_5,
  KEY_6,
  KEY_7,
  KEY_8,
  KEY_9,
  KEY_A,
  KEY_ADD,
  KEY_ALT,
  KEY_B,
  KEY_BACKSPACE,
  KEY_BACK_SLASH,
  KEY_C,
  KEY_CAPS_LOCK,
  KEY_CLOSE_BRACKET,
  KEY_COMMA,
  KEY_CONTEXT_MENU,
  KEY_CONTROL,
  KEY_D,
  KEY_DECIMAL,
  KEY_DELETE,
  KEY_DIVIDE,
  KEY_DOWN,
  KEY_E,
  KEY_END,
  KEY_ENTER,
  KEY_EQUAL,
  KEY_ESCAPE,
  KEY_F,
  KEY_F1,
  KEY_F10,
  KEY_F11,
  KEY_F12,
  KEY_F2,
  KEY_F3,
  KEY_F4,
  KEY_F5,
  KEY_F6,
  KEY_F7,
  KEY_F8,
  KEY_F9,
  KEY_G,
  KEY_H,
  KEY_HOME,
  KEY_I,
  KEY_INSERT,
  KEY_J,
  KEY_K,
  KEY_L,
  KEY_LEFT,
  KEY_M,
  KEY_META,
  KEY_MULTIPLY,
  KEY_N,
  KEY_NUMPAD_0,
  KEY_NUMPAD_1,
  KEY_NUMPAD_2,
  KEY_NUMPAD_3,
  KEY_NUMPAD_4,
  KEY_NUMPAD_5,
  KEY_NUMPAD_6,
  KEY_NUMPAD_7,
  KEY_NUMPAD_8,
  KEY_NUMPAD_9,
  KEY_O,
  KEY_OPEN_BRACKET,
  KEY_P,
  KEY_PAGE_DOWN,
  KEY_PAGE_UP,
  KEY_PAUSE,
  KEY_PERIOD,
  KEY_PRINT_SCREEN,
  KEY_Q,
  KEY_R,
  KEY_RETURN,
  KEY_RIGHT,
  KEY_S,
  KEY_SEMICOLON,
  KEY_SEPARATOR,
  KEY_SHIFT,
  KEY_SLASH,
  KEY_SPACE,
  KEY_SUBTRACT,
  KEY_T,
  KEY_TAB,
  KEY_U,
  KEY_UP,
  KEY_V,
  KEY_W,
  KEY_WINDOWS,
  KEY_X,
  KEY_Y,
  KEY_Z,
  Key,
  Keyboard,
  KeyboardEvent,
  LAYERID_DEPTH,
  LAYERID_IMMEDIATE,
  LAYERID_SKYBOX,
  LAYERID_UI,
  LAYERID_WORLD,
  LAYER_FX,
  LAYER_GIZMO,
  LAYER_HUD,
  LAYER_WORLD,
  LIGHTFALLOFF_INVERSESQUARED,
  LIGHTFALLOFF_LINEAR,
  LIGHTSHAPE_DISK,
  LIGHTSHAPE_PUNCTUAL,
  LIGHTSHAPE_RECT,
  LIGHTSHAPE_SPHERE,
  LIGHTTYPE_COUNT,
  LIGHTTYPE_DIRECTIONAL,
  LIGHTTYPE_OMNI,
  LIGHTTYPE_POINT,
  LIGHTTYPE_SPOT,
  Layer,
  LayerComposition,
  LayoutCalculator,
  LayoutChildComponent,
  LayoutChildComponentSystem,
  LayoutGroupComponent,
  LayoutGroupComponentSystem,
  Light,
  LightComponent,
  LightComponentSystem,
  LightingParams,
  Lightmapper,
  LitMaterial,
  LitOptions,
  LitShaderOptions,
  LocalizedAsset,
  MASK_AFFECT_DYNAMIC,
  MASK_AFFECT_LIGHTMAPPED,
  MASK_BAKE,
  MOTION_FREE,
  MOTION_LIMITED,
  MOTION_LOCKED,
  MOUSEBUTTON_LEFT,
  MOUSEBUTTON_MIDDLE,
  MOUSEBUTTON_NONE,
  MOUSEBUTTON_RIGHT,
  Mat3,
  Mat4,
  Material,
  MaterialHandler,
  Mesh,
  MeshInstance,
  MiniStats,
  Model,
  ModelComponent,
  ModelComponentSystem,
  ModelHandler,
  Morph,
  MorphInstance,
  MorphTarget,
  Mouse,
  MouseEvent,
  Node,
  NullGraphicsDevice,
  ORIENTATION_HORIZONTAL,
  ORIENTATION_VERTICAL,
  OrientedBox,
  PAD_1,
  PAD_2,
  PAD_3,
  PAD_4,
  PAD_DOWN,
  PAD_FACE_1,
  PAD_FACE_2,
  PAD_FACE_3,
  PAD_FACE_4,
  PAD_LEFT,
  PAD_L_SHOULDER_1,
  PAD_L_SHOULDER_2,
  PAD_L_STICK_BUTTON,
  PAD_L_STICK_X,
  PAD_L_STICK_Y,
  PAD_RIGHT,
  PAD_R_SHOULDER_1,
  PAD_R_SHOULDER_2,
  PAD_R_STICK_BUTTON,
  PAD_R_STICK_X,
  PAD_R_STICK_Y,
  PAD_SELECT,
  PAD_START,
  PAD_UP,
  PAD_VENDOR,
  PARTICLEMODE_CPU,
  PARTICLEMODE_GPU,
  PARTICLEORIENTATION_EMITTER,
  PARTICLEORIENTATION_SCREEN,
  PARTICLEORIENTATION_WORLD,
  PARTICLESORT_DISTANCE,
  PARTICLESORT_NEWER_FIRST,
  PARTICLESORT_NONE,
  PARTICLESORT_OLDER_FIRST,
  PIXELFORMAT_111110F,
  PIXELFORMAT_A8,
  PIXELFORMAT_ASTC_4x4,
  PIXELFORMAT_ASTC_4x4_SRGB,
  PIXELFORMAT_ATC_RGB,
  PIXELFORMAT_ATC_RGBA,
  PIXELFORMAT_BGRA8,
  PIXELFORMAT_DEPTH,
  PIXELFORMAT_DEPTHSTENCIL,
  PIXELFORMAT_DXT1,
  PIXELFORMAT_DXT1_SRGB,
  PIXELFORMAT_DXT3,
  PIXELFORMAT_DXT3_SRGB,
  PIXELFORMAT_DXT5,
  PIXELFORMAT_DXT5_SRGB,
  PIXELFORMAT_ETC1,
  PIXELFORMAT_ETC2_RGB,
  PIXELFORMAT_ETC2_RGBA,
  PIXELFORMAT_ETC2_SRGB,
  PIXELFORMAT_ETC2_SRGBA,
  PIXELFORMAT_L8,
  PIXELFORMAT_L8_A8,
  PIXELFORMAT_LA8,
  PIXELFORMAT_PVRTC_2BPP_RGBA_1,
  PIXELFORMAT_PVRTC_2BPP_RGB_1,
  PIXELFORMAT_PVRTC_2BPP_SRGBA_1,
  PIXELFORMAT_PVRTC_2BPP_SRGB_1,
  PIXELFORMAT_PVRTC_4BPP_RGBA_1,
  PIXELFORMAT_PVRTC_4BPP_RGB_1,
  PIXELFORMAT_PVRTC_4BPP_SRGBA_1,
  PIXELFORMAT_PVRTC_4BPP_SRGB_1,
  PIXELFORMAT_R16F,
  PIXELFORMAT_R16I,
  PIXELFORMAT_R16U,
  PIXELFORMAT_R32F,
  PIXELFORMAT_R32I,
  PIXELFORMAT_R32U,
  PIXELFORMAT_R4_G4_B4_A4,
  PIXELFORMAT_R5_G5_B5_A1,
  PIXELFORMAT_R5_G6_B5,
  PIXELFORMAT_R8,
  PIXELFORMAT_R8I,
  PIXELFORMAT_R8U,
  PIXELFORMAT_R8_G8_B8,
  PIXELFORMAT_R8_G8_B8_A8,
  PIXELFORMAT_RG16F,
  PIXELFORMAT_RG16I,
  PIXELFORMAT_RG16U,
  PIXELFORMAT_RG32I,
  PIXELFORMAT_RG32U,
  PIXELFORMAT_RG8,
  PIXELFORMAT_RG8I,
  PIXELFORMAT_RG8U,
  PIXELFORMAT_RGB16F,
  PIXELFORMAT_RGB32F,
  PIXELFORMAT_RGB565,
  PIXELFORMAT_RGB8,
  PIXELFORMAT_RGBA16F,
  PIXELFORMAT_RGBA16I,
  PIXELFORMAT_RGBA16U,
  PIXELFORMAT_RGBA32F,
  PIXELFORMAT_RGBA32I,
  PIXELFORMAT_RGBA32U,
  PIXELFORMAT_RGBA4,
  PIXELFORMAT_RGBA5551,
  PIXELFORMAT_RGBA8,
  PIXELFORMAT_RGBA8I,
  PIXELFORMAT_RGBA8U,
  PIXELFORMAT_SBGRA8,
  PIXELFORMAT_SRGB,
  PIXELFORMAT_SRGB8,
  PIXELFORMAT_SRGBA,
  PIXELFORMAT_SRGBA8,
  PRIMITIVE_LINELOOP,
  PRIMITIVE_LINES,
  PRIMITIVE_LINESTRIP,
  PRIMITIVE_POINTS,
  PRIMITIVE_TRIANGLES,
  PRIMITIVE_TRIFAN,
  PRIMITIVE_TRISTRIP,
  PROJECTION_ORTHOGRAPHIC,
  PROJECTION_PERSPECTIVE,
  ParticleEmitter,
  ParticleSystemComponent,
  ParticleSystemComponentSystem,
  Picker,
  Plane,
  PlaneGeometry,
  PostEffect,
  PostEffectQueue,
  ProgramLibrary,
  QuadRender,
  Quat,
  RENDERSTYLE_POINTS,
  RENDERSTYLE_SOLID,
  RENDERSTYLE_WIREFRAME,
  RESOLUTION_AUTO,
  RESOLUTION_FIXED,
  RIGIDBODY_ACTIVE_TAG,
  RIGIDBODY_CF_KINEMATIC_OBJECT,
  RIGIDBODY_CF_NORESPONSE_OBJECT,
  RIGIDBODY_CF_STATIC_OBJECT,
  RIGIDBODY_DISABLE_DEACTIVATION,
  RIGIDBODY_DISABLE_SIMULATION,
  RIGIDBODY_ISLAND_SLEEPING,
  RIGIDBODY_TYPE_DYNAMIC,
  RIGIDBODY_TYPE_KINEMATIC,
  RIGIDBODY_TYPE_STATIC,
  RIGIDBODY_WANTS_DEACTIVATION,
  Ray,
  RaycastResult,
  ReadStream,
  RenderComponent,
  RenderComponentSystem,
  RenderHandler,
  RenderPass,
  RenderPassBloom,
  RenderPassCameraFrame,
  RenderPassColorGrab,
  RenderPassCompose,
  RenderPassDepthAwareBlur,
  RenderPassDownsample,
  RenderPassForward,
  RenderPassShaderQuad,
  RenderPassSsao,
  RenderPassTAA,
  RenderPassUpsample,
  RenderTarget,
  RenderingParams,
  ResourceHandler,
  ResourceLoader,
  RigidBodyComponent,
  RigidBodyComponentSystem,
  RotateGizmo,
  SAMPLETYPE_DEPTH,
  SAMPLETYPE_FLOAT,
  SAMPLETYPE_INT,
  SAMPLETYPE_UINT,
  SAMPLETYPE_UNFILTERABLE_FLOAT,
  SCALEMODE_BLEND,
  SCALEMODE_NONE,
  SCROLLBAR_VISIBILITY_SHOW_ALWAYS,
  SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,
  SCROLL_MODE_BOUNCE,
  SCROLL_MODE_CLAMP,
  SCROLL_MODE_INFINITE,
  SEMANTIC_ATTR0,
  SEMANTIC_ATTR1,
  SEMANTIC_ATTR10,
  SEMANTIC_ATTR11,
  SEMANTIC_ATTR12,
  SEMANTIC_ATTR13,
  SEMANTIC_ATTR14,
  SEMANTIC_ATTR15,
  SEMANTIC_ATTR2,
  SEMANTIC_ATTR3,
  SEMANTIC_ATTR4,
  SEMANTIC_ATTR5,
  SEMANTIC_ATTR6,
  SEMANTIC_ATTR7,
  SEMANTIC_ATTR8,
  SEMANTIC_ATTR9,
  SEMANTIC_BLENDINDICES,
  SEMANTIC_BLENDWEIGHT,
  SEMANTIC_COLOR,
  SEMANTIC_NORMAL,
  SEMANTIC_POSITION,
  SEMANTIC_TANGENT,
  SEMANTIC_TEXCOORD,
  SEMANTIC_TEXCOORD0,
  SEMANTIC_TEXCOORD1,
  SEMANTIC_TEXCOORD2,
  SEMANTIC_TEXCOORD3,
  SEMANTIC_TEXCOORD4,
  SEMANTIC_TEXCOORD5,
  SEMANTIC_TEXCOORD6,
  SEMANTIC_TEXCOORD7,
  SHADERDEF_BATCH,
  SHADERDEF_DIRLM,
  SHADERDEF_INSTANCING,
  SHADERDEF_LM,
  SHADERDEF_LMAMBIENT,
  SHADERDEF_MORPH_NORMAL,
  SHADERDEF_MORPH_POSITION,
  SHADERDEF_MORPH_TEXTURE_BASED_INT,
  SHADERDEF_NOSHADOW,
  SHADERDEF_SCREENSPACE,
  SHADERDEF_SKIN,
  SHADERDEF_TANGENTS,
  SHADERDEF_UV0,
  SHADERDEF_UV1,
  SHADERDEF_VCOLOR,
  SHADERLANGUAGE_GLSL,
  SHADERLANGUAGE_WGSL,
  SHADERPASS_ALBEDO,
  SHADERPASS_AO,
  SHADERPASS_EMISSION,
  SHADERPASS_FORWARD,
  SHADERPASS_GLOSS,
  SHADERPASS_LIGHTING,
  SHADERPASS_METALNESS,
  SHADERPASS_OPACITY,
  SHADERPASS_SPECULARITY,
  SHADERPASS_UV0,
  SHADERPASS_WORLDNORMAL,
  SHADERSTAGE_COMPUTE,
  SHADERSTAGE_FRAGMENT,
  SHADERSTAGE_VERTEX,
  SHADERTAG_MATERIAL,
  SHADER_DEPTH,
  SHADER_FORWARD,
  SHADER_PICK,
  SHADER_PREPASS_VELOCITY,
  SHADER_SHADOW,
  SHADOWUPDATE_NONE,
  SHADOWUPDATE_REALTIME,
  SHADOWUPDATE_THISFRAME,
  SHADOW_DEPTH,
  SHADOW_PCF1,
  SHADOW_PCF3,
  SHADOW_PCF5,
  SHADOW_PCSS,
  SHADOW_VSM16,
  SHADOW_VSM32,
  SHADOW_VSM8,
  SKYTYPE_BOX,
  SKYTYPE_DOME,
  SKYTYPE_INFINITE,
  SORTKEY_DEPTH,
  SORTKEY_FORWARD,
  SORTMODE_BACK2FRONT,
  SORTMODE_CUSTOM,
  SORTMODE_FRONT2BACK,
  SORTMODE_MANUAL,
  SORTMODE_MATERIALMESH,
  SORTMODE_NONE,
  SPECOCC_AO,
  SPECOCC_GLOSSDEPENDENT,
  SPECOCC_NONE,
  SPRITETYPE_ANIMATED,
  SPRITETYPE_SIMPLE,
  SPRITE_RENDERMODE_SIMPLE,
  SPRITE_RENDERMODE_SLICED,
  SPRITE_RENDERMODE_TILED,
  STENCILOP_DECREMENT,
  STENCILOP_DECREMENTWRAP,
  STENCILOP_INCREMENT,
  STENCILOP_INCREMENTWRAP,
  STENCILOP_INVERT,
  STENCILOP_KEEP,
  STENCILOP_REPLACE,
  STENCILOP_ZERO,
  ScaleGizmo,
  Scene,
  SceneHandler,
  SceneRegistry,
  SceneRegistryItem,
  SceneSettingsHandler,
  ScopeId,
  ScopeSpace,
  ScreenComponent,
  ScreenComponentSystem,
  Script,
  ScriptAttributes,
  ScriptComponent,
  ScriptComponentSystem,
  ScriptHandler,
  ScriptRegistry,
  ScriptType,
  ScrollViewComponent,
  ScrollViewComponentSystem,
  ScrollbarComponent,
  ScrollbarComponentSystem,
  Shader,
  ShaderHandler,
  ShaderMaterial,
  ShaderPass,
  SingleContactResult,
  Skeleton,
  Skin,
  SkinBatchInstance,
  SkinInstance,
  SortedLoopArray,
  Sound,
  SoundComponent,
  SoundComponentSystem,
  SoundInstance,
  SoundInstance3d,
  SoundManager,
  SoundSlot,
  SphereGeometry,
  Sprite,
  SpriteAnimationClip,
  SpriteComponent,
  SpriteComponentSystem,
  SpriteHandler,
  StandardMaterial,
  StandardMaterialOptions,
  StencilParameters,
  StorageBuffer,
  TEXHINT_ASSET,
  TEXHINT_LIGHTMAP,
  TEXHINT_NONE,
  TEXHINT_SHADOWMAP,
  TEXPROPERTY_ADDRESS_U,
  TEXPROPERTY_ADDRESS_V,
  TEXPROPERTY_ADDRESS_W,
  TEXPROPERTY_ALL,
  TEXPROPERTY_ANISOTROPY,
  TEXPROPERTY_COMPARE_FUNC,
  TEXPROPERTY_COMPARE_ON_READ,
  TEXPROPERTY_MAG_FILTER,
  TEXPROPERTY_MIN_FILTER,
  TEXTUREDIMENSION_1D,
  TEXTUREDIMENSION_2D,
  TEXTUREDIMENSION_2D_ARRAY,
  TEXTUREDIMENSION_3D,
  TEXTUREDIMENSION_CUBE,
  TEXTUREDIMENSION_CUBE_ARRAY,
  TEXTURELOCK_NONE,
  TEXTURELOCK_READ,
  TEXTURELOCK_WRITE,
  TEXTUREPROJECTION_CUBE,
  TEXTUREPROJECTION_EQUIRECT,
  TEXTUREPROJECTION_NONE,
  TEXTUREPROJECTION_OCTAHEDRAL,
  TEXTURETYPE_DEFAULT,
  TEXTURETYPE_RGBE,
  TEXTURETYPE_RGBM,
  TEXTURETYPE_RGBP,
  TEXTURETYPE_SWIZZLEGGGR,
  TONEMAP_ACES,
  TONEMAP_ACES2,
  TONEMAP_FILMIC,
  TONEMAP_HEJL,
  TONEMAP_LINEAR,
  TONEMAP_NEUTRAL,
  TONEMAP_NONE,
  TRACEID_BINDGROUPFORMAT_ALLOC,
  TRACEID_BINDGROUP_ALLOC,
  TRACEID_COMPUTEPIPELINE_ALLOC,
  TRACEID_GPU_TIMINGS,
  TRACEID_PIPELINELAYOUT_ALLOC,
  TRACEID_RENDERPIPELINE_ALLOC,
  TRACEID_RENDER_ACTION,
  TRACEID_RENDER_FRAME,
  TRACEID_RENDER_FRAME_TIME,
  TRACEID_RENDER_PASS,
  TRACEID_RENDER_PASS_DETAIL,
  TRACEID_RENDER_QUEUE,
  TRACEID_RENDER_TARGET_ALLOC,
  TRACEID_SHADER_ALLOC,
  TRACEID_SHADER_COMPILE,
  TRACEID_TEXTURES,
  TRACEID_TEXTURE_ALLOC,
  TRACEID_VRAM_IB,
  TRACEID_VRAM_SB,
  TRACEID_VRAM_TEXTURE,
  TRACEID_VRAM_VB,
  TRACE_ID_ELEMENT,
  TYPE_FLOAT16,
  TYPE_FLOAT32,
  TYPE_INT16,
  TYPE_INT32,
  TYPE_INT8,
  TYPE_UINT16,
  TYPE_UINT32,
  TYPE_UINT8,
  Tags,
  Template,
  TemplateHandler,
  TextElement,
  TextHandler,
  Texture,
  TextureAtlas,
  TextureAtlasHandler,
  TextureHandler,
  TextureUtils,
  TorusGeometry,
  Touch,
  TouchDevice,
  TouchEvent,
  Tracing,
  TransformFeedback,
  TransformGizmo,
  TranslateGizmo,
  Tri,
  UNIFORMTYPE_BOOL,
  UNIFORMTYPE_BOOLARRAY,
  UNIFORMTYPE_BVEC2,
  UNIFORMTYPE_BVEC2ARRAY,
  UNIFORMTYPE_BVEC3,
  UNIFORMTYPE_BVEC3ARRAY,
  UNIFORMTYPE_BVEC4,
  UNIFORMTYPE_BVEC4ARRAY,
  UNIFORMTYPE_FLOAT,
  UNIFORMTYPE_FLOATARRAY,
  UNIFORMTYPE_INT,
  UNIFORMTYPE_INTARRAY,
  UNIFORMTYPE_ITEXTURE2D,
  UNIFORMTYPE_ITEXTURE2D_ARRAY,
  UNIFORMTYPE_ITEXTURE3D,
  UNIFORMTYPE_ITEXTURECUBE,
  UNIFORMTYPE_IVEC2,
  UNIFORMTYPE_IVEC2ARRAY,
  UNIFORMTYPE_IVEC3,
  UNIFORMTYPE_IVEC3ARRAY,
  UNIFORMTYPE_IVEC4,
  UNIFORMTYPE_IVEC4ARRAY,
  UNIFORMTYPE_MAT2,
  UNIFORMTYPE_MAT3,
  UNIFORMTYPE_MAT4,
  UNIFORMTYPE_MAT4ARRAY,
  UNIFORMTYPE_TEXTURE2D,
  UNIFORMTYPE_TEXTURE2D_ARRAY,
  UNIFORMTYPE_TEXTURE2D_SHADOW,
  UNIFORMTYPE_TEXTURE3D,
  UNIFORMTYPE_TEXTURECUBE,
  UNIFORMTYPE_TEXTURECUBE_SHADOW,
  UNIFORMTYPE_UINT,
  UNIFORMTYPE_UINTARRAY,
  UNIFORMTYPE_UTEXTURE2D,
  UNIFORMTYPE_UTEXTURE2D_ARRAY,
  UNIFORMTYPE_UTEXTURE3D,
  UNIFORMTYPE_UTEXTURECUBE,
  UNIFORMTYPE_UVEC2,
  UNIFORMTYPE_UVEC2ARRAY,
  UNIFORMTYPE_UVEC3,
  UNIFORMTYPE_UVEC3ARRAY,
  UNIFORMTYPE_UVEC4,
  UNIFORMTYPE_UVEC4ARRAY,
  UNIFORMTYPE_VEC2,
  UNIFORMTYPE_VEC2ARRAY,
  UNIFORMTYPE_VEC3,
  UNIFORMTYPE_VEC3ARRAY,
  UNIFORMTYPE_VEC4,
  UNIFORMTYPE_VEC4ARRAY,
  UNIFORM_BUFFER_DEFAULT_SLOT_NAME,
  URI,
  UniformBufferFormat,
  UniformFormat,
  UsdzExporter,
  VIEW_CENTER,
  VIEW_LEFT,
  VIEW_RIGHT,
  Vec2,
  Vec3,
  Vec4,
  VertexBuffer,
  VertexFormat,
  VertexIterator,
  WasmModule,
  WebglGraphicsDevice,
  WebgpuGraphicsDevice,
  WorldClusters,
  XRDEPTHSENSINGFORMAT_F32,
  XRDEPTHSENSINGFORMAT_L8A8,
  XRDEPTHSENSINGUSAGE_CPU,
  XRDEPTHSENSINGUSAGE_GPU,
  XREYE_LEFT,
  XREYE_NONE,
  XREYE_RIGHT,
  XRHAND_LEFT,
  XRHAND_NONE,
  XRHAND_RIGHT,
  XRPAD_A,
  XRPAD_B,
  XRPAD_SQUEEZE,
  XRPAD_STICK_BUTTON,
  XRPAD_STICK_X,
  XRPAD_STICK_Y,
  XRPAD_TOUCHPAD_BUTTON,
  XRPAD_TOUCHPAD_X,
  XRPAD_TOUCHPAD_Y,
  XRPAD_TRIGGER,
  XRSPACE_BOUNDEDFLOOR,
  XRSPACE_LOCAL,
  XRSPACE_LOCALFLOOR,
  XRSPACE_UNBOUNDED,
  XRSPACE_VIEWER,
  XRTARGETRAY_GAZE,
  XRTARGETRAY_POINTER,
  XRTARGETRAY_SCREEN,
  XRTRACKABLE_MESH,
  XRTRACKABLE_PLANE,
  XRTRACKABLE_POINT,
  XRTYPE_AR,
  XRTYPE_INLINE,
  XRTYPE_VR,
  XrAnchor,
  XrAnchors,
  XrDomOverlay,
  XrFinger,
  XrHand,
  XrHitTest,
  XrHitTestSource,
  XrImageTracking,
  XrInput,
  XrInputSource,
  XrJoint,
  XrLightEstimation,
  XrManager,
  XrMeshDetection,
  XrPlane,
  XrPlaneDetection,
  XrTrackedImage,
  XrView,
  XrViews,
  ZoneComponent,
  ZoneComponentSystem,
  app,
  basisInitialize,
  bindGroupNames,
  calculateNormals,
  calculateTangents,
  createBox,
  createCapsule,
  createCone,
  createCylinder,
  createGraphicsDevice,
  createMesh2 as createMesh,
  createPlane,
  createScript,
  createShader,
  createShaderFromCode,
  createSphere,
  createTorus,
  createURI,
  dracoInitialize,
  drawFullscreenQuad,
  drawQuadWithShader,
  extend,
  getPixelFormatArrayType,
  getReservedScriptNames,
  getTouchTargetCoords,
  guid,
  http,
  isCompressedPixelFormat,
  isIntegerPixelFormat,
  isSrgbPixelFormat,
  math,
  now,
  path,
  pixelFormatInfo,
  pixelFormatLinearToGamma,
  platform,
  registerScript,
  reprojectTexture,
  requiresManualGamma,
  revision,
  script,
  semanticToLocation,
  shaderChunks,
  shaderChunksLightmapper,
  shadowTypeToString,
  string,
  typedArrayIndexFormats,
  typedArrayIndexFormatsByteSize,
  typedArrayToType,
  typedArrayTypes,
  typedArrayTypesByteSize,
  uniformTypeToName,
  uniformTypeToStorage,
  version,
  vertexTypesNames
};
//# sourceMappingURL=playcanvas.js.map
